{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { validateAddrs } from './utils.js';\nimport { StreamHandler } from './stream-handler.js';\nimport { CircuitRelay as CircuitPB } from '../pb/index.js';\nimport { pipe } from 'it-pipe';\nimport { codes as Errors } from '../../errors.js';\nimport { stop } from './stop.js';\nimport { RELAY_CODEC } from '../multicodec.js';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nvar log = logger('libp2p:circuit:hop');\nexport function handleHop(_x) {\n  return _handleHop.apply(this, arguments);\n}\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n */\nfunction _handleHop() {\n  _handleHop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hopRequest) {\n    var connection, request, streamHandler, circuit, connectionManager, destinationPeer, destinationConnections, stopRequest, destinationStream, result, sourceStream;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          connection = hopRequest.connection, request = hopRequest.request, streamHandler = hopRequest.streamHandler, circuit = hopRequest.circuit, connectionManager = hopRequest.connectionManager; // Ensure hop is enabled\n          if (circuit.hopEnabled()) {\n            _context.next = 4;\n            break;\n          }\n          log('HOP request received but we are not acting as a relay');\n          return _context.abrupt(\"return\", streamHandler.end({\n            type: CircuitPB.Type.STATUS,\n            code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n          }));\n        case 4:\n          _context.prev = 4;\n          validateAddrs(request, streamHandler);\n          _context.next = 12;\n          break;\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](4);\n          log.error('invalid hop request via peer %p %o', connection.remotePeer, _context.t0);\n          return _context.abrupt(\"return\");\n        case 12:\n          if (!(request.dstPeer == null)) {\n            _context.next = 15;\n            break;\n          }\n          log('HOP request received but we do not receive a dstPeer');\n          return _context.abrupt(\"return\");\n        case 15:\n          // Get the connection to the destination (stop) peer\n          destinationPeer = peerIdFromBytes(request.dstPeer.id);\n          destinationConnections = connectionManager.getConnections(destinationPeer);\n          if (!(destinationConnections.length === 0 && !circuit.hopActive())) {\n            _context.next = 20;\n            break;\n          }\n          log('HOP request received but we are not connected to the destination peer');\n          return _context.abrupt(\"return\", streamHandler.end({\n            type: CircuitPB.Type.STATUS,\n            code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n          }));\n        case 20:\n          if (!(destinationConnections.length === 0)) {\n            _context.next = 23;\n            break;\n          }\n          log('did not have connection to remote peer');\n          return _context.abrupt(\"return\", streamHandler.end({\n            type: CircuitPB.Type.STATUS,\n            code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n          }));\n        case 23:\n          // Handle the incoming HOP request by performing a STOP request\n          stopRequest = {\n            type: CircuitPB.Type.STOP,\n            dstPeer: request.dstPeer,\n            srcPeer: request.srcPeer\n          };\n          _context.prev = 24;\n          log('performing STOP request');\n          _context.next = 28;\n          return stop({\n            connection: destinationConnections[0],\n            request: stopRequest\n          });\n        case 28:\n          result = _context.sent;\n          if (!(result == null)) {\n            _context.next = 31;\n            break;\n          }\n          throw new Error('Could not stop');\n        case 31:\n          destinationStream = result;\n          _context.next = 38;\n          break;\n        case 34:\n          _context.prev = 34;\n          _context.t1 = _context[\"catch\"](24);\n          log.error(_context.t1);\n          return _context.abrupt(\"return\");\n        case 38:\n          log('hop request from %p is valid', connection.remotePeer);\n          streamHandler.write({\n            type: CircuitPB.Type.STATUS,\n            code: CircuitPB.Status.SUCCESS\n          });\n          sourceStream = streamHandler.rest();\n          log('creating related connections');\n          // Short circuit the two streams to create the relayed connection\n          _context.next = 44;\n          return pipe(sourceStream, destinationStream, sourceStream);\n        case 44:\n          return _context.abrupt(\"return\", _context.sent);\n        case 45:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[4, 8], [24, 34]]);\n  }));\n  return _handleHop.apply(this, arguments);\n}\nexport function hop(_x2) {\n  return _hop.apply(this, arguments);\n}\n/**\n * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities\n */\nfunction _hop() {\n  _hop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {\n    var _response$code;\n    var connection, request, signal, stream, streamHandler, response;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          connection = options.connection, request = options.request, signal = options.signal; // Create a new stream to the relay\n          _context2.next = 3;\n          return connection.newStream(RELAY_CODEC, {\n            signal: signal\n          });\n        case 3:\n          stream = _context2.sent;\n          // Send the HOP request\n          streamHandler = new StreamHandler({\n            stream: stream\n          });\n          streamHandler.write(request);\n          _context2.next = 8;\n          return streamHandler.read();\n        case 8:\n          response = _context2.sent;\n          if (!(response == null)) {\n            _context2.next = 11;\n            break;\n          }\n          throw errCode(new Error('HOP request had no response'), Errors.ERR_HOP_REQUEST_FAILED);\n        case 11:\n          if (!(response.code === CircuitPB.Status.SUCCESS)) {\n            _context2.next = 14;\n            break;\n          }\n          log('hop request was successful');\n          return _context2.abrupt(\"return\", streamHandler.rest());\n        case 14:\n          log('hop request failed with code %d, closing stream', response.code);\n          streamHandler.close();\n          throw errCode(new Error(\"HOP request failed with code \\\"\".concat((_response$code = response.code) !== null && _response$code !== void 0 ? _response$code : 'unknown', \"\\\"\")), Errors.ERR_HOP_REQUEST_FAILED);\n        case 17:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _hop.apply(this, arguments);\n}\nexport function canHop(_x3) {\n  return _canHop.apply(this, arguments);\n}\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n */\nfunction _canHop() {\n  _canHop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {\n    var connection, signal, stream, streamHandler, response;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          connection = options.connection, signal = options.signal; // Create a new stream to the relay\n          _context3.next = 3;\n          return connection.newStream(RELAY_CODEC, {\n            signal: signal\n          });\n        case 3:\n          stream = _context3.sent;\n          // Send the HOP request\n          streamHandler = new StreamHandler({\n            stream: stream\n          });\n          streamHandler.write({\n            type: CircuitPB.Type.CAN_HOP\n          });\n          _context3.next = 8;\n          return streamHandler.read();\n        case 8:\n          response = _context3.sent;\n          _context3.next = 11;\n          return streamHandler.close();\n        case 11:\n          if (!(response == null || response.code !== CircuitPB.Status.SUCCESS)) {\n            _context3.next = 13;\n            break;\n          }\n          return _context3.abrupt(\"return\", false);\n        case 13:\n          return _context3.abrupt(\"return\", true);\n        case 14:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _canHop.apply(this, arguments);\n}\nexport function handleCanHop(options) {\n  var connection = options.connection,\n    streamHandler = options.streamHandler,\n    circuit = options.circuit;\n  var canHop = circuit.hopEnabled();\n  log('can hop (%s) request from %p', canHop, connection.remotePeer);\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  });\n}","map":{"version":3,"names":["logger","errCode","validateAddrs","StreamHandler","CircuitRelay","CircuitPB","pipe","codes","Errors","stop","RELAY_CODEC","peerIdFromBytes","log","handleHop","_x","_handleHop","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","hopRequest","connection","request","streamHandler","circuit","connectionManager","destinationPeer","destinationConnections","stopRequest","destinationStream","result","sourceStream","wrap","_callee$","_context","prev","next","hopEnabled","abrupt","end","type","Type","STATUS","code","Status","HOP_CANT_SPEAK_RELAY","t0","error","remotePeer","dstPeer","id","getConnections","length","hopActive","HOP_NO_CONN_TO_DST","STOP","srcPeer","sent","Error","t1","write","SUCCESS","rest","hop","_x2","_hop","_callee2","options","_response$code","signal","stream","response","_callee2$","_context2","newStream","read","ERR_HOP_REQUEST_FAILED","close","concat","canHop","_x3","_canHop","_callee3","_callee3$","_context3","CAN_HOP","handleCanHop"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/circuit/circuit/hop.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { validateAddrs } from './utils.js'\nimport { StreamHandler } from './stream-handler.js'\nimport { CircuitRelay as CircuitPB } from '../pb/index.js'\nimport { pipe } from 'it-pipe'\nimport { codes as Errors } from '../../errors.js'\nimport { stop } from './stop.js'\nimport { RELAY_CODEC } from '../multicodec.js'\nimport type { Connection } from '@libp2p/interface-connection'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport type { Duplex } from 'it-stream-types'\nimport type { Circuit } from '../transport.js'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:circuit:hop')\n\nexport interface HopRequest {\n  connection: Connection\n  request: CircuitPB\n  streamHandler: StreamHandler\n  circuit: Circuit\n  connectionManager: ConnectionManager\n}\n\nexport async function handleHop (hopRequest: HopRequest): Promise<void> {\n  const {\n    connection,\n    request,\n    streamHandler,\n    circuit,\n    connectionManager\n  } = hopRequest\n\n  // Ensure hop is enabled\n  if (!circuit.hopEnabled()) {\n    log('HOP request received but we are not acting as a relay')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n    })\n  }\n\n  // Validate the HOP request has the required input\n  try {\n    validateAddrs(request, streamHandler)\n  } catch (err: any) {\n    log.error('invalid hop request via peer %p %o', connection.remotePeer, err)\n\n    return\n  }\n\n  if (request.dstPeer == null) {\n    log('HOP request received but we do not receive a dstPeer')\n    return\n  }\n\n  // Get the connection to the destination (stop) peer\n  const destinationPeer = peerIdFromBytes(request.dstPeer.id)\n\n  const destinationConnections = connectionManager.getConnections(destinationPeer)\n  if (destinationConnections.length === 0 && !circuit.hopActive()) {\n    log('HOP request received but we are not connected to the destination peer')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    })\n  }\n\n  // TODO: Handle being an active relay\n  if (destinationConnections.length === 0) {\n    log('did not have connection to remote peer')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    })\n  }\n\n  // Handle the incoming HOP request by performing a STOP request\n  const stopRequest = {\n    type: CircuitPB.Type.STOP,\n    dstPeer: request.dstPeer,\n    srcPeer: request.srcPeer\n  }\n\n  let destinationStream: Duplex<Uint8ArrayList>\n  try {\n    log('performing STOP request')\n    const result = await stop({\n      connection: destinationConnections[0],\n      request: stopRequest\n    })\n\n    if (result == null) {\n      throw new Error('Could not stop')\n    }\n\n    destinationStream = result\n  } catch (err: any) {\n    log.error(err)\n\n    return\n  }\n\n  log('hop request from %p is valid', connection.remotePeer)\n  streamHandler.write({\n    type: CircuitPB.Type.STATUS,\n    code: CircuitPB.Status.SUCCESS\n  })\n  const sourceStream = streamHandler.rest()\n\n  log('creating related connections')\n  // Short circuit the two streams to create the relayed connection\n  return await pipe(\n    sourceStream,\n    destinationStream,\n    sourceStream\n  )\n}\n\nexport interface HopConfig extends AbortOptions {\n  connection: Connection\n  request: CircuitPB\n}\n\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n */\nexport async function hop (options: HopConfig): Promise<Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>> {\n  const {\n    connection,\n    request,\n    signal\n  } = options\n\n  // Create a new stream to the relay\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  })\n  // Send the HOP request\n  const streamHandler = new StreamHandler({ stream })\n  streamHandler.write(request)\n\n  const response = await streamHandler.read()\n\n  if (response == null) {\n    throw errCode(new Error('HOP request had no response'), Errors.ERR_HOP_REQUEST_FAILED)\n  }\n\n  if (response.code === CircuitPB.Status.SUCCESS) {\n    log('hop request was successful')\n\n    return streamHandler.rest()\n  }\n\n  log('hop request failed with code %d, closing stream', response.code)\n  streamHandler.close()\n\n  throw errCode(new Error(`HOP request failed with code \"${response.code ?? 'unknown'}\"`), Errors.ERR_HOP_REQUEST_FAILED)\n}\n\nexport interface CanHopOptions extends AbortOptions {\n  connection: Connection\n}\n\n/**\n * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities\n */\nexport async function canHop (options: CanHopOptions) {\n  const {\n    connection,\n    signal\n  } = options\n\n  // Create a new stream to the relay\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  })\n\n  // Send the HOP request\n  const streamHandler = new StreamHandler({ stream })\n  streamHandler.write({\n    type: CircuitPB.Type.CAN_HOP\n  })\n\n  const response = await streamHandler.read()\n  await streamHandler.close()\n\n  if (response == null || response.code !== CircuitPB.Status.SUCCESS) {\n    return false\n  }\n\n  return true\n}\n\nexport interface HandleCanHopOptions {\n  connection: Connection\n  streamHandler: StreamHandler\n  circuit: Circuit\n}\n\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n */\nexport function handleCanHop (options: HandleCanHopOptions) {\n  const {\n    connection,\n    streamHandler,\n    circuit\n  } = options\n  const canHop = circuit.hopEnabled()\n  log('can hop (%s) request from %p', canHop, connection.remotePeer)\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}