{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nexport function createListener(options) {\n  var listeningAddrs = new Map();\n  /**\n   * Add swarm handler and listen for incoming connections\n   */\n  function listen(_x) {\n    return _listen.apply(this, arguments);\n  }\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   * `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   * addr, such when dialing over a relay with this address, it will create the circuit using\n   * the encapsulated transport address. This is useful when for example, a peer should only\n   * be dialed over TCP rather than any other transport\n   *\n   * @returns {Multiaddr[]}\n   */\n  function _listen() {\n    _listen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(addr) {\n      var addrString, ma, relayPeerStr, relayPeerId, relayConn, relayedAddr;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            addrString = addr.toString().split('/p2p-circuit').find(function (a) {\n              return a !== '';\n            });\n            ma = multiaddr(addrString);\n            relayPeerStr = ma.getPeerId();\n            if (!(relayPeerStr == null)) {\n              _context2.next = 5;\n              break;\n            }\n            throw new Error('Could not determine relay peer from multiaddr');\n          case 5:\n            relayPeerId = peerIdFromString(relayPeerStr);\n            _context2.next = 8;\n            return options.peerStore.addressBook.add(relayPeerId, [ma]);\n          case 8:\n            _context2.next = 10;\n            return options.connectionManager.openConnection(relayPeerId);\n          case 10:\n            relayConn = _context2.sent;\n            relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit');\n            listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);\n            listener.dispatchEvent(new CustomEvent('listening'));\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return _listen.apply(this, arguments);\n  }\n  function getAddrs() {\n    var addrs = [];\n    var _iterator = _createForOfIteratorHelper(listeningAddrs.values()),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var addr = _step.value;\n        addrs.push(addr);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return addrs;\n  }\n  var listener = Object.assign(new EventEmitter(), {\n    close: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Promise.resolve();\n            case 2:\n              return _context.abrupt(\"return\", _context.sent);\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }(),\n    listen: listen,\n    getAddrs: getAddrs\n  });\n  // Remove listeningAddrs when a peer disconnects\n  options.connectionManager.addEventListener('peer:disconnect', function (evt) {\n    var connection = evt.detail;\n    var deleted = listeningAddrs.delete(connection.remotePeer.toString());\n    if (deleted) {\n      // Announce listen addresses change\n      listener.dispatchEvent(new CustomEvent('close'));\n    }\n  });\n  return listener;\n}","map":{"version":3,"names":["CustomEvent","EventEmitter","peerIdFromString","multiaddr","createListener","options","listeningAddrs","Map","listen","_x","_listen","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","addr","addrString","ma","relayPeerStr","relayPeerId","relayConn","relayedAddr","wrap","_callee2$","_context2","prev","next","toString","split","find","a","getPeerId","Error","peerStore","addressBook","add","connectionManager","openConnection","sent","remoteAddr","encapsulate","set","remotePeer","listener","dispatchEvent","stop","getAddrs","addrs","_iterator","_createForOfIteratorHelper","values","_step","s","n","done","value","push","err","e","f","Object","assign","close","_close","_callee","_callee$","_context","Promise","resolve","abrupt","addEventListener","evt","connection","detail","deleted","delete"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/circuit/listener.ts"],"sourcesContent":["import { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\nimport type { Listener } from '@libp2p/interface-transport'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddr } from '@multiformats/multiaddr'\n\nexport interface ListenerOptions {\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n}\n\nexport function createListener (options: ListenerOptions): Listener {\n  const listeningAddrs = new Map()\n\n  /**\n   * Add swarm handler and listen for incoming connections\n   */\n  async function listen (addr: Multiaddr): Promise<void> {\n    const addrString = addr.toString().split('/p2p-circuit').find(a => a !== '')\n    const ma = multiaddr(addrString)\n\n    const relayPeerStr = ma.getPeerId()\n\n    if (relayPeerStr == null) {\n      throw new Error('Could not determine relay peer from multiaddr')\n    }\n\n    const relayPeerId = peerIdFromString(relayPeerStr)\n\n    await options.peerStore.addressBook.add(relayPeerId, [ma])\n\n    const relayConn = await options.connectionManager.openConnection(relayPeerId)\n    const relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit')\n\n    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr)\n    listener.dispatchEvent(new CustomEvent('listening'))\n  }\n\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   * `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   * addr, such when dialing over a relay with this address, it will create the circuit using\n   * the encapsulated transport address. This is useful when for example, a peer should only\n   * be dialed over TCP rather than any other transport\n   *\n   * @returns {Multiaddr[]}\n   */\n  function getAddrs () {\n    const addrs = []\n    for (const addr of listeningAddrs.values()) {\n      addrs.push(addr)\n    }\n    return addrs\n  }\n\n  const listener: Listener = Object.assign(new EventEmitter(), {\n    close: async () => await Promise.resolve(),\n    listen,\n    getAddrs\n  })\n\n  // Remove listeningAddrs when a peer disconnects\n  options.connectionManager.addEventListener('peer:disconnect', (evt) => {\n    const { detail: connection } = evt\n    const deleted = listeningAddrs.delete(connection.remotePeer.toString())\n\n    if (deleted) {\n      // Announce listen addresses change\n      listener.dispatchEvent(new CustomEvent('close'))\n    }\n  })\n\n  return listener\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}