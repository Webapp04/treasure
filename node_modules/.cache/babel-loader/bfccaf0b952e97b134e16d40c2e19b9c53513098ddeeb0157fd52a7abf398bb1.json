{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport { AbortError } from 'abortable-iterator';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport * as mafmt from '@multiformats/mafmt';\nimport { CODE_CIRCUIT } from './constants.js';\nimport { createListener as _createListener } from './listener.js';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanMultiaddr, cleanUrlSIO } from './utils.js';\nimport { WebRTCInitiator } from '@libp2p/webrtc-peer';\nimport randomBytes from 'iso-random-stream/src/random.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { symbol } from '@libp2p/interface-transport';\nimport { Components } from '@libp2p/components';\nimport { symbol as peerDiscoverySymbol } from '@libp2p/interface-peer-discovery';\nvar webrtcSupport = ('RTCPeerConnection' in globalThis);\nvar log = logger('libp2p:webrtc-star');\nvar noop = function noop() {};\nvar WebRTCStarDiscovery = /*#__PURE__*/function (_EventEmitter, _Symbol$toStringTag) {\n  _inherits(WebRTCStarDiscovery, _EventEmitter);\n  var _super = _createSuper(WebRTCStarDiscovery);\n  function WebRTCStarDiscovery() {\n    var _this;\n    _classCallCheck(this, WebRTCStarDiscovery);\n    _this = _super.apply(this, arguments);\n    _this.started = false;\n    return _this;\n  }\n  _createClass(WebRTCStarDiscovery, [{\n    key: peerDiscoverySymbol,\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return '@libp2p/webrtc-star-discovery';\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.started = true;\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.started = false;\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      if (!this.isStarted()) {\n        return false;\n      }\n      return _get(_getPrototypeOf(WebRTCStarDiscovery.prototype), \"dispatchEvent\", this).call(this, event);\n    }\n  }]);\n  return WebRTCStarDiscovery;\n}(EventEmitter, Symbol.toStringTag);\n/**\n * @class WebRTCStar\n */\nexport var WebRTCStar = /*#__PURE__*/function (_Symbol$toStringTag2) {\n  function WebRTCStar(options) {\n    _classCallCheck(this, WebRTCStar);\n    this.components = new Components();\n    if ((options === null || options === void 0 ? void 0 : options.wrtc) != null) {\n      this.wrtc = options.wrtc;\n    }\n    // Keep Signalling references\n    this.sigServers = new Map();\n    // Discovery\n    this.discovery = new WebRTCStarDiscovery();\n    this.peerDiscovered = this.peerDiscovered.bind(this);\n  }\n  _createClass(WebRTCStar, [{\n    key: symbol,\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: _Symbol$toStringTag2,\n    get: function get() {\n      return '@libp2p/webrtc-star';\n    }\n  }, {\n    key: \"init\",\n    value: function init(components) {\n      this.components = components;\n    }\n  }, {\n    key: \"dial\",\n    value: function () {\n      var _dial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ma, options) {\n        var rawConn, maConn, conn;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this._connect(ma, options);\n            case 2:\n              rawConn = _context3.sent;\n              maConn = toMultiaddrConnection(rawConn, {\n                remoteAddr: ma,\n                signal: options.signal\n              });\n              log('new outbound connection %s', maConn.remoteAddr);\n              _context3.next = 7;\n              return options.upgrader.upgradeOutbound(maConn);\n            case 7:\n              conn = _context3.sent;\n              log('outbound connection %s upgraded', maConn.remoteAddr);\n              return _context3.abrupt(\"return\", conn);\n            case 10:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function dial(_x, _x2) {\n        return _dial.apply(this, arguments);\n      }\n      return dial;\n    }()\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ma, options) {\n        var _options$signal,\n          _options$channelOptio,\n          _this2 = this;\n        var channelOptions, cOpts, intentId;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(((_options$signal = options.signal) === null || _options$signal === void 0 ? void 0 : _options$signal.aborted) === true)) {\n                _context4.next = 2;\n                break;\n              }\n              throw new AbortError();\n            case 2:\n              channelOptions = _objectSpread({}, (_options$channelOptio = options.channelOptions) !== null && _options$channelOptio !== void 0 ? _options$channelOptio : {}); // Use custom WebRTC implementation\n              if (this.wrtc != null) {\n                channelOptions.wrtc = this.wrtc;\n              }\n              cOpts = ma.toOptions();\n              intentId = uint8ArrayToString(randomBytes(36), 'hex');\n              _context4.next = 8;\n              return new Promise(function (resolve, reject) {\n                var _options$signal3;\n                var sio = _this2.sigServers.get(cleanUrlSIO(ma));\n                if ((sio === null || sio === void 0 ? void 0 : sio.socket) == null) {\n                  return reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'));\n                }\n                var connected = false;\n                log('dialing %s:%s', cOpts.host, cOpts.port);\n                var channel = new WebRTCInitiator(channelOptions);\n                var onError = function onError(evt) {\n                  var err = evt.detail;\n                  if (!connected) {\n                    var msg = \"connection error \".concat(cOpts.host, \":\").concat(cOpts.port, \": \").concat(err.message);\n                    log.error(msg);\n                    done(err);\n                  }\n                };\n                var onReady = function onReady() {\n                  connected = true;\n                  log('connection opened %s:%s', cOpts.host, cOpts.port);\n                  done();\n                };\n                var onAbort = function onAbort() {\n                  log.error('connection aborted %s:%s', cOpts.host, cOpts.port);\n                  channel.close().finally(function () {\n                    done(new AbortError());\n                  });\n                };\n                var done = function done(err) {\n                  var _options$signal2;\n                  channel.removeEventListener('ready', onReady);\n                  (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.removeEventListener('abort', onAbort);\n                  if (err == null) {\n                    resolve(channel);\n                  } else {\n                    reject(err);\n                  }\n                };\n                channel.addEventListener('ready', onReady, {\n                  once: true\n                });\n                channel.addEventListener('close', function () {\n                  channel.removeEventListener('error', onError);\n                });\n                (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.addEventListener('abort', onAbort);\n                channel.addEventListener('signal', function (evt) {\n                  var signal = evt.detail;\n                  sio.socket.emit('ss-handshake', {\n                    intentId: intentId,\n                    srcMultiaddr: sio.signallingAddr.toString(),\n                    dstMultiaddr: ma.toString(),\n                    signal: signal\n                  });\n                });\n                sio.socket.on('ws-handshake', function (offer) {\n                  if (offer.intentId === intentId && offer.err != null) {\n                    channel.close().finally(function () {\n                      reject(errcode(new Error(offer.err), 'ERR_SIGNALLING_FAILED'));\n                    });\n                  }\n                  if (offer.intentId !== intentId || offer.answer == null || channel.closed) {\n                    return;\n                  }\n                  channel.handleSignal(offer.signal);\n                });\n              });\n            case 8:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 9:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _connect(_x3, _x4) {\n        return _connect2.apply(this, arguments);\n      }\n      return _connect;\n    }()\n    /**\n     * Creates a WebrtcStar listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     */\n  }, {\n    key: \"createListener\",\n    value: function createListener(options) {\n      var _options$channelOptio2, _options$handler;\n      if (!webrtcSupport && this.wrtc == null) {\n        throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT');\n      }\n      options.channelOptions = (_options$channelOptio2 = options.channelOptions) !== null && _options$channelOptio2 !== void 0 ? _options$channelOptio2 : {};\n      if (this.wrtc != null) {\n        options.channelOptions.wrtc = this.wrtc;\n      }\n      return _createListener(options.upgrader, (_options$handler = options.handler) !== null && _options$handler !== void 0 ? _options$handler : noop, this.components.getPeerId(), this, options);\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n      return multiaddrs.filter(function (ma) {\n        if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n          return false;\n        }\n        return mafmt.WebRTCStar.matches(ma);\n      });\n    }\n  }, {\n    key: \"peerDiscovered\",\n    value: function peerDiscovered(maStr) {\n      log('peer discovered: %s', maStr);\n      maStr = cleanMultiaddr(maStr);\n      var ma = multiaddr(maStr);\n      var peerIdStr = ma.getPeerId();\n      if (peerIdStr == null) {\n        return;\n      }\n      var peerId = peerIdFromString(peerIdStr);\n      this.discovery.dispatchEvent(new CustomEvent('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: [ma],\n          protocols: []\n        }\n      }));\n    }\n  }]);\n  return WebRTCStar;\n}(Symbol.toStringTag);","map":{"version":3,"names":["logger","errcode","AbortError","multiaddr","mafmt","CODE_CIRCUIT","createListener","toMultiaddrConnection","cleanMultiaddr","cleanUrlSIO","WebRTCInitiator","randomBytes","toString","uint8ArrayToString","EventEmitter","CustomEvent","peerIdFromString","symbol","Components","peerDiscoverySymbol","webrtcSupport","globalThis","log","noop","WebRTCStarDiscovery","_EventEmitter","_Symbol$toStringTag","_inherits","_super","_createSuper","_this","_classCallCheck","started","_createClass","key","get","value","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","stop","start","apply","arguments","_stop","_callee2","_callee2$","_context2","dispatchEvent","event","_get","_getPrototypeOf","prototype","call","Symbol","toStringTag","WebRTCStar","_Symbol$toStringTag2","options","components","wrtc","sigServers","Map","discovery","peerDiscovered","bind","init","_dial","_callee3","ma","rawConn","maConn","conn","_callee3$","_context3","_connect","sent","remoteAddr","signal","upgrader","upgradeOutbound","abrupt","dial","_x","_x2","_connect2","_callee4","_options$signal","_options$channelOptio","_this2","channelOptions","cOpts","intentId","_callee4$","_context4","aborted","_objectSpread","toOptions","Promise","resolve","reject","_options$signal3","sio","socket","Error","connected","host","port","channel","onError","evt","err","detail","msg","concat","message","error","done","onReady","onAbort","close","finally","_options$signal2","removeEventListener","addEventListener","once","emit","srcMultiaddr","signallingAddr","dstMultiaddr","on","offer","answer","closed","handleSignal","_x3","_x4","_options$channelOptio2","_options$handler","handler","getPeerId","filter","multiaddrs","Array","isArray","protoCodes","includes","matches","maStr","peerIdStr","peerId","id","protocols"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/webrtc-star/src/index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errcode from 'err-code'\nimport { AbortError } from 'abortable-iterator'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport * as mafmt from '@multiformats/mafmt'\nimport { CODE_CIRCUIT } from './constants.js'\nimport { createListener } from './listener.js'\nimport { toMultiaddrConnection } from './socket-to-conn.js'\nimport { cleanMultiaddr, cleanUrlSIO } from './utils.js'\nimport { WebRTCInitiator } from '@libp2p/webrtc-peer'\nimport randomBytes from 'iso-random-stream/src/random.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { symbol } from '@libp2p/interface-transport'\nimport type { WRTC, WebRTCInitiatorInit, WebRTCReceiver, WebRTCReceiverInit } from '@libp2p/webrtc-peer'\nimport type { Connection, MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Transport, Listener, DialOptions, CreateListenerOptions } from '@libp2p/interface-transport'\nimport type { PeerDiscovery, PeerDiscoveryEvents } from '@libp2p/interface-peer-discovery'\nimport type { WebRTCStarSocket, HandshakeSignal } from '@libp2p/webrtc-star-protocol'\nimport { Components, Initializable } from '@libp2p/components'\nimport { symbol as peerDiscoverySymbol } from '@libp2p/interface-peer-discovery'\n\nconst webrtcSupport = 'RTCPeerConnection' in globalThis\nconst log = logger('libp2p:webrtc-star')\n\nconst noop = () => {}\n\nclass WebRTCStarDiscovery extends EventEmitter<PeerDiscoveryEvents> implements PeerDiscovery, Startable {\n  private started = false\n\n  get [peerDiscoverySymbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    return '@libp2p/webrtc-star-discovery'\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    this.started = true\n  }\n\n  async stop () {\n    this.started = false\n  }\n\n  dispatchEvent (event: CustomEvent) {\n    if (!this.isStarted()) {\n      return false\n    }\n\n    return super.dispatchEvent(event)\n  }\n}\n\nexport interface WebRTCStarInit {\n  wrtc?: WRTC\n}\n\nexport interface WebRTCStarDialOptions extends DialOptions {\n  channelOptions?: WebRTCInitiatorInit\n}\n\nexport interface WebRTCStarListenerOptions extends CreateListenerOptions, WebRTCInitiatorInit {\n  channelOptions?: WebRTCReceiverInit\n}\n\nexport interface SignalServerServerEvents {\n  'error': CustomEvent<Error>\n  'listening': CustomEvent\n  'peer': CustomEvent<string>\n  'connection': CustomEvent<Connection>\n  'disconnect': CustomEvent\n  'reconnect': CustomEvent\n}\n\nexport interface SignalServer extends EventEmitter<SignalServerServerEvents> {\n  signallingAddr: Multiaddr\n  socket: WebRTCStarSocket\n  connections: MultiaddrConnection[]\n  channels: Map<string, WebRTCReceiver>\n  pendingSignals: Map<string, HandshakeSignal[]>\n  close: () => Promise<void>\n}\n\n/**\n * @class WebRTCStar\n */\nexport class WebRTCStar implements Transport, Initializable {\n  public wrtc?: WRTC\n  public discovery: PeerDiscovery & Startable\n  public sigServers: Map<string, SignalServer>\n  private components: Components = new Components()\n\n  constructor (options?: WebRTCStarInit) {\n    if (options?.wrtc != null) {\n      this.wrtc = options.wrtc\n    }\n\n    // Keep Signalling references\n    this.sigServers = new Map()\n\n    // Discovery\n    this.discovery = new WebRTCStarDiscovery()\n    this.peerDiscovered = this.peerDiscovered.bind(this)\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    return '@libp2p/webrtc-star'\n  }\n\n  init (components: Components) {\n    this.components = components\n  }\n\n  async dial (ma: Multiaddr, options: WebRTCStarDialOptions) {\n    const rawConn = await this._connect(ma, options)\n    const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n    const conn = await options.upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: WebRTCStarDialOptions) {\n    if (options.signal?.aborted === true) {\n      throw new AbortError()\n    }\n\n    const channelOptions = {\n      ...(options.channelOptions ?? {})\n    }\n\n    // Use custom WebRTC implementation\n    if (this.wrtc != null) {\n      channelOptions.wrtc = this.wrtc\n    }\n\n    const cOpts = ma.toOptions()\n    const intentId = uint8ArrayToString(randomBytes(36), 'hex')\n\n    return await new Promise<WebRTCInitiator>((resolve, reject) => {\n      const sio = this.sigServers.get(cleanUrlSIO(ma))\n\n      if (sio?.socket == null) {\n        return reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'))\n      }\n\n      let connected: boolean = false\n\n      log('dialing %s:%s', cOpts.host, cOpts.port)\n      const channel = new WebRTCInitiator(channelOptions)\n\n      const onError = (evt: CustomEvent<Error>) => {\n        const err = evt.detail\n\n        if (!connected) {\n          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`\n          log.error(msg)\n          done(err)\n        }\n      }\n\n      const onReady = () => {\n        connected = true\n\n        log('connection opened %s:%s', cOpts.host, cOpts.port)\n        done()\n      }\n\n      const onAbort = () => {\n        log.error('connection aborted %s:%s', cOpts.host, cOpts.port)\n        channel.close().finally(() => {\n          done(new AbortError())\n        })\n      }\n\n      const done = (err?: Error) => {\n        channel.removeEventListener('ready', onReady)\n        options.signal?.removeEventListener('abort', onAbort)\n\n        if (err == null) {\n          resolve(channel)\n        } else {\n          reject(err)\n        }\n      }\n\n      channel.addEventListener('ready', onReady, {\n        once: true\n      })\n      channel.addEventListener('close', () => {\n        channel.removeEventListener('error', onError)\n      })\n      options.signal?.addEventListener('abort', onAbort)\n\n      channel.addEventListener('signal', (evt) => {\n        const signal = evt.detail\n\n        sio.socket.emit('ss-handshake', {\n          intentId: intentId,\n          srcMultiaddr: sio.signallingAddr.toString(),\n          dstMultiaddr: ma.toString(),\n          signal: signal\n        })\n      })\n\n      sio.socket.on('ws-handshake', (offer) => {\n        if (offer.intentId === intentId && offer.err != null) {\n          channel.close().finally(() => {\n            reject(errcode(new Error(offer.err), 'ERR_SIGNALLING_FAILED'))\n          })\n        }\n\n        if (offer.intentId !== intentId || offer.answer == null || channel.closed) {\n          return\n        }\n\n        channel.handleSignal(offer.signal)\n      })\n    })\n  }\n\n  /**\n   * Creates a WebrtcStar listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   */\n  createListener (options: WebRTCStarListenerOptions): Listener {\n    if (!webrtcSupport && this.wrtc == null) {\n      throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT')\n    }\n\n    options.channelOptions = options.channelOptions ?? {}\n\n    if (this.wrtc != null) {\n      options.channelOptions.wrtc = this.wrtc\n    }\n\n    return createListener(options.upgrader, options.handler ?? noop, this.components.getPeerId(), this, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n   */\n  filter (multiaddrs: Multiaddr[]) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false\n      }\n\n      return mafmt.WebRTCStar.matches(ma)\n    })\n  }\n\n  peerDiscovered (maStr: string) {\n    log('peer discovered: %s', maStr)\n    maStr = cleanMultiaddr(maStr)\n\n    const ma = multiaddr(maStr)\n    const peerIdStr = ma.getPeerId()\n\n    if (peerIdStr == null) {\n      return\n    }\n\n    const peerId = peerIdFromString(peerIdStr)\n\n    this.discovery.dispatchEvent(new CustomEvent('peer', {\n      detail: {\n        id: peerId,\n        multiaddrs: [ma],\n        protocols: []\n      }\n    }))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}