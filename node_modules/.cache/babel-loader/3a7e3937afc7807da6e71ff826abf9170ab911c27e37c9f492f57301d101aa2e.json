{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { resolvePath } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input';\nimport { PinTypes } from 'ipfs-repo/pin-types';\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createAddAll(_ref2) {\n  var repo = _ref2.repo,\n    codecs = _ref2.codecs;\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"addAll\"]}\n   */\n  function addAll(_x) {\n    return _addAll.apply(this, arguments);\n  }\n  function _addAll() {\n    _addAll = _wrapAsyncGenerator(function (source) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var pinAdd, lock, release;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              /**\n               * @returns {AsyncIterable<CID>}\n               */\n              pinAdd = /*#__PURE__*/function () {\n                var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, path, recursive, metadata, _yield$_awaitAsyncGen, cid, _yield$_awaitAsyncGen2, reason;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        _iteratorAbruptCompletion = false;\n                        _didIteratorError = false;\n                        _context.prev = 2;\n                        _iterator = _asyncIterator(normaliseInput(source));\n                      case 4:\n                        _context.next = 6;\n                        return _awaitAsyncGenerator(_iterator.next());\n                      case 6:\n                        if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                          _context.next = 30;\n                          break;\n                        }\n                        _step$value = _step.value, path = _step$value.path, recursive = _step$value.recursive, metadata = _step$value.metadata;\n                        _context.next = 10;\n                        return _awaitAsyncGenerator(resolvePath(repo, codecs, path));\n                      case 10:\n                        _yield$_awaitAsyncGen = _context.sent;\n                        cid = _yield$_awaitAsyncGen.cid;\n                        _context.next = 14;\n                        return _awaitAsyncGenerator(repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]));\n                      case 14:\n                        _yield$_awaitAsyncGen2 = _context.sent;\n                        reason = _yield$_awaitAsyncGen2.reason;\n                        if (!(reason === 'recursive' && !recursive)) {\n                          _context.next = 18;\n                          break;\n                        }\n                        throw new Error(\"\".concat(cid, \" already pinned recursively\"));\n                      case 18:\n                        if (!recursive) {\n                          _context.next = 23;\n                          break;\n                        }\n                        _context.next = 21;\n                        return _awaitAsyncGenerator(repo.pins.pinRecursively(cid, {\n                          metadata: metadata\n                        }));\n                      case 21:\n                        _context.next = 25;\n                        break;\n                      case 23:\n                        _context.next = 25;\n                        return _awaitAsyncGenerator(repo.pins.pinDirectly(cid, {\n                          metadata: metadata\n                        }));\n                      case 25:\n                        _context.next = 27;\n                        return cid;\n                      case 27:\n                        _iteratorAbruptCompletion = false;\n                        _context.next = 4;\n                        break;\n                      case 30:\n                        _context.next = 36;\n                        break;\n                      case 32:\n                        _context.prev = 32;\n                        _context.t0 = _context[\"catch\"](2);\n                        _didIteratorError = true;\n                        _iteratorError = _context.t0;\n                      case 36:\n                        _context.prev = 36;\n                        _context.prev = 37;\n                        if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                          _context.next = 41;\n                          break;\n                        }\n                        _context.next = 41;\n                        return _awaitAsyncGenerator(_iterator.return());\n                      case 41:\n                        _context.prev = 41;\n                        if (!_didIteratorError) {\n                          _context.next = 44;\n                          break;\n                        }\n                        throw _iteratorError;\n                      case 44:\n                        return _context.finish(41);\n                      case 45:\n                        return _context.finish(36);\n                      case 46:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee, null, [[2, 32, 36, 46], [37,, 41, 45]]);\n                }));\n                return function pinAdd() {\n                  return _ref.apply(this, arguments);\n                };\n              }(); // When adding a file, we take a lock that gets released after pinning\n              // is complete, so don't take a second lock here\n              lock = Boolean(options.lock);\n              if (lock) {\n                _context2.next = 5;\n                break;\n              }\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator), \"t0\", 4);\n            case 4:\n              return _context2.abrupt(\"return\");\n            case 5:\n              _context2.next = 7;\n              return _awaitAsyncGenerator(repo.gcLock.readLock());\n            case 7:\n              release = _context2.sent;\n              _context2.prev = 8;\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator), \"t1\", 10);\n            case 10:\n              _context2.prev = 10;\n              release();\n              return _context2.finish(10);\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[8,, 10, 13]]);\n      })();\n    });\n    return _addAll.apply(this, arguments);\n  }\n  return withTimeoutOption(addAll);\n}","map":{"version":3,"names":["resolvePath","withTimeoutOption","normaliseInput","PinTypes","createAddAll","_ref2","repo","codecs","addAll","_x","_addAll","apply","arguments","_wrapAsyncGenerator","source","options","length","undefined","_regeneratorRuntime","mark","_callee2","pinAdd","lock","release","wrap","_callee2$","_context2","prev","next","_ref","_callee","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","_step$value","path","recursive","metadata","_yield$_awaitAsyncGen","cid","_yield$_awaitAsyncGen2","reason","_callee$","_context","_asyncIterator","_awaitAsyncGenerator","sent","done","value","pins","isPinnedWithType","direct","Error","concat","pinRecursively","pinDirectly","t0","return","finish","stop","Boolean","delegateYield","_asyncGeneratorDelegate","abrupt","gcLock","readLock"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/pin/add-all.js"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { resolvePath } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input'\nimport { PinTypes } from 'ipfs-repo/pin-types'\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createAddAll ({ repo, codecs }) {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata })\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await repo.gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}