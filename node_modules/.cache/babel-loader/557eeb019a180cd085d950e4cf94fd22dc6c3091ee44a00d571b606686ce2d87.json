{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { logger } from '@libp2p/logger';\nimport * as lp from 'it-length-prefixed';\nimport { handshake } from 'it-handshake';\nimport { CircuitRelay } from '../pb/index.js';\nvar log = logger('libp2p:circuit:stream-handler');\nexport var StreamHandler = /*#__PURE__*/function () {\n  function StreamHandler(options) {\n    _classCallCheck(this, StreamHandler);\n    var stream = options.stream,\n      _options$maxLength = options.maxLength,\n      maxLength = _options$maxLength === void 0 ? 4096 : _options$maxLength;\n    this.stream = stream;\n    this.shake = handshake(this.stream);\n    this.decoder = lp.decode.fromReader(this.shake.reader, {\n      maxDataLength: maxLength\n    });\n  }\n  /**\n   * Read and decode message\n   */\n  _createClass(StreamHandler, [{\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var msg, value;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.decoder.next();\n            case 2:\n              msg = _context.sent;\n              if (!(msg.value != null)) {\n                _context.next = 7;\n                break;\n              }\n              value = CircuitRelay.decode(msg.value);\n              log('read message type', value.type);\n              return _context.abrupt(\"return\", value);\n            case 7:\n              log('read received no value, closing stream');\n              // End the stream, we didn't get data\n              this.close();\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function read() {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n    /**\n     * Encode and write array of buffers\n     */\n  }, {\n    key: \"write\",\n    value: function write(msg) {\n      log('write message type %s', msg.type);\n      this.shake.write(lp.encode.single(CircuitRelay.encode(msg)));\n    }\n    /**\n     * Return the handshake rest stream and invalidate handler\n     */\n  }, {\n    key: \"rest\",\n    value: function rest() {\n      this.shake.rest();\n      return this.shake.stream;\n    }\n    /**\n     * @param {CircuitRelay} msg - An unencoded CircuitRelay protobuf message\n     */\n  }, {\n    key: \"end\",\n    value: function end(msg) {\n      this.write(msg);\n      this.close();\n    }\n    /**\n     * Close the stream\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      log('closing the stream');\n      void this.rest().sink([]).catch(function (err) {\n        log.error(err);\n      });\n    }\n  }]);\n  return StreamHandler;\n}();","map":{"version":3,"names":["logger","lp","handshake","CircuitRelay","log","StreamHandler","options","_classCallCheck","stream","_options$maxLength","maxLength","shake","decoder","decode","fromReader","reader","maxDataLength","_createClass","key","value","_read","_asyncToGenerator","_regeneratorRuntime","mark","_callee","msg","wrap","_callee$","_context","prev","next","sent","type","abrupt","close","stop","read","apply","arguments","write","encode","single","rest","end","sink","catch","err","error"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/circuit/circuit/stream-handler.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport * as lp from 'it-length-prefixed'\nimport { Handshake, handshake } from 'it-handshake'\nimport { CircuitRelay } from '../pb/index.js'\nimport type { Stream } from '@libp2p/interface-connection'\nimport type { Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:circuit:stream-handler')\n\nexport interface StreamHandlerOptions {\n  /**\n   * A duplex iterable\n   */\n  stream: Stream\n\n  /**\n   * max bytes length of message\n   */\n  maxLength?: number\n}\n\nexport class StreamHandler {\n  private readonly stream: Stream\n  private readonly shake: Handshake<Uint8ArrayList | Uint8Array>\n  private readonly decoder: Source<Uint8ArrayList>\n\n  constructor (options: StreamHandlerOptions) {\n    const { stream, maxLength = 4096 } = options\n\n    this.stream = stream\n    this.shake = handshake(this.stream)\n    this.decoder = lp.decode.fromReader(this.shake.reader, { maxDataLength: maxLength })\n  }\n\n  /**\n   * Read and decode message\n   */\n  async read () {\n    // @ts-expect-error FIXME is a source, needs to be a generator\n    const msg = await this.decoder.next()\n\n    if (msg.value != null) {\n      const value = CircuitRelay.decode(msg.value)\n      log('read message type', value.type)\n      return value\n    }\n\n    log('read received no value, closing stream')\n    // End the stream, we didn't get data\n    this.close()\n  }\n\n  /**\n   * Encode and write array of buffers\n   */\n  write (msg: CircuitRelay) {\n    log('write message type %s', msg.type)\n    this.shake.write(lp.encode.single(CircuitRelay.encode(msg)))\n  }\n\n  /**\n   * Return the handshake rest stream and invalidate handler\n   */\n  rest () {\n    this.shake.rest()\n    return this.shake.stream\n  }\n\n  /**\n   * @param {CircuitRelay} msg - An unencoded CircuitRelay protobuf message\n   */\n  end (msg: CircuitRelay) {\n    this.write(msg)\n    this.close()\n  }\n\n  /**\n   * Close the stream\n   */\n  close () {\n    log('closing the stream')\n    void this.rest().sink([]).catch(err => {\n      log.error(err)\n    })\n  }\n}\n"],"mappings":";;;;AAAA,SAASA,MAAM,QAAQ,gBAAgB;AACvC,OAAO,KAAKC,EAAE,MAAM,oBAAoB;AACxC,SAAoBC,SAAS,QAAQ,cAAc;AACnD,SAASC,YAAY,QAAQ,gBAAgB;AAK7C,IAAMC,GAAG,GAAGJ,MAAM,CAAC,+BAA+B,CAAC;AAcnD,WAAaK,aAAa;EAKxB,SAAAA,cAAaC,OAA6B;IAAAC,eAAA,OAAAF,aAAA;IACxC,IAAQG,MAAM,GAAuBF,OAAO,CAApCE,MAAM;MAAAC,kBAAA,GAAuBH,OAAO,CAA5BI,SAAS;MAATA,SAAS,GAAAD,kBAAA,cAAG,IAAI,GAAAA,kBAAA;IAEhC,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACG,KAAK,GAAGT,SAAS,CAAC,IAAI,CAACM,MAAM,CAAC;IACnC,IAAI,CAACI,OAAO,GAAGX,EAAE,CAACY,MAAM,CAACC,UAAU,CAAC,IAAI,CAACH,KAAK,CAACI,MAAM,EAAE;MAAEC,aAAa,EAAEN;IAAS,CAAE,CAAC;EACtF;EAEA;;;EAAAO,YAAA,CAAAZ,aAAA;IAAAa,GAAA;IAAAC,KAAA;MAAA,IAAAC,KAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGA,SAAAC,QAAA;QAAA,IAAAC,GAAA,EAAAN,KAAA;QAAA,OAAAG,mBAAA,GAAAI,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAAF,QAAA,CAAAE,IAAA;cAAA,OAEoB,IAAI,CAAClB,OAAO,CAACkB,IAAI,EAAE;YAAA;cAA/BL,GAAG,GAAAG,QAAA,CAAAG,IAAA;cAAA,MAELN,GAAG,CAACN,KAAK,IAAI,IAAI;gBAAAS,QAAA,CAAAE,IAAA;gBAAA;cAAA;cACbX,KAAK,GAAGhB,YAAY,CAACU,MAAM,CAACY,GAAG,CAACN,KAAK,CAAC;cAC5Cf,GAAG,CAAC,mBAAmB,EAAEe,KAAK,CAACa,IAAI,CAAC;cAAA,OAAAJ,QAAA,CAAAK,MAAA,WAC7Bd,KAAK;YAAA;cAGdf,GAAG,CAAC,wCAAwC,CAAC;cAC7C;cACA,IAAI,CAAC8B,KAAK,EAAE;YAAA;YAAA;cAAA,OAAAN,QAAA,CAAAO,IAAA;UAAA;QAAA,GAAAX,OAAA;MAAA,CACb;MAAA,SAAAY,KAAA;QAAA,OAAAhB,KAAA,CAAAiB,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAF,IAAA;IAAA;IAED;;;EAAA;IAAAlB,GAAA;IAAAC,KAAA,EAGA,SAAAoB,MAAOd,GAAiB;MACtBrB,GAAG,CAAC,uBAAuB,EAAEqB,GAAG,CAACO,IAAI,CAAC;MACtC,IAAI,CAACrB,KAAK,CAAC4B,KAAK,CAACtC,EAAE,CAACuC,MAAM,CAACC,MAAM,CAACtC,YAAY,CAACqC,MAAM,CAACf,GAAG,CAAC,CAAC,CAAC;IAC9D;IAEA;;;EAAA;IAAAP,GAAA;IAAAC,KAAA,EAGA,SAAAuB,KAAA,EAAI;MACF,IAAI,CAAC/B,KAAK,CAAC+B,IAAI,EAAE;MACjB,OAAO,IAAI,CAAC/B,KAAK,CAACH,MAAM;IAC1B;IAEA;;;EAAA;IAAAU,GAAA;IAAAC,KAAA,EAGA,SAAAwB,IAAKlB,GAAiB;MACpB,IAAI,CAACc,KAAK,CAACd,GAAG,CAAC;MACf,IAAI,CAACS,KAAK,EAAE;IACd;IAEA;;;EAAA;IAAAhB,GAAA;IAAAC,KAAA,EAGA,SAAAe,MAAA,EAAK;MACH9B,GAAG,CAAC,oBAAoB,CAAC;MACzB,KAAK,IAAI,CAACsC,IAAI,EAAE,CAACE,IAAI,CAAC,EAAE,CAAC,CAACC,KAAK,CAAC,UAAAC,GAAG,EAAG;QACpC1C,GAAG,CAAC2C,KAAK,CAACD,GAAG,CAAC;MAChB,CAAC,CAAC;IACJ;EAAC;EAAA,OAAAzC,aAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}