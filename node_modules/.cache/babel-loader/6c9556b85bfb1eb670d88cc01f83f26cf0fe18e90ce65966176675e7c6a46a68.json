{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CID } from 'multiformats/cid';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { BitswapMessage as Message } from '../message/index.js';\nimport { Wantlist } from '../wantlist/index.js';\nimport { Ledger } from './ledger.js';\nimport { RequestQueue } from './req-queue.js';\nimport { TaskMerger } from './task-merger.js';\nimport { logger } from '../utils/index.js';\nimport { trackedMap } from '@libp2p/tracked-map';\n\n/**\n * @typedef {import('../message/entry').BitswapMessageEntry} BitswapMessageEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nvar WantType = Message.WantType;\n\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nvar TARGET_MESSAGE_SIZE = 16 * 1024;\n\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nvar MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\nexport var DecisionEngine = /*#__PURE__*/function () {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('interface-blockstore').Blockstore} blockstore\n   * @param {import('../network').Network} network\n   * @param {import('../stats').Stats} stats\n   * @param {import('libp2p').Libp2p} libp2p\n   * @param {object} [opts]\n   * @param {number} [opts.targetMessageSize]\n   * @param {number} [opts.maxSizeReplaceHasWithBlock]\n   */\n  function DecisionEngine(peerId, blockstore, network, stats, libp2p) {\n    var opts = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    _classCallCheck(this, DecisionEngine);\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts);\n\n    // A list of of ledgers by their partner id\n    /** @type {Map<string, Ledger>} */\n    this.ledgerMap = trackedMap({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'ledger-map',\n      metrics: libp2p.metrics\n    });\n    this._running = false;\n\n    // Queue of want-have / want-block per peer\n    this._requestQueue = new RequestQueue(TaskMerger);\n  }\n\n  /**\n   * @template {object} Opts\n   * @param {Opts} opts\n   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}\n   * @private\n   */\n  _createClass(DecisionEngine, [{\n    key: \"_processOpts\",\n    value: function _processOpts(opts) {\n      return _objectSpread({\n        maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n        targetMessageSize: TARGET_MESSAGE_SIZE\n      }, opts);\n    }\n  }, {\n    key: \"_scheduleProcessTasks\",\n    value: function _scheduleProcessTasks() {\n      var _this = this;\n      setTimeout(function () {\n        _this._processTasks();\n      });\n    }\n\n    /**\n     * Pull tasks off the request queue and send a message to the corresponding\n     * peer\n     */\n  }, {\n    key: \"_processTasks\",\n    value: function () {\n      var _processTasks2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this$_requestQueue$p, peerId, tasks, pendingSize, msg, blockCids, blockTasks, _iterator, _step, task, cid, blocks, _iterator2, _step2, _step2$value, topic, taskData, _cid, blk, _iterator3, _step3, _step3$value, cidStr, block;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this._running) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              _this$_requestQueue$p = this._requestQueue.popTasks(this._opts.targetMessageSize), peerId = _this$_requestQueue$p.peerId, tasks = _this$_requestQueue$p.tasks, pendingSize = _this$_requestQueue$p.pendingSize;\n              if (!(tasks.length === 0)) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 5:\n              // Create a new message\n              msg = new Message(false); // Amount of data in the request queue still waiting to be popped\n              msg.setPendingBytes(pendingSize);\n\n              // Split out want-blocks, want-haves and DONT_HAVEs\n              blockCids = [];\n              blockTasks = new Map();\n              _iterator = _createForOfIteratorHelper(tasks);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  task = _step.value;\n                  cid = CID.parse(task.topic);\n                  if (task.data.haveBlock) {\n                    if (task.data.isWantBlock) {\n                      blockCids.push(cid);\n                      blockTasks.set(task.topic, task.data);\n                    } else {\n                      // Add HAVES to the message\n                      msg.addHave(cid);\n                    }\n                  } else {\n                    // Add DONT_HAVEs to the message\n                    msg.addDontHave(cid);\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              _context.next = 13;\n              return this._getBlocks(blockCids);\n            case 13:\n              blocks = _context.sent;\n              _iterator2 = _createForOfIteratorHelper(blockTasks);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  _step2$value = _slicedToArray(_step2.value, 2), topic = _step2$value[0], taskData = _step2$value[1];\n                  _cid = CID.parse(topic);\n                  blk = blocks.get(topic); // If the block was found (it has not been removed)\n                  if (blk) {\n                    // Add the block to the message\n                    msg.addBlock(_cid, blk);\n                  } else {\n                    // The block was not found. If the client requested DONT_HAVE,\n                    // add DONT_HAVE to the message.\n                    if (taskData.sendDontHave) {\n                      msg.addDontHave(_cid);\n                    }\n                  }\n                }\n\n                // If there's nothing in the message, bail out\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              if (!msg.empty) {\n                _context.next = 20;\n                break;\n              }\n              peerId && this._requestQueue.tasksDone(peerId, tasks);\n\n              // Trigger the next round of task processing\n              this._scheduleProcessTasks();\n              return _context.abrupt(\"return\");\n            case 20:\n              _context.prev = 20;\n              _context.t0 = peerId;\n              if (!_context.t0) {\n                _context.next = 25;\n                break;\n              }\n              _context.next = 25;\n              return this.network.sendMessage(peerId, msg);\n            case 25:\n              // Peform sent message accounting\n              _iterator3 = _createForOfIteratorHelper(blocks.entries());\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _step3$value = _slicedToArray(_step3.value, 2), cidStr = _step3$value[0], block = _step3$value[1];\n                  peerId && this.messageSent(peerId, CID.parse(cidStr), block);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              _context.next = 32;\n              break;\n            case 29:\n              _context.prev = 29;\n              _context.t1 = _context[\"catch\"](20);\n              this._log.error(_context.t1);\n            case 32:\n              // Free the tasks up from the request queue\n              peerId && this._requestQueue.tasksDone(peerId, tasks);\n\n              // Trigger the next round of task processing\n              this._scheduleProcessTasks();\n            case 34:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[20, 29]]);\n      }));\n      function _processTasks() {\n        return _processTasks2.apply(this, arguments);\n      }\n      return _processTasks;\n    }()\n    /**\n     * @param {PeerId} peerId\n     * @returns {Map<string, import('../wantlist/entry').WantListEntry>}\n     */\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      var peerIdStr = peerId.toString();\n      var ledger = this.ledgerMap.get(peerIdStr);\n      return ledger ? ledger.wantlist.sortedEntries() : new Map();\n    }\n\n    /**\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      var peerIdStr = peerId.toString();\n      var ledger = this.ledgerMap.get(peerIdStr);\n      if (!ledger) {\n        return null;\n      }\n      return {\n        peer: ledger.partner,\n        value: ledger.debtRatio(),\n        sent: ledger.accounting.bytesSent,\n        recv: ledger.accounting.bytesRecv,\n        exchanged: ledger.exchangeCount\n      };\n    }\n\n    /**\n     * @returns {PeerId[]}\n     */\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return Array.from(this.ledgerMap.values()).map(function (l) {\n        return l.partner;\n      });\n    }\n\n    /**\n     * Receive blocks either from an incoming message from the network, or from\n     * blocks being added by the client on the localhost (eg IPFS add)\n     *\n     * @param {{ cid: CID, data: Uint8Array }[]} blocks\n     */\n  }, {\n    key: \"receivedBlocks\",\n    value: function receivedBlocks(blocks) {\n      if (!blocks.length) {\n        return;\n      }\n\n      // For each connected peer, check if it wants the block we received\n      var _iterator4 = _createForOfIteratorHelper(this.ledgerMap.values()),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var ledger = _step4.value;\n          var _iterator5 = _createForOfIteratorHelper(blocks),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var block = _step5.value;\n              // Filter out blocks that we don't want\n              var want = ledger.wantlistContains(block.cid);\n              if (!want) {\n                continue;\n              }\n\n              // If the block is small enough, just send the block, even if the\n              // client asked for a HAVE\n              var blockSize = block.data.length;\n              var isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n              var entrySize = blockSize;\n              if (!isWantBlock) {\n                entrySize = Message.blockPresenceSize(want.cid);\n              }\n              this._requestQueue.pushTasks(ledger.partner, [{\n                topic: want.cid.toString(base58btc),\n                priority: want.priority,\n                size: entrySize,\n                data: {\n                  blockSize: blockSize,\n                  isWantBlock: isWantBlock,\n                  haveBlock: true,\n                  sendDontHave: false\n                }\n              }]);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      this._scheduleProcessTasks();\n    }\n\n    /**\n     * Handle incoming messages\n     *\n     * @param {PeerId} peerId\n     * @param {Message} msg\n     * @returns {Promise<void>}\n     */\n  }, {\n    key: \"messageReceived\",\n    value: function () {\n      var _messageReceived = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, msg) {\n        var ledger, cancels, wants;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              ledger = this._findOrCreate(peerId);\n              if (!msg.empty) {\n                _context2.next = 3;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 3:\n              // If the message has a full wantlist, clear the current wantlist\n              if (msg.full) {\n                ledger.wantlist = new Wantlist();\n              }\n\n              // Record the amount of block data received\n              this._updateBlockAccounting(msg.blocks, ledger);\n              if (!(msg.wantlist.size === 0)) {\n                _context2.next = 8;\n                break;\n              }\n              this._scheduleProcessTasks();\n              return _context2.abrupt(\"return\");\n            case 8:\n              // Clear cancelled wants and add new wants to the ledger\n              /** @type {CID[]} */\n              cancels = [];\n              /** @type {BitswapMessageEntry[]} */\n              wants = [];\n              msg.wantlist.forEach(function (entry) {\n                if (entry.cancel) {\n                  ledger.cancelWant(entry.cid);\n                  cancels.push(entry.cid);\n                } else {\n                  ledger.wants(entry.cid, entry.priority, entry.wantType);\n                  wants.push(entry);\n                }\n              });\n              this._cancelWants(peerId, cancels);\n              _context2.next = 14;\n              return this._addWants(peerId, wants);\n            case 14:\n              this._scheduleProcessTasks();\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function messageReceived(_x, _x2) {\n        return _messageReceived.apply(this, arguments);\n      }\n      return messageReceived;\n    }()\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @param {CID[]} cids\n     * @returns {void}\n     */\n  }, {\n    key: \"_cancelWants\",\n    value: function _cancelWants(peerId, cids) {\n      var _iterator6 = _createForOfIteratorHelper(cids),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var c = _step6.value;\n          this._requestQueue.remove(c.toString(base58btc), peerId);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @param {BitswapMessageEntry[]} wants\n     * @returns {Promise<void>}\n     */\n  }, {\n    key: \"_addWants\",\n    value: function () {\n      var _addWants2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peerId, wants) {\n        var blockSizes, tasks, _iterator7, _step7, want, id, blockSize, isWantBlock, entrySize;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this._getBlockSizes(wants.map(function (w) {\n                return w.cid;\n              }));\n            case 2:\n              blockSizes = _context3.sent;\n              tasks = [];\n              _iterator7 = _createForOfIteratorHelper(wants);\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  want = _step7.value;\n                  id = want.cid.toString(base58btc);\n                  blockSize = blockSizes.get(id); // If the block was not found\n                  if (blockSize == null) {\n                    // Only add the task to the queue if the requester wants a DONT_HAVE\n                    if (want.sendDontHave) {\n                      tasks.push({\n                        topic: id,\n                        priority: want.priority,\n                        size: Message.blockPresenceSize(want.cid),\n                        data: {\n                          isWantBlock: want.wantType === WantType.Block,\n                          blockSize: 0,\n                          haveBlock: false,\n                          sendDontHave: want.sendDontHave\n                        }\n                      });\n                    }\n                  } else {\n                    // The block was found, add it to the queue\n                    // If the block is small enough, just send the block, even if the\n                    // client asked for a HAVE\n                    isWantBlock = this._sendAsBlock(want.wantType, blockSize); // entrySize is the amount of space the entry takes up in the\n                    // message we send to the recipient. If we're sending a block, the\n                    // entrySize is the size of the block. Otherwise it's the size of\n                    // a block presence entry.\n                    entrySize = blockSize;\n                    if (!isWantBlock) {\n                      entrySize = Message.blockPresenceSize(want.cid);\n                    }\n                    tasks.push({\n                      topic: id,\n                      priority: want.priority,\n                      size: entrySize,\n                      data: {\n                        isWantBlock: isWantBlock,\n                        blockSize: blockSize,\n                        haveBlock: true,\n                        sendDontHave: want.sendDontHave\n                      }\n                    });\n                  }\n                  this._requestQueue.pushTasks(peerId, tasks);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function _addWants(_x3, _x4) {\n        return _addWants2.apply(this, arguments);\n      }\n      return _addWants;\n    }()\n    /**\n     * @private\n     * @param {import('../message/message').Message.Wantlist.WantType} wantType\n     * @param {number} blockSize\n     */\n  }, {\n    key: \"_sendAsBlock\",\n    value: function _sendAsBlock(wantType, blockSize) {\n      return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n    }\n\n    /**\n     * @private\n     * @param {CID[]} cids\n     * @returns {Promise<Map<string, number>>}\n     */\n  }, {\n    key: \"_getBlockSizes\",\n    value: function () {\n      var _getBlockSizes2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cids) {\n        var blocks;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this._getBlocks(cids);\n            case 2:\n              blocks = _context4.sent;\n              return _context4.abrupt(\"return\", new Map(_toConsumableArray(blocks).map(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                  k = _ref2[0],\n                  v = _ref2[1];\n                return [k, v.length];\n              })));\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _getBlockSizes(_x5) {\n        return _getBlockSizes2.apply(this, arguments);\n      }\n      return _getBlockSizes;\n    }()\n    /**\n     * @private\n     * @param {CID[]} cids\n     * @returns {Promise<Map<string, Uint8Array>>}\n     */\n  }, {\n    key: \"_getBlocks\",\n    value: function () {\n      var _getBlocks2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(cids) {\n        var _this2 = this;\n        var res;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              res = new Map();\n              _context6.next = 3;\n              return Promise.all(cids.map( /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cid) {\n                  var block;\n                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                    while (1) switch (_context5.prev = _context5.next) {\n                      case 0:\n                        _context5.prev = 0;\n                        _context5.next = 3;\n                        return _this2.blockstore.get(cid);\n                      case 3:\n                        block = _context5.sent;\n                        res.set(cid.toString(base58btc), block);\n                        _context5.next = 10;\n                        break;\n                      case 7:\n                        _context5.prev = 7;\n                        _context5.t0 = _context5[\"catch\"](0);\n                        if (_context5.t0.code !== 'ERR_NOT_FOUND') {\n                          _this2._log.error('failed to query blockstore for %s: %s', cid, _context5.t0);\n                        }\n                      case 10:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }, _callee5, null, [[0, 7]]);\n                }));\n                return function (_x7) {\n                  return _ref3.apply(this, arguments);\n                };\n              }()));\n            case 3:\n              return _context6.abrupt(\"return\", res);\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function _getBlocks(_x6) {\n        return _getBlocks2.apply(this, arguments);\n      }\n      return _getBlocks;\n    }()\n    /**\n     * @private\n     * @param {Map<string, Uint8Array>} blocksMap\n     * @param {Ledger} ledger\n     */\n  }, {\n    key: \"_updateBlockAccounting\",\n    value: function _updateBlockAccounting(blocksMap, ledger) {\n      var _iterator8 = _createForOfIteratorHelper(blocksMap.values()),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var block = _step8.value;\n          this._log('got block (%s bytes)', block.length);\n          ledger.receivedBytes(block.length);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n\n    /**\n     * Clear up all accounting things after message was sent\n     *\n     * @param {PeerId} peerId\n     * @param {CID} cid\n     * @param {Uint8Array} block\n     */\n  }, {\n    key: \"messageSent\",\n    value: function messageSent(peerId, cid, block) {\n      var ledger = this._findOrCreate(peerId);\n      ledger.sentBytes(block.length);\n      ledger.wantlist.remove(cid);\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {number}\n     */\n  }, {\n    key: \"numBytesSentTo\",\n    value: function numBytesSentTo(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesSent;\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {number}\n     */\n  }, {\n    key: \"numBytesReceivedFrom\",\n    value: function numBytesReceivedFrom(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesRecv;\n    }\n\n    /**\n     *\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"peerDisconnected\",\n    value: function peerDisconnected(peerId) {\n      this.ledgerMap.delete(peerId.toString());\n    }\n\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @returns {Ledger}\n     */\n  }, {\n    key: \"_findOrCreate\",\n    value: function _findOrCreate(peerId) {\n      var peerIdStr = peerId.toString();\n      var ledger = this.ledgerMap.get(peerIdStr);\n      if (ledger) {\n        return ledger;\n      }\n      var l = new Ledger(peerId);\n      this.ledgerMap.set(peerIdStr, l);\n      if (this._stats) {\n        this._stats.push(peerIdStr, 'peerCount', 1);\n      }\n      return l;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false;\n    }\n  }]);\n  return DecisionEngine;\n}();","map":{"version":3,"names":["CID","base58btc","BitswapMessage","Message","Wantlist","Ledger","RequestQueue","TaskMerger","logger","trackedMap","WantType","TARGET_MESSAGE_SIZE","MAX_SIZE_REPLACE_HAS_WITH_BLOCK","DecisionEngine","peerId","blockstore","network","stats","libp2p","opts","arguments","length","undefined","_classCallCheck","_log","_stats","_opts","_processOpts","ledgerMap","system","component","metric","metrics","_running","_requestQueue","_createClass","key","value","_objectSpread","maxSizeReplaceHasWithBlock","targetMessageSize","_scheduleProcessTasks","_this","setTimeout","_processTasks","_processTasks2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this$_requestQueue$p","tasks","pendingSize","msg","blockCids","blockTasks","_iterator","_step","task","cid","blocks","_iterator2","_step2","_step2$value","topic","taskData","_cid","blk","_iterator3","_step3","_step3$value","cidStr","block","wrap","_callee$","_context","prev","next","abrupt","popTasks","setPendingBytes","Map","_createForOfIteratorHelper","s","n","done","parse","data","haveBlock","isWantBlock","push","set","addHave","addDontHave","err","e","f","_getBlocks","sent","_slicedToArray","get","addBlock","sendDontHave","empty","tasksDone","t0","sendMessage","entries","messageSent","t1","error","stop","apply","wantlistForPeer","peerIdStr","toString","ledger","wantlist","sortedEntries","ledgerForPeer","peer","partner","debtRatio","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","peers","Array","from","values","map","l","receivedBlocks","_iterator4","_step4","_iterator5","_step5","want","wantlistContains","blockSize","_sendAsBlock","wantType","entrySize","blockPresenceSize","pushTasks","priority","size","_messageReceived","_callee2","cancels","wants","_callee2$","_context2","_findOrCreate","full","_updateBlockAccounting","forEach","entry","cancel","cancelWant","_cancelWants","_addWants","messageReceived","_x","_x2","cids","_iterator6","_step6","c","remove","_addWants2","_callee3","blockSizes","_iterator7","_step7","id","_callee3$","_context3","_getBlockSizes","w","Block","_x3","_x4","_getBlockSizes2","_callee4","_callee4$","_context4","_toConsumableArray","_ref","_ref2","k","v","_x5","_getBlocks2","_callee6","_this2","res","_callee6$","_context6","Promise","all","_ref3","_callee5","_callee5$","_context5","code","_x7","_x6","blocksMap","_iterator8","_step8","receivedBytes","sentBytes","numBytesSentTo","numBytesReceivedFrom","peerDisconnected","delete","start"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-bitswap/src/decision-engine/index.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { BitswapMessage as Message } from '../message/index.js'\nimport { Wantlist } from '../wantlist/index.js'\nimport { Ledger } from './ledger.js'\nimport { RequestQueue } from './req-queue.js'\nimport { TaskMerger } from './task-merger.js'\nimport { logger } from '../utils/index.js'\nimport { trackedMap } from '@libp2p/tracked-map'\n\n/**\n * @typedef {import('../message/entry').BitswapMessageEntry} BitswapMessageEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nconst WantType = Message.WantType\n\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nconst TARGET_MESSAGE_SIZE = 16 * 1024\n\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024\n\nexport class DecisionEngine {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('interface-blockstore').Blockstore} blockstore\n   * @param {import('../network').Network} network\n   * @param {import('../stats').Stats} stats\n   * @param {import('libp2p').Libp2p} libp2p\n   * @param {object} [opts]\n   * @param {number} [opts.targetMessageSize]\n   * @param {number} [opts.maxSizeReplaceHasWithBlock]\n   */\n  constructor (peerId, blockstore, network, stats, libp2p, opts = {}) {\n    this._log = logger(peerId, 'engine')\n    this.blockstore = blockstore\n    this.network = network\n    this._stats = stats\n    this._opts = this._processOpts(opts)\n\n    // A list of of ledgers by their partner id\n    /** @type {Map<string, Ledger>} */\n    this.ledgerMap = trackedMap({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'ledger-map',\n      metrics: libp2p.metrics\n    })\n    this._running = false\n\n    // Queue of want-have / want-block per peer\n    this._requestQueue = new RequestQueue(TaskMerger)\n  }\n\n  /**\n   * @template {object} Opts\n   * @param {Opts} opts\n   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}\n   * @private\n   */\n  _processOpts (opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    }\n  }\n\n  _scheduleProcessTasks () {\n    setTimeout(() => {\n      this._processTasks()\n    })\n  }\n\n  /**\n   * Pull tasks off the request queue and send a message to the corresponding\n   * peer\n   */\n  async _processTasks () {\n    if (!this._running) {\n      return\n    }\n\n    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize)\n\n    if (tasks.length === 0) {\n      return\n    }\n\n    // Create a new message\n    const msg = new Message(false)\n\n    // Amount of data in the request queue still waiting to be popped\n    msg.setPendingBytes(pendingSize)\n\n    // Split out want-blocks, want-haves and DONT_HAVEs\n    const blockCids = []\n    const blockTasks = new Map()\n    for (const task of tasks) {\n      const cid = CID.parse(task.topic)\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid)\n          blockTasks.set(task.topic, task.data)\n        } else {\n          // Add HAVES to the message\n          msg.addHave(cid)\n        }\n      } else {\n        // Add DONT_HAVEs to the message\n        msg.addDontHave(cid)\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids)\n    for (const [topic, taskData] of blockTasks) {\n      const cid = CID.parse(topic)\n      const blk = blocks.get(topic)\n      // If the block was found (it has not been removed)\n      if (blk) {\n        // Add the block to the message\n        msg.addBlock(cid, blk)\n      } else {\n        // The block was not found. If the client requested DONT_HAVE,\n        // add DONT_HAVE to the message.\n        if (taskData.sendDontHave) {\n          msg.addDontHave(cid)\n        }\n      }\n    }\n\n    // If there's nothing in the message, bail out\n    if (msg.empty) {\n      peerId && this._requestQueue.tasksDone(peerId, tasks)\n\n      // Trigger the next round of task processing\n      this._scheduleProcessTasks()\n\n      return\n    }\n\n    try {\n      // Send the message\n      peerId && await this.network.sendMessage(peerId, msg)\n\n      // Peform sent message accounting\n      for (const [cidStr, block] of blocks.entries()) {\n        peerId && this.messageSent(peerId, CID.parse(cidStr), block)\n      }\n    } catch (err) {\n      this._log.error(err)\n    }\n\n    // Free the tasks up from the request queue\n    peerId && this._requestQueue.tasksDone(peerId, tasks)\n\n    // Trigger the next round of task processing\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {Map<string, import('../wantlist/entry').WantListEntry>}\n   */\n  wantlistForPeer (peerId) {\n    const peerIdStr = peerId.toString()\n    const ledger = this.ledgerMap.get(peerIdStr)\n    return ledger ? ledger.wantlist.sortedEntries() : new Map()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    const peerIdStr = peerId.toString()\n\n    const ledger = this.ledgerMap.get(peerIdStr)\n\n    if (!ledger) {\n      return null\n    }\n\n    return {\n      peer: ledger.partner,\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    }\n  }\n\n  /**\n   * @returns {PeerId[]}\n   */\n  peers () {\n    return Array.from(this.ledgerMap.values()).map((l) => l.partner)\n  }\n\n  /**\n   * Receive blocks either from an incoming message from the network, or from\n   * blocks being added by the client on the localhost (eg IPFS add)\n   *\n   * @param {{ cid: CID, data: Uint8Array }[]} blocks\n   */\n  receivedBlocks (blocks) {\n    if (!blocks.length) {\n      return\n    }\n\n    // For each connected peer, check if it wants the block we received\n    for (const ledger of this.ledgerMap.values()) {\n      for (const block of blocks) {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid)\n\n        if (!want) {\n          continue\n        }\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const blockSize = block.data.length\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(base58btc),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }])\n      }\n    }\n\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * Handle incoming messages\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<void>}\n   */\n  async messageReceived (peerId, msg) {\n    const ledger = this._findOrCreate(peerId)\n\n    if (msg.empty) {\n      return\n    }\n\n    // If the message has a full wantlist, clear the current wantlist\n    if (msg.full) {\n      ledger.wantlist = new Wantlist()\n    }\n\n    // Record the amount of block data received\n    this._updateBlockAccounting(msg.blocks, ledger)\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks()\n      return\n    }\n\n    // Clear cancelled wants and add new wants to the ledger\n    /** @type {CID[]} */\n    const cancels = []\n    /** @type {BitswapMessageEntry[]} */\n    const wants = []\n    msg.wantlist.forEach((entry) => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid)\n        cancels.push(entry.cid)\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType)\n        wants.push(entry)\n      }\n    })\n\n    this._cancelWants(peerId, cancels)\n    await this._addWants(peerId, wants)\n\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID[]} cids\n   * @returns {void}\n   */\n  _cancelWants (peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(base58btc), peerId)\n    }\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {BitswapMessageEntry[]} wants\n   * @returns {Promise<void>}\n   */\n  async _addWants (peerId, wants) {\n    // Get the size of each wanted block\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid))\n\n    const tasks = []\n    for (const want of wants) {\n      const id = want.cid.toString(base58btc)\n      const blockSize = blockSizes.get(id)\n\n      // If the block was not found\n      if (blockSize == null) {\n        // Only add the task to the queue if the requester wants a DONT_HAVE\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: Message.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          })\n        }\n      } else {\n        // The block was found, add it to the queue\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        // entrySize is the amount of space the entry takes up in the\n        // message we send to the recipient. If we're sending a block, the\n        // entrySize is the size of the block. Otherwise it's the size of\n        // a block presence entry.\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        })\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks)\n    }\n  }\n\n  /**\n   * @private\n   * @param {import('../message/message').Message.Wantlist.WantType} wantType\n   * @param {number} blockSize\n   */\n  _sendAsBlock (wantType, blockSize) {\n    return wantType === WantType.Block ||\n      blockSize <= this._opts.maxSizeReplaceHasWithBlock\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, number>>}\n   */\n  async _getBlockSizes (cids) {\n    const blocks = await this._getBlocks(cids)\n    return new Map([...blocks].map(([k, v]) => [k, v.length]))\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, Uint8Array>>}\n   */\n  async _getBlocks (cids) {\n    const res = new Map()\n    await Promise.all(cids.map(async (cid) => {\n      try {\n        const block = await this.blockstore.get(cid)\n        res.set(cid.toString(base58btc), block)\n      } catch (/** @type {any} */ e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e)\n        }\n      }\n    }))\n    return res\n  }\n\n  /**\n   * @private\n   * @param {Map<string, Uint8Array>} blocksMap\n   * @param {Ledger} ledger\n   */\n  _updateBlockAccounting (blocksMap, ledger) {\n    for (const block of blocksMap.values()) {\n      this._log('got block (%s bytes)', block.length)\n      ledger.receivedBytes(block.length)\n    }\n  }\n\n  /**\n   * Clear up all accounting things after message was sent\n   *\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   */\n  messageSent (peerId, cid, block) {\n    const ledger = this._findOrCreate(peerId)\n    ledger.sentBytes(block.length)\n    ledger.wantlist.remove(cid)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n  numBytesSentTo (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n\n  numBytesReceivedFrom (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv\n  }\n\n  /**\n   *\n   * @param {PeerId} peerId\n   */\n  peerDisconnected (peerId) {\n    this.ledgerMap.delete(peerId.toString())\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @returns {Ledger}\n   */\n  _findOrCreate (peerId) {\n    const peerIdStr = peerId.toString()\n    const ledger = this.ledgerMap.get(peerIdStr)\n    if (ledger) {\n      return ledger\n    }\n\n    const l = new Ledger(peerId)\n\n    this.ledgerMap.set(peerIdStr, l)\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1)\n    }\n\n    return l\n  }\n\n  start () {\n    this._running = true\n  }\n\n  stop () {\n    this._running = false\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}