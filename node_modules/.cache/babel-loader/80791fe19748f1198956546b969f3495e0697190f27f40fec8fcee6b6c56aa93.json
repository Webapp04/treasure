{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CID } from 'multiformats/cid';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { base58btc } from 'multiformats/bases/base58';\n// @ts-ignore\nimport vd from 'varint-decoder';\nimport ve from '../utils/varint-encoder.js';\nimport { isMapEqual } from '../utils/index.js';\nimport { Message } from './message.js';\nimport { BitswapMessageEntry as Entry } from './entry.js';\nimport errcode from 'err-code';\n\n/**\n * @typedef {import('../types').MultihashHasherLoader} MultihashHasherLoader\n */\n\nexport var BitswapMessage = /*#__PURE__*/function (_Symbol$toStringTag) {\n  /**\n   * @param {boolean} full\n   */\n  function BitswapMessage(full) {\n    _classCallCheck(this, BitswapMessage);\n    this.full = full;\n    /** @type {Map<string, Entry>} */\n    this.wantlist = new Map();\n\n    /** @type {Map<string, Uint8Array>} */\n    this.blocks = new Map();\n\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n  _createClass(BitswapMessage, [{\n    key: \"empty\",\n    get: function get() {\n      return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n    }\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {number} priority\n     * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n     * @param {boolean} [cancel]\n     * @param {boolean} [sendDontHave]\n     * @returns {void}\n     */\n  }, {\n    key: \"addEntry\",\n    value: function addEntry(cid, priority, wantType, cancel, sendDontHave) {\n      if (wantType == null) {\n        wantType = BitswapMessage.WantType.Block;\n      }\n      var cidStr = cid.toString(base58btc);\n      var entry = this.wantlist.get(cidStr);\n      if (entry) {\n        // Only change priority if want is of the same type\n        if (entry.wantType === wantType) {\n          entry.priority = priority;\n        }\n        // Only change from \"dont cancel\" to \"do cancel\"\n        if (cancel) {\n          entry.cancel = Boolean(cancel);\n        }\n        // Only change from \"dont send\" to \"do send\" DONT_HAVE\n        if (sendDontHave) {\n          entry.sendDontHave = Boolean(sendDontHave);\n        }\n        // want-block overrides existing want-have\n        if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n          entry.wantType = wantType;\n        }\n      } else {\n        this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n      }\n    }\n\n    /**\n     * @param {CID} cid\n     * @param {Uint8Array} block\n     * @returns {void}\n     */\n  }, {\n    key: \"addBlock\",\n    value: function addBlock(cid, block) {\n      var cidStr = cid.toString(base58btc);\n      this.blocks.set(cidStr, block);\n    }\n\n    /**\n     * @param {CID} cid\n     */\n  }, {\n    key: \"addHave\",\n    value: function addHave(cid) {\n      var cidStr = cid.toString(base58btc);\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n      }\n    }\n\n    /**\n     * @param {CID} cid\n     */\n  }, {\n    key: \"addDontHave\",\n    value: function addDontHave(cid) {\n      var cidStr = cid.toString(base58btc);\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n      }\n    }\n\n    /**\n     * @param {CID} cid\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(cid) {\n      var cidStr = cid.toString(base58btc);\n      this.wantlist.delete(cidStr);\n      this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n    }\n\n    /**\n     * @param {number} size\n     */\n  }, {\n    key: \"setPendingBytes\",\n    value: function setPendingBytes(size) {\n      this.pendingBytes = size;\n    }\n\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     *\n     * @returns {Uint8Array}\n     */\n  }, {\n    key: \"serializeToBitswap100\",\n    value: function serializeToBitswap100() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.bytes,\n              // cid\n              priority: Number(entry.priority),\n              cancel: Boolean(entry.cancel)\n            };\n          }),\n          full: this.full ? true : undefined\n        },\n        blocks: Array.from(this.blocks.values())\n      };\n      return Message.encode(msg).finish();\n    }\n\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     *\n     * @returns {Uint8Array}\n     */\n  }, {\n    key: \"serializeToBitswap110\",\n    value: function serializeToBitswap110() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.bytes,\n              // cid\n              priority: Number(entry.priority),\n              wantType: entry.wantType,\n              cancel: Boolean(entry.cancel),\n              sendDontHave: Boolean(entry.sendDontHave)\n            };\n          }),\n          full: this.full ? true : undefined\n        },\n        /** @type {import('./message').Message.BlockPresence[]} */\n        blockPresences: [],\n        /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n        payload: [],\n        pendingBytes: this.pendingBytes\n      };\n      var _iterator = _createForOfIteratorHelper(this.blocks.entries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            cidStr = _step$value[0],\n            data = _step$value[1];\n          var cid = CID.parse(cidStr);\n          var version = cid.version;\n          var codec = cid.code;\n          var multihash = cid.multihash.code;\n          var digestLength = cid.multihash.digest.length;\n          var prefix = ve([version, codec, multihash, digestLength]);\n          msg.payload.push(new Message.Block({\n            prefix: prefix,\n            data: data\n          }));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.blockPresences),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            _cidStr = _step2$value[0],\n            bpType = _step2$value[1];\n          msg.blockPresences.push(new Message.BlockPresence({\n            cid: CID.parse(_cidStr).bytes,\n            type: bpType\n          }));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (this.pendingBytes > 0) {\n        msg.pendingBytes = this.pendingBytes;\n      }\n      return Message.encode(msg).finish();\n    }\n\n    /**\n     * @param {BitswapMessage} other\n     * @returns {boolean}\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) ||\n      // @TODO - Is this a bug ?\n      // @ts-expect-error - isMap equals map values to be objects not numbers\n      !isMapEqual(this.blockPresences, other.blockPresences)) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      var list = Array.from(this.wantlist.keys());\n      var blocks = Array.from(this.blocks.keys());\n      return \"BitswapMessage <full: \".concat(this.full, \", list: \").concat(list, \", blocks: \").concat(blocks, \">\");\n    }\n  }]);\n  return BitswapMessage;\n}(Symbol.toStringTag);\n\n/**\n * @param {Uint8Array} raw\n * @param {MultihashHasherLoader} [hashLoader]\n */\nBitswapMessage.deserialize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(raw, hashLoader) {\n    var decoded, isFull, msg;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          decoded = Message.decode(raw);\n          isFull = decoded.wantlist && decoded.wantlist.full || false;\n          msg = new BitswapMessage(isFull);\n          if (decoded.wantlist && decoded.wantlist.entries) {\n            decoded.wantlist.entries.forEach(function (entry) {\n              if (!entry.block) {\n                return;\n              }\n              // note: entry.block is the CID here\n              var cid = CID.decode(entry.block);\n              msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n            });\n          }\n          if (decoded.blockPresences) {\n            decoded.blockPresences.forEach(function (blockPresence) {\n              if (!blockPresence.cid) {\n                return;\n              }\n              var cid = CID.decode(blockPresence.cid);\n              if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n                msg.addHave(cid);\n              } else {\n                msg.addDontHave(cid);\n              }\n            });\n          }\n\n          // Bitswap 1.0.0\n          // decoded.blocks are just the byte arrays\n          if (!(decoded.blocks.length > 0)) {\n            _context3.next = 9;\n            break;\n          }\n          _context3.next = 8;\n          return Promise.all(decoded.blocks.map( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(b) {\n              var hash, cid;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return sha256.digest(b);\n                  case 2:\n                    hash = _context.sent;\n                    cid = CID.createV0(hash);\n                    msg.addBlock(cid, b);\n                  case 5:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }));\n            return function (_x3) {\n              return _ref2.apply(this, arguments);\n            };\n          }()));\n        case 8:\n          return _context3.abrupt(\"return\", msg);\n        case 9:\n          if (!(decoded.payload.length > 0)) {\n            _context3.next = 14;\n            break;\n          }\n          _context3.next = 12;\n          return Promise.all(decoded.payload.map( /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(p) {\n              var values, cidVersion, multicodec, hashAlg, hasher, hash, cid;\n              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                while (1) switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (!(!p.prefix || !p.data)) {\n                      _context2.next = 2;\n                      break;\n                    }\n                    return _context2.abrupt(\"return\");\n                  case 2:\n                    values = vd(p.prefix);\n                    cidVersion = values[0];\n                    multicodec = values[1];\n                    hashAlg = values[2];\n                    if (!(hashAlg === sha256.code)) {\n                      _context2.next = 10;\n                      break;\n                    }\n                    _context2.t0 = sha256;\n                    _context2.next = 16;\n                    break;\n                  case 10:\n                    _context2.t1 = hashLoader;\n                    if (!_context2.t1) {\n                      _context2.next = 15;\n                      break;\n                    }\n                    _context2.next = 14;\n                    return hashLoader.getHasher(hashAlg);\n                  case 14:\n                    _context2.t1 = _context2.sent;\n                  case 15:\n                    _context2.t0 = _context2.t1;\n                  case 16:\n                    hasher = _context2.t0;\n                    if (hasher) {\n                      _context2.next = 19;\n                      break;\n                    }\n                    throw errcode(new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG');\n                  case 19:\n                    _context2.next = 21;\n                    return hasher.digest(p.data);\n                  case 21:\n                    hash = _context2.sent;\n                    cid = CID.create(cidVersion, multicodec, hash);\n                    msg.addBlock(cid, p.data);\n                  case 24:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }, _callee2);\n            }));\n            return function (_x4) {\n              return _ref3.apply(this, arguments);\n            };\n          }()));\n        case 12:\n          msg.setPendingBytes(decoded.pendingBytes);\n          return _context3.abrupt(\"return\", msg);\n        case 14:\n          return _context3.abrupt(\"return\", msg);\n        case 15:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {CID} cid\n */\nBitswapMessage.blockPresenceSize = function (cid) {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1;\n};\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};","map":{"version":3,"names":["CID","sha256","base58btc","vd","ve","isMapEqual","Message","BitswapMessageEntry","Entry","errcode","BitswapMessage","_Symbol$toStringTag","full","_classCallCheck","wantlist","Map","blocks","blockPresences","pendingBytes","_createClass","key","get","size","value","addEntry","cid","priority","wantType","cancel","sendDontHave","WantType","Block","cidStr","toString","entry","Boolean","Have","set","addBlock","block","addHave","has","BlockPresenceType","addDontHave","DontHave","delete","setPendingBytes","serializeToBitswap100","msg","entries","Array","from","values","map","bytes","Number","undefined","encode","finish","serializeToBitswap110","payload","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","data","parse","version","codec","code","multihash","digestLength","digest","length","prefix","push","err","e","f","_iterator2","_step2","_step2$value","bpType","BlockPresence","type","equals","other","list","keys","concat","Symbol","toStringTag","deserialize","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee3","raw","hashLoader","decoded","isFull","wrap","_callee3$","_context3","prev","next","decode","forEach","blockPresence","Promise","all","_ref2","_callee","b","hash","_callee$","_context","sent","createV0","stop","_x3","apply","arguments","abrupt","_ref3","_callee2","p","cidVersion","multicodec","hashAlg","hasher","_callee2$","_context2","t0","t1","getHasher","Error","create","_x4","_x","_x2","blockPresenceSize","Wantlist"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-bitswap/src/message/index.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { base58btc } from 'multiformats/bases/base58'\n// @ts-ignore\nimport vd from 'varint-decoder'\nimport ve from '../utils/varint-encoder.js'\nimport { isMapEqual } from '../utils/index.js'\nimport { Message } from './message.js'\nimport { BitswapMessageEntry as Entry } from './entry.js'\nimport errcode from 'err-code'\n\n/**\n * @typedef {import('../types').MultihashHasherLoader} MultihashHasherLoader\n */\n\nexport class BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor (full) {\n    this.full = full\n    /** @type {Map<string, Entry>} */\n    this.wantlist = new Map()\n\n    /** @type {Map<string, Uint8Array>} */\n    this.blocks = new Map()\n\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n    this.blockPresences = new Map()\n    this.pendingBytes = 0\n  }\n\n  get empty () {\n    return this.blocks.size === 0 &&\n           this.wantlist.size === 0 &&\n           this.blockPresences.size === 0\n  }\n\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n  addEntry (cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block\n    }\n\n    const cidStr = cid.toString(base58btc)\n    const entry = this.wantlist.get(cidStr)\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel)\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave)\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave))\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n  addBlock (cid, block) {\n    const cidStr = cid.toString(base58btc)\n    this.blocks.set(cidStr, block)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addDontHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  cancel (cid) {\n    const cidStr = cid.toString(base58btc)\n    this.wantlist.delete(cidStr)\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false)\n  }\n\n  /**\n   * @param {number} size\n   */\n  setPendingBytes (size) {\n    this.pendingBytes = size\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap100 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap110 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    }\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n      const version = cid.version\n      const codec = cid.code\n      const multihash = cid.multihash.code\n      const digestLength = cid.multihash.digest.length\n      const prefix = ve([\n        version, codec, multihash, digestLength\n      ])\n\n      msg.payload.push(\n        new Message.Block({\n          prefix,\n          data\n        })\n      )\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }))\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    if (this.full !== other.full ||\n        this.pendingBytes !== other.pendingBytes ||\n        !isMapEqual(this.wantlist, other.wantlist) ||\n        !isMapEqual(this.blocks, other.blocks) ||\n        // @TODO - Is this a bug ?\n        // @ts-expect-error - isMap equals map values to be objects not numbers\n        !isMapEqual(this.blockPresences, other.blockPresences)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    const list = Array.from(this.wantlist.keys())\n    const blocks = Array.from(this.blocks.keys())\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`\n  }\n}\n\n/**\n * @param {Uint8Array} raw\n * @param {MultihashHasherLoader} [hashLoader]\n */\nBitswapMessage.deserialize = async (raw, hashLoader) => {\n  const decoded = Message.decode(raw)\n\n  const isFull = (decoded.wantlist && decoded.wantlist.full) || false\n  const msg = new BitswapMessage(isFull)\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach((entry) => {\n      if (!entry.block) {\n        return\n      }\n      // note: entry.block is the CID here\n      const cid = CID.decode(entry.block)\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave))\n    })\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach((blockPresence) => {\n      if (!blockPresence.cid) {\n        return\n      }\n\n      const cid = CID.decode(blockPresence.cid)\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid)\n      } else {\n        msg.addDontHave(cid)\n      }\n    })\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async (b) => {\n      const hash = await sha256.digest(b)\n      const cid = CID.createV0(hash)\n      msg.addBlock(cid, b)\n    }))\n    return msg\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async (p) => {\n      if (!p.prefix || !p.data) {\n        return\n      }\n      const values = vd(p.prefix)\n      const cidVersion = values[0]\n      const multicodec = values[1]\n      const hashAlg = values[2]\n      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && await hashLoader.getHasher(hashAlg)\n\n      if (!hasher) {\n        throw errcode(new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG')\n      }\n\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await hasher.digest(p.data)\n      const cid = CID.create(cidVersion, multicodec, hash)\n      msg.addBlock(cid, p.data)\n    }))\n    msg.setPendingBytes(decoded.pendingBytes)\n    return msg\n  }\n\n  return msg\n}\n\n/**\n * @param {CID} cid\n */\nBitswapMessage.blockPresenceSize = (cid) => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1\n}\n\nBitswapMessage.Entry = Entry\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}