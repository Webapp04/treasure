{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { codes } from '../errors.js';\nimport * as lp from 'it-length-prefixed';\nimport { FetchRequest, FetchResponse } from './pb/proto.js';\nimport { PROTOCOL_NAME, PROTOCOL_VERSION } from './constants.js';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { pipe } from 'it-pipe';\nimport first from 'it-first';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { setMaxListeners } from 'events';\nvar log = logger('libp2p:fetch');\n/**\n * A simple libp2p protocol for requesting a value corresponding to a key from a peer.\n * Developers can register one or more lookup function for retrieving the value corresponding to\n * a given key.  Each lookup function must act on a distinct part of the overall key space, defined\n * by a fixed prefix that all keys that should be routed to that lookup function will start with.\n */\nexport var FetchService = /*#__PURE__*/function () {\n  function FetchService(components, init) {\n    var _init$protocolPrefix;\n    _classCallCheck(this, FetchService);\n    this.started = false;\n    this.components = components;\n    this.protocol = \"/\".concat((_init$protocolPrefix = init.protocolPrefix) !== null && _init$protocolPrefix !== void 0 ? _init$protocolPrefix : 'libp2p', \"/\").concat(PROTOCOL_NAME, \"/\").concat(PROTOCOL_VERSION);\n    this.lookupFunctions = new Map(); // Maps key prefix to value lookup function\n    this.handleMessage = this.handleMessage.bind(this);\n    this.init = init;\n  }\n  _createClass(FetchService, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.components.getRegistrar().handle(this.protocol, function (data) {\n                void _this.handleMessage(data).catch(function (err) {\n                  log.error(err);\n                }).finally(function () {\n                  data.stream.close();\n                });\n              }, {\n                maxInboundStreams: this.init.maxInboundStreams,\n                maxOutboundStreams: this.init.maxOutboundStreams\n              });\n            case 2:\n              this.started = true;\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.components.getRegistrar().unhandle(this.protocol);\n            case 2:\n              this.started = false;\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n    /**\n     * Sends a request to fetch the value associated with the given key from the given peer\n     */\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peer, key) {\n        var options,\n          connection,\n          timeoutController,\n          signal,\n          stream,\n          source,\n          result,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n              log('dialing %s to %p', this.protocol, peer);\n              _context4.next = 4;\n              return this.components.getConnectionManager().openConnection(peer, options);\n            case 4:\n              connection = _context4.sent;\n              signal = options.signal;\n              // create a timeout if no abort signal passed\n              if (signal == null) {\n                timeoutController = new TimeoutController(this.init.timeout);\n                signal = timeoutController.signal;\n                try {\n                  // fails on node < 15.4\n                  setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, timeoutController.signal);\n                } catch (_unused) {}\n              }\n              _context4.prev = 7;\n              _context4.next = 10;\n              return connection.newStream([this.protocol], {\n                signal: signal\n              });\n            case 10:\n              stream = _context4.sent;\n              // make stream abortable\n              source = abortableDuplex(stream, signal);\n              _context4.next = 14;\n              return pipe([FetchRequest.encode({\n                identifier: key\n              })], lp.encode(), source, lp.decode(), /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n                  var buf, response, errmsg;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return first(source);\n                      case 2:\n                        buf = _context3.sent;\n                        if (!(buf == null)) {\n                          _context3.next = 5;\n                          break;\n                        }\n                        throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE);\n                      case 5:\n                        response = FetchResponse.decode(buf);\n                        _context3.t0 = response.status;\n                        _context3.next = _context3.t0 === FetchResponse.StatusCode.OK ? 9 : _context3.t0 === FetchResponse.StatusCode.NOT_FOUND ? 10 : _context3.t0 === FetchResponse.StatusCode.ERROR ? 11 : 13;\n                        break;\n                      case 9:\n                        return _context3.abrupt(\"return\", response.data);\n                      case 10:\n                        return _context3.abrupt(\"return\", null);\n                      case 11:\n                        errmsg = new TextDecoder().decode(response.data);\n                        throw errCode(new Error('Error in fetch protocol response: ' + errmsg), codes.ERR_INVALID_PARAMETERS);\n                      case 13:\n                        throw errCode(new Error('Unknown response status'), codes.ERR_INVALID_MESSAGE);\n                      case 14:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function (_x4) {\n                  return _ref2.apply(this, arguments);\n                };\n              }());\n            case 14:\n              result = _context4.sent;\n              return _context4.abrupt(\"return\", result !== null && result !== void 0 ? result : null);\n            case 16:\n              _context4.prev = 16;\n              if (timeoutController != null) {\n                timeoutController.clear();\n              }\n              if (stream != null) {\n                stream.close();\n              }\n              return _context4.finish(16);\n            case 20:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[7,, 16, 20]]);\n      }));\n      function fetch(_x2, _x3) {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n    /**\n     * Invoked when a fetch request is received.  Reads the request message off the given stream and\n     * responds based on looking up the key in the request via the lookup callback that corresponds\n     * to the key's prefix.\n     */\n  }, {\n    key: \"handleMessage\",\n    value: function () {\n      var _handleMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(data) {\n        var stream, self;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              stream = data.stream;\n              self = this;\n              _context6.next = 4;\n              return pipe(stream, lp.decode(), /*#__PURE__*/function () {\n                var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(source) {\n                  var buf, request, response, lookup, _data, errmsg;\n                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                    while (1) switch (_context5.prev = _context5.next) {\n                      case 0:\n                        _context5.next = 2;\n                        return _awaitAsyncGenerator(first(source));\n                      case 2:\n                        buf = _context5.sent;\n                        if (!(buf == null)) {\n                          _context5.next = 5;\n                          break;\n                        }\n                        throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE);\n                      case 5:\n                        // for await (const buf of source) {\n                        request = FetchRequest.decode(buf);\n                        lookup = self._getLookupFunction(request.identifier);\n                        if (!(lookup != null)) {\n                          _context5.next = 14;\n                          break;\n                        }\n                        _context5.next = 10;\n                        return _awaitAsyncGenerator(lookup(request.identifier));\n                      case 10:\n                        _data = _context5.sent;\n                        if (_data != null) {\n                          response = {\n                            status: FetchResponse.StatusCode.OK,\n                            data: _data\n                          };\n                        } else {\n                          response = {\n                            status: FetchResponse.StatusCode.NOT_FOUND,\n                            data: new Uint8Array(0)\n                          };\n                        }\n                        _context5.next = 16;\n                        break;\n                      case 14:\n                        errmsg = new TextEncoder().encode('No lookup function registered for key: ' + request.identifier);\n                        response = {\n                          status: FetchResponse.StatusCode.ERROR,\n                          data: errmsg\n                        };\n                      case 16:\n                        _context5.next = 18;\n                        return FetchResponse.encode(response);\n                      case 18:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }, _callee5);\n                }));\n                return function (_x) {\n                  return _ref.apply(this, arguments);\n                };\n              }(), lp.encode(), stream);\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function handleMessage(_x5) {\n        return _handleMessage.apply(this, arguments);\n      }\n      return handleMessage;\n    }()\n    /**\n     * Given a key, finds the appropriate function for looking up its corresponding value, based on\n     * the key's prefix.\n     */\n  }, {\n    key: \"_getLookupFunction\",\n    value: function _getLookupFunction(key) {\n      var _iterator = _createForOfIteratorHelper(this.lookupFunctions.keys()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prefix = _step.value;\n          if (key.startsWith(prefix)) {\n            return this.lookupFunctions.get(prefix);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Registers a new lookup callback that can map keys to values, for a given set of keys that\n     * share the same prefix\n     */\n  }, {\n    key: \"registerLookupFunction\",\n    value: function registerLookupFunction(prefix, lookup) {\n      if (this.lookupFunctions.has(prefix)) {\n        throw errCode(new Error(\"Fetch protocol handler for key prefix '\" + prefix + \"' already registered\"), codes.ERR_KEY_ALREADY_EXISTS);\n      }\n      this.lookupFunctions.set(prefix, lookup);\n    }\n    /**\n     * Registers a new lookup callback that can map keys to values, for a given set of keys that\n     * share the same prefix.\n     */\n  }, {\n    key: \"unregisterLookupFunction\",\n    value: function unregisterLookupFunction(prefix, lookup) {\n      if (lookup != null) {\n        var existingLookup = this.lookupFunctions.get(prefix);\n        if (existingLookup !== lookup) {\n          return;\n        }\n      }\n      this.lookupFunctions.delete(prefix);\n    }\n  }]);\n  return FetchService;\n}();","map":{"version":3,"names":["logger","errCode","codes","lp","FetchRequest","FetchResponse","PROTOCOL_NAME","PROTOCOL_VERSION","abortableDuplex","pipe","first","TimeoutController","setMaxListeners","log","FetchService","components","init","_init$protocolPrefix","_classCallCheck","started","protocol","concat","protocolPrefix","lookupFunctions","Map","handleMessage","bind","_createClass","key","value","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this","wrap","_callee$","_context","prev","next","getRegistrar","handle","data","catch","err","error","finally","stream","close","maxInboundStreams","maxOutboundStreams","stop","start","apply","arguments","_stop","_callee2","_callee2$","_context2","unhandle","isStarted","_fetch","_callee4","peer","options","connection","timeoutController","signal","source","result","_args4","_callee4$","_context4","length","undefined","getConnectionManager","openConnection","sent","timeout","Infinity","_unused","newStream","encode","identifier","decode","_ref2","_callee3","buf","response","errmsg","_callee3$","_context3","Error","ERR_INVALID_MESSAGE","t0","status","StatusCode","OK","NOT_FOUND","ERROR","abrupt","TextDecoder","ERR_INVALID_PARAMETERS","_x4","clear","finish","fetch","_x2","_x3","_handleMessage","_callee6","self","_callee6$","_context6","_ref","_wrapAsyncGenerator","_callee5","request","lookup","_data","_callee5$","_context5","_awaitAsyncGenerator","_getLookupFunction","Uint8Array","TextEncoder","_x","_x5","_iterator","_createForOfIteratorHelper","keys","_step","s","n","done","prefix","startsWith","get","e","f","registerLookupFunction","has","ERR_KEY_ALREADY_EXISTS","set","unregisterLookupFunction","existingLookup","delete"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/fetch/index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { codes } from '../errors.js'\nimport * as lp from 'it-length-prefixed'\nimport { FetchRequest, FetchResponse } from './pb/proto.js'\nimport { PROTOCOL_NAME, PROTOCOL_VERSION } from './constants.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { Stream } from '@libp2p/interface-connection'\nimport type { IncomingStreamData } from '@libp2p/interface-registrar'\nimport type { Components } from '@libp2p/components'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { pipe } from 'it-pipe'\nimport first from 'it-first'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { setMaxListeners } from 'events'\n\nconst log = logger('libp2p:fetch')\n\nexport interface FetchServiceInit {\n  protocolPrefix: string\n  maxInboundStreams: number\n  maxOutboundStreams: number\n\n  /**\n   * How long we should wait for a remote peer to send any data\n   */\n  timeout: number\n}\n\nexport interface HandleMessageOptions {\n  stream: Stream\n  protocol: string\n}\n\nexport interface LookupFunction {\n  (key: string): Promise<Uint8Array | null>\n}\n\n/**\n * A simple libp2p protocol for requesting a value corresponding to a key from a peer.\n * Developers can register one or more lookup function for retrieving the value corresponding to\n * a given key.  Each lookup function must act on a distinct part of the overall key space, defined\n * by a fixed prefix that all keys that should be routed to that lookup function will start with.\n */\nexport class FetchService implements Startable {\n  public readonly protocol: string\n  private readonly components: Components\n  private readonly lookupFunctions: Map<string, LookupFunction>\n  private started: boolean\n  private readonly init: FetchServiceInit\n\n  constructor (components: Components, init: FetchServiceInit) {\n    this.started = false\n    this.components = components\n    this.protocol = `/${init.protocolPrefix ?? 'libp2p'}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n    this.lookupFunctions = new Map() // Maps key prefix to value lookup function\n    this.handleMessage = this.handleMessage.bind(this)\n    this.init = init\n  }\n\n  async start () {\n    await this.components.getRegistrar().handle(this.protocol, (data) => {\n      void this.handleMessage(data)\n        .catch(err => {\n          log.error(err)\n        })\n        .finally(() => {\n          data.stream.close()\n        })\n    }, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    })\n    this.started = true\n  }\n\n  async stop () {\n    await this.components.getRegistrar().unhandle(this.protocol)\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer\n   */\n  async fetch (peer: PeerId, key: string, options: AbortOptions = {}): Promise<Uint8Array | null> {\n    log('dialing %s to %p', this.protocol, peer)\n\n    const connection = await this.components.getConnectionManager().openConnection(peer, options)\n    let timeoutController\n    let signal = options.signal\n    let stream: Stream | undefined\n\n    // create a timeout if no abort signal passed\n    if (signal == null) {\n      timeoutController = new TimeoutController(this.init.timeout)\n      signal = timeoutController.signal\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream([this.protocol], {\n        signal\n      })\n\n      // make stream abortable\n      const source = abortableDuplex(stream, signal)\n\n      const result = await pipe(\n        [FetchRequest.encode({ identifier: key })],\n        lp.encode(),\n        source,\n        lp.decode(),\n        async function (source) {\n          const buf = await first(source)\n\n          if (buf == null) {\n            throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE)\n          }\n\n          const response = FetchResponse.decode(buf)\n\n          switch (response.status) {\n            case (FetchResponse.StatusCode.OK): {\n              return response.data\n            }\n            case (FetchResponse.StatusCode.NOT_FOUND): {\n              return null\n            }\n            case (FetchResponse.StatusCode.ERROR): {\n              const errmsg = (new TextDecoder()).decode(response.data)\n              throw errCode(new Error('Error in fetch protocol response: ' + errmsg), codes.ERR_INVALID_PARAMETERS)\n            }\n            default: {\n              throw errCode(new Error('Unknown response status'), codes.ERR_INVALID_MESSAGE)\n            }\n          }\n        }\n      )\n\n      return result ?? null\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n\n      if (stream != null) {\n        stream.close()\n      }\n    }\n  }\n\n  /**\n   * Invoked when a fetch request is received.  Reads the request message off the given stream and\n   * responds based on looking up the key in the request via the lookup callback that corresponds\n   * to the key's prefix.\n   */\n  async handleMessage (data: IncomingStreamData) {\n    const { stream } = data\n    const self = this\n\n    await pipe(\n      stream,\n      lp.decode(),\n      async function * (source) {\n        const buf = await first(source)\n\n        if (buf == null) {\n          throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE)\n        }\n\n        // for await (const buf of source) {\n        const request = FetchRequest.decode(buf)\n\n        let response: FetchResponse\n        const lookup = self._getLookupFunction(request.identifier)\n        if (lookup != null) {\n          const data = await lookup(request.identifier)\n          if (data != null) {\n            response = { status: FetchResponse.StatusCode.OK, data }\n          } else {\n            response = { status: FetchResponse.StatusCode.NOT_FOUND, data: new Uint8Array(0) }\n          }\n        } else {\n          const errmsg = (new TextEncoder()).encode('No lookup function registered for key: ' + request.identifier)\n          response = { status: FetchResponse.StatusCode.ERROR, data: errmsg }\n        }\n\n        yield FetchResponse.encode(response)\n      },\n      lp.encode(),\n      stream\n    )\n  }\n\n  /**\n   * Given a key, finds the appropriate function for looking up its corresponding value, based on\n   * the key's prefix.\n   */\n  _getLookupFunction (key: string) {\n    for (const prefix of this.lookupFunctions.keys()) {\n      if (key.startsWith(prefix)) {\n        return this.lookupFunctions.get(prefix)\n      }\n    }\n  }\n\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix\n   */\n  registerLookupFunction (prefix: string, lookup: LookupFunction) {\n    if (this.lookupFunctions.has(prefix)) {\n      throw errCode(new Error(\"Fetch protocol handler for key prefix '\" + prefix + \"' already registered\"), codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    this.lookupFunctions.set(prefix, lookup)\n  }\n\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix.\n   */\n  unregisterLookupFunction (prefix: string, lookup?: LookupFunction) {\n    if (lookup != null) {\n      const existingLookup = this.lookupFunctions.get(prefix)\n\n      if (existingLookup !== lookup) {\n        return\n      }\n    }\n\n    this.lookupFunctions.delete(prefix)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}