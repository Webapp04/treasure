{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Key } from 'interface-datastore';\nimport { BaseDatastore } from 'datastore-core';\nimport { encodeBase32, keyToTopic, topicToKey } from './utils.js';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nvar log = logger('datastore-pubsub:publisher');\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('@libp2p/interface-pubsub').Message} PubSubMessage\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nexport var PubSubDatastore = /*#__PURE__*/function (_BaseDatastore) {\n  _inherits(PubSubDatastore, _BaseDatastore);\n  var _super = _createSuper(PubSubDatastore);\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {import('@libp2p/interface-dht').ValidateFn} validator - validator function\n   * @param {import('@libp2p/interface-dht').SelectFn} selector - selector function\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  function PubSubDatastore(pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {\n    var _this;\n    _classCallCheck(this, PubSubDatastore);\n    _this = _super.call(this);\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n    if (typeof validator !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n    if (typeof selector !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n    _this._pubsub = pubsub;\n    _this._datastore = datastore;\n    _this._peerId = peerId;\n    _this._validator = validator;\n    _this._selector = selector;\n    _this._handleSubscriptionKeyFn = subscriptionKeyFn;\n\n    // Bind _onMessage function, which is called by pubsub.\n    _this._onMessage = _this._onMessage.bind(_assertThisInitialized(_this));\n    _this._pubsub.addEventListener('message', _this._onMessage);\n    return _this;\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  _createClass(PubSubDatastore, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, val, options) {\n        var errMsg, _errMsg, stringifiedTopic;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (key instanceof Uint8Array) {\n                _context.next = 4;\n                break;\n              }\n              errMsg = 'datastore key does not have a valid format';\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n            case 4:\n              if (val instanceof Uint8Array) {\n                _context.next = 8;\n                break;\n              }\n              _errMsg = 'received value is not a Uint8Array';\n              log.error(_errMsg);\n              throw errcode(new Error(_errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n            case 8:\n              stringifiedTopic = keyToTopic(key);\n              log(\"publish value for topic \".concat(stringifiedTopic));\n\n              // Publish record to pubsub\n              _context.next = 12;\n              return this._pubsub.publish(stringifiedTopic, val);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function put(_x, _x2, _x3) {\n        return _put.apply(this, arguments);\n      }\n      return put;\n    }()\n    /**\n     * Try to subscribe a topic with Pubsub and returns the local value if available.\n     *\n     * @param {Uint8Array} key - identifier of the value to be subscribed.\n     * @param {AbortOptions} [options]\n     */\n    // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, options) {\n        var errMsg, stringifiedTopic, subscriptions, _errMsg2;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (key instanceof Uint8Array) {\n                _context2.next = 4;\n                break;\n              }\n              errMsg = 'datastore key does not have a valid format';\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n            case 4:\n              stringifiedTopic = keyToTopic(key);\n              _context2.next = 7;\n              return this._pubsub.getTopics();\n            case 7:\n              subscriptions = _context2.sent;\n              if (!(subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1)) {\n                _context2.next = 10;\n                break;\n              }\n              return _context2.abrupt(\"return\", this._getLocal(key, options));\n            case 10:\n              _context2.prev = 10;\n              _context2.next = 13;\n              return this._pubsub.subscribe(stringifiedTopic);\n            case 13:\n              _context2.next = 20;\n              break;\n            case 15:\n              _context2.prev = 15;\n              _context2.t0 = _context2[\"catch\"](10);\n              _errMsg2 = \"cannot subscribe topic \".concat(stringifiedTopic);\n              log.error(_errMsg2);\n              throw errcode(new Error(_errMsg2), 'ERR_SUBSCRIBING_TOPIC');\n            case 20:\n              log(\"subscribed values for key \".concat(stringifiedTopic));\n              return _context2.abrupt(\"return\", this._getLocal(key));\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[10, 15]]);\n      }));\n      function get(_x4, _x5) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n    /**\n     * Unsubscribe topic.\n     *\n     * @param {Uint8Array} key - identifier of the value to unsubscribe.\n     * @returns {void}\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(key) {\n      var stringifiedTopic = keyToTopic(key);\n      return this._pubsub.unsubscribe(stringifiedTopic);\n    }\n\n    /**\n     * Get record from local datastore\n     *\n     * @private\n     * @param {Uint8Array} key\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"_getLocal\",\n    value: function () {\n      var _getLocal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key, options) {\n        var routingKey, dsVal, _errMsg3, errMsg, _errMsg4;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // encode key - base32(/ipns/{cid})\n              routingKey = new Key('/' + encodeBase32(key), false);\n              _context3.prev = 1;\n              _context3.next = 4;\n              return this._datastore.get(routingKey, options);\n            case 4:\n              dsVal = _context3.sent;\n              _context3.next = 16;\n              break;\n            case 7:\n              _context3.prev = 7;\n              _context3.t0 = _context3[\"catch\"](1);\n              if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                _context3.next = 13;\n                break;\n              }\n              _errMsg3 = \"unexpected error getting the ipns record for \".concat(routingKey.toString());\n              log.error(_errMsg3);\n              throw errcode(new Error(_errMsg3), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n            case 13:\n              errMsg = \"local record requested was not found for \".concat(routingKey.toString());\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n            case 16:\n              if (dsVal instanceof Uint8Array) {\n                _context3.next = 20;\n                break;\n              }\n              _errMsg4 = 'found record that we couldn\\'t convert to a value';\n              log.error(_errMsg4);\n              throw errcode(new Error(_errMsg4), 'ERR_INVALID_RECORD_RECEIVED');\n            case 20:\n              return _context3.abrupt(\"return\", dsVal);\n            case 21:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 7]]);\n      }));\n      function _getLocal(_x6, _x7) {\n        return _getLocal2.apply(this, arguments);\n      }\n      return _getLocal;\n    }()\n    /**\n     * handles pubsub subscription messages\n     *\n     * @param {CustomEvent<PubSubMessage>} evt\n     */\n  }, {\n    key: \"_onMessage\",\n    value: function () {\n      var _onMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(evt) {\n        var msg, data, from, topic, key, res;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              msg = evt.detail;\n              if (!(msg.type !== 'signed')) {\n                _context4.next = 4;\n                break;\n              }\n              log.error('unsigned message received, this module can only work with signed messages');\n              return _context4.abrupt(\"return\");\n            case 4:\n              data = msg.data, from = msg.from, topic = msg.topic;\n              _context4.prev = 5;\n              key = topicToKey(topic);\n              _context4.next = 13;\n              break;\n            case 9:\n              _context4.prev = 9;\n              _context4.t0 = _context4[\"catch\"](5);\n              log.error(_context4.t0);\n              return _context4.abrupt(\"return\");\n            case 13:\n              log(\"message received for topic \".concat(topic));\n\n              // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n              if (!this._peerId.equals(from)) {\n                _context4.next = 17;\n                break;\n              }\n              log('message discarded as it is from the same peer');\n              return _context4.abrupt(\"return\");\n            case 17:\n              if (!this._handleSubscriptionKeyFn) {\n                _context4.next = 29;\n                break;\n              }\n              _context4.prev = 18;\n              _context4.next = 21;\n              return this._handleSubscriptionKeyFn(key);\n            case 21:\n              res = _context4.sent;\n              _context4.next = 28;\n              break;\n            case 24:\n              _context4.prev = 24;\n              _context4.t1 = _context4[\"catch\"](18);\n              log.error('message discarded by the subscriptionKeyFn');\n              return _context4.abrupt(\"return\");\n            case 28:\n              key = res;\n            case 29:\n              _context4.prev = 29;\n              _context4.next = 32;\n              return this._storeIfSubscriptionIsBetter(key, data);\n            case 32:\n              _context4.next = 37;\n              break;\n            case 34:\n              _context4.prev = 34;\n              _context4.t2 = _context4[\"catch\"](29);\n              log.error(_context4.t2);\n            case 37:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[5, 9], [18, 24], [29, 34]]);\n      }));\n      function _onMessage(_x8) {\n        return _onMessage2.apply(this, arguments);\n      }\n      return _onMessage;\n    }()\n    /**\n     * Store the received record if it is better than the current stored\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} data\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"_storeIfSubscriptionIsBetter\",\n    value: function () {\n      var _storeIfSubscriptionIsBetter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key, data, options) {\n        var isBetter;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              isBetter = false;\n              _context5.prev = 1;\n              _context5.next = 4;\n              return this._isBetter(key, data);\n            case 4:\n              isBetter = _context5.sent;\n              _context5.next = 11;\n              break;\n            case 7:\n              _context5.prev = 7;\n              _context5.t0 = _context5[\"catch\"](1);\n              if (!(_context5.t0.code !== 'ERR_NOT_VALID_RECORD')) {\n                _context5.next = 11;\n                break;\n              }\n              throw _context5.t0;\n            case 11:\n              if (!isBetter) {\n                _context5.next = 14;\n                break;\n              }\n              _context5.next = 14;\n              return this._storeRecord(key, data, options);\n            case 14:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[1, 7]]);\n      }));\n      function _storeIfSubscriptionIsBetter(_x9, _x10, _x11) {\n        return _storeIfSubscriptionIsBetter2.apply(this, arguments);\n      }\n      return _storeIfSubscriptionIsBetter;\n    }()\n    /**\n     * Validate record according to the received validation function\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     */\n  }, {\n    key: \"_validateRecord\",\n    value: function () {\n      var _validateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key, value) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this._validator(key, value));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function _validateRecord(_x12, _x13) {\n        return _validateRecord2.apply(this, arguments);\n      }\n      return _validateRecord;\n    }()\n    /**\n     * Select the best record according to the received select function\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array[]} records\n     */\n  }, {\n    key: \"_selectRecord\",\n    value: function () {\n      var _selectRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(key, records) {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this._selector(key, records);\n            case 2:\n              res = _context7.sent;\n              return _context7.abrupt(\"return\", res === 0);\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function _selectRecord(_x14, _x15) {\n        return _selectRecord2.apply(this, arguments);\n      }\n      return _selectRecord;\n    }()\n    /**\n     * Verify if the record received through pubsub is valid and better than the one currently stored\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} val\n     */\n  }, {\n    key: \"_isBetter\",\n    value: function () {\n      var _isBetter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(key, val) {\n        var errMsg, dsKey, currentRecord;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.prev = 0;\n              _context8.next = 3;\n              return this._validateRecord(key, val);\n            case 3:\n              _context8.next = 10;\n              break;\n            case 5:\n              _context8.prev = 5;\n              _context8.t0 = _context8[\"catch\"](0);\n              // If not valid, it is not better than the one currently available\n              errMsg = 'record received through pubsub is not valid';\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n            case 10:\n              // Get Local record\n              dsKey = new Key(key);\n              _context8.prev = 11;\n              _context8.next = 14;\n              return this._getLocal(dsKey.uint8Array());\n            case 14:\n              currentRecord = _context8.sent;\n              _context8.next = 20;\n              break;\n            case 17:\n              _context8.prev = 17;\n              _context8.t1 = _context8[\"catch\"](11);\n              return _context8.abrupt(\"return\", true);\n            case 20:\n              if (!uint8ArrayEquals(currentRecord, val)) {\n                _context8.next = 22;\n                break;\n              }\n              return _context8.abrupt(\"return\", false);\n            case 22:\n              return _context8.abrupt(\"return\", this._selectRecord(key, [currentRecord, val]));\n            case 23:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[0, 5], [11, 17]]);\n      }));\n      function _isBetter(_x16, _x17) {\n        return _isBetter2.apply(this, arguments);\n      }\n      return _isBetter;\n    }()\n    /**\n     * add record to datastore\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} data\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"_storeRecord\",\n    value: function () {\n      var _storeRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(key, data, options) {\n        var routingKey;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              // encode key - base32(/ipns/{cid})\n              routingKey = new Key('/' + encodeBase32(key), false);\n              _context9.next = 3;\n              return this._datastore.put(routingKey, data, options);\n            case 3:\n              log(\"record for \".concat(keyToTopic(key), \" was stored in the datastore\"));\n            case 4:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function _storeRecord(_x18, _x19, _x20) {\n        return _storeRecord2.apply(this, arguments);\n      }\n      return _storeRecord;\n    }()\n  }]);\n  return PubSubDatastore;\n}(BaseDatastore);","map":{"version":3,"names":["Key","BaseDatastore","encodeBase32","keyToTopic","topicToKey","equals","uint8ArrayEquals","errcode","logger","log","PubSubDatastore","_BaseDatastore","_inherits","_super","_createSuper","pubsub","datastore","peerId","validator","selector","subscriptionKeyFn","_this","_classCallCheck","call","TypeError","_pubsub","_datastore","_peerId","_validator","_selector","_handleSubscriptionKeyFn","_onMessage","bind","_assertThisInitialized","addEventListener","_createClass","key","value","_put","_asyncToGenerator","_regeneratorRuntime","mark","_callee","val","options","errMsg","_errMsg","stringifiedTopic","wrap","_callee$","_context","prev","next","Uint8Array","error","Error","concat","publish","stop","put","_x","_x2","_x3","apply","arguments","_get","_callee2","subscriptions","_errMsg2","_callee2$","_context2","getTopics","sent","Array","isArray","indexOf","abrupt","_getLocal","subscribe","t0","get","_x4","_x5","unsubscribe","_getLocal2","_callee3","routingKey","dsVal","_errMsg3","_errMsg4","_callee3$","_context3","code","toString","_x6","_x7","_onMessage2","_callee4","evt","msg","data","from","topic","res","_callee4$","_context4","detail","type","t1","_storeIfSubscriptionIsBetter","t2","_x8","_storeIfSubscriptionIsBetter2","_callee5","isBetter","_callee5$","_context5","_isBetter","_storeRecord","_x9","_x10","_x11","_validateRecord2","_callee6","_callee6$","_context6","_validateRecord","_x12","_x13","_selectRecord2","_callee7","records","_callee7$","_context7","_selectRecord","_x14","_x15","_isBetter2","_callee8","dsKey","currentRecord","_callee8$","_context8","uint8Array","_x16","_x17","_storeRecord2","_callee9","_callee9$","_context9","_x18","_x19","_x20"],"sources":["/Users/apple/Documents/treasure/node_modules/datastore-pubsub/src/index.js"],"sourcesContent":["import { Key } from 'interface-datastore'\nimport { BaseDatastore } from 'datastore-core'\nimport { encodeBase32, keyToTopic, topicToKey } from './utils.js'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('datastore-pubsub:publisher')\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('@libp2p/interface-pubsub').Message} PubSubMessage\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nexport class PubSubDatastore extends BaseDatastore {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {import('@libp2p/interface-dht').ValidateFn} validator - validator function\n   * @param {import('@libp2p/interface-dht').SelectFn} selector - selector function\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof selector !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._selector = selector\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n    this._pubsub.addEventListener('message', this._onMessage)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put (key, val, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get (key, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key, options)\n    }\n\n    // subscribe\n    try {\n      await this._pubsub.subscribe(stringifiedTopic)\n    } catch (/** @type {any} */ err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    return this._pubsub.unsubscribe(stringifiedTopic)\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   * @param {AbortOptions} [options]\n   */\n  async _getLocal (key, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey, options)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND')\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {CustomEvent<PubSubMessage>} evt\n   */\n  async _onMessage (evt) {\n    const msg = evt.detail\n\n    if (msg.type !== 'signed') {\n      log.error('unsigned message received, this module can only work with signed messages')\n      return\n    }\n\n    const { data, from, topic } = msg\n    let key\n    try {\n      key = topicToKey(topic)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topic}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (this._peerId.equals(from)) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (/** @type {any} */ err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeIfSubscriptionIsBetter (key, data, options) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data, options)\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   */\n  async _validateRecord (key, value) { // eslint-disable-line require-await\n    return this._validator(key, value)\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord (key, records) {\n    const res = await this._selector(key, records)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter (key, val) {\n    try {\n      await this._validateRecord(key, val)\n    } catch (/** @type {any} */ err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array())\n    } catch (/** @type {any} */ err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val])\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeRecord (key, data, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data, options)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}