{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as ipns from 'ipns';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport * as Errors from 'datastore-core/errors';\nimport { ipnsValidator } from 'ipns/validator';\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nvar log = logger('ipfs:ipns:resolver');\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\nvar defaultMaximumRecursiveDepth = 32;\nexport var IpnsResolver = /*#__PURE__*/function () {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  function IpnsResolver(routing) {\n    _classCallCheck(this, IpnsResolver);\n    this._routing = routing;\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  _createClass(IpnsResolver, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name) {\n        var options,\n          recursive,\n          nameSegments,\n          key,\n          depth,\n          res,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              if (!(typeof name !== 'string')) {\n                _context.next = 3;\n                break;\n              }\n              throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n            case 3:\n              recursive = options.recursive && options.recursive.toString() === 'true';\n              nameSegments = name.split('/');\n              if (!(nameSegments.length !== 3 || nameSegments[0] !== '')) {\n                _context.next = 7;\n                break;\n              }\n              throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n            case 7:\n              key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n              depth = Infinity;\n              if (recursive) {\n                depth = defaultMaximumRecursiveDepth;\n              }\n              _context.next = 12;\n              return this.resolver(key, depth, options);\n            case 12:\n              res = _context.sent;\n              log(\"\".concat(name, \" was locally resolved correctly\"));\n              return _context.abrupt(\"return\", res);\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function resolve(_x) {\n        return _resolve.apply(this, arguments);\n      }\n      return resolve;\n    }()\n    /**\n     * Recursive resolver according to the specified depth\n     *\n     * @param {string} name\n     * @param {number} depth\n     * @param {AbortOptions} options\n     * @returns {Promise<string>}\n     */\n  }, {\n    key: \"resolver\",\n    value: function () {\n      var _resolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name, depth, options) {\n        var errMsg, res, nameSegments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(depth === 0)) {\n                _context2.next = 4;\n                break;\n              }\n              errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n            case 4:\n              _context2.next = 6;\n              return this._resolveName(name, options);\n            case 6:\n              res = _context2.sent;\n              nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n              if (!(nameSegments[1] === 'ipfs' || !depth)) {\n                _context2.next = 10;\n                break;\n              }\n              return _context2.abrupt(\"return\", res);\n            case 10:\n              return _context2.abrupt(\"return\", this.resolver(nameSegments[2], depth - 1, options));\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function resolver(_x2, _x3, _x4) {\n        return _resolver.apply(this, arguments);\n      }\n      return resolver;\n    }()\n    /**\n     * Resolve ipns entries from the provided routing\n     *\n     * @param {string} name\n     * @param {AbortOptions} options\n     */\n  }, {\n    key: \"_resolveName\",\n    value: function () {\n      var _resolveName2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(name, options) {\n        var peerId, routingKey, record;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              peerId = peerIdFromString(name);\n              routingKey = ipns.peerIdToRoutingKey(peerId);\n              _context3.prev = 2;\n              _context3.next = 5;\n              return this._routing.get(routingKey, options);\n            case 5:\n              record = _context3.sent;\n              _context3.next = 14;\n              break;\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3[\"catch\"](2);\n              log.error('could not get record from routing', _context3.t0);\n              if (!(_context3.t0.code === ERR_NOT_FOUND)) {\n                _context3.next = 13;\n                break;\n              }\n              throw errcode(new Error(\"record requested for \".concat(name, \" was not found in the network\")), 'ERR_NO_RECORD_FOUND');\n            case 13:\n              throw errcode(new Error(\"unexpected error getting the ipns record \".concat(peerId.toString())), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n            case 14:\n              return _context3.abrupt(\"return\", this._validateRecord(peerId, record));\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[2, 8]]);\n      }));\n      function _resolveName(_x5, _x6) {\n        return _resolveName2.apply(this, arguments);\n      }\n      return _resolveName;\n    }()\n    /**\n     * Validate a resolved record\n     *\n     * @param {PeerId} peerId\n     * @param {Uint8Array} record\n     */\n  }, {\n    key: \"_validateRecord\",\n    value: function () {\n      var _validateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId, record) {\n        var ipnsEntry;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return ipnsValidator(uint8ArrayConcat([uint8ArrayFromString('/ipns/'), peerId.toBytes()]), record);\n            case 2:\n              ipnsEntry = ipns.unmarshal(record);\n              return _context4.abrupt(\"return\", uint8ArrayToString(ipnsEntry.value));\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function _validateRecord(_x7, _x8) {\n        return _validateRecord2.apply(this, arguments);\n      }\n      return _validateRecord;\n    }()\n  }]);\n  return IpnsResolver;\n}();","map":{"version":3,"names":["ipns","peerIdFromString","errcode","logger","toString","uint8ArrayToString","fromString","uint8ArrayFromString","concat","uint8ArrayConcat","Errors","ipnsValidator","log","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","routing","_classCallCheck","_routing","_createClass","key","value","_resolve","_asyncToGenerator","_regeneratorRuntime","mark","_callee","name","options","recursive","nameSegments","depth","res","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","Error","split","Infinity","resolver","sent","abrupt","stop","resolve","_x","apply","_resolver","_callee2","errMsg","_callee2$","_context2","error","_resolveName","_x2","_x3","_x4","_resolveName2","_callee3","peerId","routingKey","record","_callee3$","_context3","peerIdToRoutingKey","get","t0","_validateRecord","_x5","_x6","_validateRecord2","_callee4","ipnsEntry","_callee4$","_context4","toBytes","unmarshal","_x7","_x8"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/ipns/resolver.js"],"sourcesContent":["import * as ipns from 'ipns'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport * as Errors from 'datastore-core/errors'\nimport { ipnsValidator } from 'ipns/validator'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst log = logger('ipfs:ipns:resolver')\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nexport class IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth = Infinity\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth, options)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @param {AbortOptions} options\n   * @returns {Promise<string>}\n   */\n  async resolver (name, depth, options) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name, options)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1, options)\n  }\n\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   * @param {AbortOptions} options\n   */\n  async _resolveName (name, options) {\n    const peerId = peerIdFromString(name)\n    const routingKey = ipns.peerIdToRoutingKey(peerId)\n    let record\n\n    try {\n      record = await this._routing.get(routingKey, options)\n    } catch (/** @type {any} */ err) {\n      log.error('could not get record from routing', err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, record)\n  }\n\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} record\n   */\n  async _validateRecord (peerId, record) {\n    // IPNS entry validation\n    await ipnsValidator(uint8ArrayConcat([\n      uint8ArrayFromString('/ipns/'),\n      peerId.toBytes()\n    ]), record)\n\n    const ipnsEntry = ipns.unmarshal(record)\n\n    return uint8ArrayToString(ipnsEntry.value)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}