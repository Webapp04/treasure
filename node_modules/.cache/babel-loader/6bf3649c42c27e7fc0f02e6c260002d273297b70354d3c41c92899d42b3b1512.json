{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport source from './source.js';\nimport sink from './sink.js';\nexport default (function (socket, options) {\n  var _options;\n  options = (_options = options) !== null && _options !== void 0 ? _options : {};\n  var connectedSource = source(socket);\n  var remoteAddress = options.remoteAddress;\n  var remotePort = options.remotePort;\n  if (socket.url != null) {\n    // only client->server sockets have urls, server->client connections do not\n    try {\n      var url = new URL(socket.url);\n      remoteAddress = url.hostname;\n      remotePort = parseInt(url.port, 10);\n    } catch (_unused) {}\n  }\n  if (remoteAddress == null || remotePort == null) {\n    throw new Error('Remote connection did not have address and/or port');\n  }\n  var duplex = {\n    sink: sink(socket, options),\n    source: connectedSource,\n    connected: function () {\n      var _connected = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return connectedSource.connected();\n            case 2:\n              return _context.abrupt(\"return\", _context.sent);\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function connected() {\n        return _connected.apply(this, arguments);\n      }\n      return connected;\n    }(),\n    close: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN)) {\n                _context2.next = 3;\n                break;\n              }\n              _context2.next = 3;\n              return new Promise(function (resolve) {\n                socket.addEventListener('close', function () {\n                  resolve();\n                });\n                socket.close();\n              });\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }(),\n    destroy: function destroy() {\n      if (socket.terminate != null) {\n        socket.terminate();\n      } else {\n        socket.close();\n      }\n    },\n    remoteAddress: remoteAddress,\n    remotePort: remotePort,\n    socket: socket\n  };\n  return duplex;\n});","map":{"version":3,"names":["source","sink","socket","options","_options","connectedSource","remoteAddress","remotePort","url","URL","hostname","parseInt","port","_unused","Error","duplex","connected","_connected","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","sent","stop","apply","arguments","close","_close","_callee2","_callee2$","_context2","readyState","CONNECTING","OPEN","Promise","resolve","addEventListener","destroy","terminate"],"sources":["/Users/apple/Documents/treasure/node_modules/it-ws/src/duplex.ts"],"sourcesContent":["import source from './source.js'\nimport sink from './sink.js'\nimport type WebSocket from './web-socket.js'\nimport type { SinkOptions } from './sink.js'\nimport type { Duplex } from 'it-stream-types'\n\nexport interface DuplexWebSocket extends Duplex<Uint8Array, Uint8Array, Promise<void>> {\n  connected: () => Promise<void>\n  localAddress?: string\n  localPort?: number\n  remoteAddress: string\n  remotePort: number\n  close: () => Promise<void>\n  destroy: () => void\n  socket: WebSocket\n}\n\nexport interface DuplexWebSocketOptions extends SinkOptions {\n  remoteAddress?: string\n  remotePort?: number\n}\n\nexport default (socket: WebSocket, options?: DuplexWebSocketOptions): DuplexWebSocket => {\n  options = options ?? {}\n\n  const connectedSource = source(socket)\n  let remoteAddress: string | undefined = options.remoteAddress\n  let remotePort: number | undefined = options.remotePort\n\n  if (socket.url != null) {\n    // only client->server sockets have urls, server->client connections do not\n    try {\n      const url = new URL(socket.url)\n      remoteAddress = url.hostname\n      remotePort = parseInt(url.port, 10)\n    } catch {}\n  }\n\n  if (remoteAddress == null || remotePort == null) {\n    throw new Error('Remote connection did not have address and/or port')\n  }\n\n  const duplex: DuplexWebSocket = {\n    sink: sink(socket, options),\n    source: connectedSource,\n    connected: async () => await connectedSource.connected(),\n    close: async () => {\n      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {\n        await new Promise<void>((resolve) => {\n          socket.addEventListener('close', () => {\n            resolve()\n          })\n          socket.close()\n        })\n      }\n    },\n    destroy: () => {\n      if (socket.terminate != null) {\n        socket.terminate()\n      } else {\n        socket.close()\n      }\n    },\n    remoteAddress,\n    remotePort,\n    socket\n  }\n\n  return duplex\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}