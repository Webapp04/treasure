{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport mergeOpts from 'merge-options';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { base36 } from 'multiformats/bases/base36';\nimport { peerIdFromString } from '@libp2p/peer-id';\n// @ts-expect-error no types\nimport isDomain from 'is-domain-name';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { OFFLINE_ERROR } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nvar mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nvar log = logger('ipfs:name:resolve');\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nvar appendRemainder = function appendRemainder(result, remainder) {\n  return remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n};\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('ipfs-core-types/src/root').API<{}>[\"dns\"]} config.dns\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nexport function createResolve(_ref) {\n  var dns = _ref.dns,\n    ipns = _ref.ipns,\n    isOnline = _ref.isOnline,\n    offline = _ref.options.offline;\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"resolve\"]}\n   */\n  function resolve(_x) {\n    return _resolve.apply(this, arguments);\n  }\n  function _resolve() {\n    _resolve = _wrapAsyncGenerator(function (name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var ipnsName, _ipnsName$slice$split, _ipnsName$slice$split2, namespace, hash, remainder, id, digest, libp2pKey, cid, value;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              options = mergeOptions({\n                nocache: false,\n                recursive: true\n              }, options);\n\n              // TODO: params related logic should be in the core implementation\n              if (!(offline && options && options.nocache)) {\n                _context.next = 3;\n                break;\n              }\n              throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n            case 3:\n              if (!(!isOnline() && !offline)) {\n                _context.next = 5;\n                break;\n              }\n              throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n            case 5:\n              ipnsName = name.toString();\n              if (!ipnsName.startsWith('/ipns/')) {\n                ipnsName = \"/ipns/\".concat(ipnsName);\n              }\n              _ipnsName$slice$split = ipnsName.slice(1).split('/'), _ipnsName$slice$split2 = _toArray(_ipnsName$slice$split), namespace = _ipnsName$slice$split2[0], hash = _ipnsName$slice$split2[1], remainder = _ipnsName$slice$split2.slice(2);\n              _context.prev = 8;\n              if (hash.substring(0, 1) === '1') {\n                id = peerIdFromString(hash);\n                digest = Digest.decode(id.toBytes());\n                libp2pKey = CID.createV1(0x72, digest);\n                hash = libp2pKey.toString(base36);\n              } else {\n                cid = CID.parse(hash);\n                if (cid.version === 1) {\n                  hash = cid.toString(base36);\n                }\n              }\n              _context.next = 25;\n              break;\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](8);\n              if (!isDomain(hash)) {\n                _context.next = 23;\n                break;\n              }\n              _context.t1 = appendRemainder;\n              _context.next = 18;\n              return _awaitAsyncGenerator(dns(hash, options));\n            case 18:\n              _context.t2 = _context.sent;\n              _context.t3 = remainder;\n              _context.next = 22;\n              return (0, _context.t1)(_context.t2, _context.t3);\n            case 22:\n              return _context.abrupt(\"return\");\n            case 23:\n              log.error(_context.t0);\n              throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n            case 25:\n              _context.next = 27;\n              return _awaitAsyncGenerator(ipns.resolve(\"/\".concat(namespace, \"/\").concat(hash), options));\n            case 27:\n              value = _context.sent;\n              _context.next = 30;\n              return appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);\n            case 30:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[8, 12]]);\n      })();\n    });\n    return _resolve.apply(this, arguments);\n  }\n  return withTimeoutOption(resolve);\n}","map":{"version":3,"names":["logger","errcode","mergeOpts","CID","Digest","base36","peerIdFromString","isDomain","toString","uint8ArrayToString","OFFLINE_ERROR","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","appendRemainder","result","remainder","length","join","createResolve","_ref","dns","ipns","isOnline","offline","options","resolve","_x","_resolve","apply","arguments","_wrapAsyncGenerator","name","undefined","_regeneratorRuntime","mark","_callee","ipnsName","_ipnsName$slice$split","_ipnsName$slice$split2","namespace","hash","id","digest","libp2pKey","cid","value","wrap","_callee$","_context","prev","next","nocache","recursive","Error","startsWith","concat","slice","split","_toArray","substring","decode","toBytes","createV1","parse","version","t0","t1","_awaitAsyncGenerator","t2","sent","t3","abrupt","error","Uint8Array","stop"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/name/resolve.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errcode from 'err-code'\nimport mergeOpts from 'merge-options'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { base36 } from 'multiformats/bases/base36'\nimport { peerIdFromString } from '@libp2p/peer-id'\n// @ts-expect-error no types\nimport isDomain from 'is-domain-name'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { OFFLINE_ERROR } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst log = logger('ipfs:name:resolve')\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nconst appendRemainder = (result, remainder) =>\n  remainder.length > 0\n    ? result + '/' + remainder.join('/')\n    : result\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('ipfs-core-types/src/root').API<{}>[\"dns\"]} config.dns\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nexport function createResolve ({ dns, ipns, isOnline, options: { offline } }) {\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"resolve\"]}\n   */\n  async function * resolve (name, options = {}) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options)\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    let ipnsName = name.toString()\n\n    if (!ipnsName.startsWith('/ipns/')) {\n      ipnsName = `/ipns/${ipnsName}`\n    }\n\n    let [namespace, hash, ...remainder] = ipnsName.slice(1).split('/')\n\n    try {\n      if (hash.substring(0, 1) === '1') {\n        const id = peerIdFromString(hash)\n        const digest = Digest.decode(id.toBytes())\n        const libp2pKey = CID.createV1(0x72, digest)\n        hash = libp2pKey.toString(base36)\n      } else {\n        const cid = CID.parse(hash)\n\n        if (cid.version === 1) {\n          hash = cid.toString(base36)\n        }\n      }\n    } catch (/** @type {any} */ err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // TODO: convert ipns.resolve to return an iterator\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options)\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder)\n  }\n\n  return withTimeoutOption(resolve)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}