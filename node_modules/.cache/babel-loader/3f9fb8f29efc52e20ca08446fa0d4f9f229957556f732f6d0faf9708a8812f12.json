{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport errCode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { exporter } from 'ipfs-unixfs-exporter';\nimport { createNode } from './utils/create-node.js';\nimport { toPathComponents } from './utils/to-path-components.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { addLink } from './utils/add-link.js';\nimport { loadMfsRoot } from './utils/with-mfs-root.js';\nimport mergeOpts from 'merge-options';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nvar mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nvar log = logger('ipfs:mfs:mkdir');\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nvar defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\n\n/**\n * @param {MfsContext} context\n */\nexport function createMkdir(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"mkdir\"]}\n   */\n  function mfsMkdir(_x) {\n    return _mfsMkdir.apply(this, arguments);\n  }\n  function _mfsMkdir() {\n    _mfsMkdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path) {\n      var options,\n        opts,\n        pathComponents,\n        root,\n        parent,\n        trail,\n        emptyDir,\n        i,\n        subPathComponents,\n        subPath,\n        newRootCid,\n        _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            /** @type {DefaultOptions} */\n            opts = mergeOptions(defaultOptions, options);\n            if (path) {\n              _context.next = 4;\n              break;\n            }\n            throw new Error('no path given to Mkdir');\n          case 4:\n            path = path.trim();\n            if (!(path === '/')) {\n              _context.next = 9;\n              break;\n            }\n            if (!opts.parents) {\n              _context.next = 8;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 8:\n            throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n          case 9:\n            if (!(path.substring(0, 1) !== '/')) {\n              _context.next = 11;\n              break;\n            }\n            throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n          case 11:\n            log(\"Creating \".concat(path));\n            pathComponents = toPathComponents(path);\n            if (!(pathComponents[0] === 'ipfs')) {\n              _context.next = 15;\n              break;\n            }\n            throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n          case 15:\n            _context.next = 17;\n            return loadMfsRoot(context, opts);\n          case 17:\n            root = _context.sent;\n            trail = [];\n            _context.next = 21;\n            return createNode(context, 'directory', opts);\n          case 21:\n            emptyDir = _context.sent;\n            i = 0;\n          case 23:\n            if (!(i <= pathComponents.length)) {\n              _context.next = 52;\n              break;\n            }\n            subPathComponents = pathComponents.slice(0, i);\n            subPath = \"/ipfs/\".concat(root, \"/\").concat(subPathComponents.join('/'));\n            _context.prev = 26;\n            _context.next = 29;\n            return exporter(subPath, context.repo.blocks);\n          case 29:\n            parent = _context.sent;\n            if (!(parent.type !== 'file' && parent.type !== 'directory')) {\n              _context.next = 32;\n              break;\n            }\n            throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n          case 32:\n            if (!(i === pathComponents.length)) {\n              _context.next = 36;\n              break;\n            }\n            if (!opts.parents) {\n              _context.next = 35;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 35:\n            throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n          case 36:\n            trail.push({\n              name: parent.name,\n              cid: parent.cid\n            });\n            _context.next = 49;\n            break;\n          case 39:\n            _context.prev = 39;\n            _context.t0 = _context[\"catch\"](26);\n            if (!(_context.t0.code === 'ERR_NOT_FOUND')) {\n              _context.next = 48;\n              break;\n            }\n            if (!(i < pathComponents.length && !opts.parents)) {\n              _context.next = 44;\n              break;\n            }\n            throw errCode(new Error(\"Intermediate directory path \".concat(subPath, \" does not exist, use the -p flag to create it\")), 'ERR_NOT_FOUND');\n          case 44:\n            _context.next = 46;\n            return addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n          case 46:\n            _context.next = 49;\n            break;\n          case 48:\n            throw _context.t0;\n          case 49:\n            i++;\n            _context.next = 23;\n            break;\n          case 52:\n            _context.next = 54;\n            return updateTree(context, trail, opts);\n          case 54:\n            newRootCid = _context.sent;\n            _context.next = 57;\n            return updateMfsRoot(context, newRootCid, opts);\n          case 57:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[26, 39]]);\n    }));\n    return _mfsMkdir.apply(this, arguments);\n  }\n  return withTimeoutOption(mfsMkdir);\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\nvar addEmptyDir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, childName, emptyDir, parent, trail, options) {\n    var result;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          log(\"Adding empty dir called \".concat(childName, \" to \").concat(parent.cid));\n          _context2.next = 3;\n          return addLink(context, {\n            parent: parent.node,\n            parentCid: parent.cid,\n            // TODO vmx 2021-03-09: Remove the usage of size completely\n            size: 0,\n            cid: emptyDir.cid,\n            name: childName,\n            hashAlg: options.hashAlg,\n            cidVersion: options.cidVersion,\n            flush: options.flush,\n            shardSplitThreshold: options.shardSplitThreshold\n          });\n        case 3:\n          result = _context2.sent;\n          trail[trail.length - 1].cid = result.cid;\n          trail.push({\n            name: childName,\n            cid: emptyDir.cid\n          });\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function addEmptyDir(_x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["errCode","logger","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","loadMfsRoot","mergeOpts","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","createMkdir","context","mfsMkdir","_x","_mfsMkdir","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","path","options","opts","pathComponents","root","parent","trail","emptyDir","i","subPathComponents","subPath","newRootCid","_args","wrap","_callee$","_context","prev","next","length","undefined","Error","trim","abrupt","substring","concat","sent","slice","join","repo","blocks","type","push","name","cid","t0","code","addEmptyDir","stop","_ref","_callee2","childName","result","_callee2$","_context2","node","parentCid","size","_x2","_x3","_x4","_x5","_x6","_x7"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/mkdir.js"],"sourcesContent":["import errCode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { createNode } from './utils/create-node.js'\nimport { toPathComponents } from './utils/to-path-components.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { addLink } from './utils/add-link.js'\nimport { loadMfsRoot } from './utils/with-mfs-root.js'\nimport mergeOpts from 'merge-options'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:mkdir')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createMkdir (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"mkdir\"]}\n   */\n  async function mfsMkdir (path, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === '/') {\n      if (opts.parents) {\n        return\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await loadMfsRoot(context, opts)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', opts)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.repo.blocks)\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (/** @type {any} */ err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsMkdir)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}