{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { logger } from '@libp2p/logger';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { DirSharded } from './dir-sharded.js';\nimport { updateHamtDirectory, recreateHamtLevel, recreateInitialHamtLevel, createShard, toPrefix, addLinksToHamtBucket } from './hamt-utils.js';\nimport errCode from 'err-code';\nimport last from 'it-last';\nvar log = logger('ipfs:mfs:core:utils:add-link');\n\n/**\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {number} options.shardSplitThreshold\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {CID} [options.parentCid]\n * @param {PBNode} [options.parent]\n */\nexport function addLink(_x, _x2) {\n  return _addLink.apply(this, arguments);\n}\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {Mtime} [options.mtime]\n * @param {number} [options.mode]\n */\nfunction _addLink() {\n  _addLink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(context, options) {\n    var parent, parentCid, block, meta;\n    return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          parent = options.parent;\n          if (!options.parentCid) {\n            _context6.next = 12;\n            break;\n          }\n          parentCid = CID.asCID(options.parentCid);\n          if (!(parentCid === null)) {\n            _context6.next = 5;\n            break;\n          }\n          throw errCode(new Error('Invalid CID passed to addLink'), 'EINVALIDPARENTCID');\n        case 5:\n          if (!(parentCid.code !== dagPB.code)) {\n            _context6.next = 7;\n            break;\n          }\n          throw errCode(new Error('Unsupported codec. Only DAG-PB is supported'), 'EINVALIDPARENTCID');\n        case 7:\n          log(\"Loading parent node \".concat(parentCid));\n          _context6.next = 10;\n          return context.repo.blocks.get(parentCid);\n        case 10:\n          block = _context6.sent;\n          parent = dagPB.decode(block);\n        case 12:\n          if (parent) {\n            _context6.next = 14;\n            break;\n          }\n          throw errCode(new Error('No parent node or CID passed to addLink'), 'EINVALIDPARENT');\n        case 14:\n          if (options.cid) {\n            _context6.next = 16;\n            break;\n          }\n          throw errCode(new Error('No child cid passed to addLink'), 'EINVALIDCHILDCID');\n        case 16:\n          if (options.name) {\n            _context6.next = 18;\n            break;\n          }\n          throw errCode(new Error('No child name passed to addLink'), 'EINVALIDCHILDNAME');\n        case 18:\n          if (!(!options.size && options.size !== 0)) {\n            _context6.next = 20;\n            break;\n          }\n          throw errCode(new Error('No child size passed to addLink'), 'EINVALIDCHILDSIZE');\n        case 20:\n          if (parent.Data) {\n            _context6.next = 22;\n            break;\n          }\n          throw errCode(new Error('Parent node with no data passed to addLink'), 'ERR_INVALID_PARENT');\n        case 22:\n          meta = UnixFS.unmarshal(parent.Data);\n          if (!(meta.type === 'hamt-sharded-directory')) {\n            _context6.next = 26;\n            break;\n          }\n          log('Adding link to sharded directory');\n          return _context6.abrupt(\"return\", addToShardedDirectory(context, _objectSpread(_objectSpread({}, options), {}, {\n            parent: parent\n          })));\n        case 26:\n          if (!(parent.Links.length >= options.shardSplitThreshold)) {\n            _context6.next = 29;\n            break;\n          }\n          log('Converting directory to sharded directory');\n          return _context6.abrupt(\"return\", convertToShardedDirectory(context, _objectSpread(_objectSpread({}, options), {}, {\n            parent: parent,\n            mtime: meta.mtime,\n            mode: meta.mode\n          })));\n        case 29:\n          log(\"Adding \".concat(options.name, \" (\").concat(options.cid, \") to regular directory\"));\n          return _context6.abrupt(\"return\", addToDirectory(context, _objectSpread(_objectSpread({}, options), {}, {\n            parent: parent\n          })));\n        case 31:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee5);\n  }));\n  return _addLink.apply(this, arguments);\n}\nvar convertToShardedDirectory = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, options) {\n    var result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return createShard(context, options.parent.Links.map(function (link) {\n            return {\n              name: link.Name || '',\n              size: link.Tsize || 0,\n              cid: link.Hash\n            };\n          }).concat({\n            name: options.name,\n            size: options.size,\n            cid: options.cid\n          }), options);\n        case 2:\n          result = _context.sent;\n          log(\"Converted directory to sharded directory \".concat(result.cid));\n          return _context.abrupt(\"return\", result);\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function convertToShardedDirectory(_x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {Mtime} [options.mtime]\n * @param {number} [options.mode]\n */\nvar addToDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, options) {\n    var parentLinks, node, data, ms, secs, hasher, buf, hash, cid;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          // Remove existing link if it exists\n          parentLinks = options.parent.Links.filter(function (link) {\n            return link.Name !== options.name;\n          });\n          parentLinks.push({\n            Name: options.name,\n            Tsize: options.size,\n            Hash: options.cid\n          });\n          if (options.parent.Data) {\n            _context2.next = 4;\n            break;\n          }\n          throw errCode(new Error('Parent node with no data passed to addToDirectory'), 'ERR_INVALID_PARENT');\n        case 4:\n          node = UnixFS.unmarshal(options.parent.Data);\n          if (node.mtime) {\n            // Update mtime if previously set\n            ms = Date.now();\n            secs = Math.floor(ms / 1000);\n            node.mtime = {\n              secs: secs,\n              nsecs: (ms - secs * 1000) * 1000\n            };\n            data = node.marshal();\n          } else {\n            data = options.parent.Data;\n          }\n          options.parent = dagPB.prepare({\n            Data: data,\n            Links: parentLinks\n          });\n\n          // Persist the new parent PbNode\n          _context2.next = 9;\n          return context.hashers.getHasher(options.hashAlg);\n        case 9:\n          hasher = _context2.sent;\n          buf = dagPB.encode(options.parent);\n          _context2.next = 13;\n          return hasher.digest(buf);\n        case 13:\n          hash = _context2.sent;\n          cid = CID.create(options.cidVersion, dagPB.code, hash);\n          if (!options.flush) {\n            _context2.next = 18;\n            break;\n          }\n          _context2.next = 18;\n          return context.repo.blocks.put(cid, buf);\n        case 18:\n          return _context2.abrupt(\"return\", {\n            node: options.parent,\n            cid: cid,\n            size: buf.length\n          });\n        case 19:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function addToDirectory(_x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n */\nvar addToShardedDirectory = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(context, options) {\n    var _yield$addFileToShard, shard, path, result, block, node, parentLinks, newLink;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return addFileToShardedDirectory(context, options);\n        case 2:\n          _yield$addFileToShard = _context3.sent;\n          shard = _yield$addFileToShard.shard;\n          path = _yield$addFileToShard.path;\n          _context3.next = 7;\n          return last(shard.flush(context.repo.blocks));\n        case 7:\n          result = _context3.sent;\n          if (result) {\n            _context3.next = 10;\n            break;\n          }\n          throw new Error('No result from flushing shard');\n        case 10:\n          _context3.next = 12;\n          return context.repo.blocks.get(result.cid);\n        case 12:\n          block = _context3.sent;\n          node = dagPB.decode(block); // we have written out the shard, but only one sub-shard will have been written so replace it in the original shard\n          parentLinks = options.parent.Links.filter(function (link) {\n            // TODO vmx 2021-03-31: Check that there cannot be multiple ones matching\n            // Remove the old link\n            return (link.Name || '').substring(0, 2) !== path[0].prefix;\n          });\n          newLink = node.Links.find(function (link) {\n            return (link.Name || '').substring(0, 2) === path[0].prefix;\n          });\n          if (newLink) {\n            _context3.next = 18;\n            break;\n          }\n          throw new Error(\"No link found with prefix \".concat(path[0].prefix));\n        case 18:\n          parentLinks.push(newLink);\n          return _context3.abrupt(\"return\", updateHamtDirectory(context, parentLinks, path[0].bucket, options));\n        case 20:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function addToShardedDirectory(_x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n */\nvar addFileToShardedDirectory = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(context, options) {\n    var file, rootBucket, node, shard, position, path, index, _loop, _ret;\n    return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          file = {\n            name: options.name,\n            cid: options.cid,\n            size: options.size\n          };\n          if (options.parent.Data) {\n            _context5.next = 3;\n            break;\n          }\n          throw errCode(new Error('Parent node with no data passed to addFileToShardedDirectory'), 'ERR_INVALID_PARENT');\n        case 3:\n          _context5.next = 5;\n          return recreateInitialHamtLevel(options.parent.Links);\n        case 5:\n          rootBucket = _context5.sent;\n          node = UnixFS.unmarshal(options.parent.Data);\n          shard = new DirSharded({\n            root: true,\n            dir: true,\n            parent: undefined,\n            parentKey: undefined,\n            path: '',\n            dirty: true,\n            flat: false,\n            mode: node.mode\n          }, options);\n          shard._bucket = rootBucket;\n          if (node.mtime) {\n            // update mtime if previously set\n            shard.mtime = {\n              secs: Math.round(Date.now() / 1000)\n            };\n          }\n\n          // load subshards until the bucket & position no longer changes\n          _context5.next = 12;\n          return rootBucket._findNewBucketAndPos(file.name);\n        case 12:\n          position = _context5.sent;\n          path = toBucketPath(position);\n          path[0].node = options.parent;\n          index = 0;\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var segment, node, link, block, subShard, _position, nextSegment;\n            return _regeneratorRuntime().wrap(function _loop$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  segment = path[index];\n                  index++;\n                  node = segment.node;\n                  if (node) {\n                    _context4.next = 5;\n                    break;\n                  }\n                  throw new Error('Segment had no node');\n                case 5:\n                  link = node.Links.find(function (link) {\n                    return (link.Name || '').substring(0, 2) === segment.prefix;\n                  });\n                  if (link) {\n                    _context4.next = 10;\n                    break;\n                  }\n                  // prefix is new, file will be added to the current bucket\n                  log(\"Link \".concat(segment.prefix).concat(file.name, \" will be added\"));\n                  index = path.length;\n                  return _context4.abrupt(\"return\", 0);\n                case 10:\n                  if (!(link.Name === \"\".concat(segment.prefix).concat(file.name))) {\n                    _context4.next = 14;\n                    break;\n                  }\n                  // file already existed, file will be added to the current bucket\n                  log(\"Link \".concat(segment.prefix).concat(file.name, \" will be replaced\"));\n                  index = path.length;\n                  return _context4.abrupt(\"return\", 0);\n                case 14:\n                  if (!((link.Name || '').length > 2)) {\n                    _context4.next = 18;\n                    break;\n                  }\n                  // another file had the same prefix, will be replaced with a subshard\n                  log(\"Link \".concat(link.Name, \" \").concat(link.Hash, \" will be replaced with a subshard\"));\n                  index = path.length;\n                  return _context4.abrupt(\"return\", 0);\n                case 18:\n                  // load sub-shard\n                  log(\"Found subshard \".concat(segment.prefix));\n                  _context4.next = 21;\n                  return context.repo.blocks.get(link.Hash);\n                case 21:\n                  block = _context4.sent;\n                  subShard = dagPB.decode(block); // subshard hasn't been loaded, descend to the next level of the HAMT\n                  if (path[index]) {\n                    _context4.next = 32;\n                    break;\n                  }\n                  log(\"Loaded new subshard \".concat(segment.prefix));\n                  _context4.next = 27;\n                  return recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));\n                case 27:\n                  _context4.next = 29;\n                  return rootBucket._findNewBucketAndPos(file.name);\n                case 29:\n                  _position = _context4.sent;\n                  path.push({\n                    bucket: _position.bucket,\n                    prefix: toPrefix(_position.pos),\n                    node: subShard\n                  });\n                  return _context4.abrupt(\"return\", 0);\n                case 32:\n                  nextSegment = path[index]; // add next levels worth of links to bucket\n                  _context4.next = 35;\n                  return addLinksToHamtBucket(context, subShard.Links, nextSegment.bucket, rootBucket);\n                case 35:\n                  nextSegment.node = subShard;\n                case 36:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _loop);\n          });\n        case 17:\n          if (!(index < path.length)) {\n            _context5.next = 24;\n            break;\n          }\n          return _context5.delegateYield(_loop(), \"t0\", 19);\n        case 19:\n          _ret = _context5.t0;\n          if (!(_ret === 0)) {\n            _context5.next = 22;\n            break;\n          }\n          return _context5.abrupt(\"break\", 24);\n        case 22:\n          _context5.next = 17;\n          break;\n        case 24:\n          _context5.next = 26;\n          return shard._bucket.put(file.name, {\n            size: file.size,\n            cid: file.cid\n          });\n        case 26:\n          return _context5.abrupt(\"return\", {\n            shard: shard,\n            path: path\n          });\n        case 27:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee4);\n  }));\n  return function addFileToShardedDirectory(_x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {{ pos: number, bucket: Bucket }} position\n * @returns {{ bucket: Bucket, prefix: string, node?: PBNode }[]}\n */\nvar toBucketPath = function toBucketPath(position) {\n  var path = [{\n    bucket: position.bucket,\n    prefix: toPrefix(position.pos)\n  }];\n  var bucket = position.bucket._parent;\n  var positionInBucket = position.bucket._posAtParent;\n  while (bucket) {\n    path.push({\n      bucket: bucket,\n      prefix: toPrefix(positionInBucket)\n    });\n    positionInBucket = bucket._posAtParent;\n    bucket = bucket._parent;\n  }\n  path.reverse();\n  return path;\n};","map":{"version":3,"names":["dagPB","CID","logger","UnixFS","DirSharded","updateHamtDirectory","recreateHamtLevel","recreateInitialHamtLevel","createShard","toPrefix","addLinksToHamtBucket","errCode","last","log","addLink","_x","_x2","_addLink","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee5","context","options","parent","parentCid","block","meta","wrap","_callee5$","_context6","prev","next","asCID","Error","code","concat","repo","blocks","get","sent","decode","cid","name","size","Data","unmarshal","type","abrupt","addToShardedDirectory","_objectSpread","Links","length","shardSplitThreshold","convertToShardedDirectory","mtime","mode","addToDirectory","stop","_ref","_callee","result","_callee$","_context","map","link","Name","Tsize","Hash","_x3","_x4","_ref2","_callee2","parentLinks","node","data","ms","secs","hasher","buf","hash","_callee2$","_context2","filter","push","Date","now","Math","floor","nsecs","marshal","prepare","hashers","getHasher","hashAlg","encode","digest","create","cidVersion","flush","put","_x5","_x6","_ref3","_callee3","_yield$addFileToShard","shard","path","newLink","_callee3$","_context3","addFileToShardedDirectory","substring","prefix","find","bucket","_x7","_x8","_ref4","_callee4","file","rootBucket","position","index","_loop","_ret","_callee4$","_context5","root","dir","undefined","parentKey","dirty","flat","_bucket","round","_findNewBucketAndPos","toBucketPath","segment","subShard","_position","nextSegment","_loop$","_context4","parseInt","pos","delegateYield","t0","_x9","_x10","_parent","positionInBucket","_posAtParent","reverse"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/utils/add-link.js"],"sourcesContent":["import * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { DirSharded } from './dir-sharded.js'\nimport {\n  updateHamtDirectory,\n  recreateHamtLevel,\n  recreateInitialHamtLevel,\n  createShard,\n  toPrefix,\n  addLinksToHamtBucket\n} from './hamt-utils.js'\nimport errCode from 'err-code'\nimport last from 'it-last'\n\nconst log = logger('ipfs:mfs:core:utils:add-link')\n\n/**\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {number} options.shardSplitThreshold\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {CID} [options.parentCid]\n * @param {PBNode} [options.parent]\n */\nexport async function addLink (context, options) {\n  let parent = options.parent\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid)\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to addLink'), 'EINVALIDPARENTCID')\n    }\n\n    if (parentCid.code !== dagPB.code) {\n      throw errCode(new Error('Unsupported codec. Only DAG-PB is supported'), 'EINVALIDPARENTCID')\n    }\n\n    log(`Loading parent node ${parentCid}`)\n    const block = await context.repo.blocks.get(parentCid)\n    parent = dagPB.decode(block)\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to addLink'), 'EINVALIDPARENT')\n  }\n\n  if (!options.cid) {\n    throw errCode(new Error('No child cid passed to addLink'), 'EINVALIDCHILDCID')\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to addLink'), 'EINVALIDCHILDNAME')\n  }\n\n  if (!options.size && options.size !== 0) {\n    throw errCode(new Error('No child size passed to addLink'), 'EINVALIDCHILDSIZE')\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node with no data passed to addLink'), 'ERR_INVALID_PARENT')\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log('Adding link to sharded directory')\n\n    return addToShardedDirectory(context, {\n      ...options,\n      parent\n    })\n  }\n\n  if (parent.Links.length >= options.shardSplitThreshold) {\n    log('Converting directory to sharded directory')\n\n    return convertToShardedDirectory(context, {\n      ...options,\n      parent,\n      mtime: meta.mtime,\n      mode: meta.mode\n    })\n  }\n\n  log(`Adding ${options.name} (${options.cid}) to regular directory`)\n\n  return addToDirectory(context, {\n    ...options,\n    parent\n  })\n}\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {Mtime} [options.mtime]\n * @param {number} [options.mode]\n */\nconst convertToShardedDirectory = async (context, options) => {\n  const result = await createShard(context, options.parent.Links.map(link => ({\n    name: (link.Name || ''),\n    size: link.Tsize || 0,\n    cid: link.Hash\n  })).concat({\n    name: options.name,\n    size: options.size,\n    cid: options.cid\n  }), options)\n\n  log(`Converted directory to sharded directory ${result.cid}`)\n\n  return result\n}\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {Mtime} [options.mtime]\n * @param {number} [options.mode]\n */\nconst addToDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  const parentLinks = options.parent.Links.filter((link) => {\n    return link.Name !== options.name\n  })\n  parentLinks.push({\n    Name: options.name,\n    Tsize: options.size,\n    Hash: options.cid\n  })\n\n  if (!options.parent.Data) {\n    throw errCode(new Error('Parent node with no data passed to addToDirectory'), 'ERR_INVALID_PARENT')\n  }\n\n  const node = UnixFS.unmarshal(options.parent.Data)\n\n  let data\n  if (node.mtime) {\n    // Update mtime if previously set\n    const ms = Date.now()\n    const secs = Math.floor(ms / 1000)\n\n    node.mtime = {\n      secs: secs,\n      nsecs: (ms - (secs * 1000)) * 1000\n    }\n\n    data = node.marshal()\n  } else {\n    data = options.parent.Data\n  }\n  options.parent = dagPB.prepare({\n    Data: data,\n    Links: parentLinks\n  })\n\n  // Persist the new parent PbNode\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const buf = dagPB.encode(options.parent)\n  const hash = await hasher.digest(buf)\n  const cid = CID.create(options.cidVersion, dagPB.code, hash)\n\n  if (options.flush) {\n    await context.repo.blocks.put(cid, buf)\n  }\n\n  return {\n    node: options.parent,\n    cid,\n    size: buf.length\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n */\nconst addToShardedDirectory = async (context, options) => {\n  const {\n    shard, path\n  } = await addFileToShardedDirectory(context, options)\n  const result = await last(shard.flush(context.repo.blocks))\n\n  if (!result) {\n    throw new Error('No result from flushing shard')\n  }\n\n  const block = await context.repo.blocks.get(result.cid)\n  const node = dagPB.decode(block)\n\n  // we have written out the shard, but only one sub-shard will have been written so replace it in the original shard\n  const parentLinks = options.parent.Links.filter((link) => {\n    // TODO vmx 2021-03-31: Check that there cannot be multiple ones matching\n    // Remove the old link\n    return (link.Name || '').substring(0, 2) !== path[0].prefix\n  })\n\n  const newLink = node.Links\n    .find(link => (link.Name || '').substring(0, 2) === path[0].prefix)\n\n  if (!newLink) {\n    throw new Error(`No link found with prefix ${path[0].prefix}`)\n  }\n\n  parentLinks.push(newLink)\n\n  return updateHamtDirectory(context, parentLinks, path[0].bucket, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {object} options\n * @param {CID} options.cid\n * @param {string} options.name\n * @param {number} options.size\n * @param {PBNode} options.parent\n * @param {string} options.hashAlg\n * @param {CIDVersion} options.cidVersion\n */\nconst addFileToShardedDirectory = async (context, options) => {\n  const file = {\n    name: options.name,\n    cid: options.cid,\n    size: options.size\n  }\n\n  if (!options.parent.Data) {\n    throw errCode(new Error('Parent node with no data passed to addFileToShardedDirectory'), 'ERR_INVALID_PARENT')\n  }\n\n  // start at the root bucket and descend, loading nodes as we go\n  const rootBucket = await recreateInitialHamtLevel(options.parent.Links)\n  const node = UnixFS.unmarshal(options.parent.Data)\n\n  const shard = new DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mode: node.mode\n  }, options)\n  shard._bucket = rootBucket\n\n  if (node.mtime) {\n    // update mtime if previously set\n    shard.mtime = {\n      secs: Math.round(Date.now() / 1000)\n    }\n  }\n\n  // load subshards until the bucket & position no longer changes\n  const position = await rootBucket._findNewBucketAndPos(file.name)\n  const path = toBucketPath(position)\n  path[0].node = options.parent\n  let index = 0\n\n  while (index < path.length) {\n    const segment = path[index]\n    index++\n    const node = segment.node\n\n    if (!node) {\n      throw new Error('Segment had no node')\n    }\n\n    const link = node.Links\n      .find(link => (link.Name || '').substring(0, 2) === segment.prefix)\n\n    if (!link) {\n      // prefix is new, file will be added to the current bucket\n      log(`Link ${segment.prefix}${file.name} will be added`)\n      index = path.length\n\n      break\n    }\n\n    if (link.Name === `${segment.prefix}${file.name}`) {\n      // file already existed, file will be added to the current bucket\n      log(`Link ${segment.prefix}${file.name} will be replaced`)\n      index = path.length\n\n      break\n    }\n\n    if ((link.Name || '').length > 2) {\n      // another file had the same prefix, will be replaced with a subshard\n      log(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`)\n      index = path.length\n\n      break\n    }\n\n    // load sub-shard\n    log(`Found subshard ${segment.prefix}`)\n    const block = await context.repo.blocks.get(link.Hash)\n    const subShard = dagPB.decode(block)\n\n    // subshard hasn't been loaded, descend to the next level of the HAMT\n    if (!path[index]) {\n      log(`Loaded new subshard ${segment.prefix}`)\n      await recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16))\n\n      const position = await rootBucket._findNewBucketAndPos(file.name)\n\n      path.push({\n        bucket: position.bucket,\n        prefix: toPrefix(position.pos),\n        node: subShard\n      })\n\n      break\n    }\n\n    const nextSegment = path[index]\n\n    // add next levels worth of links to bucket\n    await addLinksToHamtBucket(context, subShard.Links, nextSegment.bucket, rootBucket)\n\n    nextSegment.node = subShard\n  }\n\n  // finally add the new file into the shard\n  await shard._bucket.put(file.name, {\n    size: file.size,\n    cid: file.cid\n  })\n\n  return {\n    shard, path\n  }\n}\n\n/**\n * @param {{ pos: number, bucket: Bucket }} position\n * @returns {{ bucket: Bucket, prefix: string, node?: PBNode }[]}\n */\nconst toBucketPath = (position) => {\n  const path = [{\n    bucket: position.bucket,\n    prefix: toPrefix(position.pos)\n  }]\n\n  let bucket = position.bucket._parent\n  let positionInBucket = position.bucket._posAtParent\n\n  while (bucket) {\n    path.push({\n      bucket,\n      prefix: toPrefix(positionInBucket)\n    })\n\n    positionInBucket = bucket._posAtParent\n    bucket = bucket._parent\n  }\n\n  path.reverse()\n\n  return path\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}