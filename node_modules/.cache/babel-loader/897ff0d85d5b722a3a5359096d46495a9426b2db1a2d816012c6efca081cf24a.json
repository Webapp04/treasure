{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { CID } from 'multiformats/cid';\nimport { createUnsafe } from 'multiformats/block';\nimport { CarWriter } from '@ipld/car/writer';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { logger } from '@libp2p/logger';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as json from 'multiformats/codecs/json';\nimport { walk } from 'multiformats/traversal';\nvar log = logger('ipfs:components:dag:import');\n\n// blocks that we're OK with not inspecting for links\n/** @type {number[]} */\nvar NO_LINKS_CODECS = [raw.code,\n// raw\njson.code // JSON\n];\n\n/**\n * @typedef {import('../../types').Preload} Preload\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('@ipld/car/api').BlockWriter} BlockWriter\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/block').Block<T>} Block\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n * @param {Preload} config.preload\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\nexport function createExport(_ref) {\n  var repo = _ref.repo,\n    preload = _ref.preload,\n    codecs = _ref.codecs;\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"export\"]}\n   */\n  function dagExport(_x) {\n    return _dagExport.apply(this, arguments);\n  }\n  function _dagExport() {\n    _dagExport = _wrapAsyncGenerator(function (root) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var cid, _yield$_awaitAsyncGen, writer, out, err, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (options.preload !== false) {\n                preload(root);\n              }\n              cid = CID.asCID(root);\n              if (cid) {\n                _context2.next = 4;\n                break;\n              }\n              throw new Error(\"Unexpected error converting CID type: \".concat(root));\n            case 4:\n              log(\"Exporting \".concat(cid, \" as car\"));\n              _context2.next = 7;\n              return _awaitAsyncGenerator(CarWriter.create([cid]));\n            case 7:\n              _yield$_awaitAsyncGen = _context2.sent;\n              writer = _yield$_awaitAsyncGen.writer;\n              out = _yield$_awaitAsyncGen.out;\n              // we need to write with one async channel and send the CarWriter output\n              // with another to the caller, but if the write causes an error we capture\n              // that and make sure it gets propagated\n              /** @type {Error|null} */\n              err = null;\n              _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var load;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.prev = 0;\n                      load = makeLoader(repo, writer, {\n                        signal: options.signal,\n                        timeout: options.timeout\n                      }, codecs);\n                      _context.next = 4;\n                      return walk({\n                        cid: cid,\n                        load: load\n                      });\n                    case 4:\n                      _context.next = 9;\n                      break;\n                    case 6:\n                      _context.prev = 6;\n                      _context.t0 = _context[\"catch\"](0);\n                      err = _context.t0;\n                    case 9:\n                      _context.prev = 9;\n                      writer.close();\n                      return _context.finish(9);\n                    case 12:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _callee, null, [[0, 6, 9, 12]]);\n              }))();\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context2.prev = 14;\n              _iterator = _asyncIterator(out);\n            case 16:\n              _context2.next = 18;\n              return _awaitAsyncGenerator(_iterator.next());\n            case 18:\n              if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n                _context2.next = 27;\n                break;\n              }\n              chunk = _step.value;\n              if (!err) {\n                _context2.next = 22;\n                break;\n              }\n              return _context2.abrupt(\"break\", 27);\n            case 22:\n              _context2.next = 24;\n              return chunk;\n            case 24:\n              _iteratorAbruptCompletion = false;\n              _context2.next = 16;\n              break;\n            case 27:\n              _context2.next = 33;\n              break;\n            case 29:\n              _context2.prev = 29;\n              _context2.t0 = _context2[\"catch\"](14);\n              _didIteratorError = true;\n              _iteratorError = _context2.t0;\n            case 33:\n              _context2.prev = 33;\n              _context2.prev = 34;\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context2.next = 38;\n                break;\n              }\n              _context2.next = 38;\n              return _awaitAsyncGenerator(_iterator.return());\n            case 38:\n              _context2.prev = 38;\n              if (!_didIteratorError) {\n                _context2.next = 41;\n                break;\n              }\n              throw _iteratorError;\n            case 41:\n              return _context2.finish(38);\n            case 42:\n              return _context2.finish(33);\n            case 43:\n              if (!err) {\n                _context2.next = 45;\n                break;\n              }\n              throw err;\n            case 45:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[14, 29, 33, 43], [34,, 38, 42]]);\n      })();\n    });\n    return _dagExport.apply(this, arguments);\n  }\n  return withTimeoutOption(dagExport);\n}\n\n/**\n * @template T\n * @param {IPFSRepo} repo\n * @param {BlockWriter} writer\n * @param {AbortOptions} options\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @returns {(cid:CID)=>Promise<Block<T>|null>}\n */\nfunction makeLoader(repo, writer, options, codecs) {\n  return /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid) {\n      var codec, bytes;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return codecs.getCodec(cid.code);\n          case 2:\n            codec = _context3.sent;\n            if (codec) {\n              _context3.next = 5;\n              break;\n            }\n            throw new Error(\"Can't decode links in block with codec 0x\".concat(cid.code.toString(16), \" to form complete DAG\"));\n          case 5:\n            _context3.next = 7;\n            return repo.blocks.get(cid, options);\n          case 7:\n            bytes = _context3.sent;\n            log(\"Adding block \".concat(cid, \" to car\"));\n            _context3.next = 11;\n            return writer.put({\n              cid: cid,\n              bytes: bytes\n            });\n          case 11:\n            if (!NO_LINKS_CODECS.includes(cid.code)) {\n              _context3.next = 13;\n              break;\n            }\n            return _context3.abrupt(\"return\", null);\n          case 13:\n            return _context3.abrupt(\"return\", createUnsafe({\n              bytes: bytes,\n              cid: cid,\n              codec: codec\n            }));\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    return function (_x2) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"names":["CID","createUnsafe","CarWriter","withTimeoutOption","logger","raw","json","walk","log","NO_LINKS_CODECS","code","createExport","_ref","repo","preload","codecs","dagExport","_x","_dagExport","apply","arguments","_wrapAsyncGenerator","root","options","length","undefined","_regeneratorRuntime","mark","_callee2","cid","_yield$_awaitAsyncGen","writer","out","err","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","wrap","_callee2$","_context2","prev","next","asCID","Error","concat","_awaitAsyncGenerator","create","sent","_asyncToGenerator","_callee","load","_callee$","_context","makeLoader","signal","timeout","t0","close","finish","stop","_asyncIterator","done","value","abrupt","return","_ref3","_callee3","codec","bytes","_callee3$","_context3","getCodec","toString","blocks","get","put","includes","_x2"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/dag/export.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { createUnsafe } from 'multiformats/block'\nimport { CarWriter } from '@ipld/car/writer'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { logger } from '@libp2p/logger'\nimport * as raw from 'multiformats/codecs/raw'\nimport * as json from 'multiformats/codecs/json'\nimport { walk } from 'multiformats/traversal'\n\nconst log = logger('ipfs:components:dag:import')\n\n// blocks that we're OK with not inspecting for links\n/** @type {number[]} */\nconst NO_LINKS_CODECS = [\n  raw.code, // raw\n  json.code // JSON\n]\n\n/**\n * @typedef {import('../../types').Preload} Preload\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('@ipld/car/api').BlockWriter} BlockWriter\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/block').Block<T>} Block\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n * @param {Preload} config.preload\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\nexport function createExport ({ repo, preload, codecs }) {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"export\"]}\n   */\n  async function * dagExport (root, options = {}) {\n    if (options.preload !== false) {\n      preload(root)\n    }\n\n    const cid = CID.asCID(root)\n    if (!cid) {\n      throw new Error(`Unexpected error converting CID type: ${root}`)\n    }\n\n    log(`Exporting ${cid} as car`)\n    const { writer, out } = await CarWriter.create([cid])\n\n    // we need to write with one async channel and send the CarWriter output\n    // with another to the caller, but if the write causes an error we capture\n    // that and make sure it gets propagated\n    /** @type {Error|null} */\n    let err = null\n    ;(async () => {\n      try {\n        const load = makeLoader(repo, writer, {\n          signal: options.signal,\n          timeout: options.timeout\n        }, codecs)\n        await walk({ cid, load })\n      } catch (/** @type {any} */ e) {\n        err = e\n      } finally {\n        writer.close()\n      }\n    })()\n\n    for await (const chunk of out) {\n      if (err) {\n        break\n      }\n      yield chunk\n    }\n    if (err) {\n      throw err\n    }\n  }\n\n  return withTimeoutOption(dagExport)\n}\n\n/**\n * @template T\n * @param {IPFSRepo} repo\n * @param {BlockWriter} writer\n * @param {AbortOptions} options\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @returns {(cid:CID)=>Promise<Block<T>|null>}\n */\nfunction makeLoader (repo, writer, options, codecs) {\n  return async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n\n    if (!codec) {\n      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`)\n    }\n\n    const bytes = await repo.blocks.get(cid, options)\n\n    log(`Adding block ${cid} to car`)\n    await writer.put({ cid, bytes })\n\n    if (NO_LINKS_CODECS.includes(cid.code)) {\n      return null // skip this block, no need to look inside\n    }\n\n    return createUnsafe({ bytes, cid, codec })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}