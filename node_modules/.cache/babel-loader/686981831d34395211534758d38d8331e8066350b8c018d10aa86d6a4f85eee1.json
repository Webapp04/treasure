{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { CID } from 'multiformats/cid';\nimport { ipfs } from './pin.js';\n// @ts-ignore\nimport fnv1a from 'fnv1a';\nimport varint from 'varint';\nimport * as dagPb from '@ipld/dag-pb';\nimport { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } from './utils.js';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { sha256 } from 'multiformats/hashes/sha2';\nvar PinSet = ipfs.pin.Set;\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  var rootData = rootNode.Data;\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n  var hdrLength = varint.decode(rootData);\n  var vBytes = varint.decode.bytes;\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n  var hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  var header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n  if (header.version !== 1) {\n    throw new Error(\"Unsupported Set version: \".concat(header.version));\n  }\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash(seed, key) {\n  var buffer = new Uint8Array(4);\n  var dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  var encodedKey = uint8ArrayFromString(key.toString());\n  var data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nfunction walkItems(_x, _x2) {\n  return _walkItems.apply(this, arguments);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nfunction _walkItems() {\n  _walkItems = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(blockstore, node) {\n    var pbh, idx, _iterator, _step, link, linkHash, buf, _node;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          pbh = readHeader(node);\n          idx = 0;\n          _iterator = _createForOfIteratorHelper(node.Links);\n          _context.prev = 3;\n          _iterator.s();\n        case 5:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 22;\n            break;\n          }\n          link = _step.value;\n          if (!(idx < pbh.header.fanout)) {\n            _context.next = 17;\n            break;\n          }\n          // the first pbh.header.fanout links are fanout bins\n          // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n          linkHash = link.Hash;\n          if (EMPTY_KEY.equals(linkHash)) {\n            _context.next = 15;\n            break;\n          }\n          _context.next = 12;\n          return _awaitAsyncGenerator(blockstore.get(linkHash));\n        case 12:\n          buf = _context.sent;\n          _node = dagPb.decode(buf);\n          return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(walkItems(blockstore, _node)), _awaitAsyncGenerator), \"t0\", 15);\n        case 15:\n          _context.next = 19;\n          break;\n        case 17:\n          _context.next = 19;\n          return link.Hash;\n        case 19:\n          idx++;\n        case 20:\n          _context.next = 5;\n          break;\n        case 22:\n          _context.next = 27;\n          break;\n        case 24:\n          _context.prev = 24;\n          _context.t1 = _context[\"catch\"](3);\n          _iterator.e(_context.t1);\n        case 27:\n          _context.prev = 27;\n          _iterator.f();\n          return _context.finish(27);\n        case 30:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[3, 24, 27, 30]]);\n  }));\n  return _walkItems.apply(this, arguments);\n}\nexport function loadSet(_x3, _x4, _x5) {\n  return _loadSet.apply(this, arguments);\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction _loadSet() {\n  _loadSet = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockstore, rootNode, name) {\n    var link, buf, node;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          link = rootNode.Links.find(function (l) {\n            return l.Name === name;\n          });\n          if (link) {\n            _context2.next = 3;\n            break;\n          }\n          throw new Error('No link found with name ' + name);\n        case 3:\n          _context2.next = 5;\n          return _awaitAsyncGenerator(blockstore.get(link.Hash));\n        case 5:\n          buf = _context2.sent;\n          node = dagPb.decode(buf);\n          return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(walkItems(blockstore, node)), _awaitAsyncGenerator), \"t0\", 8);\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _loadSet.apply(this, arguments);\n}\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  function storePins(_x6, _x7) {\n    return _storePins.apply(this, arguments);\n  }\n  function _storePins() {\n    _storePins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(pins, depth) {\n      var pbHeader, header, headerBuf, fanoutLinks, i, nodes, rootLinks, rootData, bins, idx, _iterator2, _step2, bin, child, storeChild, _storeChild;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _storeChild = function _storeChild3() {\n              _storeChild = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(child, binIdx) {\n                var buf, digest, cid, size;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      buf = dagPb.encode(child);\n                      _context3.next = 3;\n                      return sha256.digest(buf);\n                    case 3:\n                      digest = _context3.sent;\n                      cid = CID.createV0(digest);\n                      _context3.next = 7;\n                      return blockstore.put(cid, buf);\n                    case 7:\n                      size = child.Links.reduce(function (acc, curr) {\n                        return acc + (curr.Tsize || 0);\n                      }, 0) + buf.length;\n                      fanoutLinks[binIdx] = {\n                        Name: '',\n                        Tsize: size,\n                        Hash: cid\n                      };\n                    case 9:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3);\n              }));\n              return _storeChild.apply(this, arguments);\n            };\n            storeChild = function _storeChild2(_x8, _x9) {\n              return _storeChild.apply(this, arguments);\n            };\n            pbHeader = PinSet.encode({\n              version: 1,\n              fanout: DEFAULT_FANOUT,\n              seed: depth\n            }).finish();\n            header = varint.encode(pbHeader.length);\n            headerBuf = uint8ArrayConcat([header, pbHeader]);\n            fanoutLinks = [];\n            for (i = 0; i < DEFAULT_FANOUT; i++) {\n              fanoutLinks.push({\n                Name: '',\n                Tsize: 1,\n                Hash: EMPTY_KEY\n              });\n            }\n            if (!(pins.length <= MAX_ITEMS)) {\n              _context4.next = 14;\n              break;\n            }\n            nodes = pins.map(function (item) {\n              return {\n                link: {\n                  Name: '',\n                  Tsize: 1,\n                  Hash: item.key\n                },\n                data: item.data || new Uint8Array()\n              };\n            })\n            // sorting makes any ordering of `pins` produce the same DAGNode\n            .sort(function (a, b) {\n              return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n            });\n            rootLinks = fanoutLinks.concat(nodes.map(function (item) {\n              return item.link;\n            }));\n            rootData = uint8ArrayConcat([headerBuf].concat(_toConsumableArray(nodes.map(function (item) {\n              return item.data;\n            }))));\n            return _context4.abrupt(\"return\", {\n              Data: rootData,\n              Links: rootLinks\n            });\n          case 14:\n            // If the array of pins is > MAX_ITEMS, we:\n            //  - distribute the pins among `DEFAULT_FANOUT` bins\n            //    - create a DAGNode for each bin\n            //      - add each pin as a DAGLink to that bin\n            //  - create a root DAGNode\n            //    - add each bin as a DAGLink\n            //  - send that root DAGNode via callback\n            // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n            // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n            /** @type {Pin[][]} */\n            bins = pins.reduce(function (bins, pin) {\n              var n = hash(depth, pin.key) % DEFAULT_FANOUT;\n              // @ts-ignore\n              bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n              return bins;\n            }, []);\n            idx = 0;\n            _iterator2 = _createForOfIteratorHelper(bins);\n            _context4.prev = 17;\n            _iterator2.s();\n          case 19:\n            if ((_step2 = _iterator2.n()).done) {\n              _context4.next = 29;\n              break;\n            }\n            bin = _step2.value;\n            _context4.next = 23;\n            return storePins(bin, depth + 1);\n          case 23:\n            child = _context4.sent;\n            _context4.next = 26;\n            return storeChild(child, idx);\n          case 26:\n            idx++;\n          case 27:\n            _context4.next = 19;\n            break;\n          case 29:\n            _context4.next = 34;\n            break;\n          case 31:\n            _context4.prev = 31;\n            _context4.t0 = _context4[\"catch\"](17);\n            _iterator2.e(_context4.t0);\n          case 34:\n            _context4.prev = 34;\n            _iterator2.f();\n            return _context4.finish(34);\n          case 37:\n            return _context4.abrupt(\"return\", {\n              Data: headerBuf,\n              Links: fanoutLinks\n            });\n          case 38:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[17, 31, 34, 37]]);\n    }));\n    return _storePins.apply(this, arguments);\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nexport function storeSet(_x10, _x11, _x12) {\n  return _storeSet.apply(this, arguments);\n}\nfunction _storeSet() {\n  _storeSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(blockstore, type, cids) {\n    var rootNode, buf, digest, cid, size;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return storeItems(blockstore, cids.map(function (cid) {\n            return {\n              key: cid\n            };\n          }));\n        case 2:\n          rootNode = _context5.sent;\n          buf = dagPb.encode(rootNode);\n          _context5.next = 6;\n          return sha256.digest(buf);\n        case 6:\n          digest = _context5.sent;\n          cid = CID.createV0(digest);\n          _context5.next = 10;\n          return blockstore.put(cid, buf);\n        case 10:\n          size = rootNode.Links.reduce(function (acc, curr) {\n            return acc + curr.Tsize;\n          }, 0) + buf.length;\n          return _context5.abrupt(\"return\", {\n            Name: type,\n            Tsize: size,\n            Hash: cid\n          });\n        case 12:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return _storeSet.apply(this, arguments);\n}","map":{"version":3,"names":["CID","ipfs","fnv1a","varint","dagPb","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","concat","uint8ArrayConcat","compare","uint8ArrayCompare","toString","uint8ArrayToString","fromString","uint8ArrayFromString","sha256","PinSet","pin","Set","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","_x","_x2","_walkItems","apply","arguments","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","blockstore","node","pbh","idx","_iterator","_step","link","linkHash","buf","_node","wrap","_callee$","_context","prev","next","_createForOfIteratorHelper","s","n","done","value","Hash","equals","_awaitAsyncGenerator","get","sent","delegateYield","_asyncGeneratorDelegate","_asyncIterator","t1","e","f","finish","stop","loadSet","_x3","_x4","_x5","_loadSet","_callee2","name","_callee2$","_context2","find","l","Name","storeItems","items","storePins","_x6","_x7","_storePins","_asyncToGenerator","_callee4","pins","depth","pbHeader","headerBuf","fanoutLinks","i","nodes","rootLinks","bins","_iterator2","_step2","bin","child","storeChild","_storeChild","_callee4$","_context4","_storeChild3","_callee3","binIdx","digest","cid","size","_callee3$","_context3","encode","createV0","put","reduce","acc","curr","Tsize","_storeChild2","_x8","_x9","push","map","item","sort","a","b","_toConsumableArray","abrupt","t0","storeSet","_x10","_x11","_x12","_storeSet","_callee5","type","cids","_callee5$","_context5"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js"],"sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport { ipfs } from './pin.js'\n// @ts-ignore\nimport fnv1a from 'fnv1a'\nimport varint from 'varint'\nimport * as dagPb from '@ipld/dag-pb'\nimport { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } from './utils.js'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\nconst PinSet = ipfs.pin.Set\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n\n  if (!rootData) {\n    throw new Error('No data present')\n  }\n\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  })\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(key.toString())\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash)\n        const node = dagPb.decode(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nexport async function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(link.Hash)\n  const node = dagPb.decode(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins (pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish()\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      })\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return {\n        Data: rootData,\n        Links: rootLinks\n      }\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      }\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild (child, binIdx) {\n      const buf = dagPb.encode(child)\n      const digest = await sha256.digest(buf)\n      const cid = CID.createV0(digest)\n\n      await blockstore.put(cid, buf)\n\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length\n\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      }\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nexport async function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    }\n  }))\n  const buf = dagPb.encode(rootNode)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length\n\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}