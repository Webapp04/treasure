{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n/* eslint max-depth: [\"error\", 6] */\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport errCode from 'err-code';\n// Maximum length of the length section of the message\nexport var MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport var MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n  ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n  ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nvar defaultDecoder = function defaultDecoder(buf) {\n  var length = unsigned.decode(buf);\n  defaultDecoder.bytes = unsigned.encodingLength(length);\n  return length;\n};\ndefaultDecoder.bytes = 0;\nexport function decode(options) {\n  var decoder = /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n      var _options$lengthDecode, _options$maxLengthLen, _options$maxDataLengt;\n      var buffer, mode, dataLength, lengthDecoder, maxLengthLength, maxDataLength, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, buf, dataLengthLength, data;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            buffer = new Uint8ArrayList();\n            mode = ReadMode.LENGTH;\n            dataLength = -1;\n            lengthDecoder = (_options$lengthDecode = options === null || options === void 0 ? void 0 : options.lengthDecoder) !== null && _options$lengthDecode !== void 0 ? _options$lengthDecode : defaultDecoder;\n            maxLengthLength = (_options$maxLengthLen = options === null || options === void 0 ? void 0 : options.maxLengthLength) !== null && _options$maxLengthLen !== void 0 ? _options$maxLengthLen : MAX_LENGTH_LENGTH;\n            maxDataLength = (_options$maxDataLengt = options === null || options === void 0 ? void 0 : options.maxDataLength) !== null && _options$maxDataLengt !== void 0 ? _options$maxDataLengt : MAX_DATA_LENGTH;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 8;\n            _iterator = _asyncIterator(source);\n          case 10:\n            _context.next = 12;\n            return _awaitAsyncGenerator(_iterator.next());\n          case 12:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 50;\n              break;\n            }\n            buf = _step.value;\n            buffer.append(buf);\n          case 15:\n            if (!(buffer.byteLength > 0)) {\n              _context.next = 47;\n              break;\n            }\n            if (!(mode === ReadMode.LENGTH)) {\n              _context.next = 36;\n              break;\n            }\n            _context.prev = 17;\n            dataLength = lengthDecoder(buffer);\n            if (!(dataLength < 0)) {\n              _context.next = 21;\n              break;\n            }\n            throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n          case 21:\n            if (!(dataLength > maxDataLength)) {\n              _context.next = 23;\n              break;\n            }\n            throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n          case 23:\n            dataLengthLength = lengthDecoder.bytes;\n            buffer.consume(dataLengthLength);\n            if ((options === null || options === void 0 ? void 0 : options.onLength) != null) {\n              options.onLength(dataLength);\n            }\n            mode = ReadMode.DATA;\n            _context.next = 36;\n            break;\n          case 29:\n            _context.prev = 29;\n            _context.t0 = _context[\"catch\"](17);\n            if (!(_context.t0 instanceof RangeError)) {\n              _context.next = 35;\n              break;\n            }\n            if (!(buffer.byteLength > maxLengthLength)) {\n              _context.next = 34;\n              break;\n            }\n            throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n          case 34:\n            return _context.abrupt(\"break\", 47);\n          case 35:\n            throw _context.t0;\n          case 36:\n            if (!(mode === ReadMode.DATA)) {\n              _context.next = 45;\n              break;\n            }\n            if (!(buffer.byteLength < dataLength)) {\n              _context.next = 39;\n              break;\n            }\n            return _context.abrupt(\"break\", 47);\n          case 39:\n            data = buffer.sublist(0, dataLength);\n            buffer.consume(dataLength);\n            if ((options === null || options === void 0 ? void 0 : options.onData) != null) {\n              options.onData(data);\n            }\n            _context.next = 44;\n            return data;\n          case 44:\n            mode = ReadMode.LENGTH;\n          case 45:\n            _context.next = 15;\n            break;\n          case 47:\n            _iteratorAbruptCompletion = false;\n            _context.next = 10;\n            break;\n          case 50:\n            _context.next = 56;\n            break;\n          case 52:\n            _context.prev = 52;\n            _context.t1 = _context[\"catch\"](8);\n            _didIteratorError = true;\n            _iteratorError = _context.t1;\n          case 56:\n            _context.prev = 56;\n            _context.prev = 57;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 61;\n              break;\n            }\n            _context.next = 61;\n            return _awaitAsyncGenerator(_iterator.return());\n          case 61:\n            _context.prev = 61;\n            if (!_didIteratorError) {\n              _context.next = 64;\n              break;\n            }\n            throw _iteratorError;\n          case 64:\n            return _context.finish(61);\n          case 65:\n            return _context.finish(56);\n          case 66:\n            if (!(buffer.byteLength > 0)) {\n              _context.next = 68;\n              break;\n            }\n            throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n          case 68:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[8, 52, 56, 66], [17, 29], [57,, 61, 65]]);\n    }));\n    return function decoder(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return decoder;\n}\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\ndecode.fromReader = function (reader, options) {\n  var byteLength = 1; // Read single byte chunks until the length is known\n  var varByteSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var _yield$_awaitAsyncGen, done, value;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!true) {\n            _context2.next = 24;\n            break;\n          }\n          _context2.prev = 1;\n          _context2.next = 4;\n          return _awaitAsyncGenerator(reader.next(byteLength));\n        case 4:\n          _yield$_awaitAsyncGen = _context2.sent;\n          done = _yield$_awaitAsyncGen.done;\n          value = _yield$_awaitAsyncGen.value;\n          if (!(done === true)) {\n            _context2.next = 9;\n            break;\n          }\n          return _context2.abrupt(\"return\");\n        case 9:\n          if (!(value != null)) {\n            _context2.next = 12;\n            break;\n          }\n          _context2.next = 12;\n          return value;\n        case 12:\n          _context2.next = 19;\n          break;\n        case 14:\n          _context2.prev = 14;\n          _context2.t0 = _context2[\"catch\"](1);\n          if (!(_context2.t0.code === 'ERR_UNDER_READ')) {\n            _context2.next = 18;\n            break;\n          }\n          return _context2.abrupt(\"return\", {\n            done: true,\n            value: null\n          });\n        case 18:\n          throw _context2.t0;\n        case 19:\n          _context2.prev = 19;\n          // Reset the byteLength so we continue to check for varints\n          byteLength = 1;\n          return _context2.finish(19);\n        case 22:\n          _context2.next = 0;\n          break;\n        case 24:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[1, 14, 19, 22]]);\n  }))();\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  var onLength = function onLength(l) {\n    byteLength = l;\n  };\n  return decode(_objectSpread(_objectSpread({}, options !== null && options !== void 0 ? options : {}), {}, {\n    onLength: onLength\n  }))(varByteSource);\n};","map":{"version":3,"names":["Uint8ArrayList","unsigned","errCode","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","ReadMode","defaultDecoder","buf","length","decode","bytes","encodingLength","options","decoder","_ref","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","source","_options$lengthDecode","_options$maxLengthLen","_options$maxDataLengt","buffer","mode","dataLength","lengthDecoder","maxLengthLength","maxDataLength","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","dataLengthLength","data","wrap","_callee$","_context","prev","next","LENGTH","_asyncIterator","_awaitAsyncGenerator","sent","done","value","append","byteLength","Error","consume","onLength","DATA","t0","RangeError","abrupt","sublist","onData","t1","return","finish","stop","_x","apply","arguments","fromReader","reader","varByteSource","_callee2","_yield$_awaitAsyncGen","_callee2$","_context2","code","l","_objectSpread"],"sources":["/Users/apple/Documents/treasure/node_modules/it-length-prefixed/src/decode.ts"],"sourcesContent":["/* eslint max-depth: [\"error\", 6] */\n\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { unsigned } from 'uint8-varint'\nimport errCode from 'err-code'\nimport type { LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport type { Source, Transform } from 'it-stream-types'\n\nexport interface ReadState {\n  dataLength: number\n}\n\nexport interface DecoderOptions {\n  lengthDecoder?: LengthDecoderFunction\n  onData?: (data: Uint8ArrayList) => void\n  onLength?: (length: number) => void\n  maxLengthLength?: number\n  maxDataLength?: number\n}\n\nexport interface ReadResult {\n  mode: string\n  chunk?: Uint8ArrayList\n  buffer: Uint8ArrayList\n  state?: ReadState\n  data?: Uint8ArrayList\n}\n\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = unsigned.decode(buf)\n  defaultDecoder.bytes = unsigned.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (options?: DecoderOptions): Transform<Uint8ArrayList | Uint8Array, Uint8ArrayList> {\n  const decoder = async function * (source: Source<Uint8ArrayList | Uint8Array>): Source<Uint8ArrayList> {\n    const buffer = new Uint8ArrayList()\n    let mode = ReadMode.LENGTH\n    let dataLength = -1\n\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n    for await (const buf of source) {\n      buffer.append(buf)\n\n      while (buffer.byteLength > 0) {\n        if (mode === ReadMode.LENGTH) {\n          // read length, ignore errors for short reads\n          try {\n            dataLength = lengthDecoder(buffer)\n\n            if (dataLength < 0) {\n              throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH')\n            }\n\n            if (dataLength > maxDataLength) {\n              throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG')\n            }\n\n            const dataLengthLength = lengthDecoder.bytes\n            buffer.consume(dataLengthLength)\n\n            if (options?.onLength != null) {\n              options.onLength(dataLength)\n            }\n\n            mode = ReadMode.DATA\n          } catch (err: any) {\n            if (err instanceof RangeError) {\n              if (buffer.byteLength > maxLengthLength) {\n                throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG')\n              }\n\n              break\n            }\n\n            throw err\n          }\n        }\n\n        if (mode === ReadMode.DATA) {\n          if (buffer.byteLength < dataLength) {\n            // not enough data, wait for more\n            break\n          }\n\n          const data = buffer.sublist(0, dataLength)\n          buffer.consume(dataLength)\n\n          if (options?.onData != null) {\n            options.onData(data)\n          }\n\n          yield data\n\n          mode = ReadMode.LENGTH\n        }\n      }\n    }\n\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF')\n    }\n  }\n\n  return decoder\n}\n\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number) => { byteLength = l }\n  return decode({\n    ...(options ?? {}),\n    onLength\n  })(varByteSource)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}