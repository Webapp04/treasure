{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport errCode from 'err-code';\nimport { anySignal } from 'any-signal';\nimport FIFO from 'p-fifo';\nimport { setMaxListeners } from 'events';\nimport { codes } from '../../errors.js';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:dialer:dial-request');\nexport var DialRequest = /*#__PURE__*/function () {\n  /**\n   * Manages running the `dialAction` on multiple provided `addrs` in parallel\n   * up to a maximum determined by the number of tokens returned\n   * from `dialer.getTokens`. Once a DialRequest is created, it can be\n   * started using `DialRequest.run(options)`. Once a single dial has succeeded,\n   * all other dials in the request will be cancelled.\n   */\n  function DialRequest(options) {\n    _classCallCheck(this, DialRequest);\n    var addrs = options.addrs,\n      dialAction = options.dialAction,\n      dialer = options.dialer;\n    this.addrs = addrs;\n    this.dialer = dialer;\n    this.dialAction = dialAction;\n  }\n  _createClass(DialRequest, [{\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this = this;\n        var options,\n          tokens,\n          tokenHolder,\n          _iterator,\n          _step,\n          token,\n          dialAbortControllers,\n          completedDials,\n          done,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n              tokens = this.dialer.getTokens(this.addrs.length); // If no tokens are available, throw\n              if (!(tokens.length < 1)) {\n                _context2.next = 4;\n                break;\n              }\n              throw errCode(new Error('No dial tokens available'), codes.ERR_NO_DIAL_TOKENS);\n            case 4:\n              tokenHolder = new FIFO();\n              _iterator = _createForOfIteratorHelper(tokens);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  token = _step.value;\n                  void tokenHolder.push(token).catch(function (err) {\n                    log.error(err);\n                  });\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              dialAbortControllers = this.addrs.map(function () {\n                var controller = new AbortController();\n                try {\n                  // fails on node < 15.4\n                  setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, controller.signal);\n                } catch (_unused) {}\n                return controller;\n              });\n              if (options.signal != null) {\n                try {\n                  // fails on node < 15.4\n                  setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, options.signal);\n                } catch (_unused2) {}\n              }\n              completedDials = 0;\n              done = false;\n              _context2.prev = 11;\n              _context2.next = 14;\n              return Promise.any(this.addrs.map( /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(addr, i) {\n                  var token, controller, conn, signal;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return tokenHolder.shift();\n                      case 2:\n                        token = _context.sent;\n                        if (!done) {\n                          _context.next = 6;\n                          break;\n                        }\n                        _this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);\n                        throw errCode(new Error('dialAction already succeeded'), codes.ERR_ALREADY_SUCCEEDED);\n                      case 6:\n                        controller = dialAbortControllers[i];\n                        if (!(controller == null)) {\n                          _context.next = 9;\n                          break;\n                        }\n                        throw errCode(new Error('dialAction did not come with an AbortController'), codes.ERR_INVALID_PARAMETERS);\n                      case 9:\n                        _context.prev = 9;\n                        signal = controller.signal;\n                        _context.next = 13;\n                        return _this.dialAction(addr, _objectSpread(_objectSpread({}, options), {}, {\n                          signal: options.signal != null ? anySignal([signal, options.signal]) : signal\n                        }));\n                      case 13:\n                        conn = _context.sent;\n                        // Remove the successful AbortController so it is not aborted\n                        dialAbortControllers[i] = undefined;\n                      case 15:\n                        _context.prev = 15;\n                        completedDials++;\n                        // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it\n                        if (_this.addrs.length - completedDials >= tokens.length) {\n                          void tokenHolder.push(token).catch(function (err) {\n                            log.error(err);\n                          });\n                        } else {\n                          _this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);\n                        }\n                        return _context.finish(15);\n                      case 19:\n                        if (!(conn == null)) {\n                          _context.next = 23;\n                          break;\n                        }\n                        throw errCode(new Error('dialAction led to empty object'), codes.ERR_TRANSPORT_DIAL_FAILED);\n                      case 23:\n                        // This dial succeeded, don't attempt anything else\n                        done = true;\n                      case 24:\n                        return _context.abrupt(\"return\", conn);\n                      case 25:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee, null, [[9,, 15, 19]]);\n                }));\n                return function (_x, _x2) {\n                  return _ref.apply(this, arguments);\n                };\n              }()));\n            case 14:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 15:\n              _context2.prev = 15;\n              // success/failure happened, abort everything else\n              dialAbortControllers.forEach(function (c) {\n                if (c !== undefined) {\n                  c.abort();\n                }\n              });\n              tokens.forEach(function (token) {\n                return _this.dialer.releaseToken(token);\n              }); // release tokens back to the dialer\n              return _context2.finish(15);\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[11,, 15, 19]]);\n      }));\n      function run() {\n        return _run.apply(this, arguments);\n      }\n      return run;\n    }()\n  }]);\n  return DialRequest;\n}();","map":{"version":3,"names":["errCode","anySignal","FIFO","setMaxListeners","codes","logger","log","DialRequest","options","_classCallCheck","addrs","dialAction","dialer","_createClass","key","value","_run","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","_this","tokens","tokenHolder","_iterator","_step","token","dialAbortControllers","completedDials","done","_args2","arguments","wrap","_callee2$","_context2","prev","next","length","undefined","getTokens","Error","ERR_NO_DIAL_TOKENS","_createForOfIteratorHelper","s","n","push","catch","err","error","e","f","map","controller","AbortController","Infinity","signal","_unused","_unused2","Promise","any","_ref","_callee","addr","i","conn","_callee$","_context","shift","sent","releaseToken","splice","indexOf","ERR_ALREADY_SUCCEEDED","ERR_INVALID_PARAMETERS","_objectSpread","finish","ERR_TRANSPORT_DIAL_FAILED","abrupt","stop","_x","_x2","apply","forEach","c","abort","run"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/connection-manager/dialer/dial-request.ts"],"sourcesContent":["import errCode from 'err-code'\nimport { anySignal } from 'any-signal'\nimport FIFO from 'p-fifo'\nimport { setMaxListeners } from 'events'\nimport { codes } from '../../errors.js'\nimport { logger } from '@libp2p/logger'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Dialer } from '@libp2p/interface-connection-manager'\n\nconst log = logger('libp2p:dialer:dial-request')\n\nexport interface DialAction {\n  (m: Multiaddr, options: AbortOptions): Promise<Connection>\n}\n\nexport interface DialRequestOptions {\n  addrs: Multiaddr[]\n  dialAction: DialAction\n  dialer: Dialer\n}\n\nexport class DialRequest {\n  private readonly addrs: Multiaddr[]\n  private readonly dialer: Dialer\n  private readonly dialAction: DialAction\n\n  /**\n   * Manages running the `dialAction` on multiple provided `addrs` in parallel\n   * up to a maximum determined by the number of tokens returned\n   * from `dialer.getTokens`. Once a DialRequest is created, it can be\n   * started using `DialRequest.run(options)`. Once a single dial has succeeded,\n   * all other dials in the request will be cancelled.\n   */\n  constructor (options: DialRequestOptions) {\n    const {\n      addrs,\n      dialAction,\n      dialer\n    } = options\n\n    this.addrs = addrs\n    this.dialer = dialer\n    this.dialAction = dialAction\n  }\n\n  async run (options: AbortOptions = {}): Promise<Connection> {\n    const tokens = this.dialer.getTokens(this.addrs.length)\n\n    // If no tokens are available, throw\n    if (tokens.length < 1) {\n      throw errCode(new Error('No dial tokens available'), codes.ERR_NO_DIAL_TOKENS)\n    }\n\n    const tokenHolder = new FIFO<number>()\n\n    for (const token of tokens) {\n      void tokenHolder.push(token).catch(err => {\n        log.error(err)\n      })\n    }\n\n    const dialAbortControllers: Array<(AbortController | undefined)> = this.addrs.map(() => {\n      const controller = new AbortController()\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, controller.signal)\n      } catch {}\n\n      return controller\n    })\n\n    if (options.signal != null) {\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, options.signal)\n      } catch {}\n    }\n\n    let completedDials = 0\n    let done = false\n\n    try {\n      return await Promise.any(this.addrs.map(async (addr, i) => {\n        const token = await tokenHolder.shift() // get token\n        // End attempt once another attempt succeeded\n        if (done) {\n          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0])\n          throw errCode(new Error('dialAction already succeeded'), codes.ERR_ALREADY_SUCCEEDED)\n        }\n\n        const controller = dialAbortControllers[i]\n        if (controller == null) {\n          throw errCode(new Error('dialAction did not come with an AbortController'), codes.ERR_INVALID_PARAMETERS)\n        }\n        let conn\n        try {\n          const signal = controller.signal\n          conn = await this.dialAction(addr, { ...options, signal: (options.signal != null) ? anySignal([signal, options.signal]) : signal })\n          // Remove the successful AbortController so it is not aborted\n          dialAbortControllers[i] = undefined\n        } finally {\n          completedDials++\n          // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it\n          if (this.addrs.length - completedDials >= tokens.length) {\n            void tokenHolder.push(token).catch(err => {\n              log.error(err)\n            })\n          } else {\n            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0])\n          }\n        }\n\n        if (conn == null) {\n          // Notify Promise.any that attempt was not successful\n          // to prevent from returning undefined despite there\n          // were successful dial attempts\n          throw errCode(new Error('dialAction led to empty object'), codes.ERR_TRANSPORT_DIAL_FAILED)\n        } else {\n          // This dial succeeded, don't attempt anything else\n          done = true\n        }\n\n        return conn\n      }))\n    } finally {\n      // success/failure happened, abort everything else\n      dialAbortControllers.forEach(c => {\n        if (c !== undefined) {\n          c.abort()\n        }\n      })\n      tokens.forEach(token => this.dialer.releaseToken(token)) // release tokens back to the dialer\n    }\n  }\n}\n"],"mappings":";;;;;;AAAA,OAAOA,OAAO,MAAM,UAAU;AAC9B,SAASC,SAAS,QAAQ,YAAY;AACtC,OAAOC,IAAI,MAAM,QAAQ;AACzB,SAASC,eAAe,QAAQ,QAAQ;AACxC,SAASC,KAAK,QAAQ,iBAAiB;AACvC,SAASC,MAAM,QAAQ,gBAAgB;AAMvC,IAAMC,GAAG,GAAGD,MAAM,CAAC,4BAA4B,CAAC;AAYhD,WAAaE,WAAW;EAKtB;;;;;;;EAOA,SAAAA,YAAaC,OAA2B;IAAAC,eAAA,OAAAF,WAAA;IACtC,IACEG,KAAK,GAGHF,OAAO,CAHTE,KAAK;MACLC,UAAU,GAERH,OAAO,CAFTG,UAAU;MACVC,MAAM,GACJJ,OAAO,CADTI,MAAM;IAGR,IAAI,CAACF,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACD,UAAU,GAAGA,UAAU;EAC9B;EAACE,YAAA,CAAAN,WAAA;IAAAO,GAAA;IAAAC,KAAA;MAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAED,SAAAC,SAAA;QAAA,IAAAC,KAAA;QAAA,IAAAb,OAAA;UAAAc,MAAA;UAAAC,WAAA;UAAAC,SAAA;UAAAC,KAAA;UAAAC,KAAA;UAAAC,oBAAA;UAAAC,cAAA;UAAAC,IAAA;UAAAC,MAAA,GAAAC,SAAA;QAAA,OAAAb,mBAAA,GAAAc,IAAA,UAAAC,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAC,IAAA,GAAAD,SAAA,CAAAE,IAAA;YAAA;cAAW5B,OAAA,GAAAsB,MAAA,CAAAO,MAAA,QAAAP,MAAA,QAAAQ,SAAA,GAAAR,MAAA,MAAwB,EAAE;cAC7BR,MAAM,GAAG,IAAI,CAACV,MAAM,CAAC2B,SAAS,CAAC,IAAI,CAAC7B,KAAK,CAAC2B,MAAM,CAAC,EAEvD;cAAA,MACIf,MAAM,CAACe,MAAM,GAAG,CAAC;gBAAAH,SAAA,CAAAE,IAAA;gBAAA;cAAA;cAAA,MACbpC,OAAO,CAAC,IAAIwC,KAAK,CAAC,0BAA0B,CAAC,EAAEpC,KAAK,CAACqC,kBAAkB,CAAC;YAAA;cAG1ElB,WAAW,GAAG,IAAIrB,IAAI,EAAU;cAAAsB,SAAA,GAAAkB,0BAAA,CAElBpB,MAAM;cAAA;gBAA1B,KAAAE,SAAA,CAAAmB,CAAA,MAAAlB,KAAA,GAAAD,SAAA,CAAAoB,CAAA,IAAAf,IAAA,GAA4B;kBAAjBH,KAAK,GAAAD,KAAA,CAAAV,KAAA;kBACd,KAAKQ,WAAW,CAACsB,IAAI,CAACnB,KAAK,CAAC,CAACoB,KAAK,CAAC,UAAAC,GAAG,EAAG;oBACvCzC,GAAG,CAAC0C,KAAK,CAACD,GAAG,CAAC;kBAChB,CAAC,CAAC;;cACH,SAAAA,GAAA;gBAAAvB,SAAA,CAAAyB,CAAA,CAAAF,GAAA;cAAA;gBAAAvB,SAAA,CAAA0B,CAAA;cAAA;cAEKvB,oBAAoB,GAAyC,IAAI,CAACjB,KAAK,CAACyC,GAAG,CAAC,YAAK;gBACrF,IAAMC,UAAU,GAAG,IAAIC,eAAe,EAAE;gBACxC,IAAI;kBACF;kBACAlD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAGmD,QAAQ,EAAEF,UAAU,CAACG,MAAM,CAAC;iBAC/C,CAAC,OAAAC,OAAA,EAAM;gBAER,OAAOJ,UAAU;cACnB,CAAC,CAAC;cAEF,IAAI5C,OAAO,CAAC+C,MAAM,IAAI,IAAI,EAAE;gBAC1B,IAAI;kBACF;kBACApD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAGmD,QAAQ,EAAE9C,OAAO,CAAC+C,MAAM,CAAC;iBAC5C,CAAC,OAAAE,QAAA,EAAM;;cAGN7B,cAAc,GAAG,CAAC;cAClBC,IAAI,GAAG,KAAK;cAAAK,SAAA,CAAAC,IAAA;cAAAD,SAAA,CAAAE,IAAA;cAAA,OAGDsB,OAAO,CAACC,GAAG,CAAC,IAAI,CAACjD,KAAK,CAACyC,GAAG;gBAAA,IAAAS,IAAA,GAAA3C,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAC,SAAA0C,QAAOC,IAAI,EAAEC,CAAC;kBAAA,IAAArC,KAAA,EAAA0B,UAAA,EAAAY,IAAA,EAAAT,MAAA;kBAAA,OAAArC,mBAAA,GAAAc,IAAA,UAAAiC,SAAAC,QAAA;oBAAA,kBAAAA,QAAA,CAAA/B,IAAA,GAAA+B,QAAA,CAAA9B,IAAA;sBAAA;wBAAA8B,QAAA,CAAA9B,IAAA;wBAAA,OAChCb,WAAW,CAAC4C,KAAK,EAAE;sBAAA;wBAAjCzC,KAAK,GAAAwC,QAAA,CAAAE,IAAA;wBAAA,KAEPvC,IAAI;0BAAAqC,QAAA,CAAA9B,IAAA;0BAAA;wBAAA;wBACNf,KAAI,CAACT,MAAM,CAACyD,YAAY,CAAC/C,MAAM,CAACgD,MAAM,CAAChD,MAAM,CAACiD,OAAO,CAAC7C,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBAAA,MAC9D1B,OAAO,CAAC,IAAIwC,KAAK,CAAC,8BAA8B,CAAC,EAAEpC,KAAK,CAACoE,qBAAqB,CAAC;sBAAA;wBAGjFpB,UAAU,GAAGzB,oBAAoB,CAACoC,CAAC,CAAC;wBAAA,MACtCX,UAAU,IAAI,IAAI;0BAAAc,QAAA,CAAA9B,IAAA;0BAAA;wBAAA;wBAAA,MACdpC,OAAO,CAAC,IAAIwC,KAAK,CAAC,iDAAiD,CAAC,EAAEpC,KAAK,CAACqE,sBAAsB,CAAC;sBAAA;wBAAAP,QAAA,CAAA/B,IAAA;wBAInGoB,MAAM,GAAGH,UAAU,CAACG,MAAM;wBAAAW,QAAA,CAAA9B,IAAA;wBAAA,OACnBf,KAAI,CAACV,UAAU,CAACmD,IAAI,EAAAY,aAAA,CAAAA,aAAA,KAAOlE,OAAO;0BAAE+C,MAAM,EAAG/C,OAAO,CAAC+C,MAAM,IAAI,IAAI,GAAItD,SAAS,CAAC,CAACsD,MAAM,EAAE/C,OAAO,CAAC+C,MAAM,CAAC,CAAC,GAAGA;wBAAM,EAAE,CAAC;sBAAA;wBAAnIS,IAAI,GAAAE,QAAA,CAAAE,IAAA;wBACJ;wBACAzC,oBAAoB,CAACoC,CAAC,CAAC,GAAGzB,SAAS;sBAAA;wBAAA4B,QAAA,CAAA/B,IAAA;wBAEnCP,cAAc,EAAE;wBAChB;wBACA,IAAIP,KAAI,CAACX,KAAK,CAAC2B,MAAM,GAAGT,cAAc,IAAIN,MAAM,CAACe,MAAM,EAAE;0BACvD,KAAKd,WAAW,CAACsB,IAAI,CAACnB,KAAK,CAAC,CAACoB,KAAK,CAAC,UAAAC,GAAG,EAAG;4BACvCzC,GAAG,CAAC0C,KAAK,CAACD,GAAG,CAAC;0BAChB,CAAC,CAAC;yBACH,MAAM;0BACL1B,KAAI,CAACT,MAAM,CAACyD,YAAY,CAAC/C,MAAM,CAACgD,MAAM,CAAChD,MAAM,CAACiD,OAAO,CAAC7C,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;wBACrE,OAAAwC,QAAA,CAAAS,MAAA;sBAAA;wBAAA,MAGCX,IAAI,IAAI,IAAI;0BAAAE,QAAA,CAAA9B,IAAA;0BAAA;wBAAA;wBAAA,MAIRpC,OAAO,CAAC,IAAIwC,KAAK,CAAC,gCAAgC,CAAC,EAAEpC,KAAK,CAACwE,yBAAyB,CAAC;sBAAA;wBAE3F;wBACA/C,IAAI,GAAG,IAAI;sBAAA;wBAAA,OAAAqC,QAAA,CAAAW,MAAA,WAGNb,IAAI;sBAAA;sBAAA;wBAAA,OAAAE,QAAA,CAAAY,IAAA;oBAAA;kBAAA,GAAAjB,OAAA;gBAAA,CACZ;gBAAA,iBAAAkB,EAAA,EAAAC,GAAA;kBAAA,OAAApB,IAAA,CAAAqB,KAAA,OAAAlD,SAAA;gBAAA;cAAA,IAAC,CAAC;YAAA;cAAA,OAAAG,SAAA,CAAA2C,MAAA,WAAA3C,SAAA,CAAAkC,IAAA;YAAA;cAAAlC,SAAA,CAAAC,IAAA;cAEH;cACAR,oBAAoB,CAACuD,OAAO,CAAC,UAAAC,CAAC,EAAG;gBAC/B,IAAIA,CAAC,KAAK7C,SAAS,EAAE;kBACnB6C,CAAC,CAACC,KAAK,EAAE;;cAEb,CAAC,CAAC;cACF9D,MAAM,CAAC4D,OAAO,CAAC,UAAAxD,KAAK;gBAAA,OAAIL,KAAI,CAACT,MAAM,CAACyD,YAAY,CAAC3C,KAAK,CAAC;cAAA,EAAC,EAAC;cAAA,OAAAQ,SAAA,CAAAyC,MAAA;YAAA;YAAA;cAAA,OAAAzC,SAAA,CAAA4C,IAAA;UAAA;QAAA,GAAA1D,QAAA;MAAA,CAE5D;MAAA,SAAAiE,IAAA;QAAA,OAAArE,IAAA,CAAAiE,KAAA,OAAAlD,SAAA;MAAA;MAAA,OAAAsD,GAAA;IAAA;EAAA;EAAA,OAAA9E,WAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}