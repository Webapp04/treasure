{"ast":null,"code":"import get from 'dlv';\nimport mergeOpts from 'merge-options';\nimport errCode from 'err-code';\nimport { routers } from 'ipfs-core-config/libp2p-pubsub-routers';\nimport { DelegatedPeerRouting } from '@libp2p/delegated-peer-routing';\nimport { DelegatedContentRouting } from '@libp2p/delegated-content-routing';\nimport { create as ipfsHttpClient } from 'ipfs-http-client';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { ipfsCore as pkgversion } from '../version.js';\nimport { libp2pConfig as getEnvLibp2pOptions } from 'ipfs-core-config/libp2p';\nimport { createLibp2p as createNode } from 'libp2p';\nimport { KadDHT } from '@libp2p/kad-dht';\nimport { Bootstrap } from '@libp2p/bootstrap';\nimport { ipnsValidator } from 'ipns/validator';\nimport { ipnsSelector } from 'ipns/selector';\nimport { WebSockets } from '@libp2p/websockets';\nimport { Mplex } from '@libp2p/mplex';\nimport { Noise } from '@chainsafe/libp2p-noise';\nvar mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true,\n  concatArrays: true\n});\n\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p').Libp2p} LibP2P\n * @typedef {import('libp2p').Libp2pOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\nexport function createLibp2p(_ref) {\n  var _ref$options = _ref.options,\n    options = _ref$options === void 0 ? {} : _ref$options,\n    peerId = _ref.peerId,\n    _ref$multiaddrs = _ref.multiaddrs,\n    multiaddrs = _ref$multiaddrs === void 0 ? [] : _ref$multiaddrs,\n    repo = _ref.repo,\n    _ref$keychainConfig = _ref.keychainConfig,\n    keychainConfig = _ref$keychainConfig === void 0 ? {} : _ref$keychainConfig,\n    _ref$config = _ref.config,\n    config = _ref$config === void 0 ? {} : _ref$config;\n  var datastore = repo.datastore;\n  var libp2pOptions = getLibp2pOptions({\n    options: options,\n    config: config,\n    datastore: datastore,\n    keychainConfig: keychainConfig,\n    peerId: peerId,\n    multiaddrs: multiaddrs\n  });\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({\n      libp2pOptions: libp2pOptions,\n      options: options,\n      config: config,\n      datastore: datastore,\n      peerId: peerId\n    });\n  }\n  return createNode(libp2pOptions);\n}\n\n/**\n * @param {object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\nfunction getLibp2pOptions(_ref2) {\n  var options = _ref2.options,\n    config = _ref2.config,\n    datastore = _ref2.datastore,\n    keychainConfig = _ref2.keychainConfig,\n    peerId = _ref2.peerId,\n    multiaddrs = _ref2.multiaddrs;\n  var getPubsubRouter = function getPubsubRouter() {\n    var router = get(config, 'Pubsub.Router') || 'gossipsub';\n    var availableRouters = routers();\n    if (!availableRouters[router]) {\n      throw errCode(new Error(\"Router unavailable. Configure libp2p.modules.pubsub to use the \".concat(router, \" router.\")), 'ERR_NOT_SUPPORTED');\n    }\n    return availableRouters[router];\n  };\n\n  /** @type {Libp2pOptions} */\n  var libp2pDefaults = {\n    datastore: datastore,\n    peerId: peerId\n  };\n\n  /** @type {Libp2pOptions} */\n  var libp2pOptions = {\n    addresses: {\n      listen: multiaddrs.map(function (ma) {\n        return ma.toString();\n      }),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: keychainConfig,\n    identify: {\n      host: {\n        agentVersion: \"js-ipfs/\".concat(pkgversion)\n      }\n    },\n    contentRouters: [],\n    peerRouters: [],\n    peerDiscovery: [],\n    transports: [],\n    streamMuxers: [new Mplex({\n      maxInboundStreams: 256,\n      maxOutboundStreams: 1024\n    })],\n    connectionEncryption: [new Noise()],\n    relay: {\n      enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n      hop: {\n        enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n        active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n      }\n    },\n    nat: {\n      enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n    }\n  };\n  if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {\n    libp2pOptions.pubsub = getPubsubRouter();\n  }\n  if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {\n    libp2pOptions.dht = new KadDHT({\n      clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n      kBucketSize: get(options, 'dht.kBucketSize', 20),\n      validators: {\n        ipns: ipnsValidator\n      },\n      selectors: {\n        ipns: ipnsSelector\n      }\n    });\n  }\n  var boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []));\n  if (boostrapNodes.length > 0) {\n    var _libp2pOptions$peerDi;\n    (_libp2pOptions$peerDi = libp2pOptions.peerDiscovery) === null || _libp2pOptions$peerDi === void 0 ? void 0 : _libp2pOptions$peerDi.push(new Bootstrap({\n      list: boostrapNodes\n    }));\n  }\n\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n  var constructorOptions = get(options, 'libp2p', undefined);\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined;\n  }\n\n  // Merge defaults with Node.js/browser/other environments options and configuration\n  /** @type {Libp2pOptions} */\n  var libp2pFinalConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions);\n\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  var delegateHosts = get(options, 'config.Addresses.Delegates', get(config, 'Addresses.Delegates', []));\n  if (delegateHosts.length > 0) {\n    var _libp2pFinalConfig$co, _libp2pFinalConfig$pe;\n    // Pick a random delegate host\n    var delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];\n    var delegateAddr = multiaddr(delegateString).toOptions();\n    var delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-expect-error - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    };\n    var delegateHttpClient = ipfsHttpClient(delegateApiOptions);\n    (_libp2pFinalConfig$co = libp2pFinalConfig.contentRouters) === null || _libp2pFinalConfig$co === void 0 ? void 0 : _libp2pFinalConfig$co.push(new DelegatedContentRouting(delegateHttpClient));\n    (_libp2pFinalConfig$pe = libp2pFinalConfig.peerRouters) === null || _libp2pFinalConfig$pe === void 0 ? void 0 : _libp2pFinalConfig$pe.push(new DelegatedPeerRouting(delegateHttpClient));\n  }\n  if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {\n    var _libp2pFinalConfig$pe2;\n    libp2pFinalConfig.peerDiscovery = (_libp2pFinalConfig$pe2 = libp2pFinalConfig.peerDiscovery) === null || _libp2pFinalConfig$pe2 === void 0 ? void 0 : _libp2pFinalConfig$pe2.filter(function (d) {\n      return d != null && d[Symbol.toStringTag] !== '@libp2p/mdns';\n    });\n  }\n  if (libp2pFinalConfig.transports == null) {\n    libp2pFinalConfig.transports = [];\n  }\n\n  // add WebSocket transport if not overridden by user config\n  if (libp2pFinalConfig.transports.find(function (t) {\n    return t[Symbol.toStringTag] === '@libp2p/websockets';\n  }) == null) {\n    libp2pFinalConfig.transports.push(new WebSockets());\n  }\n  return libp2pFinalConfig;\n}","map":{"version":3,"names":["get","mergeOpts","errCode","routers","DelegatedPeerRouting","DelegatedContentRouting","create","ipfsHttpClient","multiaddr","ipfsCore","pkgversion","libp2pConfig","getEnvLibp2pOptions","createLibp2p","createNode","KadDHT","Bootstrap","ipnsValidator","ipnsSelector","WebSockets","Mplex","Noise","mergeOptions","bind","ignoreUndefined","concatArrays","_ref","_ref$options","options","peerId","_ref$multiaddrs","multiaddrs","repo","_ref$keychainConfig","keychainConfig","_ref$config","config","datastore","libp2pOptions","getLibp2pOptions","libp2p","_ref2","getPubsubRouter","router","availableRouters","Error","concat","libp2pDefaults","addresses","listen","map","ma","toString","announce","noAnnounce","connectionManager","maxConnections","minConnections","keychain","identify","host","agentVersion","contentRouters","peerRouters","peerDiscovery","transports","streamMuxers","maxInboundStreams","maxOutboundStreams","connectionEncryption","relay","enabled","hop","active","nat","pubsub","dht","clientMode","kBucketSize","validators","ipns","selectors","boostrapNodes","length","_libp2pOptions$peerDi","push","list","constructorOptions","undefined","libp2pFinalConfig","delegateHosts","_libp2pFinalConfig$co","_libp2pFinalConfig$pe","delegateString","Math","floor","random","delegateAddr","toOptions","delegateApiOptions","protocol","parseInt","port","delegateHttpClient","_libp2pFinalConfig$pe2","filter","d","Symbol","toStringTag","find","t"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/libp2p.js"],"sourcesContent":["import get from 'dlv'\nimport mergeOpts from 'merge-options'\nimport errCode from 'err-code'\nimport { routers } from 'ipfs-core-config/libp2p-pubsub-routers'\nimport { DelegatedPeerRouting } from '@libp2p/delegated-peer-routing'\nimport { DelegatedContentRouting } from '@libp2p/delegated-content-routing'\nimport { create as ipfsHttpClient } from 'ipfs-http-client'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { ipfsCore as pkgversion } from '../version.js'\nimport { libp2pConfig as getEnvLibp2pOptions } from 'ipfs-core-config/libp2p'\nimport { createLibp2p as createNode } from 'libp2p'\nimport { KadDHT } from '@libp2p/kad-dht'\nimport { Bootstrap } from '@libp2p/bootstrap'\nimport { ipnsValidator } from 'ipns/validator'\nimport { ipnsSelector } from 'ipns/selector'\nimport { WebSockets } from '@libp2p/websockets'\nimport { Mplex } from '@libp2p/mplex'\nimport { Noise } from '@chainsafe/libp2p-noise'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true, concatArrays: true })\n\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p').Libp2p} LibP2P\n * @typedef {import('libp2p').Libp2pOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\nexport function createLibp2p ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) {\n  const { datastore } = repo\n\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  })\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({ libp2pOptions, options, config, datastore, peerId })\n  }\n\n  return createNode(libp2pOptions)\n}\n\n/**\n * @param {object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\nfunction getLibp2pOptions ({ options, config, datastore, keychainConfig, peerId, multiaddrs }) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'\n\n    const availableRouters = routers()\n\n    if (!availableRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')\n    }\n\n    return availableRouters[router]\n  }\n\n  /** @type {Libp2pOptions} */\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId\n  }\n\n  /** @type {Libp2pOptions} */\n  const libp2pOptions = {\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: keychainConfig,\n    identify: {\n      host: {\n        agentVersion: `js-ipfs/${pkgversion}`\n      }\n    },\n    contentRouters: [],\n    peerRouters: [],\n    peerDiscovery: [],\n    transports: [],\n    streamMuxers: [\n      new Mplex({\n        maxInboundStreams: 256,\n        maxOutboundStreams: 1024\n      })\n    ],\n    connectionEncryption: [\n      new Noise()\n    ],\n    relay: {\n      enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n      hop: {\n        enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n        active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n      }\n    },\n    nat: {\n      enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n    }\n  }\n\n  if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {\n    libp2pOptions.pubsub = getPubsubRouter()\n  }\n\n  if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {\n    libp2pOptions.dht = new KadDHT({\n      clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n      kBucketSize: get(options, 'dht.kBucketSize', 20),\n      validators: {\n        ipns: ipnsValidator\n      },\n      selectors: {\n        ipns: ipnsSelector\n      }\n    })\n  }\n\n  const boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n\n  if (boostrapNodes.length > 0) {\n    libp2pOptions.peerDiscovery?.push(\n      new Bootstrap({\n        list: boostrapNodes\n      })\n    )\n  }\n\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n  let constructorOptions = get(options, 'libp2p', undefined)\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined\n  }\n\n  // Merge defaults with Node.js/browser/other environments options and configuration\n  /** @type {Libp2pOptions} */\n  const libp2pFinalConfig = mergeOptions(\n    libp2pDefaults,\n    getEnvLibp2pOptions(),\n    libp2pOptions,\n    constructorOptions\n  )\n\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  const delegateHosts = get(options, 'config.Addresses.Delegates',\n    get(config, 'Addresses.Delegates', [])\n  )\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]\n    const delegateAddr = multiaddr(delegateString).toOptions()\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-expect-error - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    }\n\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions)\n\n    libp2pFinalConfig.contentRouters?.push(new DelegatedContentRouting(delegateHttpClient))\n    libp2pFinalConfig.peerRouters?.push(new DelegatedPeerRouting(delegateHttpClient))\n  }\n\n  if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {\n    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter(d => {\n      return d != null && d[Symbol.toStringTag] !== '@libp2p/mdns'\n    })\n  }\n\n  if (libp2pFinalConfig.transports == null) {\n    libp2pFinalConfig.transports = []\n  }\n\n  // add WebSocket transport if not overridden by user config\n  if (libp2pFinalConfig.transports.find(t => t[Symbol.toStringTag] === '@libp2p/websockets') == null) {\n    libp2pFinalConfig.transports.push(new WebSockets())\n  }\n\n  return libp2pFinalConfig\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}