{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// @ts-expect-error no types\nimport KBuck from 'k-bucket';\nimport * as utils from '../utils.js';\nimport Queue from 'p-queue';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { logger } from '@libp2p/logger';\nimport { Components } from '@libp2p/components';\nimport { PeerSet } from '@libp2p/peer-collections';\nexport var KAD_CLOSE_TAG_NAME = 'kad-close';\nexport var KAD_CLOSE_TAG_VALUE = 50;\nexport var KBUCKET_SIZE = 20;\nexport var PING_TIMEOUT = 10000;\nexport var PING_CONCURRENCY = 10;\nvar METRIC_ROUTING_TABLE_SIZE = 'routing-table-size';\nvar METRIC_PING_QUEUE_SIZE = 'ping-queue-size';\nvar METRIC_PING_RUNNING = 'ping-running';\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport var RoutingTable = /*#__PURE__*/function () {\n  function RoutingTable(init) {\n    var _this = this;\n    _classCallCheck(this, RoutingTable);\n    this.components = new Components();\n    var kBucketSize = init.kBucketSize,\n      pingTimeout = init.pingTimeout,\n      lan = init.lan,\n      pingConcurrency = init.pingConcurrency,\n      protocol = init.protocol,\n      tagName = init.tagName,\n      tagValue = init.tagValue;\n    this.log = logger(\"libp2p:kad-dht:\".concat(lan ? 'lan' : 'wan', \":routing-table\"));\n    this.kBucketSize = kBucketSize !== null && kBucketSize !== void 0 ? kBucketSize : KBUCKET_SIZE;\n    this.pingTimeout = pingTimeout !== null && pingTimeout !== void 0 ? pingTimeout : PING_TIMEOUT;\n    this.pingConcurrency = pingConcurrency !== null && pingConcurrency !== void 0 ? pingConcurrency : PING_CONCURRENCY;\n    this.lan = lan;\n    this.running = false;\n    this.protocol = protocol;\n    this.tagName = tagName !== null && tagName !== void 0 ? tagName : KAD_CLOSE_TAG_NAME;\n    this.tagValue = tagValue !== null && tagValue !== void 0 ? tagValue : KAD_CLOSE_TAG_VALUE;\n    var updatePingQueueSizeMetric = function updatePingQueueSizeMetric() {\n      var _this$components$getM, _this$components$getM2;\n      (_this$components$getM = _this.components.getMetrics()) === null || _this$components$getM === void 0 ? void 0 : _this$components$getM.updateComponentMetric({\n        system: 'libp2p',\n        component: \"kad-dht-\".concat(_this.lan ? 'lan' : 'wan'),\n        metric: METRIC_PING_QUEUE_SIZE,\n        value: _this.pingQueue.size\n      });\n      (_this$components$getM2 = _this.components.getMetrics()) === null || _this$components$getM2 === void 0 ? void 0 : _this$components$getM2.updateComponentMetric({\n        system: 'libp2p',\n        component: \"kad-dht-\".concat(_this.lan ? 'lan' : 'wan'),\n        metric: METRIC_PING_RUNNING,\n        value: _this.pingQueue.pending\n      });\n    };\n    this.pingQueue = new Queue({\n      concurrency: this.pingConcurrency\n    });\n    this.pingQueue.addListener('add', updatePingQueueSizeMetric);\n    this.pingQueue.addListener('next', updatePingQueueSizeMetric);\n    this._onPing = this._onPing.bind(this);\n  }\n  _createClass(RoutingTable, [{\n    key: \"init\",\n    value: function init(components) {\n      this.components = components;\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.running;\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var kBuck;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.running = true;\n              _context.t0 = KBuck;\n              _context.next = 4;\n              return utils.convertPeerId(this.components.getPeerId());\n            case 4:\n              _context.t1 = _context.sent;\n              _context.t2 = this.kBucketSize;\n              _context.t3 = {\n                localNodeId: _context.t1,\n                numberOfNodesPerKBucket: _context.t2,\n                numberOfNodesToPing: 1\n              };\n              kBuck = new _context.t0(_context.t3);\n              this.kb = kBuck;\n              // test whether to evict peers\n              kBuck.on('ping', this._onPing);\n              // tag kad-close peers\n              this._tagPeers(kBuck);\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.running = false;\n              this.pingQueue.clear();\n              this.kb = undefined;\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Keep track of our k-closest peers and tag them in the peer store as such\n     * - this will lower the chances that connections to them get closed when\n     * we reach connection limits\n     */\n  }, {\n    key: \"_tagPeers\",\n    value: function _tagPeers(kBuck) {\n      var _this2 = this;\n      var kClosest = new PeerSet();\n      var updatePeerTags = utils.debounce(function () {\n        var newClosest = new PeerSet(kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map(function (contact) {\n          return contact.peer;\n        }));\n        var addedPeers = newClosest.difference(kClosest);\n        var removedPeers = kClosest.difference(newClosest);\n        Promise.resolve().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var _iterator, _step, peer, _iterator2, _step2, _peer;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(addedPeers);\n                _context3.prev = 1;\n                _iterator.s();\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 9;\n                  break;\n                }\n                peer = _step.value;\n                _context3.next = 7;\n                return _this2.components.getPeerStore().tagPeer(peer, _this2.tagName, {\n                  value: _this2.tagValue\n                });\n              case 7:\n                _context3.next = 3;\n                break;\n              case 9:\n                _context3.next = 14;\n                break;\n              case 11:\n                _context3.prev = 11;\n                _context3.t0 = _context3[\"catch\"](1);\n                _iterator.e(_context3.t0);\n              case 14:\n                _context3.prev = 14;\n                _iterator.f();\n                return _context3.finish(14);\n              case 17:\n                _iterator2 = _createForOfIteratorHelper(removedPeers);\n                _context3.prev = 18;\n                _iterator2.s();\n              case 20:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context3.next = 26;\n                  break;\n                }\n                _peer = _step2.value;\n                _context3.next = 24;\n                return _this2.components.getPeerStore().unTagPeer(_peer, _this2.tagName);\n              case 24:\n                _context3.next = 20;\n                break;\n              case 26:\n                _context3.next = 31;\n                break;\n              case 28:\n                _context3.prev = 28;\n                _context3.t1 = _context3[\"catch\"](18);\n                _iterator2.e(_context3.t1);\n              case 31:\n                _context3.prev = 31;\n                _iterator2.f();\n                return _context3.finish(31);\n              case 34:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3, null, [[1, 11, 14, 17], [18, 28, 31, 34]]);\n        }))).catch(function (err) {\n          _this2.log.error('Could not update peer tags', err);\n        });\n        kClosest = newClosest;\n      });\n      kBuck.on('added', function () {\n        updatePeerTags();\n      });\n      kBuck.on('removed', function () {\n        updatePeerTags();\n      });\n    }\n    /**\n     * Called on the `ping` event from `k-bucket` when a bucket is full\n     * and cannot split.\n     *\n     * `oldContacts.length` is defined by the `numberOfNodesToPing` param\n     * passed to the `k-bucket` constructor.\n     *\n     * `oldContacts` will not be empty and is the list of contacts that\n     * have not been contacted for the longest.\n     */\n  }, {\n    key: \"_onPing\",\n    value: function _onPing(oldContacts, newContact) {\n      var _this3 = this;\n      // add to a queue so multiple ping requests do not overlap and we don't\n      // flood the network with ping requests if lots of newContact requests\n      // are received\n      this.pingQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var responded;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (_this3.running) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 2:\n              responded = 0;\n              _context5.prev = 3;\n              _context5.next = 6;\n              return Promise.all(oldContacts.map( /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(oldContact) {\n                  var timeoutController, options, connection, stream, _this3$components$get;\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.prev = 0;\n                        timeoutController = new TimeoutController(_this3.pingTimeout);\n                        options = {\n                          signal: timeoutController.signal\n                        };\n                        _this3.log('pinging old contact %p', oldContact.peer);\n                        _context4.next = 6;\n                        return _this3.components.getConnectionManager().openConnection(oldContact.peer, options);\n                      case 6:\n                        connection = _context4.sent;\n                        _context4.next = 9;\n                        return connection.newStream(_this3.protocol, options);\n                      case 9:\n                        stream = _context4.sent;\n                        stream.close();\n                        responded++;\n                        _context4.next = 17;\n                        break;\n                      case 14:\n                        _context4.prev = 14;\n                        _context4.t0 = _context4[\"catch\"](0);\n                        if (_this3.running && _this3.kb != null) {\n                          // only evict peers if we are still running, otherwise we evict when dialing is\n                          // cancelled due to shutdown in progress\n                          _this3.log.error('could not ping peer %p', oldContact.peer, _context4.t0);\n                          _this3.log('evicting old contact after ping failed %p', oldContact);\n                          _this3.kb.remove(oldContact.id);\n                        }\n                      case 17:\n                        _context4.prev = 17;\n                        if (timeoutController != null) {\n                          timeoutController.clear();\n                        }\n                        (_this3$components$get = _this3.components.getMetrics()) === null || _this3$components$get === void 0 ? void 0 : _this3$components$get.updateComponentMetric({\n                          system: 'libp2p',\n                          component: \"kad-dht-\".concat(_this3.lan ? 'lan' : 'wan'),\n                          metric: METRIC_ROUTING_TABLE_SIZE,\n                          value: _this3.size\n                        });\n                        return _context4.finish(17);\n                      case 21:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4, null, [[0, 14, 17, 21]]);\n                }));\n                return function (_x) {\n                  return _ref3.apply(this, arguments);\n                };\n              }()));\n            case 6:\n              if (_this3.running && responded < oldContacts.length && _this3.kb != null) {\n                _this3.log('adding new contact %p', newContact.peer);\n                _this3.kb.add(newContact);\n              }\n              _context5.next = 12;\n              break;\n            case 9:\n              _context5.prev = 9;\n              _context5.t0 = _context5[\"catch\"](3);\n              _this3.log.error('could not process k-bucket ping event', _context5.t0);\n            case 12:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, null, [[3, 9]]);\n      }))).catch(function (err) {\n        _this3.log.error('could not process k-bucket ping event', err);\n      });\n    }\n    // -- Public Interface\n    /**\n     * Amount of currently stored peers\n     */\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this.kb == null) {\n        return 0;\n      }\n      return this.kb.count();\n    }\n    /**\n     * Find a specific peer by id\n     */\n  }, {\n    key: \"find\",\n    value: function () {\n      var _find = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(peer) {\n        var key, closest;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return utils.convertPeerId(peer);\n            case 2:\n              key = _context6.sent;\n              closest = this.closestPeer(key);\n              if (!(closest != null && peer.equals(closest))) {\n                _context6.next = 6;\n                break;\n              }\n              return _context6.abrupt(\"return\", closest);\n            case 6:\n              return _context6.abrupt(\"return\", undefined);\n            case 7:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function find(_x2) {\n        return _find.apply(this, arguments);\n      }\n      return find;\n    }()\n    /**\n     * Retrieve the closest peers to the given key\n     */\n  }, {\n    key: \"closestPeer\",\n    value: function closestPeer(key) {\n      var res = this.closestPeers(key, 1);\n      if (res.length > 0) {\n        return res[0];\n      }\n      return undefined;\n    }\n    /**\n     * Retrieve the `count`-closest peers to the given key\n     */\n  }, {\n    key: \"closestPeers\",\n    value: function closestPeers(key) {\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.kBucketSize;\n      if (this.kb == null) {\n        return [];\n      }\n      var closest = this.kb.closest(key, count);\n      return closest.map(function (p) {\n        return p.peer;\n      });\n    }\n    /**\n     * Add or update the routing table with the given peer\n     */\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(peer) {\n        var _this$components$getM3;\n        var id;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(this.kb == null)) {\n                _context7.next = 2;\n                break;\n              }\n              throw new Error('RoutingTable is not started');\n            case 2:\n              _context7.next = 4;\n              return utils.convertPeerId(peer);\n            case 4:\n              id = _context7.sent;\n              this.kb.add({\n                id: id,\n                peer: peer\n              });\n              this.log('added %p with kad id %b', peer, id);\n              (_this$components$getM3 = this.components.getMetrics()) === null || _this$components$getM3 === void 0 ? void 0 : _this$components$getM3.updateComponentMetric({\n                system: 'libp2p',\n                component: \"kad-dht-\".concat(this.lan ? 'lan' : 'wan'),\n                metric: METRIC_ROUTING_TABLE_SIZE,\n                value: this.size\n              });\n            case 8:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function add(_x3) {\n        return _add.apply(this, arguments);\n      }\n      return add;\n    }()\n    /**\n     * Remove a given peer from the table\n     */\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(peer) {\n        var _this$components$getM4;\n        var id;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!(this.kb == null)) {\n                _context8.next = 2;\n                break;\n              }\n              throw new Error('RoutingTable is not started');\n            case 2:\n              _context8.next = 4;\n              return utils.convertPeerId(peer);\n            case 4:\n              id = _context8.sent;\n              this.kb.remove(id);\n              (_this$components$getM4 = this.components.getMetrics()) === null || _this$components$getM4 === void 0 ? void 0 : _this$components$getM4.updateComponentMetric({\n                system: 'libp2p',\n                component: \"kad-dht-\".concat(this.lan ? 'lan' : 'wan'),\n                metric: METRIC_ROUTING_TABLE_SIZE,\n                value: this.size\n              });\n            case 7:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function remove(_x4) {\n        return _remove.apply(this, arguments);\n      }\n      return remove;\n    }()\n  }]);\n  return RoutingTable;\n}();","map":{"version":3,"names":["KBuck","utils","Queue","TimeoutController","logger","Components","PeerSet","KAD_CLOSE_TAG_NAME","KAD_CLOSE_TAG_VALUE","KBUCKET_SIZE","PING_TIMEOUT","PING_CONCURRENCY","METRIC_ROUTING_TABLE_SIZE","METRIC_PING_QUEUE_SIZE","METRIC_PING_RUNNING","RoutingTable","init","_this","_classCallCheck","components","kBucketSize","pingTimeout","lan","pingConcurrency","protocol","tagName","tagValue","log","concat","running","updatePingQueueSizeMetric","_this$components$getM","_this$components$getM2","getMetrics","updateComponentMetric","system","component","metric","value","pingQueue","size","pending","concurrency","addListener","_onPing","bind","_createClass","key","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","kBuck","wrap","_callee$","_context","prev","next","t0","convertPeerId","getPeerId","t1","sent","t2","t3","localNodeId","numberOfNodesPerKBucket","numberOfNodesToPing","kb","on","_tagPeers","stop","start","apply","arguments","_stop","_callee2","_callee2$","_context2","clear","undefined","_this2","kClosest","updatePeerTags","debounce","newClosest","closest","map","contact","peer","addedPeers","difference","removedPeers","Promise","resolve","then","_callee3","_iterator","_step","_iterator2","_step2","_peer","_callee3$","_context3","_createForOfIteratorHelper","s","n","done","getPeerStore","tagPeer","e","f","finish","unTagPeer","catch","err","error","oldContacts","newContact","_this3","add","_callee5","responded","_callee5$","_context5","abrupt","all","_ref3","_callee4","oldContact","timeoutController","options","connection","stream","_this3$components$get","_callee4$","_context4","signal","getConnectionManager","openConnection","newStream","close","remove","id","_x","length","get","count","_find","_callee6","_callee6$","_context6","closestPeer","equals","find","_x2","res","closestPeers","p","_add","_callee7","_this$components$getM3","_callee7$","_context7","Error","_x3","_remove","_callee8","_this$components$getM4","_callee8$","_context8","_x4"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/kad-dht/src/routing-table/index.ts"],"sourcesContent":["// @ts-expect-error no types\nimport KBuck from 'k-bucket'\nimport * as utils from '../utils.js'\nimport Queue from 'p-queue'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { logger } from '@libp2p/logger'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { Logger } from '@libp2p/logger'\nimport { Components, Initializable } from '@libp2p/components'\nimport { PeerSet } from '@libp2p/peer-collections'\n\nexport const KAD_CLOSE_TAG_NAME = 'kad-close'\nexport const KAD_CLOSE_TAG_VALUE = 50\nexport const KBUCKET_SIZE = 20\nexport const PING_TIMEOUT = 10000\nexport const PING_CONCURRENCY = 10\n\nexport interface KBucketPeer {\n  id: Uint8Array\n  peer: PeerId\n}\n\nexport interface KBucket {\n  id: Uint8Array\n  contacts: KBucketPeer[]\n  dontSplit: boolean\n  left: KBucket\n  right: KBucket\n}\n\ninterface KBucketTreeEvents {\n  'ping': (oldContacts: KBucketPeer[], newContact: KBucketPeer) => void\n  'added': (contact: KBucketPeer) => void\n  'removed': (contact: KBucketPeer) => void\n}\n\nexport interface KBucketTree {\n  root: KBucket\n  localNodeId: Uint8Array\n\n  on: <U extends keyof KBucketTreeEvents>(\n    event: U, listener: KBucketTreeEvents[U]\n  ) => this\n\n  closest: (key: Uint8Array, count: number) => KBucketPeer[]\n  closestPeer: (key: Uint8Array) => KBucketPeer\n  remove: (key: Uint8Array) => void\n  add: (peer: KBucketPeer) => void\n  get: (key: Uint8Array) => Uint8Array\n  count: () => number\n  toIterable: () => Iterable<KBucket>\n}\n\nconst METRIC_ROUTING_TABLE_SIZE = 'routing-table-size'\nconst METRIC_PING_QUEUE_SIZE = 'ping-queue-size'\nconst METRIC_PING_RUNNING = 'ping-running'\n\nexport interface RoutingTableInit {\n  lan: boolean\n  protocol: string\n  kBucketSize?: number\n  pingTimeout?: number\n  pingConcurrency?: number\n  tagName?: string\n  tagValue?: number\n}\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport class RoutingTable implements Startable, Initializable {\n  public kBucketSize: number\n  public kb?: KBucketTree\n  public pingQueue: Queue\n\n  private readonly log: Logger\n  private components: Components = new Components()\n  private readonly lan: boolean\n  private readonly pingTimeout: number\n  private readonly pingConcurrency: number\n  private running: boolean\n  private readonly protocol: string\n  private readonly tagName: string\n  private readonly tagValue: number\n\n  constructor (init: RoutingTableInit) {\n    const { kBucketSize, pingTimeout, lan, pingConcurrency, protocol, tagName, tagValue } = init\n\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table`)\n    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE\n    this.pingTimeout = pingTimeout ?? PING_TIMEOUT\n    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY\n    this.lan = lan\n    this.running = false\n    this.protocol = protocol\n    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME\n    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE\n\n    const updatePingQueueSizeMetric = () => {\n      this.components.getMetrics()?.updateComponentMetric({\n        system: 'libp2p',\n        component: `kad-dht-${this.lan ? 'lan' : 'wan'}`,\n        metric: METRIC_PING_QUEUE_SIZE,\n        value: this.pingQueue.size\n      })\n      this.components.getMetrics()?.updateComponentMetric({\n        system: 'libp2p',\n        component: `kad-dht-${this.lan ? 'lan' : 'wan'}`,\n        metric: METRIC_PING_RUNNING,\n        value: this.pingQueue.pending\n      })\n    }\n\n    this.pingQueue = new Queue({ concurrency: this.pingConcurrency })\n    this.pingQueue.addListener('add', updatePingQueueSizeMetric)\n    this.pingQueue.addListener('next', updatePingQueueSizeMetric)\n\n    this._onPing = this._onPing.bind(this)\n  }\n\n  init (components: Components): void {\n    this.components = components\n  }\n\n  isStarted () {\n    return this.running\n  }\n\n  async start () {\n    this.running = true\n\n    const kBuck: KBucketTree = new KBuck({\n      localNodeId: await utils.convertPeerId(this.components.getPeerId()),\n      numberOfNodesPerKBucket: this.kBucketSize,\n      numberOfNodesToPing: 1\n    })\n    this.kb = kBuck\n\n    // test whether to evict peers\n    kBuck.on('ping', this._onPing)\n\n    // tag kad-close peers\n    this._tagPeers(kBuck)\n  }\n\n  async stop () {\n    this.running = false\n    this.pingQueue.clear()\n    this.kb = undefined\n  }\n\n  /**\n   * Keep track of our k-closest peers and tag them in the peer store as such\n   * - this will lower the chances that connections to them get closed when\n   * we reach connection limits\n   */\n  _tagPeers (kBuck: KBucketTree) {\n    let kClosest = new PeerSet()\n\n    const updatePeerTags = utils.debounce(() => {\n      const newClosest = new PeerSet(\n        kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map(contact => contact.peer)\n      )\n      const addedPeers = newClosest.difference(kClosest)\n      const removedPeers = kClosest.difference(newClosest)\n\n      Promise.resolve()\n        .then(async () => {\n          for (const peer of addedPeers) {\n            await this.components.getPeerStore().tagPeer(peer, this.tagName, {\n              value: this.tagValue\n            })\n          }\n\n          for (const peer of removedPeers) {\n            await this.components.getPeerStore().unTagPeer(peer, this.tagName)\n          }\n        })\n        .catch(err => {\n          this.log.error('Could not update peer tags', err)\n        })\n\n      kClosest = newClosest\n    })\n\n    kBuck.on('added', () => {\n      updatePeerTags()\n    })\n    kBuck.on('removed', () => {\n      updatePeerTags()\n    })\n  }\n\n  /**\n   * Called on the `ping` event from `k-bucket` when a bucket is full\n   * and cannot split.\n   *\n   * `oldContacts.length` is defined by the `numberOfNodesToPing` param\n   * passed to the `k-bucket` constructor.\n   *\n   * `oldContacts` will not be empty and is the list of contacts that\n   * have not been contacted for the longest.\n   */\n  _onPing (oldContacts: KBucketPeer[], newContact: KBucketPeer) {\n    // add to a queue so multiple ping requests do not overlap and we don't\n    // flood the network with ping requests if lots of newContact requests\n    // are received\n    this.pingQueue.add(async () => {\n      if (!this.running) {\n        return\n      }\n\n      let responded = 0\n\n      try {\n        await Promise.all(\n          oldContacts.map(async oldContact => {\n            let timeoutController\n\n            try {\n              timeoutController = new TimeoutController(this.pingTimeout)\n\n              const options = {\n                signal: timeoutController.signal\n              }\n\n              this.log('pinging old contact %p', oldContact.peer)\n              const connection = await this.components.getConnectionManager().openConnection(oldContact.peer, options)\n              const stream = await connection.newStream(this.protocol, options)\n              stream.close()\n              responded++\n            } catch (err: any) {\n              if (this.running && this.kb != null) {\n                // only evict peers if we are still running, otherwise we evict when dialing is\n                // cancelled due to shutdown in progress\n                this.log.error('could not ping peer %p', oldContact.peer, err)\n                this.log('evicting old contact after ping failed %p', oldContact)\n                this.kb.remove(oldContact.id)\n              }\n            } finally {\n              if (timeoutController != null) {\n                timeoutController.clear()\n              }\n\n              this.components.getMetrics()?.updateComponentMetric({\n                system: 'libp2p',\n                component: `kad-dht-${this.lan ? 'lan' : 'wan'}`,\n                metric: METRIC_ROUTING_TABLE_SIZE,\n                value: this.size\n              })\n            }\n          })\n        )\n\n        if (this.running && responded < oldContacts.length && this.kb != null) {\n          this.log('adding new contact %p', newContact.peer)\n          this.kb.add(newContact)\n        }\n      } catch (err: any) {\n        this.log.error('could not process k-bucket ping event', err)\n      }\n    })\n      .catch(err => {\n        this.log.error('could not process k-bucket ping event', err)\n      })\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers\n   */\n  get size () {\n    if (this.kb == null) {\n      return 0\n    }\n\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id\n   */\n  async find (peer: PeerId): Promise<PeerId | undefined> {\n    const key = await utils.convertPeerId(peer)\n    const closest = this.closestPeer(key)\n\n    if (closest != null && peer.equals(closest)) {\n      return closest\n    }\n\n    return undefined\n  }\n\n  /**\n   * Retrieve the closest peers to the given key\n   */\n  closestPeer (key: Uint8Array): PeerId | undefined {\n    const res = this.closestPeers(key, 1)\n\n    if (res.length > 0) {\n      return res[0]\n    }\n\n    return undefined\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key\n   */\n  closestPeers (key: Uint8Array, count = this.kBucketSize): PeerId[] {\n    if (this.kb == null) {\n      return []\n    }\n\n    const closest = this.kb.closest(key, count)\n\n    return closest.map(p => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer\n   */\n  async add (peer: PeerId) {\n    if (this.kb == null) {\n      throw new Error('RoutingTable is not started')\n    }\n\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.add({ id: id, peer: peer })\n\n    this.log('added %p with kad id %b', peer, id)\n\n    this.components.getMetrics()?.updateComponentMetric({\n      system: 'libp2p',\n      component: `kad-dht-${this.lan ? 'lan' : 'wan'}`,\n      metric: METRIC_ROUTING_TABLE_SIZE,\n      value: this.size\n    })\n  }\n\n  /**\n   * Remove a given peer from the table\n   */\n  async remove (peer: PeerId) {\n    if (this.kb == null) {\n      throw new Error('RoutingTable is not started')\n    }\n\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.remove(id)\n\n    this.components.getMetrics()?.updateComponentMetric({\n      system: 'libp2p',\n      component: `kad-dht-${this.lan ? 'lan' : 'wan'}`,\n      metric: METRIC_ROUTING_TABLE_SIZE,\n      value: this.size\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}