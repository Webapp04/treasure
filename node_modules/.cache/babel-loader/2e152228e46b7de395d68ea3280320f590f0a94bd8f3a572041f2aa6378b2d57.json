{"ast":null,"code":"/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var pb;\n(function (pb) {\n  var NoiseHandshakePayload;\n  (function (NoiseHandshakePayload) {\n    var _codec;\n    NoiseHandshakePayload.codec = function () {\n      if (_codec == null) {\n        _codec = message(function (obj, writer) {\n          var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          if (opts.lengthDelimited !== false) {\n            writer.fork();\n          }\n          if (obj.identityKey != null) {\n            writer.uint32(10);\n            writer.bytes(obj.identityKey);\n          } else {\n            throw new Error('Protocol error: required field \"identityKey\" was not found in object');\n          }\n          if (obj.identitySig != null) {\n            writer.uint32(18);\n            writer.bytes(obj.identitySig);\n          } else {\n            throw new Error('Protocol error: required field \"identitySig\" was not found in object');\n          }\n          if (obj.data != null) {\n            writer.uint32(26);\n            writer.bytes(obj.data);\n          } else {\n            throw new Error('Protocol error: required field \"data\" was not found in object');\n          }\n          if (opts.lengthDelimited !== false) {\n            writer.ldelim();\n          }\n        }, function (reader, length) {\n          var obj = {\n            identityKey: new Uint8Array(0),\n            identitySig: new Uint8Array(0),\n            data: new Uint8Array(0)\n          };\n          var end = length == null ? reader.len : reader.pos + length;\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                obj.identityKey = reader.bytes();\n                break;\n              case 2:\n                obj.identitySig = reader.bytes();\n                break;\n              case 3:\n                obj.data = reader.bytes();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          if (obj.identityKey == null) {\n            throw new Error('Protocol error: value for required field \"identityKey\" was not found in protobuf');\n          }\n          if (obj.identitySig == null) {\n            throw new Error('Protocol error: value for required field \"identitySig\" was not found in protobuf');\n          }\n          if (obj.data == null) {\n            throw new Error('Protocol error: value for required field \"data\" was not found in protobuf');\n          }\n          return obj;\n        });\n      }\n      return _codec;\n    };\n    NoiseHandshakePayload.encode = function (obj) {\n      return encodeMessage(obj, NoiseHandshakePayload.codec());\n    };\n    NoiseHandshakePayload.decode = function (buf) {\n      return decodeMessage(buf, NoiseHandshakePayload.codec());\n    };\n  })(NoiseHandshakePayload = pb.NoiseHandshakePayload || (pb.NoiseHandshakePayload = {}));\n})(pb || (pb = {}));","map":{"version":3,"names":["encodeMessage","decodeMessage","message","pb","NoiseHandshakePayload","_codec","codec","obj","writer","opts","arguments","length","undefined","lengthDelimited","fork","identityKey","uint32","bytes","Error","identitySig","data","ldelim","reader","Uint8Array","end","len","pos","tag","skipType","encode","decode","buf"],"sources":["/Users/apple/Documents/treasure/node_modules/@chainsafe/libp2p-noise/src/proto/payload.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport namespace pb {\n  export interface NoiseHandshakePayload {\n    identityKey: Uint8Array\n    identitySig: Uint8Array\n    data: Uint8Array\n  }\n\n  export namespace NoiseHandshakePayload {\n    let _codec: Codec<NoiseHandshakePayload>\n\n    export const codec = (): Codec<NoiseHandshakePayload> => {\n      if (_codec == null) {\n        _codec = message<NoiseHandshakePayload>((obj, writer, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            writer.fork()\n          }\n\n          if (obj.identityKey != null) {\n            writer.uint32(10)\n            writer.bytes(obj.identityKey)\n          } else {\n            throw new Error('Protocol error: required field \"identityKey\" was not found in object')\n          }\n\n          if (obj.identitySig != null) {\n            writer.uint32(18)\n            writer.bytes(obj.identitySig)\n          } else {\n            throw new Error('Protocol error: required field \"identitySig\" was not found in object')\n          }\n\n          if (obj.data != null) {\n            writer.uint32(26)\n            writer.bytes(obj.data)\n          } else {\n            throw new Error('Protocol error: required field \"data\" was not found in object')\n          }\n\n          if (opts.lengthDelimited !== false) {\n            writer.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            identityKey: new Uint8Array(0),\n            identitySig: new Uint8Array(0),\n            data: new Uint8Array(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.identityKey = reader.bytes()\n                break\n              case 2:\n                obj.identitySig = reader.bytes()\n                break\n              case 3:\n                obj.data = reader.bytes()\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          if (obj.identityKey == null) {\n            throw new Error('Protocol error: value for required field \"identityKey\" was not found in protobuf')\n          }\n\n          if (obj.identitySig == null) {\n            throw new Error('Protocol error: value for required field \"identitySig\" was not found in protobuf')\n          }\n\n          if (obj.data == null) {\n            throw new Error('Protocol error: value for required field \"data\" was not found in protobuf')\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: NoiseHandshakePayload): Uint8Array => {\n      return encodeMessage(obj, NoiseHandshakePayload.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): NoiseHandshakePayload => {\n      return decodeMessage(buf, NoiseHandshakePayload.codec())\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA,SAASA,aAAa,EAAEC,aAAa,EAAEC,OAAO,QAAQ,iBAAiB;AAIvE,OAAM,IAAWC,EAAE;AAAnB,WAAiBA,EAAE;EAOjB,IAAiBC,qBAAqB;EAAtC,WAAiBA,qBAAqB;IACpC,IAAIC,MAAoC;IAE3BD,qBAAA,CAAAE,KAAK,GAAG,YAAmC;MACtD,IAAID,MAAM,IAAI,IAAI,EAAE;QAClBA,MAAM,GAAGH,OAAO,CAAwB,UAACK,GAAG,EAAEC,MAAM,EAAe;UAAA,IAAbC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;UAC7D,IAAID,IAAI,CAACI,eAAe,KAAK,KAAK,EAAE;YAClCL,MAAM,CAACM,IAAI,EAAE;;UAGf,IAAIP,GAAG,CAACQ,WAAW,IAAI,IAAI,EAAE;YAC3BP,MAAM,CAACQ,MAAM,CAAC,EAAE,CAAC;YACjBR,MAAM,CAACS,KAAK,CAACV,GAAG,CAACQ,WAAW,CAAC;WAC9B,MAAM;YACL,MAAM,IAAIG,KAAK,CAAC,sEAAsE,CAAC;;UAGzF,IAAIX,GAAG,CAACY,WAAW,IAAI,IAAI,EAAE;YAC3BX,MAAM,CAACQ,MAAM,CAAC,EAAE,CAAC;YACjBR,MAAM,CAACS,KAAK,CAACV,GAAG,CAACY,WAAW,CAAC;WAC9B,MAAM;YACL,MAAM,IAAID,KAAK,CAAC,sEAAsE,CAAC;;UAGzF,IAAIX,GAAG,CAACa,IAAI,IAAI,IAAI,EAAE;YACpBZ,MAAM,CAACQ,MAAM,CAAC,EAAE,CAAC;YACjBR,MAAM,CAACS,KAAK,CAACV,GAAG,CAACa,IAAI,CAAC;WACvB,MAAM;YACL,MAAM,IAAIF,KAAK,CAAC,+DAA+D,CAAC;;UAGlF,IAAIT,IAAI,CAACI,eAAe,KAAK,KAAK,EAAE;YAClCL,MAAM,CAACa,MAAM,EAAE;;QAEnB,CAAC,EAAE,UAACC,MAAM,EAAEX,MAAM,EAAI;UACpB,IAAMJ,GAAG,GAAQ;YACfQ,WAAW,EAAE,IAAIQ,UAAU,CAAC,CAAC,CAAC;YAC9BJ,WAAW,EAAE,IAAII,UAAU,CAAC,CAAC,CAAC;YAC9BH,IAAI,EAAE,IAAIG,UAAU,CAAC,CAAC;WACvB;UAED,IAAMC,GAAG,GAAGb,MAAM,IAAI,IAAI,GAAGW,MAAM,CAACG,GAAG,GAAGH,MAAM,CAACI,GAAG,GAAGf,MAAM;UAE7D,OAAOW,MAAM,CAACI,GAAG,GAAGF,GAAG,EAAE;YACvB,IAAMG,GAAG,GAAGL,MAAM,CAACN,MAAM,EAAE;YAE3B,QAAQW,GAAG,KAAK,CAAC;cACf,KAAK,CAAC;gBACJpB,GAAG,CAACQ,WAAW,GAAGO,MAAM,CAACL,KAAK,EAAE;gBAChC;cACF,KAAK,CAAC;gBACJV,GAAG,CAACY,WAAW,GAAGG,MAAM,CAACL,KAAK,EAAE;gBAChC;cACF,KAAK,CAAC;gBACJV,GAAG,CAACa,IAAI,GAAGE,MAAM,CAACL,KAAK,EAAE;gBACzB;cACF;gBACEK,MAAM,CAACM,QAAQ,CAACD,GAAG,GAAG,CAAC,CAAC;gBACxB;;;UAIN,IAAIpB,GAAG,CAACQ,WAAW,IAAI,IAAI,EAAE;YAC3B,MAAM,IAAIG,KAAK,CAAC,kFAAkF,CAAC;;UAGrG,IAAIX,GAAG,CAACY,WAAW,IAAI,IAAI,EAAE;YAC3B,MAAM,IAAID,KAAK,CAAC,kFAAkF,CAAC;;UAGrG,IAAIX,GAAG,CAACa,IAAI,IAAI,IAAI,EAAE;YACpB,MAAM,IAAIF,KAAK,CAAC,2EAA2E,CAAC;;UAG9F,OAAOX,GAAG;QACZ,CAAC,CAAC;;MAGJ,OAAOF,MAAM;IACf,CAAC;IAEYD,qBAAA,CAAAyB,MAAM,GAAG,UAACtB,GAA0B,EAAgB;MAC/D,OAAOP,aAAa,CAACO,GAAG,EAAEH,qBAAqB,CAACE,KAAK,EAAE,CAAC;IAC1D,CAAC;IAEYF,qBAAA,CAAA0B,MAAM,GAAG,UAACC,GAAgC,EAA2B;MAChF,OAAO9B,aAAa,CAAC8B,GAAG,EAAE3B,qBAAqB,CAACE,KAAK,EAAE,CAAC;IAC1D,CAAC;EACH,CAAC,EAxFgBF,qBAAqB,GAArBD,EAAA,CAAAC,qBAAqB,KAArBD,EAAA,CAAAC,qBAAqB;AAyFxC,CAAC,EAhGgBD,EAAE,KAAFA,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}