{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { codes, messages } from './errors.js';\nimport { storeAddresses, uniquePeers, requirePeers } from './content-routing/utils.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport merge from 'it-merge';\nimport { pipe } from 'it-pipe';\nimport first from 'it-first';\nimport drain from 'it-drain';\nimport filter from 'it-filter';\nimport { setDelayedInterval, clearDelayedInterval\n// @ts-expect-error module with no types\n} from 'set-delayed-interval';\nimport { setMaxListeners } from 'events';\nvar log = logger('libp2p:peer-routing');\nexport var DefaultPeerRouting = /*#__PURE__*/function () {\n  function DefaultPeerRouting(components, init) {\n    var _init$refreshManager;\n    _classCallCheck(this, DefaultPeerRouting);\n    this.components = components;\n    this.routers = init.routers;\n    this.refreshManagerInit = (_init$refreshManager = init.refreshManager) !== null && _init$refreshManager !== void 0 ? _init$refreshManager : {};\n    this.started = false;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n  _createClass(DefaultPeerRouting, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n    /**\n     * Start peer routing service.\n     */\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              this.timeoutId = setDelayedInterval(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay);\n              this.started = true;\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n    /**\n     * Recurrent task to find closest peers and add their addresses to the Address Book.\n     */\n  }, {\n    key: \"_findClosestPeersTask\",\n    value: function () {\n      var _findClosestPeersTask2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this$refreshManagerI, _this$abortController;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this.abortController != null)) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              _context2.prev = 2;\n              this.abortController = new TimeoutController((_this$refreshManagerI = this.refreshManagerInit.timeout) !== null && _this$refreshManagerI !== void 0 ? _this$refreshManagerI : 10e3);\n              // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning\n              // appearing in the console\n              try {\n                // fails on node < 15.4\n                setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, this.abortController.signal);\n              } catch (_unused) {}\n              // nb getClosestPeers adds the addresses to the address book\n              _context2.next = 7;\n              return drain(this.getClosestPeers(this.components.getPeerId().toBytes(), {\n                signal: this.abortController.signal\n              }));\n            case 7:\n              _context2.next = 12;\n              break;\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](2);\n              log.error(_context2.t0);\n            case 12:\n              _context2.prev = 12;\n              (_this$abortController = this.abortController) === null || _this$abortController === void 0 ? void 0 : _this$abortController.clear();\n              this.abortController = undefined;\n              return _context2.finish(12);\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[2, 9, 12, 16]]);\n      }));\n      function _findClosestPeersTask() {\n        return _findClosestPeersTask2.apply(this, arguments);\n      }\n      return _findClosestPeersTask;\n    }()\n    /**\n     * Stop peer routing service.\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this$abortController2;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              clearDelayedInterval(this.timeoutId);\n              // abort query if it is in-flight\n              (_this$abortController2 = this.abortController) === null || _this$abortController2 === void 0 ? void 0 : _this$abortController2.abort();\n              this.started = false;\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Iterates over all peer routers in parallel to find the given peer\n     */\n  }, {\n    key: \"findPeer\",\n    value: function () {\n      var _findPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(id, options) {\n        var _this2 = this;\n        var output;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(this.routers.length === 0)) {\n                _context6.next = 2;\n                break;\n              }\n              throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);\n            case 2:\n              if (!(id.toString() === this.components.getPeerId().toString())) {\n                _context6.next = 4;\n                break;\n              }\n              throw errCode(new Error('Should not try to find self'), codes.ERR_FIND_SELF);\n            case 4:\n              _context6.next = 6;\n              return pipe(merge.apply(void 0, _toConsumableArray(this.routers.map(function (router) {\n                return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.prev = 0;\n                        _context4.next = 3;\n                        return _awaitAsyncGenerator(router.findPeer(id, options));\n                      case 3:\n                        _context4.next = 5;\n                        return _context4.sent;\n                      case 5:\n                        _context4.next = 10;\n                        break;\n                      case 7:\n                        _context4.prev = 7;\n                        _context4.t0 = _context4[\"catch\"](0);\n                        log.error(_context4.t0);\n                      case 10:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4, null, [[0, 7]]);\n                }))();\n              }))), function (source) {\n                return filter(source, Boolean);\n              }, function (source) {\n                return storeAddresses(source, _this2.components.getPeerStore());\n              }, /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(source) {\n                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                    while (1) switch (_context5.prev = _context5.next) {\n                      case 0:\n                        _context5.next = 2;\n                        return first(source);\n                      case 2:\n                        return _context5.abrupt(\"return\", _context5.sent);\n                      case 3:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }, _callee5);\n                }));\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }());\n            case 6:\n              output = _context6.sent;\n              if (!(output != null)) {\n                _context6.next = 9;\n                break;\n              }\n              return _context6.abrupt(\"return\", output);\n            case 9:\n              throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function findPeer(_x, _x2) {\n        return _findPeer.apply(this, arguments);\n      }\n      return findPeer;\n    }()\n    /**\n     * Attempt to find the closest peers on the network to the given key\n     */\n  }, {\n    key: \"getClosestPeers\",\n    value: function getClosestPeers(key, options) {\n      var _this = this;\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(_this.routers.length === 0)) {\n                _context7.next = 2;\n                break;\n              }\n              throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);\n            case 2:\n              return _context7.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe(merge.apply(void 0, _toConsumableArray(_this.routers.map(function (router) {\n                return router.getClosestPeers(key, options);\n              }))), function (source) {\n                return storeAddresses(source, _this.components.getPeerStore());\n              }, function (source) {\n                return uniquePeers(source);\n              }, function (source) {\n                return requirePeers(source);\n              })), _awaitAsyncGenerator), \"t0\", 3);\n            case 3:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7);\n      }))();\n    }\n  }]);\n  return DefaultPeerRouting;\n}();","map":{"version":3,"names":["logger","errCode","codes","messages","storeAddresses","uniquePeers","requirePeers","TimeoutController","merge","pipe","first","drain","filter","setDelayedInterval","clearDelayedInterval","setMaxListeners","log","DefaultPeerRouting","components","init","_init$refreshManager","_classCallCheck","routers","refreshManagerInit","refreshManager","started","_findClosestPeersTask","bind","_createClass","key","value","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","length","timeoutId","enabled","abrupt","interval","bootDelay","stop","start","apply","arguments","_findClosestPeersTask2","_callee2","_this$refreshManagerI","_this$abortController","_callee2$","_context2","abortController","timeout","Infinity","signal","_unused","getClosestPeers","getPeerId","toBytes","t0","error","clear","undefined","finish","_stop","_callee3","_this$abortController2","_callee3$","_context3","abort","_findPeer","_callee6","id","options","_this2","output","_callee6$","_context6","Error","ERR_NO_ROUTERS_AVAILABLE","toString","ERR_FIND_SELF","_toConsumableArray","map","router","_wrapAsyncGenerator","_callee4","_callee4$","_context4","_awaitAsyncGenerator","findPeer","sent","source","Boolean","getPeerStore","_ref2","_callee5","_callee5$","_context5","_x3","NOT_FOUND","ERR_NOT_FOUND","_x","_x2","_this","_callee7","_callee7$","_context7","delegateYield","_asyncGeneratorDelegate","_asyncIterator"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/peer-routing.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { codes, messages } from './errors.js'\nimport {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} from './content-routing/utils.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport merge from 'it-merge'\nimport { pipe } from 'it-pipe'\nimport first from 'it-first'\nimport drain from 'it-drain'\nimport filter from 'it-filter'\nimport {\n  setDelayedInterval,\n  clearDelayedInterval\n// @ts-expect-error module with no types\n} from 'set-delayed-interval'\nimport { setMaxListeners } from 'events'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerRouting } from '@libp2p/interface-peer-routing'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Components } from '@libp2p/components'\n\nconst log = logger('libp2p:peer-routing')\n\nexport interface RefreshManagerInit {\n  /**\n   * Whether to enable the Refresh manager\n   */\n  enabled?: boolean\n\n  /**\n   * Boot delay to start the Refresh Manager (in ms)\n   */\n  bootDelay?: number\n\n  /**\n   * Interval between each Refresh Manager run (in ms)\n   */\n  interval?: number\n\n  /**\n   * How long to let each refresh run (in ms)\n   */\n  timeout?: number\n}\n\nexport interface PeerRoutingInit {\n  routers: PeerRouting[]\n  refreshManager?: RefreshManagerInit\n}\n\nexport class DefaultPeerRouting implements PeerRouting, Startable {\n  private readonly components: Components\n  private readonly routers: PeerRouting[]\n  private readonly refreshManagerInit: RefreshManagerInit\n  private timeoutId?: ReturnType<typeof setTimeout>\n  private started: boolean\n  private abortController?: TimeoutController\n\n  constructor (components: Components, init: PeerRoutingInit) {\n    this.components = components\n    this.routers = init.routers\n    this.refreshManagerInit = init.refreshManager ?? {}\n    this.started = false\n\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this)\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * Start peer routing service.\n   */\n  async start () {\n    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {\n      return\n    }\n\n    this.timeoutId = setDelayedInterval(\n      this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay\n    )\n\n    this.started = true\n  }\n\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n  async _findClosestPeersTask () {\n    if (this.abortController != null) {\n      // we are already running the query\n      return\n    }\n\n    try {\n      this.abortController = new TimeoutController(this.refreshManagerInit.timeout ?? 10e3)\n\n      // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning\n      // appearing in the console\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, this.abortController.signal)\n      } catch {}\n\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this.components.getPeerId().toBytes(), { signal: this.abortController.signal }))\n    } catch (err: any) {\n      log.error(err)\n    } finally {\n      this.abortController?.clear()\n      this.abortController = undefined\n    }\n  }\n\n  /**\n   * Stop peer routing service.\n   */\n  async stop () {\n    clearDelayedInterval(this.timeoutId)\n\n    // abort query if it is in-flight\n    this.abortController?.abort()\n\n    this.started = false\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n  async findPeer (id: PeerId, options?: AbortOptions): Promise<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    if (id.toString() === this.components.getPeerId().toString()) {\n      throw errCode(new Error('Should not try to find self'), codes.ERR_FIND_SELF)\n    }\n\n    const output = await pipe(\n      merge(\n        ...this.routers.map(router => (async function * () {\n          try {\n            yield await router.findPeer(id, options)\n          } catch (err) {\n            log.error(err)\n          }\n        })())\n      ),\n      (source) => filter(source, Boolean),\n      (source) => storeAddresses(source, this.components.getPeerStore()),\n      async (source) => await first(source)\n    )\n\n    if (output != null) {\n      return output\n    }\n\n    throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND)\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options?: AbortOptions): AsyncIterable<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.getClosestPeers(key, options))\n      ),\n      (source) => storeAddresses(source, this.components.getPeerStore()),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}