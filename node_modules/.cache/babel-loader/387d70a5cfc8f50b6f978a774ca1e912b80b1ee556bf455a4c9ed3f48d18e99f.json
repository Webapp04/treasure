{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport defer from 'p-defer';\nimport * as Headers from './extract-headers.js';\nimport { lteReader } from './lte-reader.js';\nfunction getPadding(size) {\n  size &= 511;\n  if (size !== 0) {\n    return 512 - size;\n  }\n  return 0;\n}\nfunction discardPadding(_x2, _x3) {\n  return _discardPadding.apply(this, arguments);\n}\nfunction _discardPadding() {\n  _discardPadding = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(reader, size) {\n    var overflow;\n    return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          overflow = getPadding(size);\n          if (!(overflow > 0)) {\n            _context5.next = 4;\n            break;\n          }\n          _context5.next = 4;\n          return reader.next(overflow);\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee4);\n  }));\n  return _discardPadding.apply(this, arguments);\n}\nexport function extract() {\n  var _options$highWaterMar;\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  options.highWaterMark = (_options$highWaterMar = options.highWaterMark) !== null && _options$highWaterMar !== void 0 ? _options$highWaterMar : 1024 * 16;\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n      var reader, gnuLongPath, gnuLongLinkPath, paxGlobal, pax, _loop, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ret;\n      return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            reader = lteReader(source);\n            _context4.prev = 1;\n            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n              var _options$highWaterMar2;\n              var headerBytes, result, header, _yield$_awaitAsyncGen, done, gnuLongPathBytes, _yield$_awaitAsyncGen2, _done, gnuLongLinkPathBytes, _yield$_awaitAsyncGen3, _done2, paxGlobalBytes, _yield$_awaitAsyncGen4, _done3, paxBytes, bytesRemaining, bodyConsumed, firstChunk, body, _;\n              return _regeneratorRuntime().wrap(function _loop$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.prev = 0;\n                    _context3.next = 3;\n                    return _awaitAsyncGenerator(reader.next(512));\n                  case 3:\n                    result = _context3.sent;\n                    if (!(result.done === true)) {\n                      _context3.next = 6;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\", {\n                      v: void 0\n                    });\n                  case 6:\n                    headerBytes = result.value;\n                    _context3.next = 14;\n                    break;\n                  case 9:\n                    _context3.prev = 9;\n                    _context3.t0 = _context3[\"catch\"](0);\n                    if (!(_context3.t0.code === 'ERR_UNDER_READ')) {\n                      _context3.next = 13;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\", {\n                      v: void 0\n                    });\n                  case 13:\n                    throw _context3.t0;\n                  case 14:\n                    header = Headers.decode(headerBytes, options.filenameEncoding);\n                    if (!(header == null)) {\n                      _context3.next = 17;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\", 0);\n                  case 17:\n                    if (!(header.type === 'gnu-long-path')) {\n                      _context3.next = 29;\n                      break;\n                    }\n                    _context3.next = 20;\n                    return _awaitAsyncGenerator(reader.next(header.size));\n                  case 20:\n                    _yield$_awaitAsyncGen = _context3.sent;\n                    done = _yield$_awaitAsyncGen.done;\n                    gnuLongPathBytes = _yield$_awaitAsyncGen.value;\n                    if (!(done === true || gnuLongPathBytes == null)) {\n                      _context3.next = 25;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\", {\n                      v: void 0\n                    });\n                  case 25:\n                    gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding);\n                    _context3.next = 28;\n                    return _awaitAsyncGenerator(discardPadding(reader, header.size));\n                  case 28:\n                    return _context3.abrupt(\"return\", 0);\n                  case 29:\n                    if (!(header.type === 'gnu-long-link-path')) {\n                      _context3.next = 41;\n                      break;\n                    }\n                    _context3.next = 32;\n                    return _awaitAsyncGenerator(reader.next(header.size));\n                  case 32:\n                    _yield$_awaitAsyncGen2 = _context3.sent;\n                    _done = _yield$_awaitAsyncGen2.done;\n                    gnuLongLinkPathBytes = _yield$_awaitAsyncGen2.value;\n                    if (!(_done === true || gnuLongLinkPathBytes == null)) {\n                      _context3.next = 37;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\", {\n                      v: void 0\n                    });\n                  case 37:\n                    gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding);\n                    _context3.next = 40;\n                    return _awaitAsyncGenerator(discardPadding(reader, header.size));\n                  case 40:\n                    return _context3.abrupt(\"return\", 0);\n                  case 41:\n                    if (!(header.type === 'pax-global-header')) {\n                      _context3.next = 53;\n                      break;\n                    }\n                    _context3.next = 44;\n                    return _awaitAsyncGenerator(reader.next(header.size));\n                  case 44:\n                    _yield$_awaitAsyncGen3 = _context3.sent;\n                    _done2 = _yield$_awaitAsyncGen3.done;\n                    paxGlobalBytes = _yield$_awaitAsyncGen3.value;\n                    if (!(_done2 === true || paxGlobalBytes == null)) {\n                      _context3.next = 49;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\", {\n                      v: void 0\n                    });\n                  case 49:\n                    paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding);\n                    _context3.next = 52;\n                    return _awaitAsyncGenerator(discardPadding(reader, header.size));\n                  case 52:\n                    return _context3.abrupt(\"return\", 0);\n                  case 53:\n                    if (!(header.type === 'pax-header')) {\n                      _context3.next = 66;\n                      break;\n                    }\n                    _context3.next = 56;\n                    return _awaitAsyncGenerator(reader.next(header.size));\n                  case 56:\n                    _yield$_awaitAsyncGen4 = _context3.sent;\n                    _done3 = _yield$_awaitAsyncGen4.done;\n                    paxBytes = _yield$_awaitAsyncGen4.value;\n                    if (!(_done3 === true || paxBytes == null)) {\n                      _context3.next = 61;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\", {\n                      v: void 0\n                    });\n                  case 61:\n                    pax = Headers.decodePax(paxBytes, options.filenameEncoding);\n                    if (paxGlobal != null) {\n                      pax = _objectSpread(_objectSpread({}, paxGlobal), pax);\n                    }\n                    _context3.next = 65;\n                    return _awaitAsyncGenerator(discardPadding(reader, header.size));\n                  case 65:\n                    return _context3.abrupt(\"return\", 0);\n                  case 66:\n                    if (gnuLongPath != null) {\n                      header.name = gnuLongPath;\n                      gnuLongPath = null;\n                    }\n                    if (gnuLongLinkPath != null) {\n                      header.linkname = gnuLongLinkPath;\n                      gnuLongLinkPath = null;\n                    }\n                    if (pax != null) {\n                      if (pax.path != null) {\n                        header.name = pax.path;\n                      }\n                      if (pax.linkpath != null) {\n                        header.linkname = pax.linkpath;\n                      }\n                      if (pax.size != null) {\n                        header.size = parseInt(pax.size, 10);\n                      }\n                      header.pax = pax;\n                      pax = null;\n                    }\n                    if (!(header.size == null || header.size === 0 || header.type === 'directory')) {\n                      _context3.next = 73;\n                      break;\n                    }\n                    _context3.next = 72;\n                    return {\n                      header: header,\n                      body: _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                        return _regeneratorRuntime().wrap(function _callee$(_context) {\n                          while (1) switch (_context.prev = _context.next) {\n                            case 0:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }, _callee);\n                      }))()\n                    };\n                  case 72:\n                    return _context3.abrupt(\"return\", 0);\n                  case 73:\n                    bytesRemaining = header.size;\n                    bodyConsumed = defer(); // Prefetch the first chunk.\n                    // This allows us to stream entries for small files from the tar without\n                    // explicitly streaming the body of each.\n                    _context3.next = 77;\n                    return _awaitAsyncGenerator(reader.nextLte(Math.min(bytesRemaining, (_options$highWaterMar2 = options.highWaterMark) !== null && _options$highWaterMar2 !== void 0 ? _options$highWaterMar2 : Infinity)));\n                  case 77:\n                    firstChunk = _context3.sent;\n                    bytesRemaining -= firstChunk.value.length;\n                    if (bytesRemaining === 0) {\n                      bodyConsumed.resolve();\n                    }\n                    body = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                      var _yield$_awaitAsyncGen5, _done4, value;\n                      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                        while (1) switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _context2.prev = 0;\n                            _context2.next = 3;\n                            return firstChunk.value.subarray();\n                          case 3:\n                            if (!(bytesRemaining > 0)) {\n                              _context2.next = 17;\n                              break;\n                            }\n                            _context2.next = 6;\n                            return _awaitAsyncGenerator(reader.nextLte(bytesRemaining));\n                          case 6:\n                            _yield$_awaitAsyncGen5 = _context2.sent;\n                            _done4 = _yield$_awaitAsyncGen5.done;\n                            value = _yield$_awaitAsyncGen5.value;\n                            if (!(_done4 === true)) {\n                              _context2.next = 12;\n                              break;\n                            }\n                            bytesRemaining = 0;\n                            return _context2.abrupt(\"return\");\n                          case 12:\n                            bytesRemaining -= value.length;\n                            _context2.next = 15;\n                            return value.subarray();\n                          case 15:\n                            _context2.next = 3;\n                            break;\n                          case 17:\n                            _context2.prev = 17;\n                            bodyConsumed.resolve();\n                            return _context2.finish(17);\n                          case 20:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }, _callee2, null, [[0,, 17, 20]]);\n                    }))();\n                    _context3.next = 83;\n                    return {\n                      header: header,\n                      body: body\n                    };\n                  case 83:\n                    _context3.next = 85;\n                    return _awaitAsyncGenerator(bodyConsumed.promise);\n                  case 85:\n                    if (!(bytesRemaining > 0)) {\n                      _context3.next = 113;\n                      break;\n                    }\n                    _iteratorAbruptCompletion = false;\n                    _didIteratorError = false;\n                    _context3.prev = 88;\n                    _iterator = _asyncIterator(body);\n                  case 90:\n                    _context3.next = 92;\n                    return _awaitAsyncGenerator(_iterator.next());\n                  case 92:\n                    if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {\n                      _context3.next = 97;\n                      break;\n                    }\n                    _ = _step.value;\n                  case 94:\n                    _iteratorAbruptCompletion = false;\n                    _context3.next = 90;\n                    break;\n                  case 97:\n                    _context3.next = 103;\n                    break;\n                  case 99:\n                    _context3.prev = 99;\n                    _context3.t1 = _context3[\"catch\"](88);\n                    _didIteratorError = true;\n                    _iteratorError = _context3.t1;\n                  case 103:\n                    _context3.prev = 103;\n                    _context3.prev = 104;\n                    if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                      _context3.next = 108;\n                      break;\n                    }\n                    _context3.next = 108;\n                    return _awaitAsyncGenerator(_iterator.return());\n                  case 108:\n                    _context3.prev = 108;\n                    if (!_didIteratorError) {\n                      _context3.next = 111;\n                      break;\n                    }\n                    throw _iteratorError;\n                  case 111:\n                    return _context3.finish(108);\n                  case 112:\n                    return _context3.finish(103);\n                  case 113:\n                    _context3.next = 115;\n                    return _awaitAsyncGenerator(discardPadding(reader, header.size));\n                  case 115:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _loop, null, [[0, 9], [88, 99, 103, 113], [104,, 108, 112]]);\n            });\n          case 3:\n            if (!true) {\n              _context4.next = 12;\n              break;\n            }\n            return _context4.delegateYield(_loop(), \"t0\", 5);\n          case 5:\n            _ret = _context4.t0;\n            if (!(_ret === 0)) {\n              _context4.next = 8;\n              break;\n            }\n            return _context4.abrupt(\"continue\", 3);\n          case 8:\n            if (!_ret) {\n              _context4.next = 10;\n              break;\n            }\n            return _context4.abrupt(\"return\", _ret.v);\n          case 10:\n            _context4.next = 3;\n            break;\n          case 12:\n            _context4.prev = 12;\n            _context4.next = 15;\n            return _awaitAsyncGenerator(reader.return());\n          case 15:\n            return _context4.finish(12);\n          case 16:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee3, null, [[1,, 12, 16]]);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"names":["defer","Headers","lteReader","getPadding","size","discardPadding","_x2","_x3","_discardPadding","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee4","reader","overflow","wrap","_callee4$","_context5","prev","next","stop","extract","_options$highWaterMar","options","length","undefined","highWaterMark","_ref","_wrapAsyncGenerator","_callee3","source","gnuLongPath","gnuLongLinkPath","paxGlobal","pax","_loop","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","_ret","_callee3$","_context4","_options$highWaterMar2","headerBytes","result","header","_yield$_awaitAsyncGen","done","gnuLongPathBytes","_yield$_awaitAsyncGen2","_done","gnuLongLinkPathBytes","_yield$_awaitAsyncGen3","_done2","paxGlobalBytes","_yield$_awaitAsyncGen4","_done3","paxBytes","bytesRemaining","bodyConsumed","firstChunk","body","_","_loop$","_context3","_awaitAsyncGenerator","sent","abrupt","v","value","t0","code","decode","filenameEncoding","type","decodeLongPath","decodePax","_objectSpread","name","linkname","path","linkpath","parseInt","_callee","_callee$","_context","nextLte","Math","min","Infinity","resolve","_callee2","_yield$_awaitAsyncGen5","_done4","_callee2$","_context2","subarray","finish","promise","_asyncIterator","t1","return","delegateYield","_x"],"sources":["/Users/apple/Documents/treasure/node_modules/it-tar/src/extract.ts"],"sourcesContent":["import type { Source, Transform } from 'it-stream-types'\nimport defer from 'p-defer'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { SupportedEncodings } from 'uint8arrays/to-string'\nimport * as Headers from './extract-headers.js'\nimport { lteReader } from './lte-reader.js'\nimport type { LteReader } from './lte-reader.js'\nimport type { TarEntry } from './index.js'\n\nfunction getPadding (size: number) {\n  size &= 511\n\n  if (size !== 0) {\n    return 512 - size\n  }\n\n  return 0\n}\n\nasync function discardPadding (reader: LteReader, size: number) {\n  const overflow = getPadding(size)\n  if (overflow > 0) {\n    await reader.next(overflow)\n  }\n}\n\nexport interface ExtractOptions {\n  highWaterMark?: number\n  filenameEncoding?: SupportedEncodings\n}\n\nexport interface Derp {\n  header: any\n  body: Source<Uint8Array>\n}\n\nexport function extract (options: ExtractOptions = {}): Transform<Uint8Array, TarEntry> {\n  options.highWaterMark = options.highWaterMark ?? 1024 * 16\n\n  return async function * (source: Source<Uint8Array>) { // eslint-disable-line complexity\n    const reader = lteReader(source)\n    let gnuLongPath, gnuLongLinkPath, paxGlobal, pax\n\n    try {\n      while (true) {\n        let headerBytes: Uint8ArrayList\n        try {\n          const result = await reader.next(512)\n\n          if (result.done === true) {\n            return\n          }\n\n          headerBytes = result.value\n        } catch (err: any) {\n          // Is ok, this is the end of the stream!\n          if (err.code === 'ERR_UNDER_READ') {\n            return\n          }\n\n          throw err\n        }\n\n        const header = Headers.decode(headerBytes, options.filenameEncoding)\n        if (header == null) {\n          continue\n        }\n\n        if (header.type === 'gnu-long-path') {\n          const { done, value: gnuLongPathBytes } = await reader.next(header.size)\n          if (done === true || gnuLongPathBytes == null) {\n            return\n          }\n          gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'gnu-long-link-path') {\n          const { done, value: gnuLongLinkPathBytes } = await reader.next(header.size)\n          if (done === true || gnuLongLinkPathBytes == null) {\n            return\n          }\n          gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-global-header') {\n          const { done, value: paxGlobalBytes } = await reader.next(header.size)\n          if (done === true || paxGlobalBytes == null) {\n            return\n          }\n          paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-header') {\n          const { done, value: paxBytes } = await reader.next(header.size)\n          if (done === true || paxBytes == null) {\n            return\n          }\n          pax = Headers.decodePax(paxBytes, options.filenameEncoding)\n          if (paxGlobal != null) {\n            pax = { ...paxGlobal, ...pax }\n          }\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (gnuLongPath != null) {\n          header.name = gnuLongPath\n          gnuLongPath = null\n        }\n\n        if (gnuLongLinkPath != null) {\n          header.linkname = gnuLongLinkPath\n          gnuLongLinkPath = null\n        }\n\n        if (pax != null) {\n          if (pax.path != null) {\n            header.name = pax.path\n          }\n\n          if (pax.linkpath != null) {\n            header.linkname = pax.linkpath\n          }\n\n          if (pax.size != null) {\n            header.size = parseInt(pax.size, 10)\n          }\n\n          header.pax = pax\n          pax = null\n        }\n\n        if (header.size == null || header.size === 0 || header.type === 'directory') {\n          yield { header, body: (async function * () {})() }\n          continue\n        }\n\n        let bytesRemaining = header.size\n        const bodyConsumed = defer()\n\n        // Prefetch the first chunk.\n        // This allows us to stream entries for small files from the tar without\n        // explicitly streaming the body of each.\n        const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark ?? Infinity))\n        bytesRemaining -= firstChunk.value.length\n\n        if (bytesRemaining === 0) {\n          bodyConsumed.resolve()\n        }\n\n        const body: AsyncIterable<Uint8Array> = (async function * () {\n          try {\n            yield firstChunk.value.subarray()\n\n            while (bytesRemaining > 0) {\n              const { done, value } = await reader.nextLte(bytesRemaining)\n\n              if (done === true) {\n                bytesRemaining = 0\n                return\n              }\n\n              bytesRemaining -= value.length\n\n              yield value.subarray()\n            }\n          } finally {\n            bodyConsumed.resolve()\n          }\n        })()\n\n        yield { header, body }\n\n        // Wait for the body to be consumed\n        await bodyConsumed.promise\n\n        // In case the body was not consumed entirely...\n        if (bytesRemaining > 0) {\n          for await (const _ of body) {} // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n        }\n\n        await discardPadding(reader, header.size)\n      }\n    } finally {\n      await reader.return()\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}