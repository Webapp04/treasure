{"ast":null,"code":"import _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { abortableSource } from 'abortable-iterator';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:stream:converter');\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\nexport function streamToMaConnection(props) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var stream = props.stream,\n    remoteAddr = props.remoteAddr;\n  var _sink = stream.sink,\n    source = stream.source;\n  var mapSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, list;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 2;\n          _iterator = _asyncIterator(source);\n        case 4:\n          _context.next = 6;\n          return _awaitAsyncGenerator(_iterator.next());\n        case 6:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 12;\n            break;\n          }\n          list = _step.value;\n          return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(list), _awaitAsyncGenerator), \"t0\", 9);\n        case 9:\n          _iteratorAbruptCompletion = false;\n          _context.next = 4;\n          break;\n        case 12:\n          _context.next = 18;\n          break;\n        case 14:\n          _context.prev = 14;\n          _context.t1 = _context[\"catch\"](2);\n          _didIteratorError = true;\n          _iteratorError = _context.t1;\n        case 18:\n          _context.prev = 18;\n          _context.prev = 19;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context.next = 23;\n            break;\n          }\n          _context.next = 23;\n          return _awaitAsyncGenerator(_iterator.return());\n        case 23:\n          _context.prev = 23;\n          if (!_didIteratorError) {\n            _context.next = 26;\n            break;\n          }\n          throw _iteratorError;\n        case 26:\n          return _context.finish(23);\n        case 27:\n          return _context.finish(18);\n        case 28:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2, 14, 18, 28], [19,, 23, 27]]);\n  }))();\n  var maConn = {\n    sink: function sink(source) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (options.signal != null) {\n                source = abortableSource(source, options.signal);\n              }\n              _context2.prev = 1;\n              _context2.next = 4;\n              return _sink(source);\n            case 4:\n              _context2.next = 6;\n              return _close();\n            case 6:\n              _context2.next = 11;\n              break;\n            case 8:\n              _context2.prev = 8;\n              _context2.t0 = _context2[\"catch\"](1);\n              // If aborted we can safely ignore\n              if (_context2.t0.type !== 'aborted') {\n                // If the source errored the socket will already have been destroyed by\n                // toIterable.duplex(). If the socket errored it will already be\n                // destroyed. There's nothing to do here except log the error & return.\n                log(_context2.t0);\n              }\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[1, 8]]);\n      }))();\n    },\n    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,\n    remoteAddr: remoteAddr,\n    /** @type {Timeline} */\n    timeline: {\n      open: Date.now(),\n      close: undefined\n    },\n    close: function close() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _sink(_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      _context3.next = 2;\n                      return new Uint8Array(0);\n                    case 2:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3);\n              }))());\n            case 2:\n              _context4.next = 4;\n              return _close();\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }))();\n    }\n  };\n  function _close() {\n    return _close2.apply(this, arguments);\n  }\n  function _close2() {\n    _close2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            if (maConn.timeline.close == null) {\n              maConn.timeline.close = Date.now();\n            }\n            _context5.next = 3;\n            return Promise.resolve();\n          case 3:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return _close2.apply(this, arguments);\n  }\n  return maConn;\n}","map":{"version":3,"names":["abortableSource","logger","log","streamToMaConnection","props","options","arguments","length","undefined","stream","remoteAddr","sink","source","mapSource","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","list","wrap","_callee$","_context","prev","next","_asyncIterator","_awaitAsyncGenerator","sent","done","value","delegateYield","_asyncGeneratorDelegate","t1","return","finish","stop","maConn","_asyncToGenerator","_callee2","_callee2$","_context2","signal","close","t0","type","timeline","open","Date","now","_callee4","_callee4$","_context4","_callee3","_callee3$","_context3","Uint8Array","_close2","apply","_callee5","_callee5$","_context5","Promise","resolve","abrupt"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/utils/src/stream-to-ma-conn.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { logger } from '@libp2p/logger'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Duplex } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:stream:converter')\n\nexport interface Timeline {\n  /**\n   * Connection opening timestamp\n   */\n  open: number\n\n  /**\n   * Connection upgraded timestamp\n   */\n  upgraded?: number\n\n  /**\n   * Connection closed timestamp\n   */\n  close?: number\n}\n\nexport interface StreamOptions {\n  signal?: AbortSignal\n\n}\n\nexport interface StreamProperties {\n  stream: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>\n  remoteAddr: Multiaddr\n  localAddr: Multiaddr\n}\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\nexport function streamToMaConnection (props: StreamProperties, options: StreamOptions = {}) {\n  const { stream, remoteAddr } = props\n  const { sink, source } = stream\n\n  const mapSource = (async function * () {\n    for await (const list of source) {\n      yield * list\n    }\n  }())\n\n  const maConn: MultiaddrConnection = {\n    async sink (source) {\n      if (options.signal != null) {\n        source = abortableSource(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n        await close()\n      } catch (err: any) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err)\n        }\n      }\n    },\n    source: (options.signal != null) ? abortableSource(mapSource, options.signal) : mapSource,\n    remoteAddr,\n    /** @type {Timeline} */\n    timeline: { open: Date.now(), close: undefined },\n    async close () {\n      await sink(async function * () {\n        yield new Uint8Array(0)\n      }())\n      await close()\n    }\n  }\n\n  async function close () {\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n    return await Promise.resolve()\n  }\n\n  return maConn\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}