{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { connect } from 'socket.io-client';\nimport pDefer from 'p-defer';\nimport { WebRTCReceiver } from '@libp2p/webrtc-peer';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanUrlSIO } from './utils.js';\nimport { CODE_P2P } from './constants.js';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nvar log = logger('libp2p:webrtc-star:listener');\nvar sioOptions = {\n  transports: ['websocket'],\n  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n};\nvar SigServer = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SigServer, _EventEmitter);\n  var _super = _createSuper(SigServer);\n  function SigServer(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {\n    var _this;\n    _classCallCheck(this, SigServer);\n    _this = _super.call(this);\n    _this.signallingAddr = signallingAddr;\n    _this.socket = connect(signallingUrl, sioOptions);\n    _this.connections = [];\n    _this.channels = new Map();\n    _this.pendingSignals = new Map();\n    _this.upgrader = upgrader;\n    _this.handler = handler;\n    _this.channelOptions = channelOptions;\n    _this.handleWsHandshake = _this.handleWsHandshake.bind(_assertThisInitialized(_this));\n    var previouslyConnected = false;\n    _this.socket.on('connect_error', function (err) {\n      // @ts-expect-error `.type` is missing from the types\n      if (previouslyConnected && err.type === 'TransportError') {\n        // if we've had an open connection before, and this is a\n        // transport error, let socket.io's reconnect logic take over\n        return;\n      }\n      _this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }));\n    });\n    _this.socket.on('error', function (err) {\n      _this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }));\n    });\n    _this.socket.on('ws-handshake', _this.handleWsHandshake);\n    _this.socket.on('ws-peer', function (maStr) {\n      _this.dispatchEvent(new CustomEvent('peer', {\n        detail: maStr\n      }));\n    });\n    _this.socket.on('connect', function () {\n      _this.socket.emit('ss-join', _this.signallingAddr.toString());\n      if (previouslyConnected) {\n        _this.dispatchEvent(new CustomEvent('reconnect'));\n      }\n    });\n    _this.socket.once('connect', function () {\n      // make sure we can reconnect in future\n      previouslyConnected = true;\n      _this.dispatchEvent(new CustomEvent('listening'));\n    });\n    _this.socket.on('disconnect', function () {\n      _this.dispatchEvent(new CustomEvent('disconnect'));\n    });\n    return _this;\n  }\n  _createClass(SigServer, [{\n    key: \"_createChannel\",\n    value: function _createChannel(intentId, srcMultiaddr, dstMultiaddr) {\n      var _this2 = this;\n      var channelOptions = _objectSpread({}, this.channelOptions);\n      var channel = new WebRTCReceiver(channelOptions);\n      var onError = function onError(evt) {\n        var err = evt.detail;\n        log.error('incoming connection errored', err);\n      };\n      channel.addEventListener('error', onError);\n      channel.addEventListener('close', function () {\n        channel.removeEventListener('error', onError);\n      }, {\n        once: true\n      });\n      channel.addEventListener('signal', function (evt) {\n        var signal = evt.detail;\n        _this2.socket.emit('ss-handshake', {\n          intentId: intentId,\n          srcMultiaddr: srcMultiaddr,\n          dstMultiaddr: dstMultiaddr,\n          answer: true,\n          signal: signal\n        });\n      });\n      channel.addEventListener('ready', function () {\n        var maConn = toMultiaddrConnection(channel, {\n          remoteAddr: _this2.signallingAddr\n        });\n        log('new inbound connection %s', maConn.remoteAddr);\n        try {\n          _this2.upgrader.upgradeInbound(maConn).then(function (conn) {\n            log('inbound connection %s upgraded', maConn.remoteAddr);\n            _this2.connections.push(maConn);\n            var untrackConn = function untrackConn() {\n              _this2.connections = _this2.connections.filter(function (c) {\n                return c !== maConn;\n              });\n              _this2.channels.delete(intentId);\n              _this2.pendingSignals.delete(intentId);\n            };\n            channel.addEventListener('close', untrackConn, {\n              once: true\n            });\n            _this2.dispatchEvent(new CustomEvent('connection', {\n              detail: conn\n            }));\n            _this2.handler(conn);\n          }).catch(function (err) {\n            log.error('inbound connection failed to upgrade', err);\n            maConn.close().catch(function (err) {\n              log.error('inbound connection failed to close after failing to upgrade', err);\n            });\n          });\n        } catch (err) {\n          log.error('inbound connection failed to upgrade', err);\n          maConn.close().catch(function (err) {\n            log.error('inbound connection failed to close after failing to upgrade', err);\n          });\n        }\n      }, {\n        once: true\n      });\n      return channel;\n    }\n  }, {\n    key: \"handleWsHandshake\",\n    value: function handleWsHandshake(offer) {\n      log('incoming handshake. signal type \"%s\" is answer %s', offer.signal.type, offer.answer);\n      if (offer.answer === true || offer.err != null || offer.intentId == null) {\n        return;\n      }\n      var intentId = offer.intentId;\n      var pendingSignals = this.pendingSignals.get(intentId);\n      if (pendingSignals == null) {\n        pendingSignals = [];\n        this.pendingSignals.set(intentId, pendingSignals);\n      }\n      pendingSignals.push(offer);\n      var channel = this.channels.get(intentId);\n      if (channel == null) {\n        if (offer.signal.type !== 'offer') {\n          log('handshake is not an offer and channel does not exist, buffering until we receive an offer');\n          return;\n        }\n        log('creating new channel to handle offer handshake');\n        channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);\n        this.channels.set(intentId, channel);\n      } else {\n        log('channel already exists, using it to handle handshake');\n      }\n      while (pendingSignals.length > 0) {\n        var handshake = pendingSignals.shift();\n        if ((handshake === null || handshake === void 0 ? void 0 : handshake.signal) != null) {\n          channel.handleSignal(handshake.signal);\n        }\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // Close listener\n              this.socket.emit('ss-leave', this.signallingAddr.toString());\n              this.socket.removeAllListeners();\n              this.socket.close();\n              _context3.next = 5;\n              return Promise.all([].concat(_toConsumableArray(this.connections.map( /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(maConn) {\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return maConn.close();\n                      case 2:\n                        return _context.abrupt(\"return\", _context.sent);\n                      case 3:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee);\n                }));\n                return function (_x) {\n                  return _ref.apply(this, arguments);\n                };\n              }())), _toConsumableArray(Array.from(this.channels.values()).map( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(channel) {\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return channel.close();\n                      case 2:\n                        return _context2.abrupt(\"return\", _context2.sent);\n                      case 3:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2);\n                }));\n                return function (_x2) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()))));\n            case 5:\n              this.dispatchEvent(new CustomEvent('close'));\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n  }]);\n  return SigServer;\n}(EventEmitter);\nvar WebRTCListener = /*#__PURE__*/function (_EventEmitter2) {\n  _inherits(WebRTCListener, _EventEmitter2);\n  var _super2 = _createSuper(WebRTCListener);\n  function WebRTCListener(upgrader, handler, peerId, transport, options) {\n    var _this3;\n    _classCallCheck(this, WebRTCListener);\n    _this3 = _super2.call(this);\n    _this3.upgrader = upgrader;\n    _this3.handler = handler;\n    _this3.peerId = peerId;\n    _this3.transport = transport;\n    _this3.options = options;\n    return _this3;\n  }\n  _createClass(WebRTCListener, [{\n    key: \"listen\",\n    value: function () {\n      var _listen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ma) {\n        var _this4 = this;\n        var defer, signallingAddr, signallingUrl, server;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(this.listeningAddr != null)) {\n                _context4.next = 2;\n                break;\n              }\n              throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');\n            case 2:\n              defer = pDefer(); // eslint-disable-line @typescript-eslint/no-invalid-void-type\n              // Should be kept unmodified\n              this.listeningAddr = ma;\n              if (!ma.protoCodes().includes(CODE_P2P)) {\n                signallingAddr = ma.encapsulate(\"/p2p/\".concat(this.peerId.toString()));\n              } else {\n                signallingAddr = ma;\n              }\n              signallingUrl = this.signallingUrl = cleanUrlSIO(ma);\n              log('connecting to signalling server on: %s', this.signallingUrl);\n              server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);\n              server.addEventListener('error', function (evt) {\n                var err = evt.detail;\n                log('error connecting to signalling server %o', err);\n                server.close().catch(function (err) {\n                  log.error('error closing server after error', err);\n                });\n                defer.reject(err);\n              });\n              server.addEventListener('listening', function () {\n                log('connected to signalling server');\n                _this4.dispatchEvent(new CustomEvent('listening'));\n                defer.resolve();\n              });\n              server.addEventListener('peer', function (evt) {\n                _this4.transport.peerDiscovered(evt.detail);\n              });\n              server.addEventListener('connection', function (evt) {\n                var conn = evt.detail;\n                if (conn.remoteAddr == null) {\n                  try {\n                    conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(\"/p2p/\".concat(conn.remotePeer.toString()));\n                  } catch (err) {\n                    log.error('could not determine remote address', err);\n                  }\n                }\n                _this4.dispatchEvent(new CustomEvent('connection', {\n                  detail: conn\n                }));\n              });\n              server.addEventListener('disconnect', function () {\n                // Ensure we error if we try to dial while we are disconnected from\n                // the signalling server\n                _this4.transport.sigServers.delete(signallingUrl);\n              });\n              server.addEventListener('reconnect', function () {\n                // We can dial via the signalling server again\n                _this4.transport.sigServers.set(signallingUrl, server);\n              });\n              // Store listen and signal reference addresses\n              this.transport.sigServers.set(this.signallingUrl, server);\n              _context4.next = 17;\n              return defer.promise;\n            case 17:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 18:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function listen(_x3) {\n        return _listen.apply(this, arguments);\n      }\n      return listen;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var server;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(this.signallingUrl != null)) {\n                _context5.next = 6;\n                break;\n              }\n              server = this.transport.sigServers.get(this.signallingUrl);\n              if (!(server != null)) {\n                _context5.next = 6;\n                break;\n              }\n              _context5.next = 5;\n              return server.close();\n            case 5:\n              this.transport.sigServers.delete(this.signallingUrl);\n            case 6:\n              this.dispatchEvent(new CustomEvent('close'));\n              // Reset state\n              this.listeningAddr = undefined;\n            case 8:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function close() {\n        return _close2.apply(this, arguments);\n      }\n      return close;\n    }()\n  }, {\n    key: \"getAddrs\",\n    value: function getAddrs() {\n      if (this.listeningAddr != null) {\n        return [this.listeningAddr];\n      }\n      return [];\n    }\n  }]);\n  return WebRTCListener;\n}(EventEmitter);\nexport function createListener(upgrader, handler, peerId, transport, options) {\n  return new WebRTCListener(upgrader, handler, peerId, transport, options);\n}","map":{"version":3,"names":["logger","errCode","connect","pDefer","WebRTCReceiver","toMultiaddrConnection","cleanUrlSIO","CODE_P2P","EventEmitter","CustomEvent","log","sioOptions","transports","path","SigServer","_EventEmitter","_inherits","_super","_createSuper","signallingUrl","signallingAddr","upgrader","handler","channelOptions","_this","_classCallCheck","call","socket","connections","channels","Map","pendingSignals","handleWsHandshake","bind","_assertThisInitialized","previouslyConnected","on","err","type","dispatchEvent","detail","maStr","emit","toString","once","_createClass","key","value","_createChannel","intentId","srcMultiaddr","dstMultiaddr","_this2","_objectSpread","channel","onError","evt","error","addEventListener","removeEventListener","signal","answer","maConn","remoteAddr","upgradeInbound","then","conn","push","untrackConn","filter","c","delete","catch","close","offer","get","set","length","handshake","shift","handleSignal","_close","_asyncToGenerator","_regeneratorRuntime","mark","_callee3","wrap","_callee3$","_context3","prev","next","removeAllListeners","Promise","all","concat","_toConsumableArray","map","_ref","_callee","_callee$","_context","abrupt","sent","stop","_x","apply","arguments","Array","from","values","_ref2","_callee2","_callee2$","_context2","_x2","WebRTCListener","_EventEmitter2","_super2","peerId","transport","options","_this3","_listen","_callee4","ma","_this4","defer","server","_callee4$","_context4","listeningAddr","Error","protoCodes","includes","encapsulate","reject","resolve","peerDiscovered","decapsulateCode","remotePeer","sigServers","promise","listen","_x3","_close2","_callee5","_callee5$","_context5","undefined","getAddrs","createListener"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/webrtc-star/src/listener.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { connect, ManagerOptions, SocketOptions } from 'socket.io-client'\nimport pDefer from 'p-defer'\nimport { WebRTCReceiver } from '@libp2p/webrtc-peer'\nimport { toMultiaddrConnection } from './socket-to-conn.js'\nimport { cleanUrlSIO } from './utils.js'\nimport { CODE_P2P } from './constants.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Upgrader, ConnectionHandler, Listener, ListenerEvents } from '@libp2p/interface-transport'\nimport type { WebRTCStar, WebRTCStarListenerOptions, SignalServer, SignalServerServerEvents } from './index.js'\nimport type { WebRTCReceiverInit } from '@libp2p/webrtc-peer'\nimport type { WebRTCStarSocket, HandshakeSignal } from '@libp2p/webrtc-star-protocol'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\n\nconst log = logger('libp2p:webrtc-star:listener')\n\nconst sioOptions: Partial<ManagerOptions & SocketOptions> = {\n  transports: ['websocket'],\n  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n}\n\nclass SigServer extends EventEmitter<SignalServerServerEvents> implements SignalServer {\n  public signallingAddr: Multiaddr\n  public socket: WebRTCStarSocket\n  public connections: MultiaddrConnection[]\n  public channels: Map<string, WebRTCReceiver>\n  public pendingSignals: Map<string, HandshakeSignal[]>\n\n  private readonly upgrader: Upgrader\n  private readonly handler: ConnectionHandler\n  private readonly channelOptions?: WebRTCReceiverInit\n\n  constructor (signallingUrl: string, signallingAddr: Multiaddr, upgrader: Upgrader, handler: ConnectionHandler, channelOptions?: WebRTCReceiverInit) {\n    super()\n\n    this.signallingAddr = signallingAddr\n    this.socket = connect(signallingUrl, sioOptions)\n    this.connections = []\n    this.channels = new Map()\n    this.pendingSignals = new Map()\n\n    this.upgrader = upgrader\n    this.handler = handler\n    this.channelOptions = channelOptions\n\n    this.handleWsHandshake = this.handleWsHandshake.bind(this)\n\n    let previouslyConnected = false\n\n    this.socket.on('connect_error', err => {\n      // @ts-expect-error `.type` is missing from the types\n      if (previouslyConnected && err.type === 'TransportError') {\n        // if we've had an open connection before, and this is a\n        // transport error, let socket.io's reconnect logic take over\n        return\n      }\n\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }))\n    })\n    this.socket.on('error', (err: Error) => {\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }))\n    })\n    this.socket.on('ws-handshake', this.handleWsHandshake)\n    this.socket.on('ws-peer', (maStr) => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: maStr\n      }))\n    })\n    this.socket.on('connect', () => {\n      this.socket.emit('ss-join', this.signallingAddr.toString())\n\n      if (previouslyConnected) {\n        this.dispatchEvent(new CustomEvent('reconnect'))\n      }\n    })\n    this.socket.once('connect', () => {\n      // make sure we can reconnect in future\n      previouslyConnected = true\n      this.dispatchEvent(new CustomEvent('listening'))\n    })\n    this.socket.on('disconnect', () => {\n      this.dispatchEvent(new CustomEvent('disconnect'))\n    })\n  }\n\n  _createChannel (intentId: string, srcMultiaddr: string, dstMultiaddr: string) {\n    const channelOptions: WebRTCReceiverInit = {\n      ...this.channelOptions\n    }\n\n    const channel = new WebRTCReceiver(channelOptions)\n\n    const onError = (evt: CustomEvent<Error>) => {\n      const err = evt.detail\n\n      log.error('incoming connection errored', err)\n    }\n\n    channel.addEventListener('error', onError)\n    channel.addEventListener('close', () => {\n      channel.removeEventListener('error', onError)\n    }, {\n      once: true\n    })\n\n    channel.addEventListener('signal', (evt) => {\n      const signal = evt.detail\n\n      this.socket.emit('ss-handshake', {\n        intentId,\n        srcMultiaddr,\n        dstMultiaddr,\n        answer: true,\n        signal\n      })\n    })\n\n    channel.addEventListener('ready', () => {\n      const maConn = toMultiaddrConnection(channel, { remoteAddr: this.signallingAddr })\n      log('new inbound connection %s', maConn.remoteAddr)\n\n      try {\n        this.upgrader.upgradeInbound(maConn)\n          .then(conn => {\n            log('inbound connection %s upgraded', maConn.remoteAddr)\n\n            this.connections.push(maConn)\n\n            const untrackConn = () => {\n              this.connections = this.connections.filter(c => c !== maConn)\n              this.channels.delete(intentId)\n              this.pendingSignals.delete(intentId)\n            }\n\n            channel.addEventListener('close', untrackConn, {\n              once: true\n            })\n\n            this.dispatchEvent(new CustomEvent('connection', {\n              detail: conn\n            }))\n            this.handler(conn)\n          })\n          .catch(err => {\n            log.error('inbound connection failed to upgrade', err)\n            maConn.close().catch(err => {\n              log.error('inbound connection failed to close after failing to upgrade', err)\n            })\n          })\n      } catch (err: any) {\n        log.error('inbound connection failed to upgrade', err)\n        maConn.close().catch(err => {\n          log.error('inbound connection failed to close after failing to upgrade', err)\n        })\n      }\n    }, {\n      once: true\n    })\n\n    return channel\n  }\n\n  handleWsHandshake (offer: HandshakeSignal) {\n    log('incoming handshake. signal type \"%s\" is answer %s', offer.signal.type, offer.answer)\n\n    if (offer.answer === true || offer.err != null || offer.intentId == null) {\n      return\n    }\n\n    const intentId = offer.intentId\n    let pendingSignals = this.pendingSignals.get(intentId)\n\n    if (pendingSignals == null) {\n      pendingSignals = []\n      this.pendingSignals.set(intentId, pendingSignals)\n    }\n\n    pendingSignals.push(offer)\n\n    let channel = this.channels.get(intentId)\n\n    if (channel == null) {\n      if (offer.signal.type !== 'offer') {\n        log('handshake is not an offer and channel does not exist, buffering until we receive an offer')\n        return\n      }\n\n      log('creating new channel to handle offer handshake')\n      channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr)\n      this.channels.set(intentId, channel)\n    } else {\n      log('channel already exists, using it to handle handshake')\n    }\n\n    while (pendingSignals.length > 0) {\n      const handshake = pendingSignals.shift()\n\n      if (handshake?.signal != null) {\n        channel.handleSignal(handshake.signal)\n      }\n    }\n  }\n\n  async close () {\n    // Close listener\n    this.socket.emit('ss-leave', this.signallingAddr.toString())\n    this.socket.removeAllListeners()\n    this.socket.close()\n\n    await Promise.all([\n      ...this.connections.map(async maConn => await maConn.close()),\n      ...Array.from(this.channels.values()).map(async channel => await channel.close())\n    ])\n\n    this.dispatchEvent(new CustomEvent('close'))\n  }\n}\n\nclass WebRTCListener extends EventEmitter<ListenerEvents> implements Listener {\n  private listeningAddr?: Multiaddr\n  private signallingUrl?: string\n  private readonly upgrader: Upgrader\n  private readonly handler: ConnectionHandler\n  private readonly peerId: PeerId\n  private readonly transport: WebRTCStar\n  private readonly options: WebRTCStarListenerOptions\n\n  constructor (upgrader: Upgrader, handler: ConnectionHandler, peerId: PeerId, transport: WebRTCStar, options: WebRTCStarListenerOptions) {\n    super()\n\n    this.upgrader = upgrader\n    this.handler = handler\n    this.peerId = peerId\n    this.transport = transport\n    this.options = options\n  }\n\n  async listen (ma: Multiaddr) {\n    // Should only be used if not already listening\n    if (this.listeningAddr != null) {\n      throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING')\n    }\n\n    const defer = pDefer<void>() // eslint-disable-line @typescript-eslint/no-invalid-void-type\n\n    // Should be kept unmodified\n    this.listeningAddr = ma\n\n    let signallingAddr: Multiaddr\n    if (!ma.protoCodes().includes(CODE_P2P)) {\n      signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`)\n    } else {\n      signallingAddr = ma\n    }\n\n    const signallingUrl = this.signallingUrl = cleanUrlSIO(ma)\n\n    log('connecting to signalling server on: %s', this.signallingUrl)\n    const server: SignalServer = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions)\n    server.addEventListener('error', (evt) => {\n      const err = evt.detail\n\n      log('error connecting to signalling server %o', err)\n      server.close().catch(err => {\n        log.error('error closing server after error', err)\n      })\n      defer.reject(err)\n    })\n    server.addEventListener('listening', () => {\n      log('connected to signalling server')\n      this.dispatchEvent(new CustomEvent('listening'))\n      defer.resolve()\n    })\n    server.addEventListener('peer', (evt) => {\n      this.transport.peerDiscovered(evt.detail)\n    })\n    server.addEventListener('connection', (evt) => {\n      const conn = evt.detail\n\n      if (conn.remoteAddr == null) {\n        try {\n          conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`)\n        } catch (err) {\n          log.error('could not determine remote address', err)\n        }\n      }\n\n      this.dispatchEvent(new CustomEvent('connection', {\n        detail: conn\n      }))\n    })\n    server.addEventListener('disconnect', () => {\n      // Ensure we error if we try to dial while we are disconnected from\n      // the signalling server\n      this.transport.sigServers.delete(signallingUrl)\n    })\n    server.addEventListener('reconnect', () => {\n      // We can dial via the signalling server again\n      this.transport.sigServers.set(signallingUrl, server)\n    })\n\n    // Store listen and signal reference addresses\n    this.transport.sigServers.set(this.signallingUrl, server)\n\n    return await defer.promise\n  }\n\n  async close () {\n    if (this.signallingUrl != null) {\n      const server = this.transport.sigServers.get(this.signallingUrl)\n\n      if (server != null) {\n        await server.close()\n        this.transport.sigServers.delete(this.signallingUrl)\n      }\n    }\n\n    this.dispatchEvent(new CustomEvent('close'))\n\n    // Reset state\n    this.listeningAddr = undefined\n  }\n\n  getAddrs () {\n    if (this.listeningAddr != null) {\n      return [\n        this.listeningAddr\n      ]\n    }\n\n    return []\n  }\n}\n\nexport function createListener (upgrader: Upgrader, handler: ConnectionHandler, peerId: PeerId, transport: WebRTCStar, options: WebRTCStarListenerOptions) {\n  return new WebRTCListener(upgrader, handler, peerId, transport, options)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}