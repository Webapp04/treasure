{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { codes } from './errors.js';\nimport { PeerRecord, RecordEnvelope } from '@libp2p/peer-record';\nimport { pipe } from 'it-pipe';\nimport all from 'it-all';\nimport filter from 'it-filter';\nimport map from 'it-map';\nimport each from 'it-foreach';\nimport { peerIdFromPeerId } from '@libp2p/peer-id';\nimport { CustomEvent } from '@libp2p/interfaces/events';\nvar log = logger('libp2p:peer-store:address-book');\nvar EVENT_NAME = 'change:multiaddrs';\nfunction allowAll() {\n  return _allowAll.apply(this, arguments);\n}\nfunction _allowAll() {\n  _allowAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          return _context8.abrupt(\"return\", true);\n        case 1:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return _allowAll.apply(this, arguments);\n}\nexport var PeerStoreAddressBook = /*#__PURE__*/function () {\n  function PeerStoreAddressBook(dispatchEvent, store, addressFilter) {\n    _classCallCheck(this, PeerStoreAddressBook);\n    this.dispatchEvent = dispatchEvent;\n    this.store = store;\n    this.addressFilter = addressFilter !== null && addressFilter !== void 0 ? addressFilter : allowAll;\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   */\n  _createClass(PeerStoreAddressBook, [{\n    key: \"consumePeerRecord\",\n    value: function () {\n      var _consumePeerRecord = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(envelope) {\n        var release, peerId, peer, updatedPeer, peerRecord, multiaddrs, storedEnvelope, storedRecord, addresses;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              log.trace('consumePeerRecord await write lock');\n              _context.next = 3;\n              return this.store.lock.writeLock();\n            case 3:\n              release = _context.sent;\n              log.trace('consumePeerRecord got write lock');\n              _context.prev = 5;\n              _context.prev = 6;\n              peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n              _context.next = 14;\n              break;\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](6);\n              log.error('invalid peer record received');\n              return _context.abrupt(\"return\", false);\n            case 14:\n              peerId = peerRecord.peerId;\n              multiaddrs = peerRecord.multiaddrs; // Verify peerId\n              if (peerId.equals(envelope.peerId)) {\n                _context.next = 19;\n                break;\n              }\n              log('signing key does not match PeerId in the PeerRecord');\n              return _context.abrupt(\"return\", false);\n            case 19:\n              if (!(multiaddrs == null || multiaddrs.length === 0)) {\n                _context.next = 21;\n                break;\n              }\n              return _context.abrupt(\"return\", false);\n            case 21:\n              _context.next = 23;\n              return this.store.has(peerId);\n            case 23:\n              if (!_context.sent) {\n                _context.next = 35;\n                break;\n              }\n              _context.next = 26;\n              return this.store.load(peerId);\n            case 26:\n              peer = _context.sent;\n              if (!(peer.peerRecordEnvelope != null)) {\n                _context.next = 35;\n                break;\n              }\n              _context.next = 30;\n              return RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);\n            case 30:\n              storedEnvelope = _context.sent;\n              storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload); // ensure seq is greater than, or equal to, the last received\n              if (!(storedRecord.seqNumber >= peerRecord.seqNumber)) {\n                _context.next = 35;\n                break;\n              }\n              log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber);\n              return _context.abrupt(\"return\", false);\n            case 35:\n              _context.next = 37;\n              return filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true);\n            case 37:\n              addresses = _context.sent;\n              _context.next = 40;\n              return this.store.patchOrCreate(peerId, {\n                addresses: addresses,\n                peerRecordEnvelope: envelope.marshal().subarray()\n              });\n            case 40:\n              updatedPeer = _context.sent;\n              log('stored provided peer record for %p', peerRecord.peerId);\n            case 42:\n              _context.prev = 42;\n              log.trace('consumePeerRecord release write lock');\n              release();\n              return _context.finish(42);\n            case 46:\n              this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n                detail: {\n                  peerId: peerId,\n                  multiaddrs: updatedPeer.addresses.map(function (_ref) {\n                    var multiaddr = _ref.multiaddr;\n                    return multiaddr;\n                  }),\n                  oldMultiaddrs: peer == null ? [] : peer.addresses.map(function (_ref2) {\n                    var multiaddr = _ref2.multiaddr;\n                    return multiaddr;\n                  })\n                }\n              }));\n              return _context.abrupt(\"return\", true);\n            case 48:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[5,, 42, 46], [6, 10]]);\n      }));\n      function consumePeerRecord(_x) {\n        return _consumePeerRecord.apply(this, arguments);\n      }\n      return consumePeerRecord;\n    }()\n  }, {\n    key: \"getRawEnvelope\",\n    value: function () {\n      var _getRawEnvelope = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId) {\n        var release, peer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              log.trace('getRawEnvelope await read lock');\n              _context2.next = 3;\n              return this.store.lock.readLock();\n            case 3:\n              release = _context2.sent;\n              log.trace('getRawEnvelope got read lock');\n              _context2.prev = 5;\n              _context2.next = 8;\n              return this.store.load(peerId);\n            case 8:\n              peer = _context2.sent;\n              return _context2.abrupt(\"return\", peer.peerRecordEnvelope);\n            case 12:\n              _context2.prev = 12;\n              _context2.t0 = _context2[\"catch\"](5);\n              if (!(_context2.t0.code !== codes.ERR_NOT_FOUND)) {\n                _context2.next = 16;\n                break;\n              }\n              throw _context2.t0;\n            case 16:\n              _context2.prev = 16;\n              log.trace('getRawEnvelope release read lock');\n              release();\n              return _context2.finish(16);\n            case 20:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[5, 12, 16, 20]]);\n      }));\n      function getRawEnvelope(_x2) {\n        return _getRawEnvelope.apply(this, arguments);\n      }\n      return getRawEnvelope;\n    }()\n    /**\n     * Get an Envelope containing a PeerRecord for the given peer.\n     * Returns undefined if no record exists.\n     */\n  }, {\n    key: \"getPeerRecord\",\n    value: function () {\n      var _getPeerRecord = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peerId) {\n        var raw;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.getRawEnvelope(peerId);\n            case 2:\n              raw = _context3.sent;\n              if (!(raw == null)) {\n                _context3.next = 5;\n                break;\n              }\n              return _context3.abrupt(\"return\", undefined);\n            case 5:\n              _context3.next = 7;\n              return RecordEnvelope.createFromProtobuf(raw);\n            case 7:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getPeerRecord(_x3) {\n        return _getPeerRecord.apply(this, arguments);\n      }\n      return getPeerRecord;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId) {\n        var release, peer;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              peerId = peerIdFromPeerId(peerId);\n              log.trace('get wait for read lock');\n              _context4.next = 4;\n              return this.store.lock.readLock();\n            case 4:\n              release = _context4.sent;\n              log.trace('get got read lock');\n              _context4.prev = 6;\n              _context4.next = 9;\n              return this.store.load(peerId);\n            case 9:\n              peer = _context4.sent;\n              return _context4.abrupt(\"return\", peer.addresses);\n            case 13:\n              _context4.prev = 13;\n              _context4.t0 = _context4[\"catch\"](6);\n              if (!(_context4.t0.code !== codes.ERR_NOT_FOUND)) {\n                _context4.next = 17;\n                break;\n              }\n              throw _context4.t0;\n            case 17:\n              _context4.prev = 17;\n              log.trace('get release read lock');\n              release();\n              return _context4.finish(17);\n            case 21:\n              return _context4.abrupt(\"return\", []);\n            case 22:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[6, 13, 17, 21]]);\n      }));\n      function get(_x4) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(peerId, multiaddrs) {\n        var release, hasPeer, peer, updatedPeer, addresses;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              peerId = peerIdFromPeerId(peerId);\n              if (Array.isArray(multiaddrs)) {\n                _context5.next = 4;\n                break;\n              }\n              log.error('multiaddrs must be an array of Multiaddrs');\n              throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS);\n            case 4:\n              log.trace('set await write lock');\n              _context5.next = 7;\n              return this.store.lock.writeLock();\n            case 7:\n              release = _context5.sent;\n              log.trace('set got write lock');\n              hasPeer = false;\n              _context5.prev = 10;\n              _context5.next = 13;\n              return filterMultiaddrs(peerId, multiaddrs, this.addressFilter);\n            case 13:\n              addresses = _context5.sent;\n              if (!(addresses.length === 0)) {\n                _context5.next = 16;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 16:\n              _context5.prev = 16;\n              _context5.next = 19;\n              return this.store.load(peerId);\n            case 19:\n              peer = _context5.sent;\n              hasPeer = true;\n              if (!(new Set([].concat(_toConsumableArray(addresses.map(function (_ref3) {\n                var multiaddr = _ref3.multiaddr;\n                return multiaddr.toString();\n              })), _toConsumableArray(peer.addresses.map(function (_ref4) {\n                var multiaddr = _ref4.multiaddr;\n                return multiaddr.toString();\n              })))).size === peer.addresses.length && addresses.length === peer.addresses.length)) {\n                _context5.next = 23;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 23:\n              _context5.next = 29;\n              break;\n            case 25:\n              _context5.prev = 25;\n              _context5.t0 = _context5[\"catch\"](16);\n              if (!(_context5.t0.code !== codes.ERR_NOT_FOUND)) {\n                _context5.next = 29;\n                break;\n              }\n              throw _context5.t0;\n            case 29:\n              _context5.next = 31;\n              return this.store.patchOrCreate(peerId, {\n                addresses: addresses\n              });\n            case 31:\n              updatedPeer = _context5.sent;\n              log('set multiaddrs for %p', peerId);\n            case 33:\n              _context5.prev = 33;\n              log.trace('set multiaddrs for %p', peerId);\n              log('set release write lock');\n              release();\n              return _context5.finish(33);\n            case 38:\n              this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n                detail: {\n                  peerId: peerId,\n                  multiaddrs: updatedPeer.addresses.map(function (addr) {\n                    return addr.multiaddr;\n                  }),\n                  oldMultiaddrs: peer == null ? [] : peer.addresses.map(function (_ref5) {\n                    var multiaddr = _ref5.multiaddr;\n                    return multiaddr;\n                  })\n                }\n              }));\n              // Notify the existence of a new peer\n              if (!hasPeer) {\n                this.dispatchEvent(new CustomEvent('peer', {\n                  detail: {\n                    id: peerId,\n                    multiaddrs: updatedPeer.addresses.map(function (addr) {\n                      return addr.multiaddr;\n                    }),\n                    protocols: updatedPeer.protocols\n                  }\n                }));\n              }\n            case 40:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[10,, 33, 38], [16, 25]]);\n      }));\n      function set(_x5, _x6) {\n        return _set.apply(this, arguments);\n      }\n      return set;\n    }()\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(peerId, multiaddrs) {\n        var release, hasPeer, peer, updatedPeer, addresses;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              peerId = peerIdFromPeerId(peerId);\n              if (Array.isArray(multiaddrs)) {\n                _context6.next = 4;\n                break;\n              }\n              log.error('multiaddrs must be an array of Multiaddrs');\n              throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS);\n            case 4:\n              log.trace('add await write lock');\n              _context6.next = 7;\n              return this.store.lock.writeLock();\n            case 7:\n              release = _context6.sent;\n              log.trace('add got write lock');\n              _context6.prev = 9;\n              _context6.next = 12;\n              return filterMultiaddrs(peerId, multiaddrs, this.addressFilter);\n            case 12:\n              addresses = _context6.sent;\n              if (!(addresses.length === 0)) {\n                _context6.next = 15;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 15:\n              _context6.prev = 15;\n              _context6.next = 18;\n              return this.store.load(peerId);\n            case 18:\n              peer = _context6.sent;\n              hasPeer = true;\n              if (!(new Set([].concat(_toConsumableArray(addresses.map(function (_ref6) {\n                var multiaddr = _ref6.multiaddr;\n                return multiaddr.toString();\n              })), _toConsumableArray(peer.addresses.map(function (_ref7) {\n                var multiaddr = _ref7.multiaddr;\n                return multiaddr.toString();\n              })))).size === peer.addresses.length)) {\n                _context6.next = 22;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 22:\n              _context6.next = 28;\n              break;\n            case 24:\n              _context6.prev = 24;\n              _context6.t0 = _context6[\"catch\"](15);\n              if (!(_context6.t0.code !== codes.ERR_NOT_FOUND)) {\n                _context6.next = 28;\n                break;\n              }\n              throw _context6.t0;\n            case 28:\n              _context6.next = 30;\n              return this.store.mergeOrCreate(peerId, {\n                addresses: addresses\n              });\n            case 30:\n              updatedPeer = _context6.sent;\n              log('added multiaddrs for %p', peerId);\n            case 32:\n              _context6.prev = 32;\n              log.trace('set release write lock');\n              release();\n              return _context6.finish(32);\n            case 36:\n              this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n                detail: {\n                  peerId: peerId,\n                  multiaddrs: updatedPeer.addresses.map(function (addr) {\n                    return addr.multiaddr;\n                  }),\n                  oldMultiaddrs: peer == null ? [] : peer.addresses.map(function (_ref8) {\n                    var multiaddr = _ref8.multiaddr;\n                    return multiaddr;\n                  })\n                }\n              }));\n              // Notify the existence of a new peer\n              if (hasPeer === true) {\n                this.dispatchEvent(new CustomEvent('peer', {\n                  detail: {\n                    id: peerId,\n                    multiaddrs: updatedPeer.addresses.map(function (addr) {\n                      return addr.multiaddr;\n                    }),\n                    protocols: updatedPeer.protocols\n                  }\n                }));\n              }\n            case 38:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[9,, 32, 36], [15, 24]]);\n      }));\n      function add(_x7, _x8) {\n        return _add.apply(this, arguments);\n      }\n      return add;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(peerId) {\n        var release, peer;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              peerId = peerIdFromPeerId(peerId);\n              log.trace('delete await write lock');\n              _context7.next = 4;\n              return this.store.lock.writeLock();\n            case 4:\n              release = _context7.sent;\n              log.trace('delete got write lock');\n              _context7.prev = 6;\n              _context7.prev = 7;\n              _context7.next = 10;\n              return this.store.load(peerId);\n            case 10:\n              peer = _context7.sent;\n              _context7.next = 17;\n              break;\n            case 13:\n              _context7.prev = 13;\n              _context7.t0 = _context7[\"catch\"](7);\n              if (!(_context7.t0.code !== codes.ERR_NOT_FOUND)) {\n                _context7.next = 17;\n                break;\n              }\n              throw _context7.t0;\n            case 17:\n              _context7.next = 19;\n              return this.store.patchOrCreate(peerId, {\n                addresses: []\n              });\n            case 19:\n              _context7.prev = 19;\n              log.trace('delete release write lock');\n              release();\n              return _context7.finish(19);\n            case 23:\n              if (peer != null) {\n                this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n                  detail: {\n                    peerId: peerId,\n                    multiaddrs: [],\n                    oldMultiaddrs: peer == null ? [] : peer.addresses.map(function (_ref9) {\n                      var multiaddr = _ref9.multiaddr;\n                      return multiaddr;\n                    })\n                  }\n                }));\n              }\n            case 24:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[6,, 19, 23], [7, 13]]);\n      }));\n      function _delete(_x9) {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n  }]);\n  return PeerStoreAddressBook;\n}();\nfunction filterMultiaddrs(_x10, _x11, _x12) {\n  return _filterMultiaddrs.apply(this, arguments);\n}\nfunction _filterMultiaddrs() {\n  _filterMultiaddrs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(peerId, multiaddrs, addressFilter) {\n    var isCertified,\n      _args11 = arguments;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) switch (_context11.prev = _context11.next) {\n        case 0:\n          isCertified = _args11.length > 3 && _args11[3] !== undefined ? _args11[3] : false;\n          _context11.next = 3;\n          return pipe(multiaddrs, function (source) {\n            return each(source, function (multiaddr) {\n              if (!isMultiaddr(multiaddr)) {\n                log.error('multiaddr must be an instance of Multiaddr');\n                throw errcode(new Error('multiaddr must be an instance of Multiaddr'), codes.ERR_INVALID_PARAMETERS);\n              }\n            });\n          }, function (source) {\n            return filter(source, /*#__PURE__*/function () {\n              var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(multiaddr) {\n                return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                  while (1) switch (_context9.prev = _context9.next) {\n                    case 0:\n                      _context9.next = 2;\n                      return addressFilter(peerId, multiaddr);\n                    case 2:\n                      return _context9.abrupt(\"return\", _context9.sent);\n                    case 3:\n                    case \"end\":\n                      return _context9.stop();\n                  }\n                }, _callee9);\n              }));\n              return function (_x13) {\n                return _ref10.apply(this, arguments);\n              };\n            }());\n          }, function (source) {\n            return map(source, function (multiaddr) {\n              return {\n                multiaddr: multiaddr,\n                isCertified: isCertified\n              };\n            });\n          }, /*#__PURE__*/function () {\n            var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(source) {\n              return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n                while (1) switch (_context10.prev = _context10.next) {\n                  case 0:\n                    _context10.next = 2;\n                    return all(source);\n                  case 2:\n                    return _context10.abrupt(\"return\", _context10.sent);\n                  case 3:\n                  case \"end\":\n                    return _context10.stop();\n                }\n              }, _callee10);\n            }));\n            return function (_x14) {\n              return _ref11.apply(this, arguments);\n            };\n          }());\n        case 3:\n          return _context11.abrupt(\"return\", _context11.sent);\n        case 4:\n        case \"end\":\n          return _context11.stop();\n      }\n    }, _callee11);\n  }));\n  return _filterMultiaddrs.apply(this, arguments);\n}","map":{"version":3,"names":["logger","errcode","isMultiaddr","codes","PeerRecord","RecordEnvelope","pipe","all","filter","map","each","peerIdFromPeerId","CustomEvent","log","EVENT_NAME","allowAll","_allowAll","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee8","wrap","_callee8$","_context8","prev","next","abrupt","stop","PeerStoreAddressBook","dispatchEvent","store","addressFilter","_classCallCheck","_createClass","key","value","_consumePeerRecord","_callee","envelope","release","peerId","peer","updatedPeer","peerRecord","multiaddrs","storedEnvelope","storedRecord","addresses","_callee$","_context","trace","lock","writeLock","sent","createFromProtobuf","payload","t0","error","equals","length","has","load","peerRecordEnvelope","seqNumber","filterMultiaddrs","patchOrCreate","marshal","subarray","finish","detail","_ref","multiaddr","oldMultiaddrs","_ref2","consumePeerRecord","_x","_getRawEnvelope","_callee2","_callee2$","_context2","readLock","code","ERR_NOT_FOUND","getRawEnvelope","_x2","_getPeerRecord","_callee3","raw","_callee3$","_context3","undefined","getPeerRecord","_x3","_get","_callee4","_callee4$","_context4","get","_x4","_set","_callee5","hasPeer","_callee5$","_context5","Array","isArray","Error","ERR_INVALID_PARAMETERS","Set","concat","_toConsumableArray","_ref3","toString","_ref4","size","addr","_ref5","id","protocols","set","_x5","_x6","_add","_callee6","_callee6$","_context6","_ref6","_ref7","mergeOrCreate","_ref8","add","_x7","_x8","_delete2","_callee7","_callee7$","_context7","_ref9","_delete","_x9","_x10","_x11","_x12","_filterMultiaddrs","_callee11","isCertified","_args11","_callee11$","_context11","source","_ref10","_callee9","_callee9$","_context9","_x13","_ref11","_callee10","_callee10$","_context10","_x14"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/peer-store/src/address-book.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errcode from 'err-code'\nimport { isMultiaddr } from '@multiformats/multiaddr'\nimport { codes } from './errors.js'\nimport { PeerRecord, RecordEnvelope } from '@libp2p/peer-record'\nimport { pipe } from 'it-pipe'\nimport all from 'it-all'\nimport filter from 'it-filter'\nimport map from 'it-map'\nimport each from 'it-foreach'\nimport { peerIdFromPeerId } from '@libp2p/peer-id'\nimport { CustomEvent } from '@libp2p/interfaces/events'\nimport type { AddressFilter, Peer, PeerMultiaddrsChangeData, PeerStore } from '@libp2p/interface-peer-store'\nimport type { Store } from './store.js'\nimport type { Envelope } from '@libp2p/interface-record'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:peer-store:address-book')\nconst EVENT_NAME = 'change:multiaddrs'\n\nasync function allowAll () {\n  return true\n}\n\nexport class PeerStoreAddressBook {\n  private readonly dispatchEvent: PeerStore['dispatchEvent']\n  private readonly store: Store\n  private readonly addressFilter: AddressFilter\n\n  constructor (dispatchEvent: PeerStore['dispatchEvent'], store: Store, addressFilter?: AddressFilter) {\n    this.dispatchEvent = dispatchEvent\n    this.store = store\n    this.addressFilter = addressFilter ?? allowAll\n  }\n\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   */\n  async consumePeerRecord (envelope: Envelope) {\n    log.trace('consumePeerRecord await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('consumePeerRecord got write lock')\n\n    let peerId\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      let peerRecord\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n      } catch (err: any) {\n        log.error('invalid peer record received')\n        return false\n      }\n\n      peerId = peerRecord.peerId\n      const multiaddrs = peerRecord.multiaddrs\n\n      // Verify peerId\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord')\n        return false\n      }\n\n      // ensure the record has multiaddrs\n      if (multiaddrs == null || multiaddrs.length === 0) {\n        return false\n      }\n\n      if (await this.store.has(peerId)) {\n        peer = await this.store.load(peerId)\n\n        if (peer.peerRecordEnvelope != null) {\n          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope)\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n          // ensure seq is greater than, or equal to, the last received\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n            return false\n          }\n        }\n      }\n\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true)\n\n      // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        addresses,\n        peerRecordEnvelope: envelope.marshal().subarray()\n      })\n\n      log('stored provided peer record for %p', peerRecord.peerId)\n    } finally {\n      log.trace('consumePeerRecord release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(({ multiaddr }) => multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n      }\n    }))\n\n    return true\n  }\n\n  async getRawEnvelope (peerId: PeerId) {\n    log.trace('getRawEnvelope await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('getRawEnvelope got read lock')\n\n    try {\n      const peer = await this.store.load(peerId)\n\n      return peer.peerRecordEnvelope\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('getRawEnvelope release read lock')\n      release()\n    }\n  }\n\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   */\n  async getPeerRecord (peerId: PeerId) {\n    const raw = await this.getRawEnvelope(peerId)\n\n    if (raw == null) {\n      return undefined\n    }\n\n    return await RecordEnvelope.createFromProtobuf(raw)\n  }\n\n  async get (peerId: PeerId) {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('get wait for read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('get got read lock')\n\n    try {\n      const peer = await this.store.load(peerId)\n\n      return peer.addresses\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('get release read lock')\n      release()\n    }\n\n    return []\n  }\n\n  async set (peerId: PeerId, multiaddrs: Multiaddr[]) {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('set await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('set got write lock')\n\n    let hasPeer = false\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter)\n\n      // No valid addresses found\n      if (addresses.length === 0) {\n        return\n      }\n\n      try {\n        peer = await this.store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return\n        }\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.patchOrCreate(peerId, { addresses })\n\n      log('set multiaddrs for %p', peerId)\n    } finally {\n      log.trace('set multiaddrs for %p', peerId)\n      log('set release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n      }\n    }))\n\n    // Notify the existence of a new peer\n    if (!hasPeer) {\n      this.dispatchEvent(new CustomEvent<PeerInfo>('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }))\n    }\n  }\n\n  async add (peerId: PeerId, multiaddrs: Multiaddr[]) {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('add await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('add got write lock')\n\n    let hasPeer\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter)\n\n      // No valid addresses found\n      if (addresses.length === 0) {\n        return\n      }\n\n      try {\n        peer = await this.store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length) {\n          return\n        }\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.mergeOrCreate(peerId, { addresses })\n\n      log('added multiaddrs for %p', peerId)\n    } finally {\n      log.trace('set release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n      }\n    }))\n\n    // Notify the existence of a new peer\n    if (hasPeer === true) {\n      this.dispatchEvent(new CustomEvent<PeerInfo>('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }))\n    }\n  }\n\n  async delete (peerId: PeerId) {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('delete got write lock')\n\n    let peer: Peer | undefined\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      await this.store.patchOrCreate(peerId, {\n        addresses: []\n      })\n    } finally {\n      log.trace('delete release write lock')\n      release()\n    }\n\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n        detail: {\n          peerId,\n          multiaddrs: [],\n          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n        }\n      }))\n    }\n  }\n}\n\nasync function filterMultiaddrs (peerId: PeerId, multiaddrs: Multiaddr[], addressFilter: AddressFilter, isCertified: boolean = false) {\n  return await pipe(\n    multiaddrs,\n    (source) => each(source, (multiaddr) => {\n      if (!isMultiaddr(multiaddr)) {\n        log.error('multiaddr must be an instance of Multiaddr')\n        throw errcode(new Error('multiaddr must be an instance of Multiaddr'), codes.ERR_INVALID_PARAMETERS)\n      }\n    }),\n    (source) => filter(source, async (multiaddr) => await addressFilter(peerId, multiaddr)),\n    (source) => map(source, (multiaddr) => {\n      return {\n        multiaddr,\n        isCertified\n      }\n    }),\n    async (source) => await all(source)\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}