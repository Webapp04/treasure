{"ast":null,"code":"import { base58btc } from 'multiformats/bases/base58';\nimport { base32 } from 'multiformats/bases/base32';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport * as mafmt from '@multiformats/mafmt';\nimport { CID } from 'multiformats/cid';\nimport { URL } from 'iso-url';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport var pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/;\nexport var pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/;\nvar defaultProtocolMatch = 1;\nvar defaultHashMath = 2;\n// CID, libp2p-key or DNSLink\nexport var subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/;\nvar subdomainIdMatch = 1;\nvar subdomainProtocolMatch = 2;\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nvar fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;\nfunction isMultihash(hash) {\n  var formatted = convertToString(hash);\n  if (formatted === false) {\n    return false;\n  }\n  try {\n    Digest.decode(base58btc.decode('z' + formatted));\n  } catch (_unused) {\n    return false;\n  }\n  return true;\n}\nfunction isMultiaddr(input) {\n  try {\n    return Boolean(multiaddr(input));\n  } catch (_unused2) {\n    return false;\n  }\n}\nfunction isBase32EncodedMultibase(hash) {\n  try {\n    var cid;\n    if (isString(hash)) {\n      cid = CID.parse(hash);\n    } else {\n      cid = CID.asCID(hash);\n    }\n    if (cid == null) {\n      return false;\n    }\n    base32.decode(cid.toString());\n  } catch (_unused3) {\n    return false;\n  }\n  return true;\n}\nfunction isCID(hash) {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash));\n    }\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash));\n    }\n    return Boolean(CID.asCID(hash)); // eslint-disable-line no-new\n  } catch (_unused4) {\n    return false;\n  }\n}\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.P2P.matches(input);\n}\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs(input, pattern) {\n  var protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  var hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  var formatted = convertToString(input);\n  if (formatted === false) {\n    return false;\n  }\n  var match = formatted.match(pattern);\n  if (match == null) {\n    return false;\n  }\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n  var hash = match[hashMatch];\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase();\n  }\n  return isCID(hash);\n}\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns(input, pattern) {\n  var protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  var hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  var formatted = convertToString(input);\n  if (formatted === false) {\n    return false;\n  }\n  var match = formatted.match(pattern);\n  if (match == null) {\n    return false;\n  }\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n  var ipnsId = match[hashMatch];\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase();\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true;\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org â†’ en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      var _URL = new URL(\"http://\".concat(ipnsId)),\n        hostname = _URL.hostname; // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname);\n    } catch (e) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * @param {any} input\n */\nfunction isString(input) {\n  return typeof input === 'string';\n}\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString(input) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc');\n  }\n  if (isString(input)) {\n    return input;\n  }\n  return false;\n}\nexport var ipfsSubdomain = function ipfsSubdomain(url) {\n  return isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n};\nexport var ipnsSubdomain = function ipnsSubdomain(url) {\n  return isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n};\nexport var subdomain = function subdomain(url) {\n  return ipfsSubdomain(url) || ipnsSubdomain(url);\n};\nexport var ipfsUrl = function ipfsUrl(url) {\n  return isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);\n};\nexport var ipnsUrl = function ipnsUrl(url) {\n  return isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);\n};\nexport var url = function url(_url) {\n  return ipfsUrl(_url) || ipnsUrl(_url) || subdomain(_url);\n};\nexport var path = function path(_path) {\n  return isIpfs(_path, pathPattern) || isIpns(_path, pathPattern);\n};\nexport { isMultihash as multihash };\nexport { isMultiaddr as multiaddr };\nexport { isPeerMultiaddr as peerMultiaddr };\nexport { isCID as cid };\nexport var base32cid = function base32cid(cid) {\n  return isCID(cid) && isBase32EncodedMultibase(cid);\n};\nexport var ipfsPath = function ipfsPath(path) {\n  return isIpfs(path, pathPattern);\n};\nexport var ipnsPath = function ipnsPath(path) {\n  return isIpns(path, pathPattern);\n};\nexport var urlOrPath = function urlOrPath(x) {\n  return url(x) || path(x);\n};\nexport var cidPath = function cidPath(path) {\n  return isString(path) && !isCID(path) && isIpfs(\"/ipfs/\".concat(path), pathPattern);\n};","map":{"version":3,"names":["base58btc","base32","Digest","multiaddr","mafmt","CID","URL","toString","uint8ArrayToString","pathGatewayPattern","pathPattern","defaultProtocolMatch","defaultHashMath","subdomainGatewayPattern","subdomainIdMatch","subdomainProtocolMatch","fqdnWithTld","isMultihash","hash","formatted","convertToString","decode","_unused","isMultiaddr","input","Boolean","_unused2","isBase32EncodedMultibase","cid","isString","parse","asCID","_unused3","isCID","Uint8Array","_unused4","isPeerMultiaddr","P2P","matches","isIpfs","pattern","protocolMatch","arguments","length","undefined","hashMatch","match","toLowerCase","isIpns","ipnsId","includes","replace","_URL","concat","hostname","test","e","ipfsSubdomain","url","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","path","multihash","peerMultiaddr","base32cid","ipfsPath","ipnsPath","urlOrPath","x","cidPath"],"sources":["/Users/apple/Documents/treasure/node_modules/is-ipfs/src/index.ts"],"sourcesContent":["import { base58btc } from 'multiformats/bases/base58'\nimport { base32 } from 'multiformats/bases/base32'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport * as mafmt from '@multiformats/mafmt'\nimport { CID } from 'multiformats/cid'\nimport { URL } from 'iso-url'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\nfunction isMultihash (hash: Uint8Array | string): boolean {\n  const formatted = convertToString(hash)\n\n  if (formatted === false) {\n    return false\n  }\n\n  try {\n    Digest.decode(base58btc.decode('z' + formatted))\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isMultiaddr (input: string | Uint8Array | Multiaddr): input is Multiaddr {\n  try {\n    return Boolean(multiaddr(input))\n  } catch {\n    return false\n  }\n}\n\nfunction isBase32EncodedMultibase (hash: CID | string | Uint8Array): boolean {\n  try {\n    let cid: CID | null\n\n    if (isString(hash)) {\n      cid = CID.parse(hash)\n    } else {\n      cid = CID.asCID(hash)\n    }\n\n    if (cid == null) {\n      return false\n    }\n\n    base32.decode(cid.toString())\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isCID (hash: CID | Uint8Array | string): hash is CID {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash))\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash))\n    }\n\n    return Boolean(CID.asCID(hash)) // eslint-disable-line no-new\n  } catch {\n    return false\n  }\n}\n\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr (input: string | Uint8Array | Multiaddr): boolean {\n  return isMultiaddr(input) && mafmt.P2P.matches(input)\n}\n\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org â†’ en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-')\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {any} input\n */\nfunction isString (input: any): input is string {\n  return typeof input === 'string'\n}\n\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString (input: Uint8Array | string) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc')\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\nexport const ipfsSubdomain = (url: string | Uint8Array) => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\nexport const ipnsSubdomain = (url: string | Uint8Array) => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\nexport const subdomain = (url: string | Uint8Array) => ipfsSubdomain(url) || ipnsSubdomain(url)\nexport const ipfsUrl = (url: string | Uint8Array) => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\nexport const ipnsUrl = (url: string | Uint8Array) => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\nexport const url = (url: string | Uint8Array) => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\nexport const path = (path: string | Uint8Array) => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\nexport { isMultihash as multihash }\nexport { isMultiaddr as multiaddr }\nexport { isPeerMultiaddr as peerMultiaddr }\nexport { isCID as cid }\n\nexport const base32cid = (cid: CID | string | Uint8Array) => (isCID(cid) && isBase32EncodedMultibase(cid))\nexport const ipfsPath = (path: string | Uint8Array) => isIpfs(path, pathPattern)\nexport const ipnsPath = (path: string | Uint8Array) => isIpns(path, pathPattern)\nexport const urlOrPath = (x: string | Uint8Array) => url(x) || path(x)\nexport const cidPath = (path: string | Uint8Array | CID) => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}