{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BitswapMessage as Message } from '../message/index.js';\nimport { Wantlist } from '../wantlist/index.js';\nimport * as CONSTANTS from '../constants.js';\nimport { MsgQueue } from './msg-queue.js';\nimport { logger } from '../utils/index.js';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { trackedMap } from '@libp2p/tracked-map';\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n */\n\nexport var WantManager = /*#__PURE__*/function () {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('../network').Network} network\n   * @param {import('../stats').Stats} stats\n   * @param {import('libp2p').Libp2p} libp2p\n   */\n  function WantManager(peerId, network, stats, libp2p) {\n    _classCallCheck(this, WantManager);\n    /** @type {Map<string, MsgQueue>} */\n    this.peers = trackedMap({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'want-manager-peers',\n      metrics: libp2p.metrics\n    });\n    this.wantlist = new Wantlist(stats, libp2p);\n    this.network = network;\n    this._stats = stats;\n    this._peerId = peerId;\n    this._log = logger(peerId, 'want');\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @param {boolean} cancel\n   * @param {boolean} [force]\n   */\n  _createClass(WantManager, [{\n    key: \"_addEntries\",\n    value: function _addEntries(cids, cancel, force) {\n      var _this = this;\n      var entries = cids.map(function (cid, i) {\n        return new Message.Entry(cid, CONSTANTS.kMaxPriority - i, Message.WantType.Block, cancel);\n      });\n      entries.forEach(function (e) {\n        // add changes to our wantlist\n        if (e.cancel) {\n          if (force) {\n            _this.wantlist.removeForce(e.cid.toString(base58btc));\n          } else {\n            _this.wantlist.remove(e.cid);\n          }\n        } else {\n          _this._log('adding to wl');\n          // TODO: Figure out the wantType\n          // @ts-expect-error - requires wantType\n          _this.wantlist.add(e.cid, e.priority);\n        }\n      });\n\n      // broadcast changes\n      var _iterator = _createForOfIteratorHelper(this.peers.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          p.addEntries(entries);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    /**\n     * @private\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"_startPeerHandler\",\n    value: function _startPeerHandler(peerId) {\n      var mq = this.peers.get(peerId.toString());\n      if (mq) {\n        mq.refcnt++;\n        return;\n      }\n      mq = new MsgQueue(this._peerId, peerId, this.network);\n\n      // new peer, give them the full wantlist\n      var fullwantlist = new Message(true);\n      var _iterator2 = _createForOfIteratorHelper(this.wantlist.entries()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var entry = _step2.value;\n          fullwantlist.addEntry(entry[1].cid, entry[1].priority);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      mq.addMessage(fullwantlist);\n      this.peers.set(peerId.toString(), mq);\n      return mq;\n    }\n\n    /**\n     * @private\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"_stopPeerHandler\",\n    value: function _stopPeerHandler(peerId) {\n      var mq = this.peers.get(peerId.toString());\n      if (!mq) {\n        return;\n      }\n      mq.refcnt--;\n      if (mq.refcnt > 0) {\n        return;\n      }\n      this.peers.delete(peerId.toString());\n    }\n\n    /**\n     * add all the cids to the wantlist\n     *\n     * @param {CID[]} cids\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n  }, {\n    key: \"wantBlocks\",\n    value: function wantBlocks(cids) {\n      var _this2 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this._addEntries(cids, false);\n      if (options && options.signal) {\n        options.signal.addEventListener('abort', function () {\n          _this2.cancelWants(cids);\n        });\n      }\n    }\n\n    /**\n     * Remove blocks of all the given keys without respecting refcounts\n     *\n     * @param {CID[]} cids\n     */\n  }, {\n    key: \"unwantBlocks\",\n    value: function unwantBlocks(cids) {\n      this._log('unwant blocks: %s', cids.length);\n      this._addEntries(cids, true, true);\n    }\n\n    /**\n     * Cancel wanting all of the given keys\n     *\n     * @param {CID[]} cids\n     */\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      this._log('cancel wants: %s', cids.length);\n      this._addEntries(cids, true);\n    }\n\n    /**\n     * Returns a list of all currently connected peers\n     */\n  }, {\n    key: \"connectedPeers\",\n    value: function connectedPeers() {\n      return Array.from(this.peers.keys());\n    }\n\n    /**\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"connected\",\n    value: function connected(peerId) {\n      this._startPeerHandler(peerId);\n    }\n\n    /**\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"disconnected\",\n    value: function disconnected(peerId) {\n      this._stopPeerHandler(peerId);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {}\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this3 = this;\n      this.peers.forEach(function (mq) {\n        return _this3.disconnected(mq.peerId);\n      });\n    }\n  }]);\n  return WantManager;\n}();","map":{"version":3,"names":["BitswapMessage","Message","Wantlist","CONSTANTS","MsgQueue","logger","base58btc","trackedMap","WantManager","peerId","network","stats","libp2p","_classCallCheck","peers","system","component","metric","metrics","wantlist","_stats","_peerId","_log","_createClass","key","value","_addEntries","cids","cancel","force","_this","entries","map","cid","i","Entry","kMaxPriority","WantType","Block","forEach","e","removeForce","toString","remove","add","priority","_iterator","_createForOfIteratorHelper","values","_step","s","n","done","p","addEntries","err","f","_startPeerHandler","mq","get","refcnt","fullwantlist","_iterator2","_step2","entry","addEntry","addMessage","set","_stopPeerHandler","delete","wantBlocks","_this2","options","arguments","length","undefined","signal","addEventListener","cancelWants","unwantBlocks","connectedPeers","Array","from","keys","connected","disconnected","start","stop","_this3"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-bitswap/src/want-manager/index.js"],"sourcesContent":["\nimport { BitswapMessage as Message } from '../message/index.js'\nimport { Wantlist } from '../wantlist/index.js'\nimport * as CONSTANTS from '../constants.js'\nimport { MsgQueue } from './msg-queue.js'\nimport { logger } from '../utils/index.js'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { trackedMap } from '@libp2p/tracked-map'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n */\n\nexport class WantManager {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('../network').Network} network\n   * @param {import('../stats').Stats} stats\n   * @param {import('libp2p').Libp2p} libp2p\n   */\n  constructor (peerId, network, stats, libp2p) {\n    /** @type {Map<string, MsgQueue>} */\n    this.peers = trackedMap({\n      system: 'ipfs',\n      component: 'bitswap',\n      metric: 'want-manager-peers',\n      metrics: libp2p.metrics\n    })\n    this.wantlist = new Wantlist(stats, libp2p)\n\n    this.network = network\n    this._stats = stats\n\n    this._peerId = peerId\n    this._log = logger(peerId, 'want')\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @param {boolean} cancel\n   * @param {boolean} [force]\n   */\n  _addEntries (cids, cancel, force) {\n    const entries = cids.map((cid, i) => {\n      return new Message.Entry(cid, CONSTANTS.kMaxPriority - i, Message.WantType.Block, cancel)\n    })\n\n    entries.forEach((e) => {\n      // add changes to our wantlist\n      if (e.cancel) {\n        if (force) {\n          this.wantlist.removeForce(e.cid.toString(base58btc))\n        } else {\n          this.wantlist.remove(e.cid)\n        }\n      } else {\n        this._log('adding to wl')\n        // TODO: Figure out the wantType\n        // @ts-expect-error - requires wantType\n        this.wantlist.add(e.cid, e.priority)\n      }\n    })\n\n    // broadcast changes\n    for (const p of this.peers.values()) {\n      p.addEntries(entries)\n    }\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _startPeerHandler (peerId) {\n    let mq = this.peers.get(peerId.toString())\n\n    if (mq) {\n      mq.refcnt++\n      return\n    }\n\n    mq = new MsgQueue(this._peerId, peerId, this.network)\n\n    // new peer, give them the full wantlist\n    const fullwantlist = new Message(true)\n\n    for (const entry of this.wantlist.entries()) {\n      fullwantlist.addEntry(entry[1].cid, entry[1].priority)\n    }\n\n    mq.addMessage(fullwantlist)\n\n    this.peers.set(peerId.toString(), mq)\n    return mq\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _stopPeerHandler (peerId) {\n    const mq = this.peers.get(peerId.toString())\n\n    if (!mq) {\n      return\n    }\n\n    mq.refcnt--\n    if (mq.refcnt > 0) {\n      return\n    }\n\n    this.peers.delete(peerId.toString())\n  }\n\n  /**\n   * add all the cids to the wantlist\n   *\n   * @param {CID[]} cids\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  wantBlocks (cids, options = {}) {\n    this._addEntries(cids, false)\n\n    if (options && options.signal) {\n      options.signal.addEventListener('abort', () => {\n        this.cancelWants(cids)\n      })\n    }\n  }\n\n  /**\n   * Remove blocks of all the given keys without respecting refcounts\n   *\n   * @param {CID[]} cids\n   */\n  unwantBlocks (cids) {\n    this._log('unwant blocks: %s', cids.length)\n    this._addEntries(cids, true, true)\n  }\n\n  /**\n   * Cancel wanting all of the given keys\n   *\n   * @param {CID[]} cids\n   */\n  cancelWants (cids) {\n    this._log('cancel wants: %s', cids.length)\n    this._addEntries(cids, true)\n  }\n\n  /**\n   * Returns a list of all currently connected peers\n   */\n  connectedPeers () {\n    return Array.from(this.peers.keys())\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  connected (peerId) {\n    this._startPeerHandler(peerId)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  disconnected (peerId) {\n    this._stopPeerHandler(peerId)\n  }\n\n  start () {\n  }\n\n  stop () {\n    this.peers.forEach((mq) => this.disconnected(mq.peerId))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}