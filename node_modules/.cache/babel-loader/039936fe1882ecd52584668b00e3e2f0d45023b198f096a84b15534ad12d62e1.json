{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { xor as uint8ArrayXor } from 'uint8arrays/xor';\nimport GENERATED_PREFIXES from './generated-prefix-list.js';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { randomBytes } from '@libp2p/crypto';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { logger } from '@libp2p/logger';\nimport length from 'it-length';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } from '../constants.js';\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nvar MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport var RoutingTableRefresh = /*#__PURE__*/function () {\n  function RoutingTableRefresh(init) {\n    _classCallCheck(this, RoutingTableRefresh);\n    var peerRouting = init.peerRouting,\n      routingTable = init.routingTable,\n      refreshInterval = init.refreshInterval,\n      refreshQueryTimeout = init.refreshQueryTimeout,\n      lan = init.lan;\n    this.log = logger(\"libp2p:kad-dht:\".concat(lan ? 'lan' : 'wan', \":routing-table:refresh\"));\n    this.peerRouting = peerRouting;\n    this.routingTable = routingTable;\n    this.refreshInterval = refreshInterval !== null && refreshInterval !== void 0 ? refreshInterval : TABLE_REFRESH_INTERVAL;\n    this.refreshQueryTimeout = refreshQueryTimeout !== null && refreshQueryTimeout !== void 0 ? refreshQueryTimeout : TABLE_REFRESH_QUERY_TIMEOUT;\n    this.commonPrefixLengthRefreshedAt = [];\n    this.refreshTable = this.refreshTable.bind(this);\n  }\n  _createClass(RoutingTableRefresh, [{\n    key: \"init\",\n    value: function init(components) {}\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.log(\"refreshing routing table every \".concat(this.refreshInterval, \"ms\"));\n              this.refreshTable(true);\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.refreshTimeoutId != null) {\n                clearTimeout(this.refreshTimeoutId);\n              }\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * To speed lookups, we seed the table with random PeerIds. This means\n     * when we are asked to locate a peer on the network, we can find a KadId\n     * that is close to the requested peer ID and query that, then network\n     * peers will tell us who they know who is close to the fake ID\n     */\n  }, {\n    key: \"refreshTable\",\n    value: function refreshTable() {\n      var _this = this;\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.log('refreshing routing table');\n      var prefixLength = this._maxCommonPrefix();\n      var refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n      this.log(\"max common prefix length \".concat(prefixLength));\n      this.log(\"tracked CPLs [ \".concat(refreshCpls.map(function (date) {\n        return date.toISOString();\n      }).join(', '), \" ]\"));\n      /**\n       * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n       * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n       * is smaller.\n       *\n       * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n       * before a very high max Cpl for which we do have peers in the network.\n       *\n       * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n       * the programmer had paid more attention in the Math classes at university.\n       *\n       * So, please be patient and a doc explaining it will be published soon.\n       *\n       * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n       */\n      Promise.all(refreshCpls.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(lastRefresh, index) {\n          var lastCpl, n;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return _this._refreshCommonPrefixLength(index, lastRefresh, force);\n              case 3:\n                if (!(_this._numPeersForCpl(prefixLength) === 0)) {\n                  _context3.next = 18;\n                  break;\n                }\n                lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n                n = index + 1;\n              case 6:\n                if (!(n < lastCpl + 1)) {\n                  _context3.next = 18;\n                  break;\n                }\n                _context3.prev = 7;\n                _context3.next = 10;\n                return _this._refreshCommonPrefixLength(n, lastRefresh, force);\n              case 10:\n                _context3.next = 15;\n                break;\n              case 12:\n                _context3.prev = 12;\n                _context3.t0 = _context3[\"catch\"](7);\n                _this.log.error(_context3.t0);\n              case 15:\n                n++;\n                _context3.next = 6;\n                break;\n              case 18:\n                _context3.next = 23;\n                break;\n              case 20:\n                _context3.prev = 20;\n                _context3.t1 = _context3[\"catch\"](0);\n                _this.log.error(_context3.t1);\n              case 23:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3, null, [[0, 20], [7, 12]]);\n        }));\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }())).catch(function (err) {\n        _this.log.error(err);\n      }).then(function () {\n        _this.refreshTimeoutId = setTimeout(_this.refreshTable, _this.refreshInterval);\n        if (_this.refreshTimeoutId.unref != null) {\n          _this.refreshTimeoutId.unref();\n        }\n      }).catch(function (err) {\n        _this.log.error(err);\n      });\n    }\n  }, {\n    key: \"_refreshCommonPrefixLength\",\n    value: function () {\n      var _refreshCommonPrefixLength2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cpl, lastRefresh, force) {\n        var peerId, controller, peers;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(!force && lastRefresh.getTime() > Date.now() - this.refreshInterval)) {\n                _context4.next = 3;\n                break;\n              }\n              this.log('not running refresh for cpl %s as time since last refresh not above interval', cpl);\n              return _context4.abrupt(\"return\");\n            case 3:\n              _context4.next = 5;\n              return this._generateRandomPeerId(cpl);\n            case 5:\n              peerId = _context4.sent;\n              this.log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this.routingTable.size);\n              controller = new TimeoutController(this.refreshQueryTimeout);\n              _context4.prev = 8;\n              _context4.next = 11;\n              return length(this.peerRouting.getClosestPeers(peerId.toBytes(), {\n                signal: controller.signal\n              }));\n            case 11:\n              peers = _context4.sent;\n              this.log(\"found \".concat(peers, \" peers that were close to imaginary peer %p\"), peerId);\n              this.log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this.routingTable.size);\n            case 14:\n              _context4.prev = 14;\n              controller.clear();\n              return _context4.finish(14);\n            case 17:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[8,, 14, 17]]);\n      }));\n      function _refreshCommonPrefixLength(_x3, _x4, _x5) {\n        return _refreshCommonPrefixLength2.apply(this, arguments);\n      }\n      return _refreshCommonPrefixLength;\n    }()\n  }, {\n    key: \"_getTrackedCommonPrefixLengthsForRefresh\",\n    value: function _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n      if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n        maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n      }\n      var dates = [];\n      for (var i = 0; i <= maxCommonPrefix; i++) {\n        var _this$commonPrefixLen;\n        // defaults to the zero value if we haven't refreshed it yet.\n        dates[i] = (_this$commonPrefixLen = this.commonPrefixLengthRefreshedAt[i]) !== null && _this$commonPrefixLen !== void 0 ? _this$commonPrefixLen : new Date();\n      }\n      return dates;\n    }\n  }, {\n    key: \"_generateRandomPeerId\",\n    value: function () {\n      var _generateRandomPeerId2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(targetCommonPrefixLength) {\n        var randomData, randomUint16, key;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(this.routingTable.kb == null)) {\n                _context5.next = 2;\n                break;\n              }\n              throw new Error('Routing table not started');\n            case 2:\n              randomData = randomBytes(2);\n              randomUint16 = (randomData[1] << 8) + randomData[0];\n              _context5.next = 6;\n              return this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);\n            case 6:\n              key = _context5.sent;\n              return _context5.abrupt(\"return\", peerIdFromBytes(key));\n            case 8:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _generateRandomPeerId(_x6) {\n        return _generateRandomPeerId2.apply(this, arguments);\n      }\n      return _generateRandomPeerId;\n    }()\n  }, {\n    key: \"_makePeerId\",\n    value: function () {\n      var _makePeerId2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(localKadId, randomPrefix, targetCommonPrefixLength) {\n        var view, localPrefix, toggledLocalPrefix, mask, targetPrefix, keyPrefix, keyBuffer, keyView;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH)) {\n                _context6.next = 2;\n                break;\n              }\n              throw new Error(\"Cannot generate peer ID for common prefix length greater than \".concat(MAX_COMMON_PREFIX_LENGTH));\n            case 2:\n              view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n              localPrefix = view.getUint16(0, false); // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n              // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n              // to our randomly generated prefix.\n              toggledLocalPrefix = localPrefix ^ 0x8000 >> targetCommonPrefixLength; // Combine the toggled local prefix and the random bits at the correct offset\n              // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n              mask = 65535 << 16 - (targetCommonPrefixLength + 1);\n              targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask; // Convert to a known peer ID.\n              keyPrefix = GENERATED_PREFIXES[targetPrefix];\n              keyBuffer = new ArrayBuffer(34);\n              keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n              keyView.setUint8(0, sha256.code);\n              keyView.setUint8(1, 32);\n              keyView.setUint32(2, keyPrefix, false);\n              return _context6.abrupt(\"return\", new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength));\n            case 14:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function _makePeerId(_x7, _x8, _x9) {\n        return _makePeerId2.apply(this, arguments);\n      }\n      return _makePeerId;\n    }()\n    /**\n     * returns the maximum common prefix length between any peer in the table\n     * and the current peer\n     */\n  }, {\n    key: \"_maxCommonPrefix\",\n    value: function _maxCommonPrefix() {\n      // xor our KadId with every KadId in the k-bucket tree,\n      // return the longest id prefix that is the same\n      var prefixLength = 0;\n      var _iterator = _createForOfIteratorHelper(this._prefixLengths()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _length = _step.value;\n          if (_length > prefixLength) {\n            prefixLength = _length;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return prefixLength;\n    }\n    /**\n     * Returns the number of peers in the table with a given prefix length\n     */\n  }, {\n    key: \"_numPeersForCpl\",\n    value: function _numPeersForCpl(prefixLength) {\n      var count = 0;\n      var _iterator2 = _createForOfIteratorHelper(this._prefixLengths()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _length2 = _step2.value;\n          if (_length2 === prefixLength) {\n            count++;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return count;\n    }\n    /**\n     * Yields the common prefix length of every peer in the table\n     */\n  }, {\n    key: \"_prefixLengths\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function _prefixLengths() {\n      var _iterator3, _step3, id, distance, leadingZeros, _iterator4, _step4, byte;\n      return _regeneratorRuntime().wrap(function _prefixLengths$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!(this.routingTable.kb == null)) {\n              _context7.next = 2;\n              break;\n            }\n            return _context7.abrupt(\"return\");\n          case 2:\n            _iterator3 = _createForOfIteratorHelper(this.routingTable.kb.toIterable());\n            _context7.prev = 3;\n            _iterator3.s();\n          case 5:\n            if ((_step3 = _iterator3.n()).done) {\n              _context7.next = 33;\n              break;\n            }\n            id = _step3.value.id;\n            distance = uint8ArrayXor(this.routingTable.kb.localNodeId, id);\n            leadingZeros = 0;\n            _iterator4 = _createForOfIteratorHelper(distance);\n            _context7.prev = 10;\n            _iterator4.s();\n          case 12:\n            if ((_step4 = _iterator4.n()).done) {\n              _context7.next = 21;\n              break;\n            }\n            byte = _step4.value;\n            if (!(byte === 0)) {\n              _context7.next = 18;\n              break;\n            }\n            leadingZeros++;\n            _context7.next = 19;\n            break;\n          case 18:\n            return _context7.abrupt(\"break\", 21);\n          case 19:\n            _context7.next = 12;\n            break;\n          case 21:\n            _context7.next = 26;\n            break;\n          case 23:\n            _context7.prev = 23;\n            _context7.t0 = _context7[\"catch\"](10);\n            _iterator4.e(_context7.t0);\n          case 26:\n            _context7.prev = 26;\n            _iterator4.f();\n            return _context7.finish(26);\n          case 29:\n            _context7.next = 31;\n            return leadingZeros;\n          case 31:\n            _context7.next = 5;\n            break;\n          case 33:\n            _context7.next = 38;\n            break;\n          case 35:\n            _context7.prev = 35;\n            _context7.t1 = _context7[\"catch\"](3);\n            _iterator3.e(_context7.t1);\n          case 38:\n            _context7.prev = 38;\n            _iterator3.f();\n            return _context7.finish(38);\n          case 41:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _prefixLengths, this, [[3, 35, 38, 41], [10, 23, 26, 29]]);\n    })\n  }]);\n  return RoutingTableRefresh;\n}();","map":{"version":3,"names":["xor","uint8ArrayXor","GENERATED_PREFIXES","sha256","randomBytes","peerIdFromBytes","logger","length","TimeoutController","TABLE_REFRESH_INTERVAL","TABLE_REFRESH_QUERY_TIMEOUT","MAX_COMMON_PREFIX_LENGTH","RoutingTableRefresh","init","_classCallCheck","peerRouting","routingTable","refreshInterval","refreshQueryTimeout","lan","log","concat","commonPrefixLengthRefreshedAt","refreshTable","bind","_createClass","key","value","components","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","stop","start","apply","arguments","_stop","_callee2","_callee2$","_context2","refreshTimeoutId","clearTimeout","_this","force","undefined","prefixLength","_maxCommonPrefix","refreshCpls","_getTrackedCommonPrefixLengthsForRefresh","map","date","toISOString","join","Promise","all","_ref","_callee3","lastRefresh","index","lastCpl","n","_callee3$","_context3","_refreshCommonPrefixLength","_numPeersForCpl","Math","min","t0","error","t1","_x","_x2","catch","err","then","setTimeout","unref","_refreshCommonPrefixLength2","_callee4","cpl","peerId","controller","peers","_callee4$","_context4","getTime","Date","now","abrupt","_generateRandomPeerId","sent","size","getClosestPeers","toBytes","signal","clear","finish","_x3","_x4","_x5","maxCommonPrefix","dates","i","_this$commonPrefixLen","_generateRandomPeerId2","_callee5","targetCommonPrefixLength","randomData","randomUint16","_callee5$","_context5","kb","Error","_makePeerId","localNodeId","_x6","_makePeerId2","_callee6","localKadId","randomPrefix","view","localPrefix","toggledLocalPrefix","mask","targetPrefix","keyPrefix","keyBuffer","keyView","_callee6$","_context6","DataView","buffer","byteOffset","byteLength","getUint16","ArrayBuffer","setUint8","code","setUint32","Uint8Array","_x7","_x8","_x9","_iterator","_createForOfIteratorHelper","_prefixLengths","_step","s","done","e","f","count","_iterator2","_step2","_iterator3","_step3","id","distance","leadingZeros","_iterator4","_step4","byte","_prefixLengths$","_context7","toIterable"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/kad-dht/src/routing-table/refresh.ts"],"sourcesContent":["import { xor as uint8ArrayXor } from 'uint8arrays/xor'\nimport GENERATED_PREFIXES from './generated-prefix-list.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { randomBytes } from '@libp2p/crypto'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport { logger } from '@libp2p/logger'\nimport length from 'it-length'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } from '../constants.js'\nimport type { RoutingTable } from './index.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { PeerRouting } from '../peer-routing/index.js'\nimport type { Components, Initializable } from '@libp2p/components'\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15\n\nexport interface RoutingTableRefreshInit {\n  peerRouting: PeerRouting\n  routingTable: RoutingTable\n  lan: boolean\n  refreshInterval?: number\n  refreshQueryTimeout?: number\n}\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport class RoutingTableRefresh implements Initializable {\n  private readonly log: Logger\n  private readonly peerRouting: PeerRouting\n  private readonly routingTable: RoutingTable\n  private readonly refreshInterval: number\n  private readonly refreshQueryTimeout: number\n  private readonly commonPrefixLengthRefreshedAt: Date[]\n  private refreshTimeoutId?: NodeJS.Timer\n\n  constructor (init: RoutingTableRefreshInit) {\n    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan } = init\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table:refresh`)\n    this.peerRouting = peerRouting\n    this.routingTable = routingTable\n    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL\n    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT\n    this.commonPrefixLengthRefreshedAt = []\n\n    this.refreshTable = this.refreshTable.bind(this)\n  }\n\n  init (components: Components): void {\n\n  }\n\n  async start () {\n    this.log(`refreshing routing table every ${this.refreshInterval}ms`)\n    this.refreshTable(true)\n  }\n\n  async stop () {\n    if (this.refreshTimeoutId != null) {\n      clearTimeout(this.refreshTimeoutId)\n    }\n  }\n\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   */\n  refreshTable (force: boolean = false) {\n    this.log('refreshing routing table')\n\n    const prefixLength = this._maxCommonPrefix()\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength)\n\n    this.log(`max common prefix length ${prefixLength}`)\n    this.log(`tracked CPLs [ ${refreshCpls.map(date => date.toISOString()).join(', ')} ]`)\n\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n    Promise.all(\n      refreshCpls.map(async (lastRefresh, index) => {\n        try {\n          await this._refreshCommonPrefixLength(index, lastRefresh, force)\n\n          if (this._numPeersForCpl(prefixLength) === 0) {\n            const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1)\n\n            for (let n = index + 1; n < lastCpl + 1; n++) {\n              try {\n                await this._refreshCommonPrefixLength(n, lastRefresh, force)\n              } catch (err: any) {\n                this.log.error(err)\n              }\n            }\n          }\n        } catch (err: any) {\n          this.log.error(err)\n        }\n      })\n    ).catch(err => {\n      this.log.error(err)\n    }).then(() => {\n      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval)\n\n      if (this.refreshTimeoutId.unref != null) {\n        this.refreshTimeoutId.unref()\n      }\n    }).catch(err => {\n      this.log.error(err)\n    })\n  }\n\n  async _refreshCommonPrefixLength (cpl: number, lastRefresh: Date, force: boolean) {\n    if (!force && lastRefresh.getTime() > (Date.now() - this.refreshInterval)) {\n      this.log('not running refresh for cpl %s as time since last refresh not above interval', cpl)\n      return\n    }\n\n    // gen a key for the query to refresh the cpl\n    const peerId = await this._generateRandomPeerId(cpl)\n\n    this.log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this.routingTable.size)\n\n    const controller = new TimeoutController(this.refreshQueryTimeout)\n\n    try {\n      const peers = await length(this.peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }))\n\n      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId)\n      this.log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this.routingTable.size)\n    } finally {\n      controller.clear()\n    }\n  }\n\n  _getTrackedCommonPrefixLengthsForRefresh (maxCommonPrefix: number) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH\n    }\n\n    const dates = []\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? new Date()\n    }\n\n    return dates\n  }\n\n  async _generateRandomPeerId (targetCommonPrefixLength: number) {\n    if (this.routingTable.kb == null) {\n      throw new Error('Routing table not started')\n    }\n\n    const randomData = randomBytes(2)\n    const randomUint16 = (randomData[1] << 8) + randomData[0]\n\n    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength)\n\n    return peerIdFromBytes(key)\n  }\n\n  async _makePeerId (localKadId: Uint8Array, randomPrefix: number, targetCommonPrefixLength: number) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`)\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength)\n    const localPrefix = view.getUint16(0, false)\n\n    // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n    const toggledLocalPrefix = localPrefix ^ (0x8000 >> targetCommonPrefixLength)\n\n    // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n    const mask = 65535 << (16 - (targetCommonPrefixLength + 1))\n    const targetPrefix = (toggledLocalPrefix & mask) | (randomPrefix & ~mask)\n\n    // Convert to a known peer ID.\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix]\n\n    const keyBuffer = new ArrayBuffer(34)\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength)\n    keyView.setUint8(0, sha256.code)\n    keyView.setUint8(1, 32)\n    keyView.setUint32(2, keyPrefix, false)\n\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength)\n  }\n\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n  _maxCommonPrefix () {\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length\n      }\n    }\n\n    return prefixLength\n  }\n\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   */\n  _numPeersForCpl (prefixLength: number) {\n    let count = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++\n      }\n    }\n\n    return count\n  }\n\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n  * _prefixLengths () {\n    if (this.routingTable.kb == null) {\n      return\n    }\n\n    for (const { id } of this.routingTable.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.routingTable.kb.localNodeId, id)\n      let leadingZeros = 0\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++\n        } else {\n          break\n        }\n      }\n\n      yield leadingZeros\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}