{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { WantManager } from './want-manager/index.js';\nimport { Network } from './network.js';\nimport { DecisionEngine } from './decision-engine/index.js';\nimport { Notifications } from './notifications.js';\nimport { logger } from './utils/index.js';\nimport { Stats } from './stats/index.js';\nimport { anySignal } from 'any-signal';\nimport { BaseBlockstore } from 'blockstore-core/base';\nimport { CID } from 'multiformats/cid';\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n * @typedef {import('./message').BitswapMessage} BitswapMessage\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n */\n\nvar defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nvar statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nexport var Bitswap = /*#__PURE__*/function (_BaseBlockstore) {\n  _inherits(Bitswap, _BaseBlockstore);\n  var _super = _createSuper(Bitswap);\n  /**\n   * @param {import('libp2p').Libp2p} libp2p\n   * @param {Blockstore} blockstore\n   * @param {object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   */\n  function Bitswap(libp2p, blockstore) {\n    var _this3;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Bitswap);\n    _this3 = _super.call(this);\n    _this3._libp2p = libp2p;\n    _this3._log = logger(_this3.peerId);\n    _this3._options = Object.assign({}, defaultOptions, options);\n\n    // stats\n    _this3._stats = new Stats(libp2p, statsKeys, {\n      enabled: _this3._options.statsEnabled,\n      computeThrottleTimeout: _this3._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: _this3._options.statsComputeThrottleMaxQueueSize\n    });\n\n    // the network delivers messages\n    _this3.network = new Network(libp2p, _assertThisInitialized(_this3), _this3._stats, {\n      hashLoader: options.hashLoader,\n      maxInboundStreams: options.maxInboundStreams,\n      maxOutboundStreams: options.maxOutboundStreams,\n      incomingStreamTimeout: options.incomingStreamTimeout\n    });\n\n    // local database\n    _this3.blockstore = blockstore;\n    _this3.engine = new DecisionEngine(_this3.peerId, blockstore, _this3.network, _this3._stats, libp2p);\n\n    // handle message sending\n    _this3.wm = new WantManager(_this3.peerId, _this3.network, _this3._stats, libp2p);\n    _this3.notifications = new Notifications(_this3.peerId);\n    _this3.started = false;\n    return _this3;\n  }\n  _createClass(Bitswap, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n\n    /**\n     * @type {PeerId}\n     */\n  }, {\n    key: \"peerId\",\n    get: function get() {\n      return this._libp2p.peerId;\n    }\n\n    /**\n     * handle messages received through the network\n     *\n     * @param {PeerId} peerId\n     * @param {BitswapMessage} incoming\n     */\n  }, {\n    key: \"_receiveMessage\",\n    value: function () {\n      var _receiveMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, incoming) {\n        var _this4 = this;\n        var received, _iterator3, _step3, _step3$value, cidStr, data, cid;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return this.engine.messageReceived(peerId, incoming);\n            case 3:\n              _context.next = 8;\n              break;\n            case 5:\n              _context.prev = 5;\n              _context.t0 = _context[\"catch\"](0);\n              // Log instead of throwing an error so as to process as much as\n              // possible of the message. Currently `messageReceived` does not\n              // throw any errors, but this could change in the future.\n              this._log('failed to receive message', incoming);\n            case 8:\n              if (!(incoming.blocks.size === 0)) {\n                _context.next = 10;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 10:\n              /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n              received = [];\n              _iterator3 = _createForOfIteratorHelper(incoming.blocks.entries());\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _step3$value = _slicedToArray(_step3.value, 2), cidStr = _step3$value[0], data = _step3$value[1];\n                  cid = CID.parse(cidStr);\n                  received.push({\n                    wasWanted: this.wm.wantlist.contains(cid),\n                    cid: cid,\n                    data: data\n                  });\n                }\n\n                // quickly send out cancels, reduces chances of duplicate block receives\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              this.wm.cancelWants(received.filter(function (_ref) {\n                var wasWanted = _ref.wasWanted;\n                return wasWanted;\n              }).map(function (_ref2) {\n                var cid = _ref2.cid;\n                return cid;\n              }));\n              _context.next = 16;\n              return Promise.all(received.map(function (_ref3) {\n                var cid = _ref3.cid,\n                  wasWanted = _ref3.wasWanted,\n                  data = _ref3.data;\n                return _this4._handleReceivedBlock(peerId, cid, data, wasWanted);\n              }));\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n      function _receiveMessage(_x, _x2) {\n        return _receiveMessage2.apply(this, arguments);\n      }\n      return _receiveMessage;\n    }()\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @param {CID} cid\n     * @param {Uint8Array} data\n     * @param {boolean} wasWanted\n     */\n  }, {\n    key: \"_handleReceivedBlock\",\n    value: function () {\n      var _handleReceivedBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, cid, data, wasWanted) {\n        var has;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this._log('received block');\n              _context2.next = 3;\n              return this.blockstore.has(cid);\n            case 3:\n              has = _context2.sent;\n              this._updateReceiveCounters(peerId.toString(), cid, data, has);\n              if (wasWanted) {\n                _context2.next = 7;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 7:\n              _context2.next = 9;\n              return this.put(cid, data);\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _handleReceivedBlock(_x3, _x4, _x5, _x6) {\n        return _handleReceivedBlock2.apply(this, arguments);\n      }\n      return _handleReceivedBlock;\n    }()\n    /**\n     * @private\n     * @param {string} peerIdStr\n     * @param {CID} cid\n     * @param {Uint8Array} data\n     * @param {boolean} exists\n     */\n  }, {\n    key: \"_updateReceiveCounters\",\n    value: function _updateReceiveCounters(peerIdStr, cid, data, exists) {\n      this._stats.push(peerIdStr, 'blocksReceived', 1);\n      this._stats.push(peerIdStr, 'dataReceived', data.length);\n      if (exists) {\n        this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n        this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n      }\n    }\n\n    /**\n     * handle errors on the receiving channel\n     *\n     * @param {Error} err\n     */\n  }, {\n    key: \"_receiveError\",\n    value: function _receiveError(err) {\n      this._log.error('ReceiveError: %s', err.message);\n    }\n\n    /**\n     * handle new peers\n     *\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peerId) {\n      this.wm.connected(peerId);\n    }\n\n    /**\n     * handle peers being disconnected\n     *\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId) {\n      this.wm.disconnected(peerId);\n      this.engine.peerDisconnected(peerId);\n      this._stats.disconnected(peerId);\n    }\n  }, {\n    key: \"enableStats\",\n    value: function enableStats() {\n      this._stats.enable();\n    }\n  }, {\n    key: \"disableStats\",\n    value: function disableStats() {\n      this._stats.disable();\n    }\n\n    /**\n     * Return the current wantlist for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @param {any} [_options]\n     */\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId, _options) {\n      return this.engine.wantlistForPeer(peerId);\n    }\n\n    /**\n     * Return ledger information for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      return this.engine.ledgerForPeer(peerId);\n    }\n\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     *\n     * @param {CID} cid\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cid) {\n        var _this5 = this;\n        var options,\n          fetchFromNetwork,\n          promptedNetwork,\n          loadOrFetchFromNetwork,\n          controller,\n          signal,\n          block,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n              /**\n               * @param {CID} cid\n               * @param {object} options\n               * @param {AbortSignal} options.signal\n               */\n              fetchFromNetwork = function fetchFromNetwork(cid, options) {\n                // add it to the want list - n.b. later we will abort the AbortSignal\n                // so no need to remove the blocks from the wantlist after we have it\n                _this5.wm.wantBlocks([cid], options);\n                return _this5.notifications.wantBlock(cid, options);\n              };\n              promptedNetwork = false;\n              /**\n               *\n               * @param {CID} cid\n               * @param {object} options\n               * @param {AbortSignal} options.signal\n               */\n              loadOrFetchFromNetwork = /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid, options) {\n                  var block;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.prev = 0;\n                        _context3.next = 3;\n                        return _this5.blockstore.get(cid, options);\n                      case 3:\n                        block = _context3.sent;\n                        return _context3.abrupt(\"return\", block);\n                      case 7:\n                        _context3.prev = 7;\n                        _context3.t0 = _context3[\"catch\"](0);\n                        if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                          _context3.next = 11;\n                          break;\n                        }\n                        throw _context3.t0;\n                      case 11:\n                        if (!promptedNetwork) {\n                          promptedNetwork = true;\n                          _this5.network.findAndConnect(cid, options).catch(function (err) {\n                            return _this5._log.error(err);\n                          });\n                        }\n\n                        // we don't have the block locally so fetch it from the network\n                        return _context3.abrupt(\"return\", fetchFromNetwork(cid, options));\n                      case 13:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3, null, [[0, 7]]);\n                }));\n                return function loadOrFetchFromNetwork(_x8, _x9) {\n                  return _ref4.apply(this, arguments);\n                };\n              }(); // depending on implementation it's possible for blocks to come in while\n              // we do the async operations to get them from the blockstore leading to\n              // a race condition, so register for incoming block notifications as well\n              // as trying to get it from the datastore\n              controller = new AbortController();\n              signal = options.signal ? anySignal([options.signal, controller.signal]) : controller.signal;\n              _context4.prev = 6;\n              _context4.next = 9;\n              return Promise.race([this.notifications.wantBlock(cid, {\n                signal: signal\n              }), loadOrFetchFromNetwork(cid, {\n                signal: signal\n              })]);\n            case 9:\n              block = _context4.sent;\n              return _context4.abrupt(\"return\", block);\n            case 11:\n              _context4.prev = 11;\n              // since we have the block we can now remove our listener\n              controller.abort();\n              return _context4.finish(11);\n            case 14:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[6,, 11, 14]]);\n      }));\n      function get(_x7) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n    /**\n     * Fetch a a list of blocks by cid. If the blocks are in the local\n     * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n     *\n     * @param {AsyncIterable<CID>|Iterable<CID>} cids\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids) {\n      var _this = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context5.prev = 2;\n              _iterator = _asyncIterator(cids);\n            case 4:\n              _context5.next = 6;\n              return _awaitAsyncGenerator(_iterator.next());\n            case 6:\n              if (!(_iteratorAbruptCompletion = !(_step = _context5.sent).done)) {\n                _context5.next = 13;\n                break;\n              }\n              cid = _step.value;\n              _context5.next = 10;\n              return _this.get(cid, options);\n            case 10:\n              _iteratorAbruptCompletion = false;\n              _context5.next = 4;\n              break;\n            case 13:\n              _context5.next = 19;\n              break;\n            case 15:\n              _context5.prev = 15;\n              _context5.t0 = _context5[\"catch\"](2);\n              _didIteratorError = true;\n              _iteratorError = _context5.t0;\n            case 19:\n              _context5.prev = 19;\n              _context5.prev = 20;\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context5.next = 24;\n                break;\n              }\n              _context5.next = 24;\n              return _awaitAsyncGenerator(_iterator.return());\n            case 24:\n              _context5.prev = 24;\n              if (!_didIteratorError) {\n                _context5.next = 27;\n                break;\n              }\n              throw _iteratorError;\n            case 27:\n              return _context5.finish(24);\n            case 28:\n              return _context5.finish(19);\n            case 29:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n      }))();\n    }\n\n    /**\n     * Removes the given CIDs from the wantlist independent of any ref counts.\n     *\n     * This will cause all outstanding promises for a given block to reject.\n     *\n     * If you want to cancel the want for a block without doing that, pass an\n     * AbortSignal in to `.get` or `.getMany` and abort it.\n     *\n     * @param {CID[]|CID} cids\n     */\n  }, {\n    key: \"unwant\",\n    value: function unwant(cids) {\n      var _this6 = this;\n      var cidsArray = Array.isArray(cids) ? cids : [cids];\n      this.wm.unwantBlocks(cidsArray);\n      cidsArray.forEach(function (cid) {\n        return _this6.notifications.unwantBlock(cid);\n      });\n    }\n\n    /**\n     * Removes the given keys from the want list. This may cause pending promises\n     * for blocks to never resolve.  If you wish these promises to abort instead\n     * call `unwant(cids)` instead.\n     *\n     * @param {CID[]|CID} cids\n     */\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n    }\n\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     *\n     * @param {CID} cid\n     * @param {Uint8Array} block\n     * @param {any} [_options]\n     */\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(cid, block, _options) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.blockstore.put(cid, block);\n            case 2:\n              this._sendHaveBlockNotifications(cid, block);\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function put(_x10, _x11, _x12) {\n        return _put.apply(this, arguments);\n      }\n      return put;\n    }()\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     *\n     * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n     * @param {Options} [options]\n     */\n  }, {\n    key: \"putMany\",\n    value: function putMany(source, options) {\n      var _this2 = this;\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, key, value;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _iteratorAbruptCompletion2 = false;\n              _didIteratorError2 = false;\n              _context7.prev = 2;\n              _iterator2 = _asyncIterator(_this2.blockstore.putMany(source, options));\n            case 4:\n              _context7.next = 6;\n              return _awaitAsyncGenerator(_iterator2.next());\n            case 6:\n              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context7.sent).done)) {\n                _context7.next = 14;\n                break;\n              }\n              _step2$value = _step2.value, key = _step2$value.key, value = _step2$value.value;\n              _this2._sendHaveBlockNotifications(key, value);\n              _context7.next = 11;\n              return {\n                key: key,\n                value: value\n              };\n            case 11:\n              _iteratorAbruptCompletion2 = false;\n              _context7.next = 4;\n              break;\n            case 14:\n              _context7.next = 20;\n              break;\n            case 16:\n              _context7.prev = 16;\n              _context7.t0 = _context7[\"catch\"](2);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context7.t0;\n            case 20:\n              _context7.prev = 20;\n              _context7.prev = 21;\n              if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                _context7.next = 25;\n                break;\n              }\n              _context7.next = 25;\n              return _awaitAsyncGenerator(_iterator2.return());\n            case 25:\n              _context7.prev = 25;\n              if (!_didIteratorError2) {\n                _context7.next = 28;\n                break;\n              }\n              throw _iteratorError2;\n            case 28:\n              return _context7.finish(25);\n            case 29:\n              return _context7.finish(20);\n            case 30:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, null, [[2, 16, 20, 30], [21,, 25, 29]]);\n      }))();\n    }\n\n    /**\n     * Sends notifications about the arrival of a block\n     *\n     * @private\n     * @param {CID} cid\n     * @param {Uint8Array} data\n     */\n  }, {\n    key: \"_sendHaveBlockNotifications\",\n    value: function _sendHaveBlockNotifications(cid, data) {\n      var _this7 = this;\n      this.notifications.hasBlock(cid, data);\n      this.engine.receivedBlocks([{\n        cid: cid,\n        data: data\n      }]);\n      // Note: Don't wait for provide to finish before returning\n      this.network.provide(cid).catch(function (err) {\n        _this7._log.error('Failed to provide: %s', err.message);\n      });\n    }\n\n    /**\n     * Get the current list of wants\n     */\n  }, {\n    key: \"getWantlist\",\n    value: function getWantlist() {\n      return this.wm.wantlist.entries();\n    }\n\n    /**\n     * Get the current list of partners\n     */\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return this.engine.peers();\n    }\n\n    /**\n     * Get stats about the bitswap node\n     */\n  }, {\n    key: \"stat\",\n    value: function stat() {\n      return this._stats;\n    }\n\n    /**\n     * Start the bitswap node\n     */\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              this.wm.start();\n              _context8.next = 3;\n              return this.network.start();\n            case 3:\n              this.engine.start();\n              this.started = true;\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n    /**\n     * Stop the bitswap node\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              this._stats.stop();\n              this.wm.stop();\n              _context9.next = 4;\n              return this.network.stop();\n            case 4:\n              this.engine.stop();\n              this.started = false;\n            case 6:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      return this.blockstore;\n    }\n  }]);\n  return Bitswap;\n}(BaseBlockstore);","map":{"version":3,"names":["WantManager","Network","DecisionEngine","Notifications","logger","Stats","anySignal","BaseBlockstore","CID","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","_BaseBlockstore","_inherits","_super","_createSuper","libp2p","blockstore","_this3","options","arguments","length","undefined","_classCallCheck","call","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","_assertThisInitialized","hashLoader","maxInboundStreams","maxOutboundStreams","incomingStreamTimeout","engine","wm","notifications","started","_createClass","key","value","isStarted","get","_receiveMessage2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","incoming","_this4","received","_iterator3","_step3","_step3$value","cidStr","data","cid","wrap","_callee$","_context","prev","next","messageReceived","t0","blocks","size","abrupt","_createForOfIteratorHelper","entries","s","n","done","_slicedToArray","parse","push","wasWanted","wantlist","contains","err","e","f","cancelWants","filter","_ref","map","_ref2","Promise","all","_ref3","_handleReceivedBlock","stop","_receiveMessage","_x","_x2","apply","_handleReceivedBlock2","_callee2","has","_callee2$","_context2","sent","_updateReceiveCounters","toString","put","_x3","_x4","_x5","_x6","peerIdStr","exists","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","_get","_callee4","_this5","fetchFromNetwork","promptedNetwork","loadOrFetchFromNetwork","controller","signal","block","_args4","_callee4$","_context4","wantBlocks","wantBlock","_ref4","_callee3","_callee3$","_context3","code","findAndConnect","catch","_x8","_x9","AbortController","race","abort","finish","_x7","getMany","cids","_this","_wrapAsyncGenerator","_callee5","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","_callee5$","_context5","_asyncIterator","_awaitAsyncGenerator","return","unwant","_this6","cidsArray","Array","isArray","unwantBlocks","forEach","unwantBlock","_put","_callee6","_callee6$","_context6","_sendHaveBlockNotifications","_x10","_x11","_x12","putMany","source","_this2","_callee7","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_step2$value","_callee7$","_context7","_this7","hasBlock","receivedBlocks","provide","getWantlist","peers","stat","_start","_callee8","_callee8$","_context8","start","_stop","_callee9","_callee9$","_context9","unwrap"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-bitswap/src/bitswap.js"],"sourcesContent":["import { WantManager } from './want-manager/index.js'\nimport { Network } from './network.js'\nimport { DecisionEngine } from './decision-engine/index.js'\nimport { Notifications } from './notifications.js'\nimport { logger } from './utils/index.js'\nimport { Stats } from './stats/index.js'\nimport { anySignal } from 'any-signal'\nimport { BaseBlockstore } from 'blockstore-core/base'\nimport { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n * @typedef {import('./message').BitswapMessage} BitswapMessage\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nexport class Bitswap extends BaseBlockstore {\n  /**\n   * @param {import('libp2p').Libp2p} libp2p\n   * @param {Blockstore} blockstore\n   * @param {object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   */\n  constructor (libp2p, blockstore, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(libp2p, statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, this._stats, {\n      hashLoader: options.hashLoader,\n      maxInboundStreams: options.maxInboundStreams,\n      maxOutboundStreams: options.maxOutboundStreams,\n      incomingStreamTimeout: options.incomingStreamTimeout\n    })\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p)\n\n    this.notifications = new Notifications(this.peerId)\n\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * @type {PeerId}\n   */\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n    const received = []\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      })\n    }\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    this.wm.cancelWants(\n      received\n        .filter(({ wasWanted }) => wasWanted)\n        .map(({ cid }) => cid)\n    )\n\n    await Promise.all(\n      received.map(\n        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)\n      )\n    )\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n  async _handleReceivedBlock (peerId, cid, data, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(cid)\n\n    this._updateReceiveCounters(peerId.toString(), cid, data, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(cid, data)\n  }\n\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n  _updateReceiveCounters (peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1)\n    this._stats.push(peerIdStr, 'dataReceived', data.length)\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1)\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length)\n    }\n  }\n\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  enableStats () {\n    this._stats.enable()\n  }\n\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n  wantlistForPeer (peerId, _options) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async get (cid, options = {}) {\n    /**\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (/** @type {any} */ err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid, options)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = options.signal\n      ? anySignal([options.signal, controller.signal])\n      : controller.signal\n\n    try {\n      const block = await Promise.race([\n        this.notifications.wantBlock(cid, {\n          signal\n        }),\n        loadOrFetchFromNetwork(cid, {\n          signal\n        })\n      ])\n\n      return block\n    } finally {\n      // since we have the block we can now remove our listener\n      controller.abort()\n    }\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n  unwant (cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids]\n\n    this.wm.unwantBlocks(cidsArray)\n    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n  cancelWants (cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids])\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n  async put (cid, block, _options) {\n    await this.blockstore.put(cid, block)\n    this._sendHaveBlockNotifications(cid, block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n  async * putMany (source, options) {\n    for await (const { key, value } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value)\n\n      yield { key, value }\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n  _sendHaveBlockNotifications (cid, data) {\n    this.notifications.hasBlock(cid, data)\n    this.engine.receivedBlocks([{ cid, data }])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node\n   */\n  async start () {\n    this.wm.start()\n    await this.network.start()\n    this.engine.start()\n    this.started = true\n  }\n\n  /**\n   * Stop the bitswap node\n   */\n  async stop () {\n    this._stats.stop()\n    this.wm.stop()\n    await this.network.stop()\n    this.engine.stop()\n    this.started = false\n  }\n\n  unwrap () {\n    return this.blockstore\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}