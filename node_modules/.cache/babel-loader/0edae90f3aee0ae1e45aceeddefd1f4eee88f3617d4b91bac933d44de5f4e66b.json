{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport mergeOptions from 'merge-options';\nimport { LatencyMonitor } from './latency-monitor.js';\n// @ts-expect-error retimer does not have types\nimport retimer from 'retimer';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { codes } from '../errors.js';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport { setMaxListeners } from 'events';\nimport { Components } from '@libp2p/components';\nimport * as STATUS from '@libp2p/interface-connection/status';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { KEEP_ALIVE } from '@libp2p/interface-peer-store/tags';\nvar log = logger('libp2p:connection-manager');\nvar defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000\n};\nvar METRICS_SYSTEM = 'libp2p';\nvar METRICS_COMPONENT = 'connection-manager';\nvar STARTUP_RECONNECT_TIMEOUT = 60000;\n/**\n * Responsible for managing known connections.\n */\nexport var DefaultConnectionManager = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(DefaultConnectionManager, _EventEmitter);\n  var _super = _createSuper(DefaultConnectionManager);\n  function DefaultConnectionManager(init) {\n    var _init$startupReconnec, _init$dialTimeout;\n    var _this;\n    _classCallCheck(this, DefaultConnectionManager);\n    _this = _super.call(this);\n    _this.components = new Components();\n    _this.opts = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, init);\n    if (_this.opts.maxConnections < _this.opts.minConnections) {\n      throw errCode(new Error('Connection Manager maxConnections must be greater than minConnections'), codes.ERR_INVALID_PARAMETERS);\n    }\n    log('options: %o', _this.opts);\n    /**\n     * Map of connections per peer\n     */\n    _this.connections = new Map();\n    _this.started = false;\n    _this._checkMetrics = _this._checkMetrics.bind(_assertThisInitialized(_this));\n    _this.latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: init.pollInterval,\n      dataEmitIntervalMs: init.pollInterval\n    });\n    try {\n      // This emitter gets listened to a lot\n      setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, _assertThisInitialized(_this));\n    } catch (_unused) {}\n    _this.onConnect = _this.onConnect.bind(_assertThisInitialized(_this));\n    _this.onDisconnect = _this.onDisconnect.bind(_assertThisInitialized(_this));\n    _this.startupReconnectTimeout = (_init$startupReconnec = init.startupReconnectTimeout) !== null && _init$startupReconnec !== void 0 ? _init$startupReconnec : STARTUP_RECONNECT_TIMEOUT;\n    _this.dialTimeout = (_init$dialTimeout = init.dialTimeout) !== null && _init$dialTimeout !== void 0 ? _init$dialTimeout : 30000;\n    return _this;\n  }\n  _createClass(DefaultConnectionManager, [{\n    key: \"init\",\n    value: function init(components) {\n      var _this$components$getM,\n        _this2 = this,\n        _this$components$getM2,\n        _this$components$getM3;\n      this.components = components;\n      // track inbound/outbound connections\n      (_this$components$getM = this.components.getMetrics()) === null || _this$components$getM === void 0 ? void 0 : _this$components$getM.updateComponentMetric({\n        system: METRICS_SYSTEM,\n        component: METRICS_COMPONENT,\n        metric: 'connections',\n        label: 'direction',\n        value: function value() {\n          var metric = {\n            inbound: 0,\n            outbound: 0\n          };\n          var _iterator = _createForOfIteratorHelper(_this2.connections.values()),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var conns = _step.value;\n              var _iterator2 = _createForOfIteratorHelper(conns),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var conn = _step2.value;\n                  if (conn.stat.direction === 'inbound') {\n                    metric.inbound++;\n                  } else {\n                    metric.outbound++;\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          return metric;\n        }\n      });\n      // track total number of streams per protocol\n      (_this$components$getM2 = this.components.getMetrics()) === null || _this$components$getM2 === void 0 ? void 0 : _this$components$getM2.updateComponentMetric({\n        system: METRICS_SYSTEM,\n        component: METRICS_COMPONENT,\n        metric: 'protocol-streams-total',\n        label: 'protocol',\n        value: function value() {\n          var metric = {};\n          var _iterator3 = _createForOfIteratorHelper(_this2.connections.values()),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var conns = _step3.value;\n              var _iterator4 = _createForOfIteratorHelper(conns),\n                _step4;\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var conn = _step4.value;\n                  var _iterator5 = _createForOfIteratorHelper(conn.streams),\n                    _step5;\n                  try {\n                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                      var _stream$stat$protocol, _metric$key;\n                      var stream = _step5.value;\n                      var key = \"\".concat(stream.stat.direction, \" \").concat((_stream$stat$protocol = stream.stat.protocol) !== null && _stream$stat$protocol !== void 0 ? _stream$stat$protocol : 'unnegotiated');\n                      metric[key] = ((_metric$key = metric[key]) !== null && _metric$key !== void 0 ? _metric$key : 0) + 1;\n                    }\n                  } catch (err) {\n                    _iterator5.e(err);\n                  } finally {\n                    _iterator5.f();\n                  }\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return metric;\n        }\n      });\n      // track 90th percentile of streams per protocol\n      (_this$components$getM3 = this.components.getMetrics()) === null || _this$components$getM3 === void 0 ? void 0 : _this$components$getM3.updateComponentMetric({\n        system: METRICS_SYSTEM,\n        component: METRICS_COMPONENT,\n        metric: 'protocol-streams-per-connection-90th-percentile',\n        label: 'protocol',\n        value: function value() {\n          var allStreams = {};\n          var _iterator6 = _createForOfIteratorHelper(_this2.connections.values()),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var conns = _step6.value;\n              var _iterator7 = _createForOfIteratorHelper(conns),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var conn = _step7.value;\n                  var streams = {};\n                  var _iterator8 = _createForOfIteratorHelper(conn.streams),\n                    _step8;\n                  try {\n                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                      var _stream$stat$protocol2, _streams$key;\n                      var stream = _step8.value;\n                      var key = \"\".concat(stream.stat.direction, \" \").concat((_stream$stat$protocol2 = stream.stat.protocol) !== null && _stream$stat$protocol2 !== void 0 ? _stream$stat$protocol2 : 'unnegotiated');\n                      streams[key] = ((_streams$key = streams[key]) !== null && _streams$key !== void 0 ? _streams$key : 0) + 1;\n                    }\n                  } catch (err) {\n                    _iterator8.e(err);\n                  } finally {\n                    _iterator8.f();\n                  }\n                  for (var _i2 = 0, _Object$entries2 = Object.entries(streams); _i2 < _Object$entries2.length; _i2++) {\n                    var _allStreams$_protocol;\n                    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n                      _protocol = _Object$entries2$_i[0],\n                      count = _Object$entries2$_i[1];\n                    allStreams[_protocol] = (_allStreams$_protocol = allStreams[_protocol]) !== null && _allStreams$_protocol !== void 0 ? _allStreams$_protocol : [];\n                    allStreams[_protocol].push(count);\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          var metric = {};\n          for (var _i = 0, _Object$entries = Object.entries(allStreams); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              protocol = _Object$entries$_i[0],\n              counts = _Object$entries$_i[1];\n            counts = counts.sort(function (a, b) {\n              return a - b;\n            });\n            var index = Math.floor(counts.length * 0.9);\n            metric[protocol] = counts[index];\n          }\n          return metric;\n        }\n      });\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n    /**\n     * Starts the Connection Manager. If Metrics are not enabled on libp2p\n     * only event loop and connection limits will be monitored.\n     */\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this$timer;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.components.getMetrics() != null) {\n                this.timer = (_this$timer = this.timer) !== null && _this$timer !== void 0 ? _this$timer : retimer(this._checkMetrics, this.opts.pollInterval);\n              }\n              // latency monitor\n              this.latencyMonitor.start();\n              this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n              this.latencyMonitor.addEventListener('data', this._onLatencyMeasure);\n              this.started = true;\n              log('started');\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"afterStart\",\n    value: function () {\n      var _afterStart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              this.components.getUpgrader().addEventListener('connection', this.onConnect);\n              this.components.getUpgrader().addEventListener('connectionEnd', this.onDisconnect);\n              // re-connect to any peers with the KEEP_ALIVE tag\n              void Promise.resolve().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                var _this3$connectOnStart;\n                var keepAlivePeers, _iterator9, _step9, peer, tags, hasKeepAlive;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      keepAlivePeers = [];\n                      _context3.t0 = _createForOfIteratorHelper;\n                      _context3.next = 4;\n                      return _this3.components.getPeerStore().all();\n                    case 4:\n                      _context3.t1 = _context3.sent;\n                      _iterator9 = (0, _context3.t0)(_context3.t1);\n                      _context3.prev = 6;\n                      _iterator9.s();\n                    case 8:\n                      if ((_step9 = _iterator9.n()).done) {\n                        _context3.next = 17;\n                        break;\n                      }\n                      peer = _step9.value;\n                      _context3.next = 12;\n                      return _this3.components.getPeerStore().getTags(peer.id);\n                    case 12:\n                      tags = _context3.sent;\n                      hasKeepAlive = tags.filter(function (tag) {\n                        return tag.name === KEEP_ALIVE;\n                      }).length > 0;\n                      if (hasKeepAlive) {\n                        keepAlivePeers.push(peer.id);\n                      }\n                    case 15:\n                      _context3.next = 8;\n                      break;\n                    case 17:\n                      _context3.next = 22;\n                      break;\n                    case 19:\n                      _context3.prev = 19;\n                      _context3.t2 = _context3[\"catch\"](6);\n                      _iterator9.e(_context3.t2);\n                    case 22:\n                      _context3.prev = 22;\n                      _iterator9.f();\n                      return _context3.finish(22);\n                    case 25:\n                      (_this3$connectOnStart = _this3.connectOnStartupController) === null || _this3$connectOnStart === void 0 ? void 0 : _this3$connectOnStart.clear();\n                      _this3.connectOnStartupController = new TimeoutController(_this3.startupReconnectTimeout);\n                      try {\n                        // fails on node < 15.4\n                        setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, _this3.connectOnStartupController.signal);\n                      } catch (_unused2) {}\n                      _context3.next = 30;\n                      return Promise.all(keepAlivePeers.map( /*#__PURE__*/function () {\n                        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peer) {\n                          var _this3$connectOnStart2;\n                          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                            while (1) switch (_context2.prev = _context2.next) {\n                              case 0:\n                                _context2.next = 2;\n                                return _this3.openConnection(peer, {\n                                  signal: (_this3$connectOnStart2 = _this3.connectOnStartupController) === null || _this3$connectOnStart2 === void 0 ? void 0 : _this3$connectOnStart2.signal\n                                }).catch(function (err) {\n                                  log.error(err);\n                                });\n                              case 2:\n                              case \"end\":\n                                return _context2.stop();\n                            }\n                          }, _callee2);\n                        }));\n                        return function (_x) {\n                          return _ref2.apply(this, arguments);\n                        };\n                      }()));\n                    case 30:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3, null, [[6, 19, 22, 25]]);\n              }))).catch(function (err) {\n                log.error(err);\n              }).finally(function () {\n                var _this3$connectOnStart3;\n                (_this3$connectOnStart3 = _this3.connectOnStartupController) === null || _this3$connectOnStart3 === void 0 ? void 0 : _this3$connectOnStart3.clear();\n              });\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function afterStart() {\n        return _afterStart.apply(this, arguments);\n      }\n      return afterStart;\n    }()\n  }, {\n    key: \"beforeStop\",\n    value: function () {\n      var _beforeStop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this$connectOnStartu;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              // if we are still dialing KEEP_ALIVE peers, abort those dials\n              (_this$connectOnStartu = this.connectOnStartupController) === null || _this$connectOnStartu === void 0 ? void 0 : _this$connectOnStartu.abort();\n              this.components.getUpgrader().removeEventListener('connection', this.onConnect);\n              this.components.getUpgrader().removeEventListener('connectionEnd', this.onDisconnect);\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function beforeStop() {\n        return _beforeStop.apply(this, arguments);\n      }\n      return beforeStop;\n    }()\n    /**\n     * Stops the Connection Manager\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this$timer2;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              (_this$timer2 = this.timer) === null || _this$timer2 === void 0 ? void 0 : _this$timer2.clear();\n              this.latencyMonitor.removeEventListener('data', this._onLatencyMeasure);\n              this.latencyMonitor.stop();\n              this.started = false;\n              _context6.next = 6;\n              return this._close();\n            case 6:\n              log('stopped');\n            case 7:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Cleans up the connections\n     */\n  }, {\n    key: \"_close\",\n    value: function () {\n      var _close2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var tasks, _iterator10, _step10, connectionList, _iterator11, _step11, _loop;\n        return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              // Close all connections we're tracking\n              tasks = [];\n              _iterator10 = _createForOfIteratorHelper(this.connections.values());\n              _context9.prev = 2;\n              _iterator10.s();\n            case 4:\n              if ((_step10 = _iterator10.n()).done) {\n                _context9.next = 24;\n                break;\n              }\n              connectionList = _step10.value;\n              _iterator11 = _createForOfIteratorHelper(connectionList);\n              _context9.prev = 7;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var connection;\n                return _regeneratorRuntime().wrap(function _loop$(_context8) {\n                  while (1) switch (_context8.prev = _context8.next) {\n                    case 0:\n                      connection = _step11.value;\n                      tasks.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n                        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                          while (1) switch (_context7.prev = _context7.next) {\n                            case 0:\n                              _context7.prev = 0;\n                              _context7.next = 3;\n                              return connection.close();\n                            case 3:\n                              _context7.next = 8;\n                              break;\n                            case 5:\n                              _context7.prev = 5;\n                              _context7.t0 = _context7[\"catch\"](0);\n                              log.error(_context7.t0);\n                            case 8:\n                            case \"end\":\n                              return _context7.stop();\n                          }\n                        }, _callee7, null, [[0, 5]]);\n                      }))());\n                    case 2:\n                    case \"end\":\n                      return _context8.stop();\n                  }\n                }, _loop);\n              });\n              _iterator11.s();\n            case 10:\n              if ((_step11 = _iterator11.n()).done) {\n                _context9.next = 14;\n                break;\n              }\n              return _context9.delegateYield(_loop(), \"t0\", 12);\n            case 12:\n              _context9.next = 10;\n              break;\n            case 14:\n              _context9.next = 19;\n              break;\n            case 16:\n              _context9.prev = 16;\n              _context9.t1 = _context9[\"catch\"](7);\n              _iterator11.e(_context9.t1);\n            case 19:\n              _context9.prev = 19;\n              _iterator11.f();\n              return _context9.finish(19);\n            case 22:\n              _context9.next = 4;\n              break;\n            case 24:\n              _context9.next = 29;\n              break;\n            case 26:\n              _context9.prev = 26;\n              _context9.t2 = _context9[\"catch\"](2);\n              _iterator10.e(_context9.t2);\n            case 29:\n              _context9.prev = 29;\n              _iterator10.f();\n              return _context9.finish(29);\n            case 32:\n              log('closing %d connections', tasks.length);\n              _context9.next = 35;\n              return Promise.all(tasks);\n            case 35:\n              this.connections.clear();\n            case 36:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee8, this, [[2, 26, 29, 32], [7, 16, 19, 22]]);\n      }));\n      function _close() {\n        return _close2.apply(this, arguments);\n      }\n      return _close;\n    }()\n    /**\n     * Checks the libp2p metrics to determine if any values have exceeded\n     * the configured maximums.\n     *\n     * @private\n     */\n  }, {\n    key: \"_checkMetrics\",\n    value: function () {\n      var _checkMetrics2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var metrics, movingAverages, received, sent, total;\n        return _regeneratorRuntime().wrap(function _callee9$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              metrics = this.components.getMetrics();\n              if (!(metrics != null)) {\n                _context10.next = 17;\n                break;\n              }\n              _context10.prev = 2;\n              movingAverages = metrics.getGlobal().getMovingAverages();\n              received = movingAverages.dataReceived[this.opts.movingAverageInterval].movingAverage;\n              _context10.next = 7;\n              return this._checkMaxLimit('maxReceivedData', received);\n            case 7:\n              sent = movingAverages.dataSent[this.opts.movingAverageInterval].movingAverage;\n              _context10.next = 10;\n              return this._checkMaxLimit('maxSentData', sent);\n            case 10:\n              total = received + sent;\n              _context10.next = 13;\n              return this._checkMaxLimit('maxData', total);\n            case 13:\n              log.trace('metrics update', total);\n            case 14:\n              _context10.prev = 14;\n              this.timer = retimer(this._checkMetrics, this.opts.pollInterval);\n              return _context10.finish(14);\n            case 17:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee9, this, [[2,, 14, 17]]);\n      }));\n      function _checkMetrics() {\n        return _checkMetrics2.apply(this, arguments);\n      }\n      return _checkMetrics;\n    }()\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(evt) {\n      void this._onConnect(evt).catch(function (err) {\n        log.error(err);\n      });\n    }\n    /**\n     * Tracks the incoming connection and check the connection limit\n     */\n  }, {\n    key: \"_onConnect\",\n    value: function () {\n      var _onConnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(evt) {\n        var connection, peerId, peerIdStr, storedConns, numConnections, toPrune;\n        return _regeneratorRuntime().wrap(function _callee10$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              connection = evt.detail;\n              if (this.started) {\n                _context11.next = 5;\n                break;\n              }\n              _context11.next = 4;\n              return connection.close();\n            case 4:\n              return _context11.abrupt(\"return\");\n            case 5:\n              peerId = connection.remotePeer;\n              peerIdStr = peerId.toString();\n              storedConns = this.connections.get(peerIdStr);\n              if (storedConns != null) {\n                storedConns.push(connection);\n              } else {\n                this.connections.set(peerIdStr, [connection]);\n              }\n              if (!(peerId.publicKey != null)) {\n                _context11.next = 12;\n                break;\n              }\n              _context11.next = 12;\n              return this.components.getPeerStore().keyBook.set(peerId, peerId.publicKey);\n            case 12:\n              numConnections = this.getConnections().length;\n              toPrune = numConnections - this.opts.maxConnections;\n              _context11.next = 16;\n              return this._checkMaxLimit('maxConnections', numConnections, toPrune);\n            case 16:\n              this.dispatchEvent(new CustomEvent('peer:connect', {\n                detail: connection\n              }));\n            case 17:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee10, this);\n      }));\n      function _onConnect(_x2) {\n        return _onConnect2.apply(this, arguments);\n      }\n      return _onConnect;\n    }()\n    /**\n     * Removes the connection from tracking\n     */\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(evt) {\n      var connection = evt.detail;\n      if (!this.started) {\n        // This can happen when we are in the process of shutting down the node\n        return;\n      }\n      var peerId = connection.remotePeer.toString();\n      var storedConn = this.connections.get(peerId);\n      if (storedConn != null && storedConn.length > 1) {\n        storedConn = storedConn.filter(function (conn) {\n          return conn.id !== connection.id;\n        });\n        this.connections.set(peerId, storedConn);\n      } else if (storedConn != null) {\n        var _this$components$getM4;\n        this.connections.delete(peerId);\n        this.dispatchEvent(new CustomEvent('peer:disconnect', {\n          detail: connection\n        }));\n        (_this$components$getM4 = this.components.getMetrics()) === null || _this$components$getM4 === void 0 ? void 0 : _this$components$getM4.onPeerDisconnected(connection.remotePeer);\n      }\n    }\n  }, {\n    key: \"getConnections\",\n    value: function getConnections(peerId) {\n      if (peerId != null) {\n        var _this$connections$get;\n        return (_this$connections$get = this.connections.get(peerId.toString())) !== null && _this$connections$get !== void 0 ? _this$connections$get : [];\n      }\n      var conns = [];\n      var _iterator12 = _createForOfIteratorHelper(this.connections.values()),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var c = _step12.value;\n          conns = conns.concat(c);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      return conns;\n    }\n  }, {\n    key: \"openConnection\",\n    value: function () {\n      var _openConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(peerId) {\n        var options,\n          existingConnections,\n          timeoutController,\n          connection,\n          peerConnections,\n          trackedConnection,\n          _iterator13,\n          _step13,\n          conn,\n          _args12 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              options = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};\n              log('dial to %p', peerId);\n              existingConnections = this.getConnections(peerId);\n              if (!(existingConnections.length > 0)) {\n                _context12.next = 6;\n                break;\n              }\n              log('had an existing connection to %p', peerId);\n              return _context12.abrupt(\"return\", existingConnections[0]);\n            case 6:\n              if ((options === null || options === void 0 ? void 0 : options.signal) == null) {\n                timeoutController = new TimeoutController(this.dialTimeout);\n                options.signal = timeoutController.signal;\n                try {\n                  // fails on node < 15.4\n                  setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, timeoutController.signal);\n                } catch (_unused3) {}\n              }\n              _context12.prev = 7;\n              _context12.next = 10;\n              return this.components.getDialer().dial(peerId, options);\n            case 10:\n              connection = _context12.sent;\n              peerConnections = this.connections.get(peerId.toString());\n              if (peerConnections == null) {\n                peerConnections = [];\n                this.connections.set(peerId.toString(), peerConnections);\n              }\n              // we get notified of connections via the Upgrader emitting \"connection\"\n              // events, double check we aren't already tracking this connection before\n              // storing it\n              trackedConnection = false;\n              _iterator13 = _createForOfIteratorHelper(peerConnections);\n              try {\n                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                  conn = _step13.value;\n                  if (conn.id === connection.id) {\n                    trackedConnection = true;\n                  }\n                }\n              } catch (err) {\n                _iterator13.e(err);\n              } finally {\n                _iterator13.f();\n              }\n              if (!trackedConnection) {\n                peerConnections.push(connection);\n              }\n              return _context12.abrupt(\"return\", connection);\n            case 18:\n              _context12.prev = 18;\n              if (timeoutController != null) {\n                timeoutController.clear();\n              }\n              return _context12.finish(18);\n            case 21:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee11, this, [[7,, 18, 21]]);\n      }));\n      function openConnection(_x3) {\n        return _openConnection.apply(this, arguments);\n      }\n      return openConnection;\n    }()\n  }, {\n    key: \"closeConnections\",\n    value: function () {\n      var _closeConnections = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(peerId) {\n        var _this$connections$get2;\n        var connections;\n        return _regeneratorRuntime().wrap(function _callee13$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              connections = (_this$connections$get2 = this.connections.get(peerId.toString())) !== null && _this$connections$get2 !== void 0 ? _this$connections$get2 : [];\n              _context14.next = 3;\n              return Promise.all(connections.map( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(connection) {\n                  return _regeneratorRuntime().wrap(function _callee12$(_context13) {\n                    while (1) switch (_context13.prev = _context13.next) {\n                      case 0:\n                        _context13.next = 2;\n                        return connection.close();\n                      case 2:\n                        return _context13.abrupt(\"return\", _context13.sent);\n                      case 3:\n                      case \"end\":\n                        return _context13.stop();\n                    }\n                  }, _callee12);\n                }));\n                return function (_x5) {\n                  return _ref4.apply(this, arguments);\n                };\n              }()));\n            case 3:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee13, this);\n      }));\n      function closeConnections(_x4) {\n        return _closeConnections.apply(this, arguments);\n      }\n      return closeConnections;\n    }()\n    /**\n     * Get all open connections with a peer\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll(peerId) {\n      if (!isPeerId(peerId)) {\n        throw errCode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n      }\n      var id = peerId.toString();\n      var connections = this.connections.get(id);\n      // Return all open connections\n      if (connections != null) {\n        return connections.filter(function (connection) {\n          return connection.stat.status === STATUS.OPEN;\n        });\n      }\n      return [];\n    }\n    /**\n     * If the event loop is slow, maybe close a connection\n     */\n  }, {\n    key: \"_onLatencyMeasure\",\n    value: function _onLatencyMeasure(evt) {\n      var summary = evt.detail;\n      this._checkMaxLimit('maxEventLoopDelay', summary.avgMs, 1).catch(function (err) {\n        log.error(err);\n      });\n    }\n    /**\n     * If the `value` of `name` has exceeded its limit, maybe close a connection\n     */\n  }, {\n    key: \"_checkMaxLimit\",\n    value: function () {\n      var _checkMaxLimit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(name, value) {\n        var toPrune,\n          limit,\n          _args15 = arguments;\n        return _regeneratorRuntime().wrap(function _callee14$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              toPrune = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : 1;\n              limit = this.opts[name];\n              log.trace('checking limit of %s. current value: %d of %d', name, value, limit);\n              if (!(value > limit)) {\n                _context15.next = 7;\n                break;\n              }\n              log('%s: limit exceeded: %p, %d/%d, pruning %d connection(s)', this.components.getPeerId(), name, value, limit, toPrune);\n              _context15.next = 7;\n              return this._maybePruneConnections(toPrune);\n            case 7:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee14, this);\n      }));\n      function _checkMaxLimit(_x6, _x7) {\n        return _checkMaxLimit2.apply(this, arguments);\n      }\n      return _checkMaxLimit;\n    }()\n    /**\n     * If we have more connections than our maximum, select some excess connections\n     * to prune based on peer value\n     */\n  }, {\n    key: \"_maybePruneConnections\",\n    value: function () {\n      var _maybePruneConnections2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(toPrune) {\n        var _this4 = this;\n        var connections, peerValues, _iterator14, _step14, connection, remotePeer, tags, sortedConnections, toClose, _iterator15, _step15, _connection;\n        return _regeneratorRuntime().wrap(function _callee16$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              connections = this.getConnections();\n              if (!(connections.length <= this.opts.minConnections || toPrune < 1)) {\n                _context17.next = 3;\n                break;\n              }\n              return _context17.abrupt(\"return\");\n            case 3:\n              peerValues = new PeerMap(); // work out peer values\n              _iterator14 = _createForOfIteratorHelper(connections);\n              _context17.prev = 5;\n              _iterator14.s();\n            case 7:\n              if ((_step14 = _iterator14.n()).done) {\n                _context17.next = 18;\n                break;\n              }\n              connection = _step14.value;\n              remotePeer = connection.remotePeer;\n              if (!peerValues.has(remotePeer)) {\n                _context17.next = 12;\n                break;\n              }\n              return _context17.abrupt(\"continue\", 16);\n            case 12:\n              _context17.next = 14;\n              return this.components.getPeerStore().getTags(remotePeer);\n            case 14:\n              tags = _context17.sent;\n              // sum all tag values\n              peerValues.set(remotePeer, tags.reduce(function (acc, curr) {\n                return acc + curr.value;\n              }, 0));\n            case 16:\n              _context17.next = 7;\n              break;\n            case 18:\n              _context17.next = 23;\n              break;\n            case 20:\n              _context17.prev = 20;\n              _context17.t0 = _context17[\"catch\"](5);\n              _iterator14.e(_context17.t0);\n            case 23:\n              _context17.prev = 23;\n              _iterator14.f();\n              return _context17.finish(23);\n            case 26:\n              // sort by value, lowest to highest\n              sortedConnections = connections.sort(function (a, b) {\n                var _peerValues$get, _peerValues$get2;\n                var peerAValue = (_peerValues$get = peerValues.get(a.remotePeer)) !== null && _peerValues$get !== void 0 ? _peerValues$get : 0;\n                var peerBValue = (_peerValues$get2 = peerValues.get(b.remotePeer)) !== null && _peerValues$get2 !== void 0 ? _peerValues$get2 : 0;\n                if (peerAValue > peerBValue) {\n                  return 1;\n                }\n                if (peerAValue < peerBValue) {\n                  return -1;\n                }\n                return 0;\n              }); // close some connections\n              toClose = [];\n              _iterator15 = _createForOfIteratorHelper(sortedConnections);\n              _context17.prev = 29;\n              _iterator15.s();\n            case 31:\n              if ((_step15 = _iterator15.n()).done) {\n                _context17.next = 39;\n                break;\n              }\n              _connection = _step15.value;\n              log('too many connections open - closing a connection to %p', _connection.remotePeer);\n              toClose.push(_connection);\n              if (!(toClose.length === toPrune)) {\n                _context17.next = 37;\n                break;\n              }\n              return _context17.abrupt(\"break\", 39);\n            case 37:\n              _context17.next = 31;\n              break;\n            case 39:\n              _context17.next = 44;\n              break;\n            case 41:\n              _context17.prev = 41;\n              _context17.t1 = _context17[\"catch\"](29);\n              _iterator15.e(_context17.t1);\n            case 44:\n              _context17.prev = 44;\n              _iterator15.f();\n              return _context17.finish(44);\n            case 47:\n              _context17.next = 49;\n              return Promise.all(toClose.map( /*#__PURE__*/function () {\n                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(connection) {\n                  return _regeneratorRuntime().wrap(function _callee15$(_context16) {\n                    while (1) switch (_context16.prev = _context16.next) {\n                      case 0:\n                        _context16.prev = 0;\n                        _context16.next = 3;\n                        return connection.close();\n                      case 3:\n                        _context16.next = 8;\n                        break;\n                      case 5:\n                        _context16.prev = 5;\n                        _context16.t0 = _context16[\"catch\"](0);\n                        log.error(_context16.t0);\n                      case 8:\n                        // TODO: should not need to invoke this manually\n                        _this4.onDisconnect(new CustomEvent('connectionEnd', {\n                          detail: connection\n                        }));\n                      case 9:\n                      case \"end\":\n                        return _context16.stop();\n                    }\n                  }, _callee15, null, [[0, 5]]);\n                }));\n                return function (_x9) {\n                  return _ref5.apply(this, arguments);\n                };\n              }()));\n            case 49:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee16, this, [[5, 20, 23, 26], [29, 41, 44, 47]]);\n      }));\n      function _maybePruneConnections(_x8) {\n        return _maybePruneConnections2.apply(this, arguments);\n      }\n      return _maybePruneConnections;\n    }()\n  }, {\n    key: \"acceptIncomingConnection\",\n    value: function () {\n      var _acceptIncomingConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(maConn) {\n        return _regeneratorRuntime().wrap(function _callee17$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              return _context18.abrupt(\"return\", true);\n            case 1:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee17);\n      }));\n      function acceptIncomingConnection(_x10) {\n        return _acceptIncomingConnection.apply(this, arguments);\n      }\n      return acceptIncomingConnection;\n    }()\n  }]);\n  return DefaultConnectionManager;\n}(EventEmitter);","map":{"version":3,"names":["logger","errCode","mergeOptions","LatencyMonitor","retimer","CustomEvent","EventEmitter","codes","isPeerId","setMaxListeners","Components","STATUS","PeerMap","TimeoutController","KEEP_ALIVE","log","defaultOptions","maxConnections","Infinity","minConnections","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","autoDialInterval","movingAverageInterval","METRICS_SYSTEM","METRICS_COMPONENT","STARTUP_RECONNECT_TIMEOUT","DefaultConnectionManager","_EventEmitter","_inherits","_super","_createSuper","init","_init$startupReconnec","_init$dialTimeout","_this","_classCallCheck","call","components","opts","ignoreUndefined","Error","ERR_INVALID_PARAMETERS","connections","Map","started","_checkMetrics","bind","_assertThisInitialized","latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","_unused","onConnect","onDisconnect","startupReconnectTimeout","dialTimeout","_createClass","key","value","_this$components$getM","_this2","_this$components$getM2","_this$components$getM3","getMetrics","updateComponentMetric","system","component","metric","label","inbound","outbound","_iterator","_createForOfIteratorHelper","values","_step","s","n","done","conns","_iterator2","_step2","conn","stat","direction","err","e","f","_iterator3","_step3","_iterator4","_step4","_iterator5","streams","_step5","_stream$stat$protocol","_metric$key","stream","concat","protocol","allStreams","_iterator6","_step6","_iterator7","_step7","_iterator8","_step8","_stream$stat$protocol2","_streams$key","_i2","_Object$entries2","Object","entries","length","_allStreams$_protocol","_Object$entries2$_i","_slicedToArray","count","push","_i","_Object$entries","_Object$entries$_i","counts","sort","a","b","index","Math","floor","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this$timer","wrap","_callee$","_context","prev","next","timer","start","_onLatencyMeasure","addEventListener","stop","apply","arguments","_afterStart","_callee4","_this3","_callee4$","_context4","getUpgrader","Promise","resolve","then","_callee3","_this3$connectOnStart","keepAlivePeers","_iterator9","_step9","peer","tags","hasKeepAlive","_callee3$","_context3","t0","getPeerStore","all","t1","sent","getTags","id","filter","tag","name","t2","finish","connectOnStartupController","clear","signal","_unused2","map","_ref2","_callee2","_this3$connectOnStart2","_callee2$","_context2","openConnection","catch","error","_x","finally","_this3$connectOnStart3","afterStart","_beforeStop","_callee5","_this$connectOnStartu","_callee5$","_context5","abort","removeEventListener","beforeStop","_stop","_callee6","_this$timer2","_callee6$","_context6","_close","_close2","_callee8","tasks","_iterator10","_step10","connectionList","_iterator11","_step11","_loop","_callee8$","_context9","connection","_loop$","_context8","_callee7","_callee7$","_context7","close","delegateYield","_checkMetrics2","_callee9","metrics","movingAverages","received","total","_callee9$","_context10","getGlobal","getMovingAverages","dataReceived","movingAverage","_checkMaxLimit","dataSent","trace","evt","_onConnect","_onConnect2","_callee10","peerId","peerIdStr","storedConns","numConnections","toPrune","_callee10$","_context11","detail","abrupt","remotePeer","toString","get","set","publicKey","keyBook","getConnections","dispatchEvent","_x2","storedConn","_this$components$getM4","delete","onPeerDisconnected","_this$connections$get","_iterator12","_step12","c","_openConnection","_callee11","options","existingConnections","timeoutController","peerConnections","trackedConnection","_iterator13","_step13","_args12","_callee11$","_context12","undefined","_unused3","getDialer","dial","_x3","_closeConnections","_callee13","_this$connections$get2","_callee13$","_context14","_ref4","_callee12","_callee12$","_context13","_x5","closeConnections","_x4","getAll","status","OPEN","summary","avgMs","_checkMaxLimit2","_callee14","limit","_args15","_callee14$","_context15","getPeerId","_maybePruneConnections","_x6","_x7","_maybePruneConnections2","_callee16","_this4","peerValues","_iterator14","_step14","sortedConnections","toClose","_iterator15","_step15","_connection","_callee16$","_context17","has","reduce","acc","curr","_peerValues$get","_peerValues$get2","peerAValue","peerBValue","_ref5","_callee15","_callee15$","_context16","_x9","_x8","_acceptIncomingConnection","_callee17","maConn","_callee17$","_context18","acceptIncomingConnection","_x10"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/connection-manager/index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport mergeOptions from 'merge-options'\nimport { LatencyMonitor, SummaryObject } from './latency-monitor.js'\n// @ts-expect-error retimer does not have types\nimport retimer from 'retimer'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { codes } from '../errors.js'\nimport { isPeerId, PeerId } from '@libp2p/interface-peer-id'\nimport { setMaxListeners } from 'events'\nimport type { Connection, MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport { Components, Initializable } from '@libp2p/components'\nimport * as STATUS from '@libp2p/interface-connection/status'\nimport type { AddressSorter } from '@libp2p/interface-peer-store'\nimport type { Resolver } from '@multiformats/multiaddr'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { KEEP_ALIVE } from '@libp2p/interface-peer-store/tags'\n\nconst log = logger('libp2p:connection-manager')\n\nconst defaultOptions: Partial<ConnectionManagerInit> = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000\n}\n\nconst METRICS_SYSTEM = 'libp2p'\nconst METRICS_COMPONENT = 'connection-manager'\nconst STARTUP_RECONNECT_TIMEOUT = 60000\n\nexport interface ConnectionManagerInit {\n  /**\n   * The maximum number of connections to keep open\n   */\n  maxConnections: number\n\n  /**\n   * The minimum number of connections to keep open\n   */\n  minConnections: number\n\n  /**\n   * The max data (in and out), per average interval to allow\n   */\n  maxData?: number\n\n  /**\n   * The max outgoing data, per average interval to allow\n   */\n  maxSentData?: number\n\n  /**\n   * The max incoming data, per average interval to allow\n   */\n  maxReceivedData?: number\n\n  /**\n   * The upper limit the event loop can take to run\n   */\n  maxEventLoopDelay?: number\n\n  /**\n   * How often, in milliseconds, metrics and latency should be checked\n   */\n  pollInterval?: number\n\n  /**\n   * How often, in milliseconds, to compute averages\n   */\n  movingAverageInterval?: number\n\n  /**\n   * If true, try to connect to all discovered peers up to the connection manager limit\n   */\n  autoDial?: boolean\n\n  /**\n   * How long to wait between attempting to keep our number of concurrent connections\n   * above minConnections\n   */\n  autoDialInterval: number\n\n  /**\n   * Sort the known addresses of a peer before trying to dial\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * Number of max concurrent dials\n   */\n  maxParallelDials?: number\n\n  /**\n   * Number of max addresses to dial for a given peer\n   */\n  maxAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take, including DNS resolution\n   * of the multiaddr, opening a socket and upgrading it to a Connection.\n   */\n  dialTimeout?: number\n\n  /**\n   * When a new inbound connection is opened, the upgrade process (e.g. protect,\n   * encrypt, multiplex etc) must complete within this number of ms.\n   */\n  inboundUpgradeTimeout: number\n\n  /**\n   * Number of max concurrent dials per peer\n   */\n  maxDialsPerPeer?: number\n\n  /**\n   * Multiaddr resolvers to use when dialing\n   */\n  resolvers?: Record<string, Resolver>\n\n  /**\n   * On startup we try to dial any peer that has previously been\n   * tagged with KEEP_ALIVE up to this timeout in ms. (default: 60000)\n   */\n  startupReconnectTimeout?: number\n}\n\nexport interface ConnectionManagerEvents {\n  'peer:connect': CustomEvent<PeerId>\n  'peer:disconnect': CustomEvent<PeerId>\n}\n\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager extends EventEmitter<ConnectionManagerEvents> implements ConnectionManager, Startable, Initializable {\n  private components = new Components()\n  private readonly opts: Required<ConnectionManagerInit>\n  private readonly connections: Map<string, Connection[]>\n  private started: boolean\n  private timer?: ReturnType<retimer>\n  private readonly latencyMonitor: LatencyMonitor\n  private readonly startupReconnectTimeout: number\n  private connectOnStartupController?: TimeoutController\n  private readonly dialTimeout: number\n\n  constructor (init: ConnectionManagerInit) {\n    super()\n\n    this.opts = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, init)\n\n    if (this.opts.maxConnections < this.opts.minConnections) {\n      throw errCode(new Error('Connection Manager maxConnections must be greater than minConnections'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('options: %o', this.opts)\n\n    /**\n     * Map of connections per peer\n     */\n    this.connections = new Map()\n\n    this.started = false\n    this._checkMetrics = this._checkMetrics.bind(this)\n\n    this.latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: init.pollInterval,\n      dataEmitIntervalMs: init.pollInterval\n    })\n\n    try {\n      // This emitter gets listened to a lot\n      setMaxListeners?.(Infinity, this)\n    } catch {}\n\n    this.onConnect = this.onConnect.bind(this)\n    this.onDisconnect = this.onDisconnect.bind(this)\n\n    this.startupReconnectTimeout = init.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT\n    this.dialTimeout = init.dialTimeout ?? 30000\n  }\n\n  init (components: Components): void {\n    this.components = components\n\n    // track inbound/outbound connections\n    this.components.getMetrics()?.updateComponentMetric({\n      system: METRICS_SYSTEM,\n      component: METRICS_COMPONENT,\n      metric: 'connections',\n      label: 'direction',\n      value: () => {\n        const metric = {\n          inbound: 0,\n          outbound: 0\n        }\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            if (conn.stat.direction === 'inbound') {\n              metric.inbound++\n            } else {\n              metric.outbound++\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track total number of streams per protocol\n    this.components.getMetrics()?.updateComponentMetric({\n      system: METRICS_SYSTEM,\n      component: METRICS_COMPONENT,\n      metric: 'protocol-streams-total',\n      label: 'protocol',\n      value: () => {\n        const metric: Record<string, number> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.stat.direction} ${stream.stat.protocol ?? 'unnegotiated'}`\n\n              metric[key] = (metric[key] ?? 0) + 1\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track 90th percentile of streams per protocol\n    this.components.getMetrics()?.updateComponentMetric({\n      system: METRICS_SYSTEM,\n      component: METRICS_COMPONENT,\n      metric: 'protocol-streams-per-connection-90th-percentile',\n      label: 'protocol',\n      value: () => {\n        const allStreams: Record<string, number[]> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams: Record<string, number> = {}\n\n            for (const stream of conn.streams) {\n              const key = `${stream.stat.direction} ${stream.stat.protocol ?? 'unnegotiated'}`\n\n              streams[key] = (streams[key] ?? 0) + 1\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? []\n              allStreams[protocol].push(count)\n            }\n          }\n        }\n\n        const metric: Record<string, number> = {}\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b)\n\n          const index = Math.floor(counts.length * 0.9)\n          metric[protocol] = counts[index]\n        }\n\n        return metric\n      }\n    })\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  async start () {\n    if (this.components.getMetrics() != null) {\n      this.timer = this.timer ?? retimer(this._checkMetrics, this.opts.pollInterval)\n    }\n\n    // latency monitor\n    this.latencyMonitor.start()\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this.latencyMonitor.addEventListener('data', this._onLatencyMeasure)\n\n    this.started = true\n    log('started')\n  }\n\n  async afterStart () {\n    this.components.getUpgrader().addEventListener('connection', this.onConnect)\n    this.components.getUpgrader().addEventListener('connectionEnd', this.onDisconnect)\n\n    // re-connect to any peers with the KEEP_ALIVE tag\n    void Promise.resolve()\n      .then(async () => {\n        const keepAlivePeers: PeerId[] = []\n\n        for (const peer of await this.components.getPeerStore().all()) {\n          const tags = await this.components.getPeerStore().getTags(peer.id)\n          const hasKeepAlive = tags.filter(tag => tag.name === KEEP_ALIVE).length > 0\n\n          if (hasKeepAlive) {\n            keepAlivePeers.push(peer.id)\n          }\n        }\n\n        this.connectOnStartupController?.clear()\n        this.connectOnStartupController = new TimeoutController(this.startupReconnectTimeout)\n\n        try {\n          // fails on node < 15.4\n          setMaxListeners?.(Infinity, this.connectOnStartupController.signal)\n        } catch {}\n\n        await Promise.all(\n          keepAlivePeers.map(async peer => {\n            await this.openConnection(peer, {\n              signal: this.connectOnStartupController?.signal\n            })\n              .catch(err => {\n                log.error(err)\n              })\n          })\n        )\n      })\n      .catch(err => {\n        log.error(err)\n      })\n      .finally(() => {\n        this.connectOnStartupController?.clear()\n      })\n  }\n\n  async beforeStop () {\n    // if we are still dialing KEEP_ALIVE peers, abort those dials\n    this.connectOnStartupController?.abort()\n    this.components.getUpgrader().removeEventListener('connection', this.onConnect)\n    this.components.getUpgrader().removeEventListener('connectionEnd', this.onDisconnect)\n  }\n\n  /**\n   * Stops the Connection Manager\n   */\n  async stop () {\n    this.timer?.clear()\n\n    this.latencyMonitor.removeEventListener('data', this._onLatencyMeasure)\n    this.latencyMonitor.stop()\n\n    this.started = false\n    await this._close()\n    log('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks: Array<Promise<void>> = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push((async () => {\n          try {\n            await connection.close()\n          } catch (err) {\n            log.error(err)\n          }\n        })())\n      }\n    }\n\n    log('closing %d connections', tasks.length)\n    await Promise.all(tasks)\n    this.connections.clear()\n  }\n\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   *\n   * @private\n   */\n  async _checkMetrics () {\n    const metrics = this.components.getMetrics()\n\n    if (metrics != null) {\n      try {\n        const movingAverages = metrics.getGlobal().getMovingAverages()\n        const received = movingAverages.dataReceived[this.opts.movingAverageInterval].movingAverage\n        await this._checkMaxLimit('maxReceivedData', received)\n        const sent = movingAverages.dataSent[this.opts.movingAverageInterval].movingAverage\n        await this._checkMaxLimit('maxSentData', sent)\n        const total = received + sent\n        await this._checkMaxLimit('maxData', total)\n        log.trace('metrics update', total)\n      } finally {\n        this.timer = retimer(this._checkMetrics, this.opts.pollInterval)\n      }\n    }\n  }\n\n  onConnect (evt: CustomEvent<Connection>) {\n    void this._onConnect(evt).catch(err => {\n      log.error(err)\n    })\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n  async _onConnect (evt: CustomEvent<Connection>) {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toString()\n    const storedConns = this.connections.get(peerIdStr)\n\n    if (storedConns != null) {\n      storedConns.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    if (peerId.publicKey != null) {\n      await this.components.getPeerStore().keyBook.set(peerId, peerId.publicKey)\n    }\n\n    const numConnections = this.getConnections().length\n    const toPrune = numConnections - this.opts.maxConnections\n\n    await this._checkMaxLimit('maxConnections', numConnections, toPrune)\n    this.dispatchEvent(new CustomEvent<Connection>('peer:connect', { detail: connection }))\n  }\n\n  /**\n   * Removes the connection from tracking\n   */\n  onDisconnect (evt: CustomEvent<Connection>) {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      return\n    }\n\n    const peerId = connection.remotePeer.toString()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn != null && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn != null) {\n      this.connections.delete(peerId)\n      this.dispatchEvent(new CustomEvent<Connection>('peer:disconnect', { detail: connection }))\n\n      this.components.getMetrics()?.onPeerDisconnected(connection.remotePeer)\n    }\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    if (peerId != null) {\n      return this.connections.get(peerId.toString()) ?? []\n    }\n\n    let conns: Connection[] = []\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c)\n    }\n\n    return conns\n  }\n\n  async openConnection (peerId: PeerId, options: AbortOptions = {}): Promise<Connection> {\n    log('dial to %p', peerId)\n    const existingConnections = this.getConnections(peerId)\n\n    if (existingConnections.length > 0) {\n      log('had an existing connection to %p', peerId)\n\n      return existingConnections[0]\n    }\n\n    let timeoutController: TimeoutController | undefined\n\n    if (options?.signal == null) {\n      timeoutController = new TimeoutController(this.dialTimeout)\n      options.signal = timeoutController.signal\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n    }\n\n    try {\n      const connection = await this.components.getDialer().dial(peerId, options)\n      let peerConnections = this.connections.get(peerId.toString())\n\n      if (peerConnections == null) {\n        peerConnections = []\n        this.connections.set(peerId.toString(), peerConnections)\n      }\n\n      // we get notified of connections via the Upgrader emitting \"connection\"\n      // events, double check we aren't already tracking this connection before\n      // storing it\n      let trackedConnection = false\n\n      for (const conn of peerConnections) {\n        if (conn.id === connection.id) {\n          trackedConnection = true\n        }\n      }\n\n      if (!trackedConnection) {\n        peerConnections.push(connection)\n      }\n\n      return connection\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n    }\n  }\n\n  async closeConnections (peerId: PeerId): Promise<void> {\n    const connections = this.connections.get(peerId.toString()) ?? []\n\n    await Promise.all(\n      connections.map(async connection => {\n        return await connection.close()\n      })\n    )\n  }\n\n  /**\n   * Get all open connections with a peer\n   */\n  getAll (peerId: PeerId): Connection[] {\n    if (!isPeerId(peerId)) {\n      throw errCode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toString()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections != null) {\n      return connections.filter(connection => connection.stat.status === STATUS.OPEN)\n    }\n\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   */\n  _onLatencyMeasure (evt: CustomEvent<SummaryObject>) {\n    const { detail: summary } = evt\n\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs, 1)\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   */\n  async _checkMaxLimit (name: keyof ConnectionManagerInit, value: number, toPrune: number = 1) {\n    const limit = this.opts[name]\n    log.trace('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      log('%s: limit exceeded: %p, %d/%d, pruning %d connection(s)', this.components.getPeerId(), name, value, limit, toPrune)\n      await this._maybePruneConnections(toPrune)\n    }\n  }\n\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n  async _maybePruneConnections (toPrune: number) {\n    const connections = this.getConnections()\n\n    if (connections.length <= this.opts.minConnections || toPrune < 1) {\n      return\n    }\n\n    const peerValues = new PeerMap<number>()\n\n    // work out peer values\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer\n\n      if (peerValues.has(remotePeer)) {\n        continue\n      }\n\n      const tags = await this.components.getPeerStore().getTags(remotePeer)\n\n      // sum all tag values\n      peerValues.set(remotePeer, tags.reduce((acc, curr) => {\n        return acc + curr.value\n      }, 0))\n    }\n\n    // sort by value, lowest to highest\n    const sortedConnections = connections.sort((a, b) => {\n      const peerAValue = peerValues.get(a.remotePeer) ?? 0\n      const peerBValue = peerValues.get(b.remotePeer) ?? 0\n\n      if (peerAValue > peerBValue) {\n        return 1\n      }\n\n      if (peerAValue < peerBValue) {\n        return -1\n      }\n\n      return 0\n    })\n\n    // close some connections\n    const toClose = []\n\n    for (const connection of sortedConnections) {\n      log('too many connections open - closing a connection to %p', connection.remotePeer)\n      toClose.push(connection)\n\n      if (toClose.length === toPrune) {\n        break\n      }\n    }\n\n    // close connections\n    await Promise.all(\n      toClose.map(async connection => {\n        try {\n          await connection.close()\n        } catch (err) {\n          log.error(err)\n        }\n\n        // TODO: should not need to invoke this manually\n        this.onDisconnect(new CustomEvent<Connection>('connectionEnd', {\n          detail: connection\n        }))\n      })\n    )\n  }\n\n  async acceptIncomingConnection (maConn: MultiaddrConnection): Promise<boolean> {\n    return true\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}