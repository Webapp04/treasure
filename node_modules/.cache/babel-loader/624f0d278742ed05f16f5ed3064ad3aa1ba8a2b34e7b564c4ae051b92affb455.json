{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as dagPB from '@ipld/dag-pb';\nimport { Bucket, createHAMT } from 'hamt-sharding';\nimport { DirSharded } from './dir-sharded.js';\nimport { logger } from '@libp2p/logger';\nimport { UnixFS } from 'ipfs-unixfs';\nimport last from 'it-last';\nimport { CID } from 'multiformats/cid';\nimport { hamtHashCode, hamtHashFn, hamtBucketBits } from './hamt-constants.js';\nvar log = logger('ipfs:mfs:core:utils:hamt-utils');\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n/**\n * @param {MfsContext} context\n * @param {PBLink[]} links\n * @param {Bucket<any>} bucket\n * @param {object} options\n * @param {PBNode} options.parent\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {string} options.hashAlg\n */\nexport var updateHamtDirectory = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, links, bucket, options) {\n    var data, node, dir, hasher, parent, buf, hash, cid;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (options.parent.Data) {\n            _context.next = 2;\n            break;\n          }\n          throw new Error('Could not update HAMT directory because parent had no data');\n        case 2:\n          // update parent with new bit field\n          data = Uint8Array.from(bucket._children.bitField().reverse());\n          node = UnixFS.unmarshal(options.parent.Data);\n          dir = new UnixFS({\n            type: 'hamt-sharded-directory',\n            data: data,\n            fanout: bucket.tableSize(),\n            hashType: hamtHashCode,\n            mode: node.mode,\n            mtime: node.mtime\n          });\n          _context.next = 7;\n          return context.hashers.getHasher(options.hashAlg);\n        case 7:\n          hasher = _context.sent;\n          parent = {\n            Data: dir.marshal(),\n            Links: links.sort(function (a, b) {\n              return (a.Name || '').localeCompare(b.Name || '');\n            })\n          };\n          buf = dagPB.encode(parent);\n          _context.next = 12;\n          return hasher.digest(buf);\n        case 12:\n          hash = _context.sent;\n          cid = CID.create(options.cidVersion, dagPB.code, hash);\n          if (!options.flush) {\n            _context.next = 17;\n            break;\n          }\n          _context.next = 17;\n          return context.repo.blocks.put(cid, buf);\n        case 17:\n          return _context.abrupt(\"return\", {\n            node: parent,\n            cid: cid,\n            size: links.reduce(function (sum, link) {\n              return sum + (link.Tsize || 0);\n            }, buf.length)\n          });\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function updateHamtDirectory(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {PBLink[]} links\n * @param {Bucket<any>} rootBucket\n * @param {Bucket<any>} parentBucket\n * @param {number} positionAtParent\n */\nexport var recreateHamtLevel = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, links, rootBucket, parentBucket, positionAtParent) {\n    var bucket;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          // recreate this level of the HAMT\n          bucket = new Bucket({\n            hash: rootBucket._options.hash,\n            bits: rootBucket._options.bits\n          }, parentBucket, positionAtParent);\n          parentBucket._putObjectAt(positionAtParent, bucket);\n          _context2.next = 4;\n          return addLinksToHamtBucket(context, links, bucket, rootBucket);\n        case 4:\n          return _context2.abrupt(\"return\", bucket);\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function recreateHamtLevel(_x5, _x6, _x7, _x8, _x9) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {PBLink[]} links\n */\nexport var recreateInitialHamtLevel = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(links) {\n    var bucket;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          bucket = createHAMT({\n            hashFn: hamtHashFn,\n            bits: hamtBucketBits\n          }); // populate sub bucket but do not recurse as we do not want to pull whole shard in\n          _context4.next = 3;\n          return Promise.all(links.map( /*#__PURE__*/function () {\n            var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(link) {\n              var linkName, pos, subBucket;\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    linkName = link.Name || '';\n                    if (!(linkName.length === 2)) {\n                      _context3.next = 6;\n                      break;\n                    }\n                    pos = parseInt(linkName, 16);\n                    subBucket = new Bucket({\n                      hash: bucket._options.hash,\n                      bits: bucket._options.bits\n                    }, bucket, pos);\n                    bucket._putObjectAt(pos, subBucket);\n                    return _context3.abrupt(\"return\", Promise.resolve());\n                  case 6:\n                    return _context3.abrupt(\"return\", bucket.put(linkName.substring(2), {\n                      size: link.Tsize,\n                      cid: link.Hash\n                    }));\n                  case 7:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _callee3);\n            }));\n            return function (_x11) {\n              return _ref4.apply(this, arguments);\n            };\n          }()));\n        case 3:\n          return _context4.abrupt(\"return\", bucket);\n        case 4:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function recreateInitialHamtLevel(_x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {PBLink[]} links\n * @param {Bucket<any>} bucket\n * @param {Bucket<any>} rootBucket\n */\nexport var addLinksToHamtBucket = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(context, links, bucket, rootBucket) {\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          _context6.next = 2;\n          return Promise.all(links.map( /*#__PURE__*/function () {\n            var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(link) {\n              var linkName, pos, block, node, subBucket;\n              return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                while (1) switch (_context5.prev = _context5.next) {\n                  case 0:\n                    linkName = link.Name || '';\n                    if (!(linkName.length === 2)) {\n                      _context5.next = 13;\n                      break;\n                    }\n                    log('Populating sub bucket', linkName);\n                    pos = parseInt(linkName, 16);\n                    _context5.next = 6;\n                    return context.repo.blocks.get(link.Hash);\n                  case 6:\n                    block = _context5.sent;\n                    node = dagPB.decode(block);\n                    subBucket = new Bucket({\n                      hash: rootBucket._options.hash,\n                      bits: rootBucket._options.bits\n                    }, bucket, pos);\n                    bucket._putObjectAt(pos, subBucket);\n                    _context5.next = 12;\n                    return addLinksToHamtBucket(context, node.Links, subBucket, rootBucket);\n                  case 12:\n                    return _context5.abrupt(\"return\", Promise.resolve());\n                  case 13:\n                    return _context5.abrupt(\"return\", rootBucket.put(linkName.substring(2), {\n                      size: link.Tsize,\n                      cid: link.Hash\n                    }));\n                  case 14:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }, _callee5);\n            }));\n            return function (_x16) {\n              return _ref6.apply(this, arguments);\n            };\n          }()));\n        case 2:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return function addLinksToHamtBucket(_x12, _x13, _x14, _x15) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {number} position\n */\nexport var toPrefix = function toPrefix(position) {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\n/**\n * @param {MfsContext} context\n * @param {string} fileName\n * @param {PBNode} rootNode\n */\nexport var generatePath = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(context, fileName, rootNode) {\n    var rootBucket, position, path, currentBucket, _loop, _ret, i;\n    return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.next = 2;\n          return recreateInitialHamtLevel(rootNode.Links);\n        case 2:\n          rootBucket = _context8.sent;\n          _context8.next = 5;\n          return rootBucket._findNewBucketAndPos(fileName);\n        case 5:\n          position = _context8.sent;\n          // the path to the root bucket\n          /** @type {{ bucket: Bucket<any>, prefix: string, node?: PBNode }[]} */\n          path = [{\n            bucket: position.bucket,\n            prefix: toPrefix(position.pos)\n          }];\n          currentBucket = position.bucket;\n          while (currentBucket !== rootBucket) {\n            path.push({\n              bucket: currentBucket,\n              prefix: toPrefix(currentBucket._posAtParent)\n            });\n\n            // @ts-expect-error - only the root bucket's parent will be undefined\n            currentBucket = currentBucket._parent;\n          }\n          path.reverse();\n          path[0].node = rootNode;\n\n          // load PbNode for each path segment\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var segment, link, block, node, _position, nextSegment;\n            return _regeneratorRuntime().wrap(function _loop$(_context7) {\n              while (1) switch (_context7.prev = _context7.next) {\n                case 0:\n                  segment = path[i];\n                  if (segment.node) {\n                    _context7.next = 3;\n                    break;\n                  }\n                  throw new Error('Could not generate HAMT path');\n                case 3:\n                  // find prefix in links\n                  link = segment.node.Links.filter(function (link) {\n                    return (link.Name || '').substring(0, 2) === segment.prefix;\n                  }).pop(); // entry was not in shard\n                  if (link) {\n                    _context7.next = 7;\n                    break;\n                  }\n                  // reached bottom of tree, file will be added to the current bucket\n                  log(\"Link \".concat(segment.prefix).concat(fileName, \" will be added\"));\n                  // return path\n                  return _context7.abrupt(\"return\", 0);\n                case 7:\n                  if (!(link.Name === \"\".concat(segment.prefix).concat(fileName))) {\n                    _context7.next = 10;\n                    break;\n                  }\n                  log(\"Link \".concat(segment.prefix).concat(fileName, \" will be replaced\"));\n                  // file already existed, file will be added to the current bucket\n                  // return path\n                  return _context7.abrupt(\"return\", 0);\n                case 10:\n                  // found subshard\n                  log(\"Found subshard \".concat(segment.prefix));\n                  _context7.next = 13;\n                  return context.repo.blocks.get(link.Hash);\n                case 13:\n                  block = _context7.sent;\n                  node = dagPB.decode(block); // subshard hasn't been loaded, descend to the next level of the HAMT\n                  if (path[i + 1]) {\n                    _context7.next = 24;\n                    break;\n                  }\n                  log(\"Loaded new subshard \".concat(segment.prefix));\n                  _context7.next = 19;\n                  return recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));\n                case 19:\n                  _context7.next = 21;\n                  return rootBucket._findNewBucketAndPos(fileName);\n                case 21:\n                  _position = _context7.sent;\n                  // i--\n                  path.push({\n                    bucket: _position.bucket,\n                    prefix: toPrefix(_position.pos),\n                    node: node\n                  });\n                  return _context7.abrupt(\"return\", 0);\n                case 24:\n                  nextSegment = path[i + 1]; // add intermediate links to bucket\n                  _context7.next = 27;\n                  return addLinksToHamtBucket(context, node.Links, nextSegment.bucket, rootBucket);\n                case 27:\n                  nextSegment.node = node;\n                case 28:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }, _loop);\n          });\n          i = 0;\n        case 13:\n          if (!(i < path.length)) {\n            _context8.next = 21;\n            break;\n          }\n          return _context8.delegateYield(_loop(), \"t0\", 15);\n        case 15:\n          _ret = _context8.t0;\n          if (!(_ret === 0)) {\n            _context8.next = 18;\n            break;\n          }\n          return _context8.abrupt(\"continue\", 18);\n        case 18:\n          i++;\n          _context8.next = 13;\n          break;\n        case 21:\n          _context8.next = 23;\n          return rootBucket.put(fileName, true);\n        case 23:\n          path.reverse();\n          return _context8.abrupt(\"return\", {\n            rootBucket: rootBucket,\n            path: path\n          });\n        case 25:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee7);\n  }));\n  return function generatePath(_x17, _x18, _x19) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {{ name: string, size: number, cid: CID }[]} contents\n * @param {object} [options]\n * @param {Mtime} [options.mtime]\n * @param {number} [options.mode]\n */\nexport var createShard = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(context, contents) {\n    var options,\n      shard,\n      i,\n      res,\n      _args9 = arguments;\n    return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          options = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};\n          shard = new DirSharded({\n            root: true,\n            dir: true,\n            parent: undefined,\n            parentKey: undefined,\n            path: '',\n            dirty: true,\n            flat: false,\n            mtime: options.mtime,\n            mode: options.mode\n          }, options);\n          i = 0;\n        case 3:\n          if (!(i < contents.length)) {\n            _context9.next = 9;\n            break;\n          }\n          _context9.next = 6;\n          return shard._bucket.put(contents[i].name, {\n            size: contents[i].size,\n            cid: contents[i].cid\n          });\n        case 6:\n          i++;\n          _context9.next = 3;\n          break;\n        case 9:\n          _context9.next = 11;\n          return last(shard.flush(context.repo.blocks));\n        case 11:\n          res = _context9.sent;\n          if (res) {\n            _context9.next = 14;\n            break;\n          }\n          throw new Error('Flushing shard yielded no result');\n        case 14:\n          return _context9.abrupt(\"return\", res);\n        case 15:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee8);\n  }));\n  return function createShard(_x20, _x21) {\n    return _ref8.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["dagPB","Bucket","createHAMT","DirSharded","logger","UnixFS","last","CID","hamtHashCode","hamtHashFn","hamtBucketBits","log","updateHamtDirectory","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","context","links","bucket","options","data","node","dir","hasher","parent","buf","hash","cid","wrap","_callee$","_context","prev","next","Data","Error","Uint8Array","from","_children","bitField","reverse","unmarshal","type","fanout","tableSize","hashType","mode","mtime","hashers","getHasher","hashAlg","sent","marshal","Links","sort","a","b","Name","localeCompare","encode","digest","create","cidVersion","code","flush","repo","blocks","put","abrupt","size","reduce","sum","link","Tsize","length","stop","_x","_x2","_x3","_x4","apply","arguments","recreateHamtLevel","_ref2","_callee2","rootBucket","parentBucket","positionAtParent","_callee2$","_context2","_options","bits","_putObjectAt","addLinksToHamtBucket","_x5","_x6","_x7","_x8","_x9","recreateInitialHamtLevel","_ref3","_callee4","_callee4$","_context4","hashFn","Promise","all","map","_ref4","_callee3","linkName","pos","subBucket","_callee3$","_context3","parseInt","resolve","substring","Hash","_x11","_x10","_ref5","_callee6","_callee6$","_context6","_ref6","_callee5","block","_callee5$","_context5","get","decode","_x16","_x12","_x13","_x14","_x15","toPrefix","position","toString","toUpperCase","padStart","generatePath","_ref7","_callee7","fileName","rootNode","path","currentBucket","_loop","_ret","i","_callee7$","_context8","_findNewBucketAndPos","prefix","push","_posAtParent","_parent","segment","_position","nextSegment","_loop$","_context7","filter","pop","concat","delegateYield","t0","_x17","_x18","_x19","createShard","_ref8","_callee8","contents","shard","res","_args9","_callee8$","_context9","undefined","root","parentKey","dirty","flat","_bucket","name","_x20","_x21"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/utils/hamt-utils.js"],"sourcesContent":["import * as dagPB from '@ipld/dag-pb'\nimport {\n  Bucket,\n  createHAMT\n} from 'hamt-sharding'\nimport { DirSharded } from './dir-sharded.js'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport last from 'it-last'\nimport { CID } from 'multiformats/cid'\nimport {\n  hamtHashCode,\n  hamtHashFn,\n  hamtBucketBits\n} from './hamt-constants.js'\n\nconst log = logger('ipfs:mfs:core:utils:hamt-utils')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n/**\n * @param {MfsContext} context\n * @param {PBLink[]} links\n * @param {Bucket<any>} bucket\n * @param {object} options\n * @param {PBNode} options.parent\n * @param {CIDVersion} options.cidVersion\n * @param {boolean} options.flush\n * @param {string} options.hashAlg\n */\nexport const updateHamtDirectory = async (context, links, bucket, options) => {\n  if (!options.parent.Data) {\n    throw new Error('Could not update HAMT directory because parent had no data')\n  }\n\n  // update parent with new bit field\n  const data = Uint8Array.from(bucket._children.bitField().reverse())\n  const node = UnixFS.unmarshal(options.parent.Data)\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: hamtHashCode,\n    mode: node.mode,\n    mtime: node.mtime\n  })\n\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const parent = {\n    Data: dir.marshal(),\n    Links: links.sort((a, b) => (a.Name || '').localeCompare(b.Name || ''))\n  }\n  const buf = dagPB.encode(parent)\n  const hash = await hasher.digest(buf)\n  const cid = CID.create(options.cidVersion, dagPB.code, hash)\n\n  if (options.flush) {\n    await context.repo.blocks.put(cid, buf)\n  }\n\n  return {\n    node: parent,\n    cid,\n    size: links.reduce((sum, link) => sum + (link.Tsize || 0), buf.length)\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {PBLink[]} links\n * @param {Bucket<any>} rootBucket\n * @param {Bucket<any>} parentBucket\n * @param {number} positionAtParent\n */\nexport const recreateHamtLevel = async (context, links, rootBucket, parentBucket, positionAtParent) => {\n  // recreate this level of the HAMT\n  const bucket = new Bucket({\n    hash: rootBucket._options.hash,\n    bits: rootBucket._options.bits\n  }, parentBucket, positionAtParent)\n  parentBucket._putObjectAt(positionAtParent, bucket)\n\n  await addLinksToHamtBucket(context, links, bucket, rootBucket)\n\n  return bucket\n}\n\n/**\n * @param {PBLink[]} links\n */\nexport const recreateInitialHamtLevel = async (links) => {\n  const bucket = createHAMT({\n    hashFn: hamtHashFn,\n    bits: hamtBucketBits\n  })\n\n  // populate sub bucket but do not recurse as we do not want to pull whole shard in\n  await Promise.all(\n    links.map(async link => {\n      const linkName = (link.Name || '')\n\n      if (linkName.length === 2) {\n        const pos = parseInt(linkName, 16)\n\n        const subBucket = new Bucket({\n          hash: bucket._options.hash,\n          bits: bucket._options.bits\n        }, bucket, pos)\n        bucket._putObjectAt(pos, subBucket)\n\n        return Promise.resolve()\n      }\n\n      return bucket.put(linkName.substring(2), {\n        size: link.Tsize,\n        cid: link.Hash\n      })\n    })\n  )\n\n  return bucket\n}\n\n/**\n * @param {MfsContext} context\n * @param {PBLink[]} links\n * @param {Bucket<any>} bucket\n * @param {Bucket<any>} rootBucket\n */\nexport const addLinksToHamtBucket = async (context, links, bucket, rootBucket) => {\n  await Promise.all(\n    links.map(async link => {\n      const linkName = (link.Name || '')\n\n      if (linkName.length === 2) {\n        log('Populating sub bucket', linkName)\n        const pos = parseInt(linkName, 16)\n        const block = await context.repo.blocks.get(link.Hash)\n        const node = dagPB.decode(block)\n\n        const subBucket = new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos)\n        bucket._putObjectAt(pos, subBucket)\n\n        await addLinksToHamtBucket(context, node.Links, subBucket, rootBucket)\n\n        return Promise.resolve()\n      }\n\n      return rootBucket.put(linkName.substring(2), {\n        size: link.Tsize,\n        cid: link.Hash\n      })\n    })\n  )\n}\n\n/**\n * @param {number} position\n */\nexport const toPrefix = (position) => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} fileName\n * @param {PBNode} rootNode\n */\nexport const generatePath = async (context, fileName, rootNode) => {\n  // start at the root bucket and descend, loading nodes as we go\n  const rootBucket = await recreateInitialHamtLevel(rootNode.Links)\n  const position = await rootBucket._findNewBucketAndPos(fileName)\n\n  // the path to the root bucket\n  /** @type {{ bucket: Bucket<any>, prefix: string, node?: PBNode }[]} */\n  const path = [{\n    bucket: position.bucket,\n    prefix: toPrefix(position.pos)\n  }]\n  let currentBucket = position.bucket\n\n  while (currentBucket !== rootBucket) {\n    path.push({\n      bucket: currentBucket,\n      prefix: toPrefix(currentBucket._posAtParent)\n    })\n\n    // @ts-expect-error - only the root bucket's parent will be undefined\n    currentBucket = currentBucket._parent\n  }\n\n  path.reverse()\n  path[0].node = rootNode\n\n  // load PbNode for each path segment\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i]\n\n    if (!segment.node) {\n      throw new Error('Could not generate HAMT path')\n    }\n\n    // find prefix in links\n    const link = segment.node.Links\n      .filter(link => (link.Name || '').substring(0, 2) === segment.prefix)\n      .pop()\n\n    // entry was not in shard\n    if (!link) {\n      // reached bottom of tree, file will be added to the current bucket\n      log(`Link ${segment.prefix}${fileName} will be added`)\n      // return path\n      continue\n    }\n\n    // found entry\n    if (link.Name === `${segment.prefix}${fileName}`) {\n      log(`Link ${segment.prefix}${fileName} will be replaced`)\n      // file already existed, file will be added to the current bucket\n      // return path\n      continue\n    }\n\n    // found subshard\n    log(`Found subshard ${segment.prefix}`)\n    const block = await context.repo.blocks.get(link.Hash)\n    const node = dagPB.decode(block)\n\n    // subshard hasn't been loaded, descend to the next level of the HAMT\n    if (!path[i + 1]) {\n      log(`Loaded new subshard ${segment.prefix}`)\n\n      await recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16))\n      const position = await rootBucket._findNewBucketAndPos(fileName)\n\n      // i--\n      path.push({\n        bucket: position.bucket,\n        prefix: toPrefix(position.pos),\n        node: node\n      })\n\n      continue\n    }\n\n    const nextSegment = path[i + 1]\n\n    // add intermediate links to bucket\n    await addLinksToHamtBucket(context, node.Links, nextSegment.bucket, rootBucket)\n\n    nextSegment.node = node\n  }\n\n  await rootBucket.put(fileName, true)\n\n  path.reverse()\n\n  return {\n    rootBucket,\n    path\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {{ name: string, size: number, cid: CID }[]} contents\n * @param {object} [options]\n * @param {Mtime} [options.mtime]\n * @param {number} [options.mode]\n */\nexport const createShard = async (context, contents, options = {}) => {\n  const shard = new DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mtime: options.mtime,\n    mode: options.mode\n  }, options)\n\n  for (let i = 0; i < contents.length; i++) {\n    await shard._bucket.put(contents[i].name, {\n      size: contents[i].size,\n      cid: contents[i].cid\n    })\n  }\n\n  const res = await last(shard.flush(context.repo.blocks))\n\n  if (!res) {\n    throw new Error('Flushing shard yielded no result')\n  }\n\n  return res\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}