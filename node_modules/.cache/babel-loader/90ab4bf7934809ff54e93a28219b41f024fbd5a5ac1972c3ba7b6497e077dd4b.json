{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { pipe } from 'it-pipe';\nimport each from 'it-foreach';\nimport LRU from 'hashlru';\nimport { METRICS as defaultOptions } from '../constants.js';\nimport { DefaultStats } from './stats.js';\nvar initialCounters = ['dataReceived', 'dataSent'];\nvar directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\nexport var DefaultMetrics = /*#__PURE__*/function () {\n  function DefaultMetrics(init) {\n    var _init$maxOldPeersRete;\n    _classCallCheck(this, DefaultMetrics);\n    this.enabled = init.enabled;\n    this.statsInit = _objectSpread(_objectSpread({}, init), {}, {\n      initialCounters: initialCounters\n    });\n    this.globalStats = new DefaultStats(this.statsInit);\n    this.peerStats = new Map();\n    this.protocolStats = new Map();\n    this.oldPeers = LRU((_init$maxOldPeersRete = init.maxOldPeersRetention) !== null && _init$maxOldPeersRete !== void 0 ? _init$maxOldPeersRete : defaultOptions.maxOldPeersRetention);\n    this.running = false;\n    this._onMessage = this._onMessage.bind(this);\n    this.systems = new Map();\n  }\n  _createClass(DefaultMetrics, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.running;\n    }\n    /**\n     * Must be called for stats to saved. Any data pushed for tracking\n     * will be ignored.\n     */\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.enabled) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              this.running = true;\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n    /**\n     * Stops all averages timers and prevents new data from being tracked.\n     * Once `stop` is called, `start` must be called to resume stats tracking.\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _iterator, _step, stats, _iterator2, _step2, _stats;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.running) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              this.running = false;\n              this.globalStats.stop();\n              _iterator = _createForOfIteratorHelper(this.peerStats.values());\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  stats = _step.value;\n                  stats.stop();\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              _iterator2 = _createForOfIteratorHelper(this.protocolStats.values());\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  _stats = _step2.value;\n                  _stats.stop();\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Gets the global `Stats` object\n     */\n  }, {\n    key: \"getGlobal\",\n    value: function getGlobal() {\n      return this.globalStats;\n    }\n    /**\n     * Returns a list of `PeerId` strings currently being tracked\n     */\n  }, {\n    key: \"getPeers\",\n    value: function getPeers() {\n      return Array.from(this.peerStats.keys());\n    }\n  }, {\n    key: \"getComponentMetrics\",\n    value: function getComponentMetrics() {\n      return this.systems;\n    }\n  }, {\n    key: \"updateComponentMetric\",\n    value: function updateComponentMetric(update) {\n      var _update$system = update.system,\n        system = _update$system === void 0 ? 'libp2p' : _update$system,\n        component = update.component,\n        metric = update.metric,\n        value = update.value,\n        label = update.label,\n        help = update.help;\n      if (!this.systems.has(system)) {\n        this.systems.set(system, new Map());\n      }\n      var systemMetrics = this.systems.get(system);\n      if (systemMetrics == null) {\n        throw new Error('Unknown metric system');\n      }\n      if (!systemMetrics.has(component)) {\n        systemMetrics.set(component, new Map());\n      }\n      var componentMetrics = systemMetrics.get(component);\n      if (componentMetrics == null) {\n        throw new Error('Unknown metric component');\n      }\n      componentMetrics.set(metric, {\n        label: label,\n        help: help,\n        calculate: typeof value !== 'function' ? function () {\n          return value;\n        } : value\n      });\n    }\n    /**\n     * Returns the `Stats` object for the given `PeerId` whether it\n     * is a live peer, or in the disconnected peer LRU cache.\n     */\n  }, {\n    key: \"forPeer\",\n    value: function forPeer(peerId) {\n      var _this$peerStats$get;\n      var idString = peerId.toString();\n      return (_this$peerStats$get = this.peerStats.get(idString)) !== null && _this$peerStats$get !== void 0 ? _this$peerStats$get : this.oldPeers.get(idString);\n    }\n    /**\n     * Returns a list of all protocol strings currently being tracked\n     */\n  }, {\n    key: \"getProtocols\",\n    value: function getProtocols() {\n      return Array.from(this.protocolStats.keys());\n    }\n    /**\n     * Returns the `Stats` object for the given `protocol`\n     */\n  }, {\n    key: \"forProtocol\",\n    value: function forProtocol(protocol) {\n      return this.protocolStats.get(protocol);\n    }\n    /**\n     * Should be called when all connections to a given peer\n     * have closed. The `Stats` collection for the peer will\n     * be stopped and moved to an LRU for temporary retention.\n     */\n  }, {\n    key: \"onPeerDisconnected\",\n    value: function onPeerDisconnected(peerId) {\n      var idString = peerId.toString();\n      var peerStats = this.peerStats.get(idString);\n      if (peerStats != null) {\n        peerStats.stop();\n        this.peerStats.delete(idString);\n        this.oldPeers.set(idString, peerStats);\n      }\n    }\n    /**\n     * Takes the metadata for a message and tracks it in the\n     * appropriate categories. If the protocol is present, protocol\n     * stats will also be tracked.\n     */\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(opts) {\n      if (!this.running) {\n        return;\n      }\n      var remotePeer = opts.remotePeer,\n        protocol = opts.protocol,\n        direction = opts.direction,\n        dataLength = opts.dataLength;\n      var key = directionToEvent[direction];\n      var peerStats = this.forPeer(remotePeer);\n      if (peerStats == null) {\n        var stats = new DefaultStats(this.statsInit);\n        this.peerStats.set(remotePeer.toString(), stats);\n        peerStats = stats;\n      }\n      // Peer and global stats\n      peerStats.push(key, dataLength);\n      this.globalStats.push(key, dataLength);\n      // Protocol specific stats\n      if (protocol != null) {\n        var protocolStats = this.forProtocol(protocol);\n        if (protocolStats == null) {\n          var _stats2 = new DefaultStats(this.statsInit);\n          this.protocolStats.set(protocol, _stats2);\n          protocolStats = _stats2;\n        }\n        protocolStats.push(key, dataLength);\n      }\n    }\n    /**\n     * Replaces the `PeerId` string with the given `peerId`.\n     * If stats are already being tracked for the given `peerId`, the\n     * placeholder stats will be merged with the existing stats.\n     *\n     * @param {PeerId} placeholder - A peerId string\n     * @param {PeerId} peerId\n     * @returns {void}\n     */\n  }, {\n    key: \"updatePlaceholder\",\n    value: function updatePlaceholder(placeholder, peerId) {\n      var _this$peerStats$get2, _this$peerStats$get3;\n      if (!this.running) {\n        return;\n      }\n      var placeholderString = placeholder.toString();\n      var placeholderStats = (_this$peerStats$get2 = this.peerStats.get(placeholderString)) !== null && _this$peerStats$get2 !== void 0 ? _this$peerStats$get2 : this.oldPeers.get(placeholderString);\n      var peerIdString = peerId.toString();\n      var existingStats = (_this$peerStats$get3 = this.peerStats.get(peerIdString)) !== null && _this$peerStats$get3 !== void 0 ? _this$peerStats$get3 : this.oldPeers.get(peerIdString);\n      var mergedStats = placeholderStats;\n      // If we already have stats, merge the two\n      if (existingStats != null) {\n        // If existing, merge\n        mergedStats = mergeStats(existingStats, mergedStats);\n        // Attempt to delete from the old peers list just in case it was tracked there\n        this.oldPeers.remove(peerIdString);\n      }\n      this.peerStats.delete(placeholder.toString());\n      this.peerStats.set(peerIdString, mergedStats);\n      mergedStats.start();\n    }\n    /**\n     * Tracks data running through a given Duplex Iterable `stream`. If\n     * the `peerId` is not provided, a placeholder string will be created and\n     * returned. This allows lazy tracking of a peer when the peer is not yet known.\n     * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n     * with the placeholder string returned from here, and the known `PeerId`.\n     */\n  }, {\n    key: \"trackStream\",\n    value: function trackStream(opts) {\n      var _this = this;\n      var stream = opts.stream,\n        remotePeer = opts.remotePeer,\n        protocol = opts.protocol;\n      if (!this.running) {\n        return;\n      }\n      var source = stream.source;\n      stream.source = each(source, function (chunk) {\n        return _this._onMessage({\n          remotePeer: remotePeer,\n          protocol: protocol,\n          direction: 'in',\n          dataLength: chunk.byteLength\n        });\n      });\n      var sink = stream.sink;\n      stream.sink = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return pipe(source, function (source) {\n                  return each(source, function (chunk) {\n                    _this._onMessage({\n                      remotePeer: remotePeer,\n                      protocol: protocol,\n                      direction: 'out',\n                      dataLength: chunk.byteLength\n                    });\n                  });\n                }, sink);\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n  }]);\n  return DefaultMetrics;\n}();\n/**\n * Merges `other` into `target`. `target` will be modified\n * and returned\n */\nfunction mergeStats(target, other) {\n  target.stop();\n  other.stop();\n  // Merge queues\n  target.queue = [].concat(_toConsumableArray(target.queue), _toConsumableArray(other.queue));\n  // TODO: how to merge moving averages?\n  return target;\n}","map":{"version":3,"names":["pipe","each","LRU","METRICS","defaultOptions","DefaultStats","initialCounters","directionToEvent","in","out","DefaultMetrics","init","_init$maxOldPeersRete","_classCallCheck","enabled","statsInit","_objectSpread","globalStats","peerStats","Map","protocolStats","oldPeers","maxOldPeersRetention","running","_onMessage","bind","systems","_createClass","key","value","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","stop","start","apply","arguments","_stop","_callee2","_iterator","_step","stats","_iterator2","_step2","_stats","_callee2$","_context2","_createForOfIteratorHelper","values","s","n","done","err","e","f","getGlobal","getPeers","Array","from","keys","getComponentMetrics","updateComponentMetric","update","_update$system","system","component","metric","label","help","has","set","systemMetrics","get","Error","componentMetrics","calculate","forPeer","peerId","_this$peerStats$get","idString","toString","getProtocols","forProtocol","protocol","onPeerDisconnected","delete","opts","remotePeer","direction","dataLength","push","updatePlaceholder","placeholder","_this$peerStats$get2","_this$peerStats$get3","placeholderString","placeholderStats","peerIdString","existingStats","mergedStats","mergeStats","remove","trackStream","_this","stream","source","chunk","byteLength","sink","_ref","_callee3","_callee3$","_context3","sent","_x","target","other","queue","concat","_toConsumableArray"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/metrics/index.ts"],"sourcesContent":["import { pipe } from 'it-pipe'\nimport each from 'it-foreach'\nimport LRU from 'hashlru'\nimport { METRICS as defaultOptions } from '../constants.js'\nimport { DefaultStats, StatsInit } from './stats.js'\nimport type { ComponentMetricsUpdate, Metrics, Stats, TrackedMetric, TrackStreamOptions } from '@libp2p/interface-metrics'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Startable } from '@libp2p/interfaces/startable'\n\nconst initialCounters: ['dataReceived', 'dataSent'] = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\nexport interface OnMessageOptions {\n  remotePeer: PeerId\n  protocol?: string\n  direction: 'in' | 'out'\n  dataLength: number\n}\n\nexport interface MetricsInit {\n  enabled: boolean\n  computeThrottleMaxQueueSize: number\n  computeThrottleTimeout: number\n  movingAverageIntervals: number[]\n  maxOldPeersRetention: number\n}\n\nexport class DefaultMetrics implements Metrics, Startable {\n  public globalStats: DefaultStats\n\n  private readonly enabled: boolean\n  private readonly peerStats: Map<string, DefaultStats>\n  private readonly protocolStats: Map<string, DefaultStats>\n  private readonly oldPeers: ReturnType<typeof LRU>\n  private running: boolean\n  private readonly systems: Map<string, Map<string, Map<string, TrackedMetric>>>\n  private readonly statsInit: StatsInit\n\n  constructor (init: MetricsInit) {\n    this.enabled = init.enabled\n    this.statsInit = {\n      ...init,\n      initialCounters\n    }\n    this.globalStats = new DefaultStats(this.statsInit)\n    this.peerStats = new Map()\n    this.protocolStats = new Map()\n    this.oldPeers = LRU(init.maxOldPeersRetention ?? defaultOptions.maxOldPeersRetention)\n    this.running = false\n    this._onMessage = this._onMessage.bind(this)\n    this.systems = new Map()\n  }\n\n  isStarted () {\n    return this.running\n  }\n\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n  async start () {\n    if (!this.enabled) {\n      return\n    }\n\n    this.running = true\n  }\n\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n  async stop () {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    this.globalStats.stop()\n\n    for (const stats of this.peerStats.values()) {\n      stats.stop()\n    }\n\n    for (const stats of this.protocolStats.values()) {\n      stats.stop()\n    }\n  }\n\n  /**\n   * Gets the global `Stats` object\n   */\n  getGlobal () {\n    return this.globalStats\n  }\n\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   */\n  getPeers () {\n    return Array.from(this.peerStats.keys())\n  }\n\n  getComponentMetrics () {\n    return this.systems\n  }\n\n  updateComponentMetric (update: ComponentMetricsUpdate) {\n    const { system = 'libp2p', component, metric, value, label, help } = update\n\n    if (!this.systems.has(system)) {\n      this.systems.set(system, new Map())\n    }\n\n    const systemMetrics = this.systems.get(system)\n\n    if (systemMetrics == null) {\n      throw new Error('Unknown metric system')\n    }\n\n    if (!systemMetrics.has(component)) {\n      systemMetrics.set(component, new Map())\n    }\n\n    const componentMetrics = systemMetrics.get(component)\n\n    if (componentMetrics == null) {\n      throw new Error('Unknown metric component')\n    }\n\n    componentMetrics.set(metric, {\n      label,\n      help,\n      calculate: typeof value !== 'function' ? () => value : value\n    })\n  }\n\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   */\n  forPeer (peerId: PeerId): Stats | undefined {\n    const idString = peerId.toString()\n    return this.peerStats.get(idString) ?? this.oldPeers.get(idString)\n  }\n\n  /**\n   * Returns a list of all protocol strings currently being tracked\n   */\n  getProtocols (): string[] {\n    return Array.from(this.protocolStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `protocol`\n   */\n  forProtocol (protocol: string): Stats | undefined {\n    return this.protocolStats.get(protocol)\n  }\n\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   */\n  onPeerDisconnected (peerId: PeerId) {\n    const idString = peerId.toString()\n    const peerStats = this.peerStats.get(idString)\n\n    if (peerStats != null) {\n      peerStats.stop()\n\n      this.peerStats.delete(idString)\n      this.oldPeers.set(idString, peerStats)\n    }\n  }\n\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   */\n  _onMessage (opts: OnMessageOptions) {\n    if (!this.running) {\n      return\n    }\n\n    const { remotePeer, protocol, direction, dataLength } = opts\n\n    const key = directionToEvent[direction]\n\n    let peerStats = this.forPeer(remotePeer)\n    if (peerStats == null) {\n      const stats = new DefaultStats(this.statsInit)\n      this.peerStats.set(remotePeer.toString(), stats)\n      peerStats = stats\n    }\n\n    // Peer and global stats\n    peerStats.push(key, dataLength)\n    this.globalStats.push(key, dataLength)\n\n    // Protocol specific stats\n    if (protocol != null) {\n      let protocolStats = this.forProtocol(protocol)\n\n      if (protocolStats == null) {\n        const stats = new DefaultStats(this.statsInit)\n        this.protocolStats.set(protocol, stats)\n        protocolStats = stats\n      }\n\n      protocolStats.push(key, dataLength)\n    }\n  }\n\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  updatePlaceholder (placeholder: PeerId, peerId: PeerId) {\n    if (!this.running) {\n      return\n    }\n\n    const placeholderString = placeholder.toString()\n    const placeholderStats = this.peerStats.get(placeholderString) ?? this.oldPeers.get(placeholderString)\n    const peerIdString = peerId.toString()\n    const existingStats = this.peerStats.get(peerIdString) ?? this.oldPeers.get(peerIdString)\n    let mergedStats = placeholderStats\n\n    // If we already have stats, merge the two\n    if (existingStats != null) {\n      // If existing, merge\n      mergedStats = mergeStats(existingStats, mergedStats)\n      // Attempt to delete from the old peers list just in case it was tracked there\n      this.oldPeers.remove(peerIdString)\n    }\n\n    this.peerStats.delete(placeholder.toString())\n    this.peerStats.set(peerIdString, mergedStats)\n    mergedStats.start()\n  }\n\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   */\n  trackStream (opts: TrackStreamOptions): void {\n    const { stream, remotePeer, protocol } = opts\n\n    if (!this.running) {\n      return\n    }\n\n    const source = stream.source\n    stream.source = each(source, chunk => this._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.byteLength\n    }))\n\n    const sink = stream.sink\n    stream.sink = async source => {\n      return await pipe(\n        source,\n        (source) => each(source, chunk => {\n          this._onMessage({\n            remotePeer,\n            protocol,\n            direction: 'out',\n            dataLength: chunk.byteLength\n          })\n        }),\n        sink\n      )\n    }\n  }\n}\n\n/**\n * Merges `other` into `target`. `target` will be modified\n * and returned\n */\nfunction mergeStats (target: DefaultStats, other: DefaultStats) {\n  target.stop()\n  other.stop()\n\n  // Merge queues\n  target.queue = [...target.queue, ...other.queue]\n\n  // TODO: how to merge moving averages?\n  return target\n}\n"],"mappings":";;;;;;;AAAA,SAASA,IAAI,QAAQ,SAAS;AAC9B,OAAOC,IAAI,MAAM,YAAY;AAC7B,OAAOC,GAAG,MAAM,SAAS;AACzB,SAASC,OAAO,IAAIC,cAAc,QAAQ,iBAAiB;AAC3D,SAASC,YAAY,QAAmB,YAAY;AAKpD,IAAMC,eAAe,GAAiC,CACpD,cAAc,EACd,UAAU,CACX;AAED,IAAMC,gBAAgB,GAAG;EACvBC,EAAE,EAAE,cAAc;EAClBC,GAAG,EAAE;CACN;AAiBD,WAAaC,cAAc;EAWzB,SAAAA,eAAaC,IAAiB;IAAA,IAAAC,qBAAA;IAAAC,eAAA,OAAAH,cAAA;IAC5B,IAAI,CAACI,OAAO,GAAGH,IAAI,CAACG,OAAO;IAC3B,IAAI,CAACC,SAAS,GAAAC,aAAA,CAAAA,aAAA,KACTL,IAAI;MACPL,eAAe,EAAfA;IAAe,EAChB;IACD,IAAI,CAACW,WAAW,GAAG,IAAIZ,YAAY,CAAC,IAAI,CAACU,SAAS,CAAC;IACnD,IAAI,CAACG,SAAS,GAAG,IAAIC,GAAG,EAAE;IAC1B,IAAI,CAACC,aAAa,GAAG,IAAID,GAAG,EAAE;IAC9B,IAAI,CAACE,QAAQ,GAAGnB,GAAG,EAAAU,qBAAA,GAACD,IAAI,CAACW,oBAAoB,cAAAV,qBAAA,cAAAA,qBAAA,GAAIR,cAAc,CAACkB,oBAAoB,CAAC;IACrF,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,UAAU,GAAG,IAAI,CAACA,UAAU,CAACC,IAAI,CAAC,IAAI,CAAC;IAC5C,IAAI,CAACC,OAAO,GAAG,IAAIP,GAAG,EAAE;EAC1B;EAACQ,YAAA,CAAAjB,cAAA;IAAAkB,GAAA;IAAAC,KAAA,EAED,SAAAC,UAAA,EAAS;MACP,OAAO,IAAI,CAACP,OAAO;IACrB;IAEA;;;;EAAA;IAAAK,GAAA;IAAAC,KAAA;MAAA,IAAAE,MAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAIA,SAAAC,QAAA;QAAA,OAAAF,mBAAA,GAAAG,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAA,IACO,IAAI,CAAC1B,OAAO;gBAAAwB,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAAA,OAAAF,QAAA,CAAAG,MAAA;YAAA;cAIjB,IAAI,CAAClB,OAAO,GAAG,IAAI;YAAA;YAAA;cAAA,OAAAe,QAAA,CAAAI,IAAA;UAAA;QAAA,GAAAP,OAAA;MAAA,CACpB;MAAA,SAAAQ,MAAA;QAAA,OAAAZ,MAAA,CAAAa,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAF,KAAA;IAAA;IAED;;;;EAAA;IAAAf,GAAA;IAAAC,KAAA;MAAA,IAAAiB,KAAA,GAAAd,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAIA,SAAAa,SAAA;QAAA,IAAAC,SAAA,EAAAC,KAAA,EAAAC,KAAA,EAAAC,UAAA,EAAAC,MAAA,EAAAC,MAAA;QAAA,OAAApB,mBAAA,GAAAG,IAAA,UAAAkB,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAhB,IAAA,GAAAgB,SAAA,CAAAf,IAAA;YAAA;cAAA,IACO,IAAI,CAACjB,OAAO;gBAAAgC,SAAA,CAAAf,IAAA;gBAAA;cAAA;cAAA,OAAAe,SAAA,CAAAd,MAAA;YAAA;cAIjB,IAAI,CAAClB,OAAO,GAAG,KAAK;cACpB,IAAI,CAACN,WAAW,CAACyB,IAAI,EAAE;cAAAM,SAAA,GAAAQ,0BAAA,CAEH,IAAI,CAACtC,SAAS,CAACuC,MAAM,EAAE;cAAA;gBAA3C,KAAAT,SAAA,CAAAU,CAAA,MAAAT,KAAA,GAAAD,SAAA,CAAAW,CAAA,IAAAC,IAAA,GAA6C;kBAAlCV,KAAK,GAAAD,KAAA,CAAApB,KAAA;kBACdqB,KAAK,CAACR,IAAI,EAAE;;cACb,SAAAmB,GAAA;gBAAAb,SAAA,CAAAc,CAAA,CAAAD,GAAA;cAAA;gBAAAb,SAAA,CAAAe,CAAA;cAAA;cAAAZ,UAAA,GAAAK,0BAAA,CAEmB,IAAI,CAACpC,aAAa,CAACqC,MAAM,EAAE;cAAA;gBAA/C,KAAAN,UAAA,CAAAO,CAAA,MAAAN,MAAA,GAAAD,UAAA,CAAAQ,CAAA,IAAAC,IAAA,GAAiD;kBAAtCV,MAAK,GAAAE,MAAA,CAAAvB,KAAA;kBACdqB,MAAK,CAACR,IAAI,EAAE;;cACb,SAAAmB,GAAA;gBAAAV,UAAA,CAAAW,CAAA,CAAAD,GAAA;cAAA;gBAAAV,UAAA,CAAAY,CAAA;cAAA;YAAA;YAAA;cAAA,OAAAR,SAAA,CAAAb,IAAA;UAAA;QAAA,GAAAK,QAAA;MAAA,CACF;MAAA,SAAAL,KAAA;QAAA,OAAAI,KAAA,CAAAF,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAH,IAAA;IAAA;IAED;;;EAAA;IAAAd,GAAA;IAAAC,KAAA,EAGA,SAAAmC,UAAA,EAAS;MACP,OAAO,IAAI,CAAC/C,WAAW;IACzB;IAEA;;;EAAA;IAAAW,GAAA;IAAAC,KAAA,EAGA,SAAAoC,SAAA,EAAQ;MACN,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACjD,SAAS,CAACkD,IAAI,EAAE,CAAC;IAC1C;EAAC;IAAAxC,GAAA;IAAAC,KAAA,EAED,SAAAwC,oBAAA,EAAmB;MACjB,OAAO,IAAI,CAAC3C,OAAO;IACrB;EAAC;IAAAE,GAAA;IAAAC,KAAA,EAED,SAAAyC,sBAAuBC,MAA8B;MACnD,IAAAC,cAAA,GAAqED,MAAM,CAAnEE,MAAM;QAANA,MAAM,GAAAD,cAAA,cAAG,QAAQ,GAAAA,cAAA;QAAEE,SAAS,GAAiCH,MAAM,CAAhDG,SAAS;QAAEC,MAAM,GAAyBJ,MAAM,CAArCI,MAAM;QAAE9C,KAAK,GAAkB0C,MAAM,CAA7B1C,KAAK;QAAE+C,KAAK,GAAWL,MAAM,CAAtBK,KAAK;QAAEC,IAAI,GAAKN,MAAM,CAAfM,IAAI;MAEhE,IAAI,CAAC,IAAI,CAACnD,OAAO,CAACoD,GAAG,CAACL,MAAM,CAAC,EAAE;QAC7B,IAAI,CAAC/C,OAAO,CAACqD,GAAG,CAACN,MAAM,EAAE,IAAItD,GAAG,EAAE,CAAC;;MAGrC,IAAM6D,aAAa,GAAG,IAAI,CAACtD,OAAO,CAACuD,GAAG,CAACR,MAAM,CAAC;MAE9C,IAAIO,aAAa,IAAI,IAAI,EAAE;QACzB,MAAM,IAAIE,KAAK,CAAC,uBAAuB,CAAC;;MAG1C,IAAI,CAACF,aAAa,CAACF,GAAG,CAACJ,SAAS,CAAC,EAAE;QACjCM,aAAa,CAACD,GAAG,CAACL,SAAS,EAAE,IAAIvD,GAAG,EAAE,CAAC;;MAGzC,IAAMgE,gBAAgB,GAAGH,aAAa,CAACC,GAAG,CAACP,SAAS,CAAC;MAErD,IAAIS,gBAAgB,IAAI,IAAI,EAAE;QAC5B,MAAM,IAAID,KAAK,CAAC,0BAA0B,CAAC;;MAG7CC,gBAAgB,CAACJ,GAAG,CAACJ,MAAM,EAAE;QAC3BC,KAAK,EAALA,KAAK;QACLC,IAAI,EAAJA,IAAI;QACJO,SAAS,EAAE,OAAOvD,KAAK,KAAK,UAAU,GAAG;UAAA,OAAMA,KAAK;QAAA,IAAGA;OACxD,CAAC;IACJ;IAEA;;;;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAIA,SAAAwD,QAASC,MAAc;MAAA,IAAAC,mBAAA;MACrB,IAAMC,QAAQ,GAAGF,MAAM,CAACG,QAAQ,EAAE;MAClC,QAAAF,mBAAA,GAAO,IAAI,CAACrE,SAAS,CAAC+D,GAAG,CAACO,QAAQ,CAAC,cAAAD,mBAAA,cAAAA,mBAAA,GAAI,IAAI,CAAClE,QAAQ,CAAC4D,GAAG,CAACO,QAAQ,CAAC;IACpE;IAEA;;;EAAA;IAAA5D,GAAA;IAAAC,KAAA,EAGA,SAAA6D,aAAA,EAAY;MACV,OAAOxB,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC/C,aAAa,CAACgD,IAAI,EAAE,CAAC;IAC9C;IAEA;;;EAAA;IAAAxC,GAAA;IAAAC,KAAA,EAGA,SAAA8D,YAAaC,QAAgB;MAC3B,OAAO,IAAI,CAACxE,aAAa,CAAC6D,GAAG,CAACW,QAAQ,CAAC;IACzC;IAEA;;;;;EAAA;IAAAhE,GAAA;IAAAC,KAAA,EAKA,SAAAgE,mBAAoBP,MAAc;MAChC,IAAME,QAAQ,GAAGF,MAAM,CAACG,QAAQ,EAAE;MAClC,IAAMvE,SAAS,GAAG,IAAI,CAACA,SAAS,CAAC+D,GAAG,CAACO,QAAQ,CAAC;MAE9C,IAAItE,SAAS,IAAI,IAAI,EAAE;QACrBA,SAAS,CAACwB,IAAI,EAAE;QAEhB,IAAI,CAACxB,SAAS,CAAC4E,MAAM,CAACN,QAAQ,CAAC;QAC/B,IAAI,CAACnE,QAAQ,CAAC0D,GAAG,CAACS,QAAQ,EAAEtE,SAAS,CAAC;;IAE1C;IAEA;;;;;EAAA;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAAL,WAAYuE,IAAsB;MAChC,IAAI,CAAC,IAAI,CAACxE,OAAO,EAAE;QACjB;;MAGF,IAAQyE,UAAU,GAAsCD,IAAI,CAApDC,UAAU;QAAEJ,QAAQ,GAA4BG,IAAI,CAAxCH,QAAQ;QAAEK,SAAS,GAAiBF,IAAI,CAA9BE,SAAS;QAAEC,UAAU,GAAKH,IAAI,CAAnBG,UAAU;MAEnD,IAAMtE,GAAG,GAAGrB,gBAAgB,CAAC0F,SAAS,CAAC;MAEvC,IAAI/E,SAAS,GAAG,IAAI,CAACmE,OAAO,CAACW,UAAU,CAAC;MACxC,IAAI9E,SAAS,IAAI,IAAI,EAAE;QACrB,IAAMgC,KAAK,GAAG,IAAI7C,YAAY,CAAC,IAAI,CAACU,SAAS,CAAC;QAC9C,IAAI,CAACG,SAAS,CAAC6D,GAAG,CAACiB,UAAU,CAACP,QAAQ,EAAE,EAAEvC,KAAK,CAAC;QAChDhC,SAAS,GAAGgC,KAAK;;MAGnB;MACAhC,SAAS,CAACiF,IAAI,CAACvE,GAAG,EAAEsE,UAAU,CAAC;MAC/B,IAAI,CAACjF,WAAW,CAACkF,IAAI,CAACvE,GAAG,EAAEsE,UAAU,CAAC;MAEtC;MACA,IAAIN,QAAQ,IAAI,IAAI,EAAE;QACpB,IAAIxE,aAAa,GAAG,IAAI,CAACuE,WAAW,CAACC,QAAQ,CAAC;QAE9C,IAAIxE,aAAa,IAAI,IAAI,EAAE;UACzB,IAAM8B,OAAK,GAAG,IAAI7C,YAAY,CAAC,IAAI,CAACU,SAAS,CAAC;UAC9C,IAAI,CAACK,aAAa,CAAC2D,GAAG,CAACa,QAAQ,EAAE1C,OAAK,CAAC;UACvC9B,aAAa,GAAG8B,OAAK;;QAGvB9B,aAAa,CAAC+E,IAAI,CAACvE,GAAG,EAAEsE,UAAU,CAAC;;IAEvC;IAEA;;;;;;;;;EAAA;IAAAtE,GAAA;IAAAC,KAAA,EASA,SAAAuE,kBAAmBC,WAAmB,EAAEf,MAAc;MAAA,IAAAgB,oBAAA,EAAAC,oBAAA;MACpD,IAAI,CAAC,IAAI,CAAChF,OAAO,EAAE;QACjB;;MAGF,IAAMiF,iBAAiB,GAAGH,WAAW,CAACZ,QAAQ,EAAE;MAChD,IAAMgB,gBAAgB,IAAAH,oBAAA,GAAG,IAAI,CAACpF,SAAS,CAAC+D,GAAG,CAACuB,iBAAiB,CAAC,cAAAF,oBAAA,cAAAA,oBAAA,GAAI,IAAI,CAACjF,QAAQ,CAAC4D,GAAG,CAACuB,iBAAiB,CAAC;MACtG,IAAME,YAAY,GAAGpB,MAAM,CAACG,QAAQ,EAAE;MACtC,IAAMkB,aAAa,IAAAJ,oBAAA,GAAG,IAAI,CAACrF,SAAS,CAAC+D,GAAG,CAACyB,YAAY,CAAC,cAAAH,oBAAA,cAAAA,oBAAA,GAAI,IAAI,CAAClF,QAAQ,CAAC4D,GAAG,CAACyB,YAAY,CAAC;MACzF,IAAIE,WAAW,GAAGH,gBAAgB;MAElC;MACA,IAAIE,aAAa,IAAI,IAAI,EAAE;QACzB;QACAC,WAAW,GAAGC,UAAU,CAACF,aAAa,EAAEC,WAAW,CAAC;QACpD;QACA,IAAI,CAACvF,QAAQ,CAACyF,MAAM,CAACJ,YAAY,CAAC;;MAGpC,IAAI,CAACxF,SAAS,CAAC4E,MAAM,CAACO,WAAW,CAACZ,QAAQ,EAAE,CAAC;MAC7C,IAAI,CAACvE,SAAS,CAAC6D,GAAG,CAAC2B,YAAY,EAAEE,WAAW,CAAC;MAC7CA,WAAW,CAACjE,KAAK,EAAE;IACrB;IAEA;;;;;;;EAAA;IAAAf,GAAA;IAAAC,KAAA,EAOA,SAAAkF,YAAahB,IAAwB;MAAA,IAAAiB,KAAA;MACnC,IAAQC,MAAM,GAA2BlB,IAAI,CAArCkB,MAAM;QAAEjB,UAAU,GAAeD,IAAI,CAA7BC,UAAU;QAAEJ,QAAQ,GAAKG,IAAI,CAAjBH,QAAQ;MAEpC,IAAI,CAAC,IAAI,CAACrE,OAAO,EAAE;QACjB;;MAGF,IAAM2F,MAAM,GAAGD,MAAM,CAACC,MAAM;MAC5BD,MAAM,CAACC,MAAM,GAAGjH,IAAI,CAACiH,MAAM,EAAE,UAAAC,KAAK;QAAA,OAAIH,KAAI,CAACxF,UAAU,CAAC;UACpDwE,UAAU,EAAVA,UAAU;UACVJ,QAAQ,EAARA,QAAQ;UACRK,SAAS,EAAE,IAAI;UACfC,UAAU,EAAEiB,KAAK,CAACC;SACnB,CAAC;MAAA,EAAC;MAEH,IAAMC,IAAI,GAAGJ,MAAM,CAACI,IAAI;MACxBJ,MAAM,CAACI,IAAI;QAAA,IAAAC,IAAA,GAAAtF,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAqF,SAAML,MAAM;UAAA,OAAAjF,mBAAA,GAAAG,IAAA,UAAAoF,UAAAC,SAAA;YAAA,kBAAAA,SAAA,CAAAlF,IAAA,GAAAkF,SAAA,CAAAjF,IAAA;cAAA;gBAAAiF,SAAA,CAAAjF,IAAA;gBAAA,OACXxC,IAAI,CACfkH,MAAM,EACN,UAACA,MAAM;kBAAA,OAAKjH,IAAI,CAACiH,MAAM,EAAE,UAAAC,KAAK,EAAG;oBAC/BH,KAAI,CAACxF,UAAU,CAAC;sBACdwE,UAAU,EAAVA,UAAU;sBACVJ,QAAQ,EAARA,QAAQ;sBACRK,SAAS,EAAE,KAAK;sBAChBC,UAAU,EAAEiB,KAAK,CAACC;qBACnB,CAAC;kBACJ,CAAC,CAAC;gBAAA,GACFC,IAAI,CACL;cAAA;gBAAA,OAAAI,SAAA,CAAAhF,MAAA,WAAAgF,SAAA,CAAAC,IAAA;cAAA;cAAA;gBAAA,OAAAD,SAAA,CAAA/E,IAAA;YAAA;UAAA,GAAA6E,QAAA;QAAA,CACF;QAAA,iBAAAI,EAAA;UAAA,OAAAL,IAAA,CAAA1E,KAAA,OAAAC,SAAA;QAAA;MAAA;IACH;EAAC;EAAA,OAAAnC,cAAA;AAAA;AAGH;;;;AAIA,SAASmG,UAAUA,CAAEe,MAAoB,EAAEC,KAAmB;EAC5DD,MAAM,CAAClF,IAAI,EAAE;EACbmF,KAAK,CAACnF,IAAI,EAAE;EAEZ;EACAkF,MAAM,CAACE,KAAK,MAAAC,MAAA,CAAAC,kBAAA,CAAOJ,MAAM,CAACE,KAAK,GAAAE,kBAAA,CAAKH,KAAK,CAACC,KAAK,EAAC;EAEhD;EACA,OAAOF,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}