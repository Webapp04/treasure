{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\n\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/** @type {{success:true, time:0, text: ''}} */\nvar basePacket = {\n  success: true,\n  time: 0,\n  text: ''\n};\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n */\nexport function createPing(_ref) {\n  var network = _ref.network;\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"ping\"]}\n   */\n  function ping(_x) {\n    return _ping.apply(this, arguments);\n  }\n  function _ping() {\n    _ping = _wrapAsyncGenerator(function (peerId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _yield$_awaitAsyncGen, libp2p, storedPeer, id, remotePeer, packetCount, totalTime, i, time, average;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _awaitAsyncGenerator(network.use());\n            case 2:\n              _yield$_awaitAsyncGen = _context.sent;\n              libp2p = _yield$_awaitAsyncGen.libp2p;\n              options.count = options.count || 10;\n              _context.next = 7;\n              return _awaitAsyncGenerator(libp2p.peerStore.get(peerId));\n            case 7:\n              storedPeer = _context.sent;\n              id = storedPeer && storedPeer.id;\n              if (id) {\n                _context.next = 16;\n                break;\n              }\n              _context.next = 12;\n              return _objectSpread(_objectSpread({}, basePacket), {}, {\n                text: \"Looking up peer \".concat(peerId)\n              });\n            case 12:\n              _context.next = 14;\n              return _awaitAsyncGenerator(libp2p.peerRouting.findPeer(peerId));\n            case 14:\n              remotePeer = _context.sent;\n              id = remotePeer && remotePeer.id;\n            case 16:\n              if (id) {\n                _context.next = 18;\n                break;\n              }\n              throw new Error('Peer was not found');\n            case 18:\n              _context.next = 20;\n              return _objectSpread(_objectSpread({}, basePacket), {}, {\n                text: \"PING \".concat(id.toString())\n              });\n            case 20:\n              packetCount = 0;\n              totalTime = 0;\n              i = 0;\n            case 23:\n              if (!(i < options.count)) {\n                _context.next = 41;\n                break;\n              }\n              _context.prev = 24;\n              _context.next = 27;\n              return _awaitAsyncGenerator(libp2p.ping(id));\n            case 27:\n              time = _context.sent;\n              totalTime += time;\n              packetCount++;\n              _context.next = 32;\n              return _objectSpread(_objectSpread({}, basePacket), {}, {\n                time: time\n              });\n            case 32:\n              _context.next = 38;\n              break;\n            case 34:\n              _context.prev = 34;\n              _context.t0 = _context[\"catch\"](24);\n              _context.next = 38;\n              return _objectSpread(_objectSpread({}, basePacket), {}, {\n                success: false,\n                text: _context.t0.toString()\n              });\n            case 38:\n              i++;\n              _context.next = 23;\n              break;\n            case 41:\n              if (!packetCount) {\n                _context.next = 45;\n                break;\n              }\n              average = totalTime / packetCount;\n              _context.next = 45;\n              return _objectSpread(_objectSpread({}, basePacket), {}, {\n                text: \"Average latency: \".concat(average, \"ms\")\n              });\n            case 45:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[24, 34]]);\n      })();\n    });\n    return _ping.apply(this, arguments);\n  }\n  return withTimeoutOption(ping);\n}","map":{"version":3,"names":["withTimeoutOption","basePacket","success","time","text","createPing","_ref","network","ping","_x","_ping","apply","arguments","_wrapAsyncGenerator","peerId","options","length","undefined","_regeneratorRuntime","mark","_callee","_yield$_awaitAsyncGen","libp2p","storedPeer","id","remotePeer","packetCount","totalTime","i","average","wrap","_callee$","_context","prev","next","_awaitAsyncGenerator","use","sent","count","peerStore","get","_objectSpread","concat","peerRouting","findPeer","Error","toString","t0","stop"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/ping.js"],"sourcesContent":["import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/** @type {{success:true, time:0, text: ''}} */\nconst basePacket = { success: true, time: 0, text: '' }\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n */\nexport function createPing ({ network }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"ping\"]}\n   */\n  async function * ping (peerId, options = {}) {\n    const { libp2p } = await network.use()\n    options.count = options.count || 10\n\n    const storedPeer = await libp2p.peerStore.get(peerId)\n    let id = storedPeer && storedPeer.id\n\n    if (!id) {\n      yield { ...basePacket, text: `Looking up peer ${peerId}` }\n      const remotePeer = await libp2p.peerRouting.findPeer(peerId)\n\n      id = remotePeer && remotePeer.id\n    }\n\n    if (!id) {\n      throw new Error('Peer was not found')\n    }\n\n    yield { ...basePacket, text: `PING ${id.toString()}` }\n\n    let packetCount = 0\n    let totalTime = 0\n\n    for (let i = 0; i < options.count; i++) {\n      try {\n        const time = await libp2p.ping(id)\n        totalTime += time\n        packetCount++\n        yield { ...basePacket, time }\n      } catch (/** @type {any} */ err) {\n        yield { ...basePacket, success: false, text: err.toString() }\n      }\n    }\n\n    if (packetCount) {\n      const average = totalTime / packetCount\n      yield { ...basePacket, text: `Average latency: ${average}ms` }\n    }\n  }\n\n  return withTimeoutOption(ping)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}