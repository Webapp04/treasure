{"ast":null,"code":"import _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport var PeerMap = /*#__PURE__*/function (_Symbol$iterator) {\n  function PeerMap(map) {\n    _classCallCheck(this, PeerMap);\n    this.map = new Map();\n    if (map != null) {\n      var _iterator = _createForOfIteratorHelper(map.entries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n          this.map.set(key.toString(), value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  _createClass(PeerMap, [{\n    key: _Symbol$iterator,\n    value: function value() {\n      return this.entries();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.map.clear();\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(peer) {\n      this.map.delete(peer.toString());\n    }\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      return mapIterable(this.map.entries(), function (val) {\n        return [peerIdFromString(val[0]), val[1]];\n      });\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      var _this = this;\n      this.map.forEach(function (value, key) {\n        fn(value, peerIdFromString(key), _this);\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(peer) {\n      return this.map.get(peer.toString());\n    }\n  }, {\n    key: \"has\",\n    value: function has(peer) {\n      return this.map.has(peer.toString());\n    }\n  }, {\n    key: \"set\",\n    value: function set(peer, value) {\n      this.map.set(peer.toString(), value);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return mapIterable(this.map.keys(), function (val) {\n        return peerIdFromString(val);\n      });\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      return this.map.values();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.map.size;\n    }\n  }]);\n  return PeerMap;\n}(Symbol.iterator);","map":{"version":3,"names":["peerIdFromString","mapIterable","PeerMap","_Symbol$iterator","map","_classCallCheck","Map","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","value","key","set","toString","err","e","f","_createClass","clear","_delete","peer","delete","val","forEach","fn","_this","get","has","keys","values","size","Symbol","iterator"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/peer-collections/src/map.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { mapIterable } from './util.js'\n\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap <T> {\n  private readonly map: Map<string, T>\n\n  constructor (map?: PeerMap<T>) {\n    this.map = new Map()\n\n    if (map != null) {\n      for (const [key, value] of map.entries()) {\n        this.map.set(key.toString(), value)\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<[PeerId, T]> {\n    return this.entries()\n  }\n\n  clear (): void {\n    this.map.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.map.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, T]> {\n    return mapIterable<[string, T], [PeerId, T]>(\n      this.map.entries(),\n      (val) => {\n        return [peerIdFromString(val[0]), val[1]]\n      }\n    )\n  }\n\n  forEach (fn: (value: T, key: PeerId, map: PeerMap<T>) => void): void {\n    this.map.forEach((value, key) => {\n      fn(value, peerIdFromString(key), this)\n    })\n  }\n\n  get (peer: PeerId): T | undefined {\n    return this.map.get(peer.toString())\n  }\n\n  has (peer: PeerId): boolean {\n    return this.map.has(peer.toString())\n  }\n\n  set (peer: PeerId, value: T): void {\n    this.map.set(peer.toString(), value)\n  }\n\n  keys (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.map.keys(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  values (): IterableIterator<T> {\n    return this.map.values()\n  }\n\n  get size (): number {\n    return this.map.size\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}