{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport webcrypto from '../webcrypto.js';\nimport { base64urlToBuffer } from '../util.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nvar bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\nvar curveTypes = Object.keys(bits);\nvar names = curveTypes.join(' / ');\nexport function generateEphmeralKeyPair(_x) {\n  return _generateEphmeralKeyPair.apply(this, arguments);\n}\nfunction _generateEphmeralKeyPair() {\n  _generateEphmeralKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(curve) {\n    var pair, genSharedKey, publicKey, ecdhKey;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521')) {\n            _context2.next = 2;\n            break;\n          }\n          throw new CodeError(\"Unknown curve: \".concat(curve, \". Must be \").concat(names), 'ERR_INVALID_CURVE');\n        case 2:\n          _context2.next = 4;\n          return webcrypto.get().subtle.generateKey({\n            name: 'ECDH',\n            namedCurve: curve\n          }, true, ['deriveBits']);\n        case 4:\n          pair = _context2.sent;\n          // forcePrivate is used for testing only\n          genSharedKey = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(theirPub, forcePrivate) {\n              var privateKey, key, buffer;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!(forcePrivate != null)) {\n                      _context.next = 6;\n                      break;\n                    }\n                    _context.next = 3;\n                    return webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n                      name: 'ECDH',\n                      namedCurve: curve\n                    }, false, ['deriveBits']);\n                  case 3:\n                    privateKey = _context.sent;\n                    _context.next = 7;\n                    break;\n                  case 6:\n                    privateKey = pair.privateKey;\n                  case 7:\n                    _context.next = 9;\n                    return webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n                      name: 'ECDH',\n                      namedCurve: curve\n                    }, false, []);\n                  case 9:\n                    key = _context.sent;\n                    _context.next = 12;\n                    return webcrypto.get().subtle.deriveBits({\n                      name: 'ECDH',\n                      // @ts-expect-error namedCurve is missing from the types\n                      namedCurve: curve,\n                      public: key\n                    }, privateKey, bits[curve]);\n                  case 12:\n                    buffer = _context.sent;\n                    return _context.abrupt(\"return\", new Uint8Array(buffer, 0, buffer.byteLength));\n                  case 14:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }));\n            return function genSharedKey(_x2, _x3) {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          _context2.next = 8;\n          return webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n        case 8:\n          publicKey = _context2.sent;\n          ecdhKey = {\n            key: marshalPublicKey(publicKey),\n            genSharedKey: genSharedKey\n          };\n          return _context2.abrupt(\"return\", ecdhKey);\n        case 11:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _generateEphmeralKeyPair.apply(this, arguments);\n}\nvar curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n};\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey(jwk) {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n  }\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new CodeError(\"Unknown curve: \".concat(jwk.crv, \". Must be \").concat(names), 'ERR_INVALID_CURVE');\n  }\n  var byteLen = curveLengths[jwk.crv];\n  return uint8ArrayConcat([Uint8Array.from([4]), base64urlToBuffer(jwk.x, byteLen), base64urlToBuffer(jwk.y, byteLen)], 1 + byteLen * 2);\n}\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey(curve, key) {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(\"Unknown curve: \".concat(curve, \". Must be \").concat(names), 'ERR_INVALID_CURVE');\n  }\n  var byteLen = curveLengths[curve];\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT');\n  }\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  };\n}\nvar unmarshalPrivateKey = function unmarshalPrivateKey(curve, key) {\n  return _objectSpread(_objectSpread({}, unmarshalPublicKey(curve, key.public)), {}, {\n    d: uint8ArrayToString(key.private, 'base64url')\n  });\n};","map":{"version":3,"names":["CodeError","webcrypto","base64urlToBuffer","toString","uint8ArrayToString","concat","uint8ArrayConcat","equals","uint8ArrayEquals","bits","curveTypes","Object","keys","names","join","generateEphmeralKeyPair","_x","_generateEphmeralKeyPair","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","curve","pair","genSharedKey","publicKey","ecdhKey","wrap","_callee2$","_context2","prev","next","get","subtle","generateKey","name","namedCurve","sent","_ref","_callee","theirPub","forcePrivate","privateKey","key","buffer","_callee$","_context","importKey","unmarshalPrivateKey","unmarshalPublicKey","deriveBits","public","abrupt","Uint8Array","byteLength","stop","_x2","_x3","exportKey","marshalPublicKey","curveLengths","jwk","crv","x","y","byteLen","from","subarray","kty","ext","_objectSpread","d","private"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/crypto/src/keys/ecdh-browser.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport webcrypto from '../webcrypto.js'\nimport { base64urlToBuffer } from '../util.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { ECDHKey, ECDHKeyPair } from './interface.js'\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nconst curveTypes = Object.keys(bits)\nconst names = curveTypes.join(' / ')\n\nexport async function generateEphmeralKeyPair (curve: string) {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub: Uint8Array, forcePrivate?: ECDHKeyPair) => {\n    let privateKey\n\n    if (forcePrivate != null) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const key = await webcrypto.get().subtle.importKey(\n      'jwk',\n      unmarshalPublicKey(curve, theirPub),\n      {\n        name: 'ECDH',\n        namedCurve: curve\n      },\n      false,\n      []\n    )\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        // @ts-expect-error namedCurve is missing from the types\n        namedCurve: curve,\n        public: key\n      },\n      privateKey,\n      bits[curve]\n    )\n\n    return new Uint8Array(buffer, 0, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  const ecdhKey: ECDHKey = {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n\n  return ecdhKey\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk: JsonWebKey) {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve: string, key: Uint8Array) {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const byteLen = curveLengths[curve]\n\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve: string, key: ECDHKeyPair) => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}