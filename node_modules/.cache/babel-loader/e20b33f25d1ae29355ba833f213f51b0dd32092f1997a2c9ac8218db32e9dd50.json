{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/* eslint complexity: [\"error\", 28] */\n\nimport defaultMigrations from '../migrations/index.js';\nimport * as repoVersion from './repo/version.js';\nimport * as Errors from './errors.js';\nimport { wrapBackends } from './utils.js';\nimport debug from 'debug';\nvar log = debug('ipfs:repo:migrator');\n\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\nexport function getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n  return migrations[migrations.length - 1].version;\n}\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\nexport function migrate(_x, _x2, _x3, _x4) {\n  return _migrate.apply(this, arguments);\n}\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\nfunction _migrate() {\n  _migrate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path, backends, repoOptions, toVersion) {\n    var _options$ignoreLock, _options$isDryRun, _options$migrations;\n    var options,\n      ignoreLock,\n      onProgress,\n      isDryRun,\n      migrations,\n      currentVersion,\n      lock,\n      _iterator2,\n      _step2,\n      _loop,\n      _ret,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : {};\n          ignoreLock = (_options$ignoreLock = options.ignoreLock) !== null && _options$ignoreLock !== void 0 ? _options$ignoreLock : false;\n          onProgress = options.onProgress;\n          isDryRun = (_options$isDryRun = options.isDryRun) !== null && _options$isDryRun !== void 0 ? _options$isDryRun : false;\n          migrations = (_options$migrations = options.migrations) !== null && _options$migrations !== void 0 ? _options$migrations : defaultMigrations;\n          if (path) {\n            _context2.next = 7;\n            break;\n          }\n          throw new errors.RequiredParameterError('Path argument is required!');\n        case 7:\n          if (repoOptions) {\n            _context2.next = 9;\n            break;\n          }\n          throw new errors.RequiredParameterError('repoOptions argument is required!');\n        case 9:\n          if (toVersion) {\n            _context2.next = 11;\n            break;\n          }\n          throw new errors.RequiredParameterError('toVersion argument is required!');\n        case 11:\n          if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n            _context2.next = 13;\n            break;\n          }\n          throw new errors.InvalidValueError('Version has to be positive integer!');\n        case 13:\n          // make sure we can read pre-level@5 datastores\n          backends = wrapBackends(backends);\n          _context2.next = 16;\n          return repoVersion.getVersion(backends);\n        case 16:\n          currentVersion = _context2.sent;\n          if (!(currentVersion === toVersion)) {\n            _context2.next = 20;\n            break;\n          }\n          log('Nothing to migrate.');\n          return _context2.abrupt(\"return\");\n        case 20:\n          if (!(currentVersion > toVersion)) {\n            _context2.next = 22;\n            break;\n          }\n          throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is higher then toVersion (\").concat(toVersion, \"), you probably wanted to revert it?\"));\n        case 22:\n          verifyAvailableMigrations(migrations, currentVersion, toVersion);\n          if (!(!isDryRun && !ignoreLock)) {\n            _context2.next = 27;\n            break;\n          }\n          _context2.next = 26;\n          return repoOptions.repoLock.lock(path);\n        case 26:\n          lock = _context2.sent;\n        case 27:\n          _context2.prev = 27;\n          _iterator2 = _createForOfIteratorHelper(migrations);\n          _context2.prev = 29;\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var migration, progressCallback, lastSuccessfullyMigratedVersion;\n            return _regeneratorRuntime().wrap(function _loop$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  migration = _step2.value;\n                  if (!(toVersion !== undefined && migration.version > toVersion)) {\n                    _context.next = 3;\n                    break;\n                  }\n                  return _context.abrupt(\"return\", 0);\n                case 3:\n                  if (!(migration.version <= currentVersion)) {\n                    _context.next = 5;\n                    break;\n                  }\n                  return _context.abrupt(\"return\", 1);\n                case 5:\n                  log(\"Migrating version \".concat(migration.version));\n                  _context.prev = 6;\n                  if (isDryRun) {\n                    _context.next = 12;\n                    break;\n                  }\n                  /** @type {MigrationProgressCallback} */\n                  progressCallback = function progressCallback() {};\n                  if (onProgress) {\n                    // eslint-disable-line max-depth\n                    progressCallback = function progressCallback(percent, message) {\n                      return onProgress(migration.version, percent.toFixed(2), message);\n                    };\n                  }\n                  _context.next = 12;\n                  return migration.migrate(backends, progressCallback);\n                case 12:\n                  _context.next = 21;\n                  break;\n                case 14:\n                  _context.prev = 14;\n                  _context.t0 = _context[\"catch\"](6);\n                  lastSuccessfullyMigratedVersion = migration.version - 1;\n                  log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: \".concat(lastSuccessfullyMigratedVersion));\n                  _context.next = 20;\n                  return repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends);\n                case 20:\n                  throw new Error(\"During migration to version \".concat(migration.version, \" exception was raised: \").concat(_context.t0.stack || _context.t0.message || _context.t0));\n                case 21:\n                  log(\"Migrating to version \".concat(migration.version, \" finished\"));\n                case 22:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _loop, null, [[6, 14]]);\n          });\n          _iterator2.s();\n        case 32:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 41;\n            break;\n          }\n          return _context2.delegateYield(_loop(), \"t0\", 34);\n        case 34:\n          _ret = _context2.t0;\n          if (!(_ret === 0)) {\n            _context2.next = 37;\n            break;\n          }\n          return _context2.abrupt(\"break\", 41);\n        case 37:\n          if (!(_ret === 1)) {\n            _context2.next = 39;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 39);\n        case 39:\n          _context2.next = 32;\n          break;\n        case 41:\n          _context2.next = 46;\n          break;\n        case 43:\n          _context2.prev = 43;\n          _context2.t1 = _context2[\"catch\"](29);\n          _iterator2.e(_context2.t1);\n        case 46:\n          _context2.prev = 46;\n          _iterator2.f();\n          return _context2.finish(46);\n        case 49:\n          if (isDryRun) {\n            _context2.next = 52;\n            break;\n          }\n          _context2.next = 52;\n          return repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n        case 52:\n          log('Repo successfully migrated', toVersion !== undefined ? \"to version \".concat(toVersion, \"!\") : 'to latest version!');\n        case 53:\n          _context2.prev = 53;\n          if (!(!isDryRun && !ignoreLock && lock)) {\n            _context2.next = 57;\n            break;\n          }\n          _context2.next = 57;\n          return lock.close();\n        case 57:\n          return _context2.finish(53);\n        case 58:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[27,, 53, 58], [29, 43, 46, 49]]);\n  }));\n  return _migrate.apply(this, arguments);\n}\nexport function revert(_x5, _x6, _x7, _x8) {\n  return _revert.apply(this, arguments);\n}\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\nfunction _revert() {\n  _revert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, backends, repoOptions, toVersion) {\n    var _options$ignoreLock2, _options$isDryRun2, _options$migrations2;\n    var options,\n      ignoreLock,\n      onProgress,\n      isDryRun,\n      migrations,\n      currentVersion,\n      lock,\n      reversedMigrationArray,\n      _iterator3,\n      _step3,\n      _loop2,\n      _ret2,\n      _args4 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : {};\n          ignoreLock = (_options$ignoreLock2 = options.ignoreLock) !== null && _options$ignoreLock2 !== void 0 ? _options$ignoreLock2 : false;\n          onProgress = options.onProgress;\n          isDryRun = (_options$isDryRun2 = options.isDryRun) !== null && _options$isDryRun2 !== void 0 ? _options$isDryRun2 : false;\n          migrations = (_options$migrations2 = options.migrations) !== null && _options$migrations2 !== void 0 ? _options$migrations2 : defaultMigrations;\n          if (path) {\n            _context4.next = 7;\n            break;\n          }\n          throw new errors.RequiredParameterError('Path argument is required!');\n        case 7:\n          if (repoOptions) {\n            _context4.next = 9;\n            break;\n          }\n          throw new errors.RequiredParameterError('repoOptions argument is required!');\n        case 9:\n          if (toVersion) {\n            _context4.next = 11;\n            break;\n          }\n          throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n        case 11:\n          if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n            _context4.next = 13;\n            break;\n          }\n          throw new errors.InvalidValueError('Version has to be positive integer!');\n        case 13:\n          // make sure we can read pre-level@5 datastores\n          backends = wrapBackends(backends);\n          _context4.next = 16;\n          return repoVersion.getVersion(backends);\n        case 16:\n          currentVersion = _context4.sent;\n          if (!(currentVersion === toVersion)) {\n            _context4.next = 20;\n            break;\n          }\n          log('Nothing to revert.');\n          return _context4.abrupt(\"return\");\n        case 20:\n          if (!(currentVersion < toVersion)) {\n            _context4.next = 22;\n            break;\n          }\n          throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is lower then toVersion (\").concat(toVersion, \"), you probably wanted to migrate it?\"));\n        case 22:\n          verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n          if (!(!isDryRun && !ignoreLock)) {\n            _context4.next = 27;\n            break;\n          }\n          _context4.next = 26;\n          return repoOptions.repoLock.lock(path);\n        case 26:\n          lock = _context4.sent;\n        case 27:\n          log(\"Reverting from version \".concat(currentVersion, \" to \").concat(toVersion));\n          _context4.prev = 28;\n          reversedMigrationArray = migrations.slice().reverse();\n          _iterator3 = _createForOfIteratorHelper(reversedMigrationArray);\n          _context4.prev = 31;\n          _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n            var migration, progressCallback, lastSuccessfullyRevertedVersion;\n            return _regeneratorRuntime().wrap(function _loop2$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  migration = _step3.value;\n                  if (!(migration.version <= toVersion)) {\n                    _context3.next = 3;\n                    break;\n                  }\n                  return _context3.abrupt(\"return\", 0);\n                case 3:\n                  if (!(migration.version > currentVersion)) {\n                    _context3.next = 5;\n                    break;\n                  }\n                  return _context3.abrupt(\"return\", 1);\n                case 5:\n                  log(\"Reverting migration version \".concat(migration.version));\n                  _context3.prev = 6;\n                  if (isDryRun) {\n                    _context3.next = 12;\n                    break;\n                  }\n                  /** @type {MigrationProgressCallback} */\n                  progressCallback = function progressCallback() {};\n                  if (onProgress) {\n                    // eslint-disable-line max-depth\n                    progressCallback = function progressCallback(percent, message) {\n                      return onProgress(migration.version, percent.toFixed(2), message);\n                    };\n                  }\n                  _context3.next = 12;\n                  return migration.revert(backends, progressCallback);\n                case 12:\n                  _context3.next = 22;\n                  break;\n                case 14:\n                  _context3.prev = 14;\n                  _context3.t0 = _context3[\"catch\"](6);\n                  lastSuccessfullyRevertedVersion = migration.version;\n                  log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: \".concat(lastSuccessfullyRevertedVersion));\n                  _context3.next = 20;\n                  return repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends);\n                case 20:\n                  _context3.t0.message = \"During reversion to version \".concat(migration.version, \" exception was raised: \").concat(_context3.t0.message);\n                  throw _context3.t0;\n                case 22:\n                  log(\"Reverting to version \".concat(migration.version, \" finished\"));\n                case 23:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, _loop2, null, [[6, 14]]);\n          });\n          _iterator3.s();\n        case 34:\n          if ((_step3 = _iterator3.n()).done) {\n            _context4.next = 43;\n            break;\n          }\n          return _context4.delegateYield(_loop2(), \"t0\", 36);\n        case 36:\n          _ret2 = _context4.t0;\n          if (!(_ret2 === 0)) {\n            _context4.next = 39;\n            break;\n          }\n          return _context4.abrupt(\"break\", 43);\n        case 39:\n          if (!(_ret2 === 1)) {\n            _context4.next = 41;\n            break;\n          }\n          return _context4.abrupt(\"continue\", 41);\n        case 41:\n          _context4.next = 34;\n          break;\n        case 43:\n          _context4.next = 48;\n          break;\n        case 45:\n          _context4.prev = 45;\n          _context4.t1 = _context4[\"catch\"](31);\n          _iterator3.e(_context4.t1);\n        case 48:\n          _context4.prev = 48;\n          _iterator3.f();\n          return _context4.finish(48);\n        case 51:\n          if (isDryRun) {\n            _context4.next = 54;\n            break;\n          }\n          _context4.next = 54;\n          return repoVersion.setVersion(toVersion, backends);\n        case 54:\n          log(\"All migrations successfully reverted to version \".concat(toVersion, \"!\"));\n        case 55:\n          _context4.prev = 55;\n          if (!(!isDryRun && !ignoreLock && lock)) {\n            _context4.next = 59;\n            break;\n          }\n          _context4.next = 59;\n          return lock.close();\n        case 59:\n          return _context4.finish(55);\n        case 60:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee2, null, [[28,, 55, 60], [31, 45, 48, 51]]);\n  }));\n  return _revert.apply(this, arguments);\n}\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion) {\n  var checkReversibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var migrationCounter = 0;\n  var _iterator = _createForOfIteratorHelper(migrations),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var migration = _step.value;\n      if (migration.version > toVersion) {\n        break;\n      }\n      if (migration.version > fromVersion) {\n        if (checkReversibility && !migration.revert) {\n          throw new errors.NonReversibleMigrationError(\"It is not possible to revert to version \".concat(fromVersion, \" because migration version \").concat(migration.version, \" is not reversible. Cancelling reversion.\"));\n        }\n        migrationCounter++;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(\"The ipfs-repo-migrations package does not have all migration to migrate from version \".concat(fromVersion, \" to \").concat(toVersion));\n  }\n}\nexport var getCurrentRepoVersion = repoVersion.getVersion;\nexport var errors = Errors;\nexport var migrations = defaultMigrations;","map":{"version":3,"names":["defaultMigrations","repoVersion","Errors","wrapBackends","debug","log","getLatestMigrationVersion","migrations","Array","isArray","length","version","migrate","_x","_x2","_x3","_x4","_migrate","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","path","backends","repoOptions","toVersion","_options$ignoreLock","_options$isDryRun","_options$migrations","options","ignoreLock","onProgress","isDryRun","currentVersion","lock","_iterator2","_step2","_loop","_ret","_args2","wrap","_callee$","_context2","prev","next","undefined","errors","RequiredParameterError","Number","isInteger","InvalidValueError","getVersion","sent","abrupt","concat","verifyAvailableMigrations","repoLock","_createForOfIteratorHelper","migration","progressCallback","lastSuccessfullyMigratedVersion","_loop$","_context","value","percent","message","toFixed","t0","setVersion","Error","stack","stop","s","n","done","delegateYield","t1","e","f","finish","close","revert","_x5","_x6","_x7","_x8","_revert","_callee2","_options$ignoreLock2","_options$isDryRun2","_options$migrations2","reversedMigrationArray","_iterator3","_step3","_loop2","_ret2","_args4","_callee2$","_context4","slice","reverse","lastSuccessfullyRevertedVersion","_loop2$","_context3","fromVersion","checkReversibility","migrationCounter","_iterator","_step","NonReversibleMigrationError","err","getCurrentRepoVersion"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-repo-migrations/src/index.js"],"sourcesContent":["/* eslint complexity: [\"error\", 28] */\n\nimport defaultMigrations from '../migrations/index.js'\nimport * as repoVersion from './repo/version.js'\nimport * as Errors from './errors.js'\nimport { wrapBackends } from './utils.js'\nimport debug from 'debug'\n\nconst log = debug('ipfs:repo:migrator')\n\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\nexport function getLatestMigrationVersion (migrations) {\n  migrations = migrations || defaultMigrations\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0\n  }\n\n  return migrations[migrations.length - 1].version\n}\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\nexport async function migrate (path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false\n  const onProgress = options.onProgress\n  const isDryRun = options.isDryRun ?? false\n  const migrations = options.migrations ?? defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.')\n    return\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`)\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion)\n\n  let lock\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break\n      }\n\n      if (migration.version <= currentVersion) {\n        continue\n      }\n\n      log(`Migrating version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.migrate(backends, progressCallback)\n        }\n      } catch (/** @type {any} */ e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1\n\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends)\n\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`)\n      }\n\n      log(`Migrating to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends)\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!')\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\nexport async function revert (path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false\n  const onProgress = options.onProgress\n  const isDryRun = options.isDryRun ?? false\n  const migrations = options.migrations ?? defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.')\n    return\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`)\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true)\n\n  let lock\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`)\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse()\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break\n      }\n\n      if (migration.version > currentVersion) {\n        continue\n      }\n\n      log(`Reverting migration version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.revert(backends, progressCallback)\n        }\n      } catch (/** @type {any} */ e) {\n        const lastSuccessfullyRevertedVersion = migration.version\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends)\n\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      log(`Reverting to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion, backends)\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`)\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\nfunction verifyAvailableMigrations (migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`)\n      }\n\n      migrationCounter++\n    }\n  }\n\n  if (migrationCounter !== (toVersion - fromVersion)) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`)\n  }\n}\n\nexport const getCurrentRepoVersion = repoVersion.getVersion\nexport const errors = Errors\nexport const migrations = defaultMigrations\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}