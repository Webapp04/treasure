{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/**\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMergerAPI\n */\n\n/** @type {TaskMergerAPI} */\nexport var TaskMerger = {\n  /**\n   * Indicates whether the given task has newer information than the active\n   * tasks with the same topic.\n   *\n   * @param {Task} task\n   * @param {Task[]} tasksWithTopic\n   * @returns {boolean}\n   */\n  hasNewInfo: function hasNewInfo(task, tasksWithTopic) {\n    var haveBlock = false;\n    var isWantBlock = false;\n    var _iterator = _createForOfIteratorHelper(tasksWithTopic),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var existing = _step.value;\n        if (existing.data.haveBlock) {\n          haveBlock = true;\n        }\n        if (existing.data.isWantBlock) {\n          isWantBlock = true;\n        }\n      }\n\n      // If there is no active want-block and the new task is a want-block,\n      // the new task is better\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (!isWantBlock && task.data.isWantBlock) {\n      return true;\n    }\n\n    // If we didn't have the block, and the new task indicates that we now\n    // do have the block, then we must also have size information for the\n    // block, so the new task has new information.\n    if (!haveBlock && task.data.haveBlock) {\n      return true;\n    }\n    return false;\n  },\n  /**\n   * Merge the information from the given task into the existing task (with the\n   * same topic)\n   *\n   * @param {Task} newTask\n   * @param {Task} existingTask\n   */\n  merge: function merge(newTask, existingTask) {\n    // The merge function ignores the topic and priority as these don't change.\n    //\n    // We may receive new information about a want before the want has been\n    // popped from the queue in the following scenarios:\n    //\n    // - Replace want type:\n    //   1. Client sends want-have CID1\n    //   2. Client sends want-block CID1\n    //   In this case we should replace want-have with want-block, including\n    //   updating the task size to be the block size.\n    //\n    // - Replace DONT_HAVE with want:\n    //   1. Client sends want-have CID1 or want-block CID1\n    //   2. Local node doesn't have block for CID1\n    //   3. Local node receives block for CID1 from peer\n    //   In this case we should replace DONT_HAVE with the want, including\n    //   updating the task size and block size.\n    var taskData = newTask.data;\n    var existingData = existingTask.data;\n\n    // If we didn't have block size information (because we didn't have the\n    // block) and we receive the block from a peer, update the task with the\n    // new block size\n    if (!existingData.haveBlock && taskData.haveBlock) {\n      existingData.haveBlock = taskData.haveBlock;\n      existingData.blockSize = taskData.blockSize;\n    }\n\n    // If replacing a want-have with a want-block\n    if (!existingData.isWantBlock && taskData.isWantBlock) {\n      // Change the type from want-have to want-block\n      existingData.isWantBlock = true;\n      // If the want-have was a DONT_HAVE, or the want-block has a size\n      if (!existingData.haveBlock || taskData.haveBlock) {\n        // Update the entry size\n        existingData.haveBlock = taskData.haveBlock;\n        existingTask.size = newTask.size;\n      }\n    }\n\n    // If the task is a want-block, make sure the entry size is equal\n    // to the block size (because we will send the whole block)\n    if (existingData.isWantBlock && existingData.haveBlock) {\n      existingTask.size = existingData.blockSize;\n    }\n  }\n};","map":{"version":3,"names":["TaskMerger","hasNewInfo","task","tasksWithTopic","haveBlock","isWantBlock","_iterator","_createForOfIteratorHelper","_step","s","n","done","existing","value","data","err","e","f","merge","newTask","existingTask","taskData","existingData","blockSize","size"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-bitswap/src/decision-engine/task-merger.js"],"sourcesContent":["/**\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMergerAPI\n */\n\n/** @type {TaskMergerAPI} */\nexport const TaskMerger = {\n  /**\n   * Indicates whether the given task has newer information than the active\n   * tasks with the same topic.\n   *\n   * @param {Task} task\n   * @param {Task[]} tasksWithTopic\n   * @returns {boolean}\n   */\n  hasNewInfo (task, tasksWithTopic) {\n    let haveBlock = false\n    let isWantBlock = false\n    for (const existing of tasksWithTopic) {\n      if (existing.data.haveBlock) {\n        haveBlock = true\n      }\n\n      if (existing.data.isWantBlock) {\n        isWantBlock = true\n      }\n    }\n\n    // If there is no active want-block and the new task is a want-block,\n    // the new task is better\n    if (!isWantBlock && task.data.isWantBlock) {\n      return true\n    }\n\n    // If we didn't have the block, and the new task indicates that we now\n    // do have the block, then we must also have size information for the\n    // block, so the new task has new information.\n    if (!haveBlock && task.data.haveBlock) {\n      return true\n    }\n\n    return false\n  },\n\n  /**\n   * Merge the information from the given task into the existing task (with the\n   * same topic)\n   *\n   * @param {Task} newTask\n   * @param {Task} existingTask\n   */\n  merge (newTask, existingTask) {\n    // The merge function ignores the topic and priority as these don't change.\n    //\n    // We may receive new information about a want before the want has been\n    // popped from the queue in the following scenarios:\n    //\n    // - Replace want type:\n    //   1. Client sends want-have CID1\n    //   2. Client sends want-block CID1\n    //   In this case we should replace want-have with want-block, including\n    //   updating the task size to be the block size.\n    //\n    // - Replace DONT_HAVE with want:\n    //   1. Client sends want-have CID1 or want-block CID1\n    //   2. Local node doesn't have block for CID1\n    //   3. Local node receives block for CID1 from peer\n    //   In this case we should replace DONT_HAVE with the want, including\n    //   updating the task size and block size.\n    const taskData = newTask.data\n    const existingData = existingTask.data\n\n    // If we didn't have block size information (because we didn't have the\n    // block) and we receive the block from a peer, update the task with the\n    // new block size\n    if (!existingData.haveBlock && taskData.haveBlock) {\n      existingData.haveBlock = taskData.haveBlock\n      existingData.blockSize = taskData.blockSize\n    }\n\n    // If replacing a want-have with a want-block\n    if (!existingData.isWantBlock && taskData.isWantBlock) {\n      // Change the type from want-have to want-block\n      existingData.isWantBlock = true\n      // If the want-have was a DONT_HAVE, or the want-block has a size\n      if (!existingData.haveBlock || taskData.haveBlock) {\n        // Update the entry size\n        existingData.haveBlock = taskData.haveBlock\n        existingTask.size = newTask.size\n      }\n    }\n\n    // If the task is a want-block, make sure the entry size is equal\n    // to the block size (because we will send the whole block)\n    if (existingData.isWantBlock && existingData.haveBlock) {\n      existingTask.size = existingData.blockSize\n    }\n  }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;;AAEA;AACA,OAAO,IAAMA,UAAU,GAAG;EACxB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAU,WAAAA,WAAEC,IAAI,EAAEC,cAAc,EAAE;IAChC,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAIC,WAAW,GAAG,KAAK;IAAA,IAAAC,SAAA,GAAAC,0BAAA,CACAJ,cAAc;MAAAK,KAAA;IAAA;MAArC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAuC;QAAA,IAA5BC,QAAQ,GAAAJ,KAAA,CAAAK,KAAA;QACjB,IAAID,QAAQ,CAACE,IAAI,CAACV,SAAS,EAAE;UAC3BA,SAAS,GAAG,IAAI;QAClB;QAEA,IAAIQ,QAAQ,CAACE,IAAI,CAACT,WAAW,EAAE;UAC7BA,WAAW,GAAG,IAAI;QACpB;MACF;;MAEA;MACA;IAAA,SAAAU,GAAA;MAAAT,SAAA,CAAAU,CAAA,CAAAD,GAAA;IAAA;MAAAT,SAAA,CAAAW,CAAA;IAAA;IACA,IAAI,CAACZ,WAAW,IAAIH,IAAI,CAACY,IAAI,CAACT,WAAW,EAAE;MACzC,OAAO,IAAI;IACb;;IAEA;IACA;IACA;IACA,IAAI,CAACD,SAAS,IAAIF,IAAI,CAACY,IAAI,CAACV,SAAS,EAAE;MACrC,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEc,KAAK,WAAAA,MAAEC,OAAO,EAAEC,YAAY,EAAE;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAMC,QAAQ,GAAGF,OAAO,CAACL,IAAI;IAC7B,IAAMQ,YAAY,GAAGF,YAAY,CAACN,IAAI;;IAEtC;IACA;IACA;IACA,IAAI,CAACQ,YAAY,CAAClB,SAAS,IAAIiB,QAAQ,CAACjB,SAAS,EAAE;MACjDkB,YAAY,CAAClB,SAAS,GAAGiB,QAAQ,CAACjB,SAAS;MAC3CkB,YAAY,CAACC,SAAS,GAAGF,QAAQ,CAACE,SAAS;IAC7C;;IAEA;IACA,IAAI,CAACD,YAAY,CAACjB,WAAW,IAAIgB,QAAQ,CAAChB,WAAW,EAAE;MACrD;MACAiB,YAAY,CAACjB,WAAW,GAAG,IAAI;MAC/B;MACA,IAAI,CAACiB,YAAY,CAAClB,SAAS,IAAIiB,QAAQ,CAACjB,SAAS,EAAE;QACjD;QACAkB,YAAY,CAAClB,SAAS,GAAGiB,QAAQ,CAACjB,SAAS;QAC3CgB,YAAY,CAACI,IAAI,GAAGL,OAAO,CAACK,IAAI;MAClC;IACF;;IAEA;IACA;IACA,IAAIF,YAAY,CAACjB,WAAW,IAAIiB,YAAY,CAAClB,SAAS,EAAE;MACtDgB,YAAY,CAACI,IAAI,GAAGF,YAAY,CAACC,SAAS;IAC5C;EACF;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}