{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { createMovingAverage } from './moving-average.js';\n// @ts-expect-error no types\nimport retimer from 'retimer';\nexport var DefaultStats = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(DefaultStats, _EventEmitter);\n  var _super = _createSuper(DefaultStats);\n  /**\n   * A queue based manager for stat processing\n   */\n  function DefaultStats(init) {\n    var _this;\n    _classCallCheck(this, DefaultStats);\n    _this = _super.call(this);\n    _this.enabled = init.enabled;\n    _this.queue = [];\n    _this.stats = {\n      dataReceived: 0n,\n      dataSent: 0n\n    };\n    _this.frequencyLastTime = Date.now();\n    _this.frequencyAccumulators = {};\n    _this.movingAverages = {\n      dataReceived: [],\n      dataSent: []\n    };\n    _this.computeThrottleMaxQueueSize = init.computeThrottleMaxQueueSize;\n    _this.computeThrottleTimeout = init.computeThrottleTimeout;\n    _this._update = _this._update.bind(_assertThisInitialized(_this));\n    _this.movingAverageIntervals = init.movingAverageIntervals;\n    for (var i = 0; i < init.initialCounters.length; i++) {\n      var key = init.initialCounters[i];\n      _this.stats[key] = 0n;\n      _this.movingAverages[key] = [];\n      for (var k = 0; k < _this.movingAverageIntervals.length; k++) {\n        var interval = _this.movingAverageIntervals[k];\n        var ma = _this.movingAverages[key][interval] = createMovingAverage(interval);\n        ma.push(_this.frequencyLastTime, 0);\n      }\n    }\n    return _this;\n  }\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing\n   */\n  _createClass(DefaultStats, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.enabled) {\n        return;\n      }\n      if (this.queue.length > 0) {\n        this._resetComputeTimeout();\n      }\n    }\n    /**\n     * Stops processing and computing of stats by clearing the internal\n     * timer\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.timeout != null) {\n        this.timeout.clear();\n        this.timeout = null;\n      }\n    }\n    /**\n     * Returns a clone of the current stats.\n     */\n  }, {\n    key: \"getSnapshot\",\n    value: function getSnapshot() {\n      return Object.assign({}, this.stats);\n    }\n    /**\n     * Returns a clone of the internal movingAverages\n     */\n  }, {\n    key: \"getMovingAverages\",\n    value: function getMovingAverages() {\n      return Object.assign({}, this.movingAverages);\n    }\n    /**\n     * Pushes the given operation data to the queue, along with the\n     * current Timestamp, then resets the update timer.\n     */\n  }, {\n    key: \"push\",\n    value: function push(counter, inc) {\n      this.queue.push([counter, inc, Date.now()]);\n      this._resetComputeTimeout();\n    }\n    /**\n     * Resets the timeout for triggering updates.\n     */\n  }, {\n    key: \"_resetComputeTimeout\",\n    value: function _resetComputeTimeout() {\n      this.timeout = retimer(this._update, this._nextTimeout());\n    }\n    /**\n     * Calculates and returns the timeout for the next update based on\n     * the urgency of the update.\n     */\n  }, {\n    key: \"_nextTimeout\",\n    value: function _nextTimeout() {\n      // calculate the need for an update, depending on the queue length\n      var urgency = this.queue.length / this.computeThrottleMaxQueueSize;\n      var timeout = Math.max(this.computeThrottleTimeout * (1 - urgency), 0);\n      return timeout;\n    }\n    /**\n     * If there are items in the queue, they will will be processed and\n     * the frequency for all items will be updated based on the Timestamp\n     * of the last item in the queue. The `update` event will also be emitted\n     * with the latest stats.\n     *\n     * If there are no items in the queue, no action is taken.\n     */\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this.timeout = null;\n      if (this.queue.length > 0) {\n        var last = ['', 0, 0];\n        var _iterator = _createForOfIteratorHelper(this.queue),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            last = _step.value;\n            this._applyOp(last);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.queue = [];\n        if (last.length > 2 && last[0] !== '') {\n          this._updateFrequency(last[2]); // contains timestamp of last op\n        }\n\n        this.dispatchEvent(new CustomEvent('update', {\n          detail: this.stats\n        }));\n      }\n    }\n    /**\n     * For each key in the stats, the frequency and moving averages\n     * will be updated via Stats._updateFrequencyFor based on the time\n     * difference between calls to this method.\n     */\n  }, {\n    key: \"_updateFrequency\",\n    value: function _updateFrequency(latestTime) {\n      var timeDiff = latestTime - this.frequencyLastTime;\n      this._updateFrequencyFor('dataReceived', timeDiff, latestTime);\n      this._updateFrequencyFor('dataSent', timeDiff, latestTime);\n      this.frequencyLastTime = latestTime;\n    }\n    /**\n     * Updates the `movingAverages` for the given `key` and also\n     * resets the `frequencyAccumulator` for the `key`.\n     */\n  }, {\n    key: \"_updateFrequencyFor\",\n    value: function _updateFrequencyFor(key, timeDiffMS, latestTime) {\n      var _this$frequencyAccumu;\n      var count = (_this$frequencyAccumu = this.frequencyAccumulators[key]) !== null && _this$frequencyAccumu !== void 0 ? _this$frequencyAccumu : 0;\n      this.frequencyAccumulators[key] = 0;\n      // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms\n      var safeTimeDiff = timeDiffMS !== null && timeDiffMS !== void 0 ? timeDiffMS : 1;\n      var hz = count / safeTimeDiff * 1000;\n      var movingAverages = this.movingAverages[key];\n      if (movingAverages == null) {\n        movingAverages = this.movingAverages[key] = [];\n      }\n      var intervals = this.movingAverageIntervals;\n      for (var i = 0; i < intervals.length; i++) {\n        var movingAverageInterval = intervals[i];\n        var movingAverage = movingAverages[movingAverageInterval];\n        if (movingAverage == null) {\n          movingAverage = movingAverages[movingAverageInterval] = createMovingAverage(movingAverageInterval);\n        }\n        movingAverage.push(latestTime, hz);\n      }\n    }\n    /**\n     * For the given operation, `op`, the stats and `frequencyAccumulator`\n     * will be updated or initialized if they don't already exist.\n     */\n  }, {\n    key: \"_applyOp\",\n    value: function _applyOp(op) {\n      var key = op[0];\n      var inc = op[1];\n      if (typeof inc !== 'number') {\n        throw new Error('invalid increment number');\n      }\n      var n;\n      if (!Object.prototype.hasOwnProperty.call(this.stats, key)) {\n        // @ts-expect-error cannot index type with key\n        n = this.stats[key] = 0n;\n      } else {\n        // @ts-expect-error cannot index type with key\n        n = this.stats[key];\n      }\n      // @ts-expect-error cannot index type with key\n      this.stats[key] = n + BigInt(inc);\n      if (this.frequencyAccumulators[key] == null) {\n        this.frequencyAccumulators[key] = 0;\n      }\n      this.frequencyAccumulators[key] += inc;\n    }\n  }]);\n  return DefaultStats;\n}(EventEmitter);","map":{"version":3,"names":["CustomEvent","EventEmitter","createMovingAverage","retimer","DefaultStats","_EventEmitter","_inherits","_super","_createSuper","init","_this","_classCallCheck","call","enabled","queue","stats","dataReceived","dataSent","frequencyLastTime","Date","now","frequencyAccumulators","movingAverages","computeThrottleMaxQueueSize","computeThrottleTimeout","_update","bind","_assertThisInitialized","movingAverageIntervals","i","initialCounters","length","key","k","interval","ma","push","_createClass","value","start","_resetComputeTimeout","stop","timeout","clear","getSnapshot","Object","assign","getMovingAverages","counter","inc","_nextTimeout","urgency","Math","max","last","_iterator","_createForOfIteratorHelper","_step","s","n","done","_applyOp","err","e","f","_updateFrequency","dispatchEvent","detail","latestTime","timeDiff","_updateFrequencyFor","timeDiffMS","_this$frequencyAccumu","count","safeTimeDiff","hz","intervals","movingAverageInterval","movingAverage","op","Error","prototype","hasOwnProperty","BigInt"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/metrics/stats.ts"],"sourcesContent":["import { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport { createMovingAverage } from './moving-average.js'\n// @ts-expect-error no types\nimport retimer from 'retimer'\nimport type { MovingAverages, Stats, TransferStats } from '@libp2p/interface-metrics'\n\nexport interface StatsEvents {\n  'update': CustomEvent<TransferStats>\n}\n\nexport interface StatsInit {\n  enabled: boolean\n  initialCounters: ['dataReceived', 'dataSent']\n  movingAverageIntervals: number[]\n  computeThrottleMaxQueueSize: number\n  computeThrottleTimeout: number\n}\n\nexport class DefaultStats extends EventEmitter<StatsEvents> implements Stats {\n  private readonly enabled: boolean\n  public queue: Array<[string, number, number]>\n  private stats: TransferStats\n  private frequencyLastTime: number\n  private frequencyAccumulators: Record<string, number>\n  private movingAverages: MovingAverages\n  private timeout?: any\n  private readonly computeThrottleMaxQueueSize: number\n  private readonly computeThrottleTimeout: number\n  private readonly movingAverageIntervals: number[]\n\n  /**\n   * A queue based manager for stat processing\n   */\n  constructor (init: StatsInit) {\n    super()\n\n    this.enabled = init.enabled\n    this.queue = []\n    this.stats = {\n      dataReceived: 0n,\n      dataSent: 0n\n    }\n    this.frequencyLastTime = Date.now()\n    this.frequencyAccumulators = {}\n    this.movingAverages = {\n      dataReceived: [],\n      dataSent: []\n    }\n    this.computeThrottleMaxQueueSize = init.computeThrottleMaxQueueSize\n    this.computeThrottleTimeout = init.computeThrottleTimeout\n\n    this._update = this._update.bind(this)\n\n    this.movingAverageIntervals = init.movingAverageIntervals\n\n    for (let i = 0; i < init.initialCounters.length; i++) {\n      const key = init.initialCounters[i]\n      this.stats[key] = 0n\n      this.movingAverages[key] = []\n\n      for (let k = 0; k < this.movingAverageIntervals.length; k++) {\n        const interval = this.movingAverageIntervals[k]\n        const ma = this.movingAverages[key][interval] = createMovingAverage(interval)\n        ma.push(this.frequencyLastTime, 0)\n      }\n    }\n  }\n\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing\n   */\n  start () {\n    if (!this.enabled) {\n      return\n    }\n\n    if (this.queue.length > 0) {\n      this._resetComputeTimeout()\n    }\n  }\n\n  /**\n   * Stops processing and computing of stats by clearing the internal\n   * timer\n   */\n  stop () {\n    if (this.timeout != null) {\n      this.timeout.clear()\n      this.timeout = null\n    }\n  }\n\n  /**\n   * Returns a clone of the current stats.\n   */\n  getSnapshot () {\n    return Object.assign({}, this.stats)\n  }\n\n  /**\n   * Returns a clone of the internal movingAverages\n   */\n  getMovingAverages (): MovingAverages {\n    return Object.assign({}, this.movingAverages)\n  }\n\n  /**\n   * Pushes the given operation data to the queue, along with the\n   * current Timestamp, then resets the update timer.\n   */\n  push (counter: string, inc: number) {\n    this.queue.push([counter, inc, Date.now()])\n    this._resetComputeTimeout()\n  }\n\n  /**\n   * Resets the timeout for triggering updates.\n   */\n  _resetComputeTimeout () {\n    this.timeout = retimer(this._update, this._nextTimeout())\n  }\n\n  /**\n   * Calculates and returns the timeout for the next update based on\n   * the urgency of the update.\n   */\n  _nextTimeout () {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this.queue.length / this.computeThrottleMaxQueueSize\n    const timeout = Math.max(this.computeThrottleTimeout * (1 - urgency), 0)\n    return timeout\n  }\n\n  /**\n   * If there are items in the queue, they will will be processed and\n   * the frequency for all items will be updated based on the Timestamp\n   * of the last item in the queue. The `update` event will also be emitted\n   * with the latest stats.\n   *\n   * If there are no items in the queue, no action is taken.\n   */\n  _update () {\n    this.timeout = null\n    if (this.queue.length > 0) {\n      let last: [string, number, number] = ['', 0, 0]\n\n      for (last of this.queue) {\n        this._applyOp(last)\n      }\n\n      this.queue = []\n\n      if (last.length > 2 && last[0] !== '') {\n        this._updateFrequency(last[2]) // contains timestamp of last op\n      }\n\n      this.dispatchEvent(new CustomEvent<TransferStats>('update', {\n        detail: this.stats\n      }))\n    }\n  }\n\n  /**\n   * For each key in the stats, the frequency and moving averages\n   * will be updated via Stats._updateFrequencyFor based on the time\n   * difference between calls to this method.\n   */\n  _updateFrequency (latestTime: number) {\n    const timeDiff = latestTime - this.frequencyLastTime\n\n    this._updateFrequencyFor('dataReceived', timeDiff, latestTime)\n    this._updateFrequencyFor('dataSent', timeDiff, latestTime)\n\n    this.frequencyLastTime = latestTime\n  }\n\n  /**\n   * Updates the `movingAverages` for the given `key` and also\n   * resets the `frequencyAccumulator` for the `key`.\n   */\n  _updateFrequencyFor (key: 'dataReceived' | 'dataSent', timeDiffMS: number, latestTime: number) {\n    const count = this.frequencyAccumulators[key] ?? 0\n    this.frequencyAccumulators[key] = 0\n    // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms\n    const safeTimeDiff = timeDiffMS ?? 1\n    const hz = (count / safeTimeDiff) * 1000\n\n    let movingAverages = this.movingAverages[key]\n    if (movingAverages == null) {\n      movingAverages = this.movingAverages[key] = []\n    }\n\n    const intervals = this.movingAverageIntervals\n\n    for (let i = 0; i < intervals.length; i++) {\n      const movingAverageInterval = intervals[i]\n      let movingAverage = movingAverages[movingAverageInterval]\n      if (movingAverage == null) {\n        movingAverage = movingAverages[movingAverageInterval] = createMovingAverage(movingAverageInterval)\n      }\n      movingAverage.push(latestTime, hz)\n    }\n  }\n\n  /**\n   * For the given operation, `op`, the stats and `frequencyAccumulator`\n   * will be updated or initialized if they don't already exist.\n   */\n  _applyOp (op: [string, number, number]) {\n    const key = op[0]\n    const inc = op[1]\n\n    if (typeof inc !== 'number') {\n      throw new Error('invalid increment number')\n    }\n\n    let n: bigint\n\n    if (!Object.prototype.hasOwnProperty.call(this.stats, key)) {\n      // @ts-expect-error cannot index type with key\n      n = this.stats[key] = 0n\n    } else {\n      // @ts-expect-error cannot index type with key\n      n = this.stats[key]\n    }\n\n    // @ts-expect-error cannot index type with key\n    this.stats[key] = n + BigInt(inc)\n\n    if (this.frequencyAccumulators[key] == null) {\n      this.frequencyAccumulators[key] = 0\n    }\n\n    this.frequencyAccumulators[key] += inc\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}