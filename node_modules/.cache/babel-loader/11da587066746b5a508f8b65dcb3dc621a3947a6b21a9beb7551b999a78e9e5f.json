{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport NanoDate from 'timestamp-nano';\nimport { Key } from 'interface-datastore/key';\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport errCode from 'err-code';\nimport { base32upper } from 'multiformats/bases/base32';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { logger } from '@libp2p/logger';\nimport { createCborData, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig } from './utils.js';\nimport * as ERRORS from './errors.js';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { IpnsEntry } from './pb/ipns.js';\nvar log = logger('ipns');\nvar ID_MULTIHASH_CODE = identity.code;\nexport var namespace = '/ipns/';\nexport var namespaceLength = namespace.length;\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PeerId} peerId - peer id containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\nexport var create = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, value, seq, lifetime) {\n    var expirationDate, validityType, _lifetime$toString$sp, _lifetime$toString$sp2, ms, ns, lifetimeNs;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          // Validity in ISOString with nanoseconds precision and validity type EOL\n          expirationDate = new NanoDate(Date.now() + Number(lifetime));\n          validityType = IpnsEntry.ValidityType.EOL;\n          _lifetime$toString$sp = lifetime.toString().split('.'), _lifetime$toString$sp2 = _slicedToArray(_lifetime$toString$sp, 2), ms = _lifetime$toString$sp2[0], ns = _lifetime$toString$sp2[1];\n          lifetimeNs = BigInt(ms) * BigInt(100000) + BigInt(ns !== null && ns !== void 0 ? ns : '0');\n          _context.next = 6;\n          return _create(peerId, value, seq, validityType, expirationDate, lifetimeNs);\n        case 6:\n          return _context.abrupt(\"return\", _context.sent);\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function create(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PeerId} peerId - PeerId containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\nexport var createWithExpiration = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, value, seq, expiration) {\n    var expirationDate, validityType, ttlMs, ttlNs;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          expirationDate = NanoDate.fromString(expiration);\n          validityType = IpnsEntry.ValidityType.EOL;\n          ttlMs = expirationDate.toDate().getTime() - Date.now();\n          ttlNs = BigInt(ttlMs) * BigInt(100000) + BigInt(expirationDate.getNano());\n          _context2.next = 6;\n          return _create(peerId, value, seq, validityType, expirationDate, ttlNs);\n        case 6:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function createWithExpiration(_x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar _create = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peerId, value, seq, validityType, expirationDate, ttl) {\n    var isoValidity, privateKey, signatureV1, data, sigData, signatureV2, entry, digest;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          seq = BigInt(seq);\n          isoValidity = uint8ArrayFromString(expirationDate.toString());\n          if (!(peerId.privateKey == null)) {\n            _context3.next = 4;\n            break;\n          }\n          throw errCode(new Error('Missing private key'), ERRORS.ERR_MISSING_PRIVATE_KEY);\n        case 4:\n          _context3.next = 6;\n          return unmarshalPrivateKey(peerId.privateKey);\n        case 6:\n          privateKey = _context3.sent;\n          _context3.next = 9;\n          return sign(privateKey, value, validityType, isoValidity);\n        case 9:\n          signatureV1 = _context3.sent;\n          data = createCborData(value, isoValidity, validityType, seq, ttl);\n          sigData = ipnsEntryDataForV2Sig(data);\n          _context3.next = 14;\n          return privateKey.sign(sigData);\n        case 14:\n          signatureV2 = _context3.sent;\n          entry = {\n            value: value,\n            signature: signatureV1,\n            validityType: validityType,\n            validity: isoValidity,\n            sequence: seq,\n            ttl: ttl,\n            signatureV2: signatureV2,\n            data: data\n          }; // if we cannot derive the public key from the PeerId (e.g. RSA PeerIDs),\n          // we have to embed it in the IPNS record\n          if (peerId.publicKey != null) {\n            digest = Digest.decode(peerId.toBytes());\n            if (digest.code !== ID_MULTIHASH_CODE || !uint8ArrayEquals(peerId.publicKey, digest.digest)) {\n              entry.pubKey = peerId.publicKey;\n            }\n          }\n          log('ipns entry for %b created', value);\n          return _context3.abrupt(\"return\", entry);\n        case 19:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function _create(_x9, _x10, _x11, _x12, _x13, _x14) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * rawStdEncoding with RFC4648\n */\nvar rawStdEncoding = function rawStdEncoding(key) {\n  return base32upper.encode(key).slice(1);\n};\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\nexport var getLocalKey = function getLocalKey(key) {\n  return new Key(\"/ipns/\".concat(rawStdEncoding(key)));\n};\nexport { unmarshal } from './utils.js';\nexport { marshal } from './utils.js';\nexport { peerIdToRoutingKey } from './utils.js';\nexport { peerIdFromRoutingKey } from './utils.js';\n/**\n * Sign ipns record data\n */\nvar sign = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(privateKey, value, validityType, validity) {\n    var dataForSignature;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.prev = 0;\n          dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n          _context4.next = 4;\n          return privateKey.sign(dataForSignature);\n        case 4:\n          return _context4.abrupt(\"return\", _context4.sent);\n        case 7:\n          _context4.prev = 7;\n          _context4.t0 = _context4[\"catch\"](0);\n          log.error('record signature creation failed', _context4.t0);\n          throw errCode(new Error('record signature creation failed'), ERRORS.ERR_SIGNATURE_CREATION);\n        case 11:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[0, 7]]);\n  }));\n  return function sign(_x15, _x16, _x17, _x18) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["NanoDate","Key","unmarshalPrivateKey","errCode","base32upper","fromString","uint8ArrayFromString","logger","createCborData","ipnsEntryDataForV1Sig","ipnsEntryDataForV2Sig","ERRORS","equals","uint8ArrayEquals","Digest","identity","IpnsEntry","log","ID_MULTIHASH_CODE","code","namespace","namespaceLength","length","create","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","peerId","value","seq","lifetime","expirationDate","validityType","_lifetime$toString$sp","_lifetime$toString$sp2","ms","ns","lifetimeNs","wrap","_callee$","_context","prev","next","Date","now","Number","ValidityType","EOL","toString","split","_slicedToArray","BigInt","_create","abrupt","sent","stop","_x","_x2","_x3","_x4","apply","arguments","createWithExpiration","_ref2","_callee2","expiration","ttlMs","ttlNs","_callee2$","_context2","toDate","getTime","getNano","_x5","_x6","_x7","_x8","_ref3","_callee3","ttl","isoValidity","privateKey","signatureV1","data","sigData","signatureV2","entry","digest","_callee3$","_context3","Error","ERR_MISSING_PRIVATE_KEY","sign","signature","validity","sequence","publicKey","decode","toBytes","pubKey","_x9","_x10","_x11","_x12","_x13","_x14","rawStdEncoding","key","encode","slice","getLocalKey","concat","unmarshal","marshal","peerIdToRoutingKey","peerIdFromRoutingKey","_ref4","_callee4","dataForSignature","_callee4$","_context4","t0","error","ERR_SIGNATURE_CREATION","_x15","_x16","_x17","_x18"],"sources":["/Users/apple/Documents/treasure/node_modules/ipns/src/index.ts"],"sourcesContent":["import NanoDate from 'timestamp-nano'\nimport { Key } from 'interface-datastore/key'\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport errCode from 'err-code'\nimport { base32upper } from 'multiformats/bases/base32'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { logger } from '@libp2p/logger'\nimport { createCborData, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig } from './utils.js'\nimport * as ERRORS from './errors.js'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { IpnsEntry } from './pb/ipns.js'\nimport type { PrivateKey } from '@libp2p/interface-keys'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst log = logger('ipns')\nconst ID_MULTIHASH_CODE = identity.code\n\nexport const namespace = '/ipns/'\nexport const namespaceLength = namespace.length\n\nexport interface IPNSEntry {\n  value: Uint8Array\n  signature: Uint8Array // signature of the record\n  validityType: IpnsEntry.ValidityType // Type of validation being used\n  validity: Uint8Array // expiration datetime for the record in RFC3339 format\n  sequence: bigint // number representing the version of the record\n  ttl?: bigint // ttl in nanoseconds\n  pubKey?: Uint8Array // the public portion of the key that signed this record (only present if it was not embedded in the IPNS key)\n  signatureV2?: Uint8Array // the v2 signature of the record\n  data?: Uint8Array // extensible data\n}\n\nexport interface IPNSEntryData {\n  Value: Uint8Array\n  Validity: Uint8Array\n  ValidityType: IpnsEntry.ValidityType\n  Sequence: bigint\n  TTL: bigint\n}\n\nexport interface IDKeys {\n  routingPubKey: Key\n  pkKey: Key\n  routingKey: Key\n  ipnsKey: Key\n}\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PeerId} peerId - peer id containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\nexport const create = async (peerId: PeerId, value: Uint8Array, seq: number | bigint, lifetime: number): Promise<IPNSEntry> => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime))\n  const validityType = IpnsEntry.ValidityType.EOL\n  const [ms, ns] = lifetime.toString().split('.')\n  const lifetimeNs = (BigInt(ms) * BigInt(100000)) + BigInt(ns ?? '0')\n\n  return await _create(peerId, value, seq, validityType, expirationDate, lifetimeNs)\n}\n\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PeerId} peerId - PeerId containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\nexport const createWithExpiration = async (peerId: PeerId, value: Uint8Array, seq: number | bigint, expiration: string): Promise<IPNSEntry> => {\n  const expirationDate = NanoDate.fromString(expiration)\n  const validityType = IpnsEntry.ValidityType.EOL\n\n  const ttlMs = expirationDate.toDate().getTime() - Date.now()\n  const ttlNs = (BigInt(ttlMs) * BigInt(100000)) + BigInt(expirationDate.getNano())\n\n  return await _create(peerId, value, seq, validityType, expirationDate, ttlNs)\n}\n\nconst _create = async (peerId: PeerId, value: Uint8Array, seq: number | bigint, validityType: IpnsEntry.ValidityType, expirationDate: NanoDate, ttl: bigint): Promise<IPNSEntry> => {\n  seq = BigInt(seq)\n  const isoValidity = uint8ArrayFromString(expirationDate.toString())\n\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Missing private key'), ERRORS.ERR_MISSING_PRIVATE_KEY)\n  }\n\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n  const signatureV1 = await sign(privateKey, value, validityType, isoValidity)\n  const data = createCborData(value, isoValidity, validityType, seq, ttl)\n  const sigData = ipnsEntryDataForV2Sig(data)\n  const signatureV2 = await privateKey.sign(sigData)\n\n  const entry: IPNSEntry = {\n    value,\n    signature: signatureV1,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  }\n\n  // if we cannot derive the public key from the PeerId (e.g. RSA PeerIDs),\n  // we have to embed it in the IPNS record\n  if (peerId.publicKey != null) {\n    const digest = Digest.decode(peerId.toBytes())\n\n    if (digest.code !== ID_MULTIHASH_CODE || !uint8ArrayEquals(peerId.publicKey, digest.digest)) {\n      entry.pubKey = peerId.publicKey\n    }\n  }\n\n  log('ipns entry for %b created', value)\n  return entry\n}\n\n/**\n * rawStdEncoding with RFC4648\n */\nconst rawStdEncoding = (key: Uint8Array): string => base32upper.encode(key).slice(1)\n\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\nexport const getLocalKey = (key: Uint8Array): Key => new Key(`/ipns/${rawStdEncoding(key)}`)\n\nexport { unmarshal } from './utils.js'\nexport { marshal } from './utils.js'\nexport { peerIdToRoutingKey } from './utils.js'\nexport { peerIdFromRoutingKey } from './utils.js'\n\n/**\n * Sign ipns record data\n */\nconst sign = async (privateKey: PrivateKey, value: Uint8Array, validityType: IpnsEntry.ValidityType, validity: Uint8Array) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity)\n\n    return await privateKey.sign(dataForSignature)\n  } catch (error: any) {\n    log.error('record signature creation failed', error)\n    throw errCode(new Error('record signature creation failed'), ERRORS.ERR_SIGNATURE_CREATION)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}