{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport * as secp from '@noble/secp256k1';\nimport { sha256 } from 'multiformats/hashes/sha2';\nvar PRIVATE_KEY_BYTE_LENGTH = 32;\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport function generateKey() {\n  return secp.utils.randomPrivateKey();\n}\n/**\n * Hash and sign message with private key\n */\nexport function hashAndSign(_x, _x2) {\n  return _hashAndSign.apply(this, arguments);\n}\n/**\n * Hash message and verify signature with public key\n */\nfunction _hashAndSign() {\n  _hashAndSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, msg) {\n    var _yield$sha256$digest, digest;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return sha256.digest(msg);\n        case 2:\n          _yield$sha256$digest = _context.sent;\n          digest = _yield$sha256$digest.digest;\n          _context.prev = 4;\n          _context.next = 7;\n          return secp.sign(digest, key);\n        case 7:\n          return _context.abrupt(\"return\", _context.sent);\n        case 10:\n          _context.prev = 10;\n          _context.t0 = _context[\"catch\"](4);\n          throw new CodeError(String(_context.t0), 'ERR_INVALID_INPUT');\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[4, 10]]);\n  }));\n  return _hashAndSign.apply(this, arguments);\n}\nexport function hashAndVerify(_x3, _x4, _x5) {\n  return _hashAndVerify.apply(this, arguments);\n}\nfunction _hashAndVerify() {\n  _hashAndVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, sig, msg) {\n    var _yield$sha256$digest2, digest;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          _context2.next = 3;\n          return sha256.digest(msg);\n        case 3:\n          _yield$sha256$digest2 = _context2.sent;\n          digest = _yield$sha256$digest2.digest;\n          return _context2.abrupt(\"return\", secp.verify(sig, digest, key));\n        case 8:\n          _context2.prev = 8;\n          _context2.t0 = _context2[\"catch\"](0);\n          throw new CodeError(String(_context2.t0), 'ERR_INVALID_INPUT');\n        case 11:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[0, 8]]);\n  }));\n  return _hashAndVerify.apply(this, arguments);\n}\nexport function compressPublicKey(key) {\n  var point = secp.Point.fromHex(key).toRawBytes(true);\n  return point;\n}\nexport function decompressPublicKey(key) {\n  var point = secp.Point.fromHex(key).toRawBytes(false);\n  return point;\n}\nexport function validatePrivateKey(key) {\n  try {\n    secp.getPublicKey(key, true);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n  }\n}\nexport function validatePublicKey(key) {\n  try {\n    secp.Point.fromHex(key);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PUBLIC_KEY');\n  }\n}\nexport function computePublicKey(privateKey) {\n  try {\n    return secp.getPublicKey(privateKey, true);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n  }\n}","map":{"version":3,"names":["CodeError","secp","sha256","PRIVATE_KEY_BYTE_LENGTH","privateKeyLength","generateKey","utils","randomPrivateKey","hashAndSign","_x","_x2","_hashAndSign","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","key","msg","_yield$sha256$digest","digest","wrap","_callee$","_context","prev","next","sent","sign","abrupt","t0","String","stop","hashAndVerify","_x3","_x4","_x5","_hashAndVerify","_callee2","sig","_yield$sha256$digest2","_callee2$","_context2","verify","compressPublicKey","point","Point","fromHex","toRawBytes","decompressPublicKey","validatePrivateKey","getPublicKey","err","validatePublicKey","computePublicKey","privateKey"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/crypto/src/keys/secp256k1.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport * as secp from '@noble/secp256k1'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function generateKey () {\n  return secp.utils.randomPrivateKey()\n}\n\n/**\n * Hash and sign message with private key\n */\nexport async function hashAndSign (key: Uint8Array, msg: Uint8Array) {\n  const { digest } = await sha256.digest(msg)\n  try {\n    return await secp.sign(digest, key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT')\n  }\n}\n\n/**\n * Hash message and verify signature with public key\n */\nexport async function hashAndVerify (key: Uint8Array, sig: Uint8Array, msg: Uint8Array) {\n  try {\n    const { digest } = await sha256.digest(msg)\n    return secp.verify(sig, digest, key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT')\n  }\n}\n\nexport function compressPublicKey (key: Uint8Array) {\n  const point = secp.Point.fromHex(key).toRawBytes(true)\n  return point\n}\n\nexport function decompressPublicKey (key: Uint8Array) {\n  const point = secp.Point.fromHex(key).toRawBytes(false)\n  return point\n}\n\nexport function validatePrivateKey (key: Uint8Array) {\n  try {\n    secp.getPublicKey(key, true)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY')\n  }\n}\n\nexport function validatePublicKey (key: Uint8Array) {\n  try {\n    secp.Point.fromHex(key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PUBLIC_KEY')\n  }\n}\n\nexport function computePublicKey (privateKey: Uint8Array) {\n  try {\n    return secp.getPublicKey(privateKey, true)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}