{"ast":null,"code":"var _assertThisInitialized = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createClass = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\n\nvar cluster = require('cluster');\nvar crypto = require('crypto');\nvar RateLimiterAbstract = require('./RateLimiterAbstract');\nvar RateLimiterMemory = require('./RateLimiterMemory');\nvar RateLimiterRes = require('./RateLimiterRes');\nvar channel = 'rate_limiter_flexible';\nvar masterInstance = null;\nvar masterSendToWorker = function masterSendToWorker(worker, msg, type, res) {\n  var data;\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration\n    };\n  }\n  worker.send({\n    channel: channel,\n    keyPrefix: msg.keyPrefix,\n    // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type: type,\n    data: data\n  });\n};\nvar workerWaitInit = function workerWaitInit(payload) {\n  var _this = this;\n  setTimeout(function () {\n    if (_this._initiated) {\n      process.send(payload);\n      // Promise will be removed by timeout if too long\n    } else if (typeof _this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(_this, payload);\n    }\n  }, 30);\n};\nvar workerSendToMaster = function workerSendToMaster(func, promiseId, key, arg, opts) {\n  var payload = {\n    channel: channel,\n    keyPrefix: this.keyPrefix,\n    func: func,\n    promiseId: promiseId,\n    data: {\n      key: key,\n      arg: arg,\n      opts: opts\n    }\n  };\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\nvar masterProcessMsg = function masterProcessMsg(worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n  var promise;\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n    default:\n      return false;\n  }\n  if (promise) {\n    promise.then(function (res) {\n      masterSendToWorker(worker, msg, 'resolve', res);\n    }).catch(function (rejRes) {\n      masterSendToWorker(worker, msg, 'reject', rejRes);\n    });\n  }\n};\nvar workerProcessMsg = function workerProcessMsg(msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    var res;\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(msg.data.remainingPoints, msg.data.msBeforeNext, msg.data.consumedPoints, msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n        break;\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n        break;\n      default:\n        throw new Error(\"RateLimiterCluster: no such message type '\".concat(msg.type, \"'\"));\n    }\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\nvar getOpts = function getOpts() {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix\n  };\n};\nvar savePromise = function savePromise(resolve, reject) {\n  var _this2 = this;\n  var hrtime = process.hrtime();\n  var promiseId = hrtime[0].toString() + hrtime[1].toString();\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n  this._promises[promiseId] = {\n    resolve: resolve,\n    reject: reject,\n    timeoutId: setTimeout(function () {\n      delete _this2._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs)\n  };\n  return promiseId;\n};\nvar RateLimiterClusterMaster = /*#__PURE__*/_createClass(function RateLimiterClusterMaster() {\n  \"use strict\";\n\n  var _this3 = this;\n  _classCallCheck(this, RateLimiterClusterMaster);\n  if (masterInstance) {\n    return masterInstance;\n  }\n  this._rateLimiters = {};\n  cluster.setMaxListeners(0);\n  cluster.on('message', function (worker, msg) {\n    if (msg && msg.channel === channel && msg.type === 'init') {\n      // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n      if (typeof _this3._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n        _this3._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n      }\n      worker.send({\n        channel: channel,\n        type: 'init',\n        keyPrefix: msg.opts.keyPrefix\n      });\n    } else {\n      masterProcessMsg.call(_this3, worker, msg);\n    }\n  });\n  masterInstance = this;\n});\nvar RateLimiterClusterMasterPM2 = /*#__PURE__*/_createClass(function RateLimiterClusterMasterPM2(pm2) {\n  \"use strict\";\n\n  var _this4 = this;\n  _classCallCheck(this, RateLimiterClusterMasterPM2);\n  if (masterInstance) {\n    return masterInstance;\n  }\n  this._rateLimiters = {};\n  pm2.launchBus(function (err, pm2Bus) {\n    pm2Bus.on('process:msg', function (packet) {\n      var msg = packet.raw;\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof _this4._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          _this4._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n        pm2.sendDataToProcessId(packet.process.pm_id, {\n          data: {},\n          topic: channel,\n          channel: channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix\n        }, function (sendErr, res) {\n          if (sendErr) {\n            console.log(sendErr, res);\n          }\n        });\n      } else {\n        var worker = {\n          send: function send(msgData) {\n            var pm2Message = msgData;\n            pm2Message.topic = channel;\n            if (typeof pm2Message.data === 'undefined') {\n              pm2Message.data = {};\n            }\n            pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, function (sendErr, res) {\n              if (sendErr) {\n                console.log(sendErr, res);\n              }\n            });\n          }\n        };\n        masterProcessMsg.call(_this4, worker, msg);\n      }\n    });\n  });\n  masterInstance = this;\n});\nvar RateLimiterClusterWorker = /*#__PURE__*/function (_RateLimiterAbstract) {\n  \"use strict\";\n\n  _inherits(RateLimiterClusterWorker, _RateLimiterAbstract);\n  var _super = _createSuper(RateLimiterClusterWorker);\n  function RateLimiterClusterWorker() {\n    var _this5;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, RateLimiterClusterWorker);\n    _this5 = _super.call(this, opts);\n    process.setMaxListeners(0);\n    _this5.timeoutMs = opts.timeoutMs;\n    _this5._initiated = false;\n    process.on('message', function (msg) {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === _this5.keyPrefix) {\n        _this5._initiated = true;\n      } else {\n        workerProcessMsg.call(_assertThisInitialized(_this5), msg);\n      }\n    });\n\n    // Create limiter on master with specific options\n    process.send({\n      channel: channel,\n      type: 'init',\n      opts: getOpts.call(_assertThisInitialized(_this5))\n    });\n    _this5._promises = {};\n    return _this5;\n  }\n  _createClass(RateLimiterClusterWorker, [{\n    key: \"timeoutMs\",\n    get: function get() {\n      return this._timeoutMs;\n    },\n    set: function set(value) {\n      this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n    }\n  }, {\n    key: \"consume\",\n    value: function consume(key) {\n      var _this6 = this;\n      var pointsToConsume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return new Promise(function (resolve, reject) {\n        var promiseId = savePromise.call(_this6, resolve, reject);\n        workerSendToMaster.call(_this6, 'consume', promiseId, key, pointsToConsume, options);\n      });\n    }\n  }, {\n    key: \"penalty\",\n    value: function penalty(key) {\n      var _this7 = this;\n      var points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return new Promise(function (resolve, reject) {\n        var promiseId = savePromise.call(_this7, resolve, reject);\n        workerSendToMaster.call(_this7, 'penalty', promiseId, key, points, options);\n      });\n    }\n  }, {\n    key: \"reward\",\n    value: function reward(key) {\n      var _this8 = this;\n      var points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return new Promise(function (resolve, reject) {\n        var promiseId = savePromise.call(_this8, resolve, reject);\n        workerSendToMaster.call(_this8, 'reward', promiseId, key, points, options);\n      });\n    }\n  }, {\n    key: \"block\",\n    value: function block(key, secDuration) {\n      var _this9 = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return new Promise(function (resolve, reject) {\n        var promiseId = savePromise.call(_this9, resolve, reject);\n        workerSendToMaster.call(_this9, 'block', promiseId, key, secDuration, options);\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var _this10 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function (resolve, reject) {\n        var promiseId = savePromise.call(_this10, resolve, reject);\n        workerSendToMaster.call(_this10, 'get', promiseId, key, options);\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var _this11 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function (resolve, reject) {\n        var promiseId = savePromise.call(_this11, resolve, reject);\n        workerSendToMaster.call(_this11, 'delete', promiseId, key, options);\n      });\n    }\n  }]);\n  return RateLimiterClusterWorker;\n}(RateLimiterAbstract);\nmodule.exports = {\n  RateLimiterClusterMaster: RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2: RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker\n};","map":{"version":3,"names":["cluster","require","crypto","RateLimiterAbstract","RateLimiterMemory","RateLimiterRes","channel","masterInstance","masterSendToWorker","worker","msg","type","res","data","remainingPoints","msBeforeNext","consumedPoints","isFirstInDuration","send","keyPrefix","promiseId","workerWaitInit","payload","_this","setTimeout","_initiated","process","_promises","call","workerSendToMaster","func","key","arg","opts","masterProcessMsg","_rateLimiters","promise","consume","penalty","reward","block","get","delete","then","catch","rejRes","workerProcessMsg","clearTimeout","timeoutId","resolve","reject","Error","concat","getOpts","points","duration","blockDuration","execEvenly","execEvenlyMinDelayMs","savePromise","_this2","hrtime","toString","randomBytes","timeoutMs","RateLimiterClusterMaster","_createClass","_this3","_classCallCheck","setMaxListeners","on","RateLimiterClusterMasterPM2","pm2","_this4","launchBus","err","pm2Bus","packet","raw","sendDataToProcessId","pm_id","topic","sendErr","console","log","msgData","pm2Message","RateLimiterClusterWorker","_RateLimiterAbstract","_inherits","_super","_createSuper","_this5","arguments","length","undefined","_assertThisInitialized","_timeoutMs","set","value","Math","abs","parseInt","_this6","pointsToConsume","options","Promise","_this7","_this8","secDuration","_this9","_this10","_delete","_this11","module","exports","RateLimiterCluster"],"sources":["/Users/apple/Documents/treasure/node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"],"sourcesContent":["/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\n\nconst cluster = require('cluster');\nconst crypto = require('crypto');\nconst RateLimiterAbstract = require('./RateLimiterAbstract');\nconst RateLimiterMemory = require('./RateLimiterMemory');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst channel = 'rate_limiter_flexible';\nlet masterInstance = null;\n\nconst masterSendToWorker = function (worker, msg, type, res) {\n  let data;\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration,\n    };\n  }\n  worker.send({\n    channel,\n    keyPrefix: msg.keyPrefix, // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type,\n    data,\n  });\n};\n\nconst workerWaitInit = function (payload) {\n  setTimeout(() => {\n    if (this._initiated) {\n      process.send(payload);\n      // Promise will be removed by timeout if too long\n    } else if (typeof this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(this, payload);\n    }\n  }, 30);\n};\n\nconst workerSendToMaster = function (func, promiseId, key, arg, opts) {\n  const payload = {\n    channel,\n    keyPrefix: this.keyPrefix,\n    func,\n    promiseId,\n    data: {\n      key,\n      arg,\n      opts,\n    },\n  };\n\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\n\nconst masterProcessMsg = function (worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n\n  let promise;\n\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n    default:\n      return false;\n  }\n\n  if (promise) {\n    promise\n      .then((res) => {\n        masterSendToWorker(worker, msg, 'resolve', res);\n      })\n      .catch((rejRes) => {\n        masterSendToWorker(worker, msg, 'reject', rejRes);\n      });\n  }\n};\n\nconst workerProcessMsg = function (msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    let res;\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(\n        msg.data.remainingPoints,\n        msg.data.msBeforeNext,\n        msg.data.consumedPoints,\n        msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n        break;\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n        break;\n      default:\n        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);\n    }\n\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\nconst getOpts = function () {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix,\n  };\n};\n\nconst savePromise = function (resolve, reject) {\n  const hrtime = process.hrtime();\n  let promiseId = hrtime[0].toString() + hrtime[1].toString();\n\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n\n  this._promises[promiseId] = {\n    resolve,\n    reject,\n    timeoutId: setTimeout(() => {\n      delete this._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs),\n  };\n\n  return promiseId;\n};\n\nclass RateLimiterClusterMaster {\n  constructor() {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    cluster.setMaxListeners(0);\n\n    cluster.on('message', (worker, msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n\n        worker.send({\n          channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix,\n        });\n      } else {\n        masterProcessMsg.call(this, worker, msg);\n      }\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterMasterPM2 {\n  constructor(pm2) {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    pm2.launchBus((err, pm2Bus) => {\n      pm2Bus.on('process:msg', (packet) => {\n        const msg = packet.raw;\n        if (msg && msg.channel === channel && msg.type === 'init') {\n          // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n          if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n          }\n\n          pm2.sendDataToProcessId(packet.process.pm_id, {\n            data: {},\n            topic: channel,\n            channel,\n            type: 'init',\n            keyPrefix: msg.opts.keyPrefix,\n          }, (sendErr, res) => {\n            if (sendErr) {\n              console.log(sendErr, res);\n            }\n          });\n        } else {\n          const worker = {\n            send: (msgData) => {\n              const pm2Message = msgData;\n              pm2Message.topic = channel;\n              if (typeof pm2Message.data === 'undefined') {\n                pm2Message.data = {};\n              }\n              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {\n                if (sendErr) {\n                  console.log(sendErr, res);\n                }\n              });\n            },\n          };\n          masterProcessMsg.call(this, worker, msg);\n        }\n      });\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterWorker extends RateLimiterAbstract {\n  get timeoutMs() {\n    return this._timeoutMs;\n  }\n\n  set timeoutMs(value) {\n    this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n  }\n\n  constructor(opts = {}) {\n    super(opts);\n\n    process.setMaxListeners(0);\n\n    this.timeoutMs = opts.timeoutMs;\n\n    this._initiated = false;\n\n    process.on('message', (msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === this.keyPrefix) {\n        this._initiated = true;\n      } else {\n        workerProcessMsg.call(this, msg);\n      }\n    });\n\n    // Create limiter on master with specific options\n    process.send({\n      channel,\n      type: 'init',\n      opts: getOpts.call(this),\n    });\n\n    this._promises = {};\n  }\n\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'consume', promiseId, key, pointsToConsume, options);\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'penalty', promiseId, key, points, options);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'reward', promiseId, key, points, options);\n    });\n  }\n\n  block(key, secDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'block', promiseId, key, secDuration, options);\n    });\n  }\n\n  get(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'get', promiseId, key, options);\n    });\n  }\n\n  delete(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'delete', promiseId, key, options);\n    });\n  }\n}\n\nmodule.exports = {\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}