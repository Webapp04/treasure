{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n/* eslint-disable no-unreachable */\n\nimport * as isIpfs from 'is-ipfs';\nimport { CID } from 'multiformats/cid';\nimport { Key } from 'interface-datastore/key';\nimport errCode from 'err-code';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path';\nimport * as dagPB from '@ipld/dag-pb';\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nvar ERR_BAD_PATH = 'ERR_BAD_PATH';\nexport var OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexport var MFS_ROOT_KEY = new Key('/local/filesroot');\nexport var MFS_MAX_CHUNK_SIZE = 262144;\nexport var MFS_MAX_LINKS = 174;\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\nexport var normalizePath = function normalizePath(pathStr) {\n  var cid = CID.asCID(pathStr);\n  if (cid) {\n    return \"/ipfs/\".concat(pathStr);\n  }\n  var str = pathStr.toString();\n  try {\n    return \"/ipfs/\".concat(CID.parse(str));\n  } catch (_unused) {}\n  if (isIpfs.path(str)) {\n    return str;\n  } else {\n    throw errCode(new Error(\"invalid path: \".concat(pathStr)), ERR_BAD_PATH);\n  }\n};\n\n// TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n/**\n * @param {Uint8Array|CID|string} path\n */\nexport var normalizeCidPath = function normalizeCidPath(path) {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString();\n  }\n  path = path.toString();\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n  return path;\n};\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\nexport var resolvePath = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(repo, codecs, ipfsPath) {\n    var options,\n      _toCidAndPath,\n      cid,\n      path,\n      lastCid,\n      lastRemainderPath,\n      _iteratorAbruptCompletion,\n      _didIteratorError,\n      _iteratorError,\n      _iterator,\n      _step,\n      _step$value,\n      value,\n      remainderPath,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n          _toCidAndPath = toCidAndPath(ipfsPath), cid = _toCidAndPath.cid, path = _toCidAndPath.path;\n          if (path) {\n            options.path = path;\n          }\n          lastCid = cid;\n          lastRemainderPath = options.path || '';\n          if (lastRemainderPath.startsWith('/')) {\n            lastRemainderPath = lastRemainderPath.substring(1);\n          }\n          if (!options.path) {\n            _context.next = 45;\n            break;\n          }\n          _context.prev = 7;\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 10;\n          _iterator = _asyncIterator(resolve(cid, options.path, codecs, repo, {\n            signal: options.signal\n          }));\n        case 12:\n          _context.next = 14;\n          return _iterator.next();\n        case 14:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 23;\n            break;\n          }\n          _step$value = _step.value, value = _step$value.value, remainderPath = _step$value.remainderPath;\n          if (CID.asCID(value)) {\n            _context.next = 18;\n            break;\n          }\n          return _context.abrupt(\"break\", 23);\n        case 18:\n          lastRemainderPath = remainderPath;\n          lastCid = value;\n        case 20:\n          _iteratorAbruptCompletion = false;\n          _context.next = 12;\n          break;\n        case 23:\n          _context.next = 29;\n          break;\n        case 25:\n          _context.prev = 25;\n          _context.t0 = _context[\"catch\"](10);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n        case 29:\n          _context.prev = 29;\n          _context.prev = 30;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context.next = 34;\n            break;\n          }\n          _context.next = 34;\n          return _iterator.return();\n        case 34:\n          _context.prev = 34;\n          if (!_didIteratorError) {\n            _context.next = 37;\n            break;\n          }\n          throw _iteratorError;\n        case 37:\n          return _context.finish(34);\n        case 38:\n          return _context.finish(29);\n        case 39:\n          _context.next = 45;\n          break;\n        case 41:\n          _context.prev = 41;\n          _context.t1 = _context[\"catch\"](7);\n          // TODO: add error codes to IPLD\n          if (_context.t1.message.startsWith('Object has no property')) {\n            _context.t1.message = \"no link named \\\"\".concat(lastRemainderPath.split('/')[0], \"\\\" under \").concat(lastCid);\n            _context.t1.code = 'ERR_NO_LINK';\n          }\n          throw _context.t1;\n        case 45:\n          return _context.abrupt(\"return\", {\n            cid: lastCid,\n            remainderPath: lastRemainderPath || ''\n          });\n        case 46:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[7, 41], [10, 25, 29, 39], [30,, 34, 38]]);\n  }));\n  return function resolvePath(_x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\nexport var mapFile = function mapFile(file) {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(\"Unknown node type '\".concat(file.type, \"'\"));\n  }\n\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n  var output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  };\n  if (file.type === 'directory') {\n    // @ts-expect-error - TS type can't be changed from File to Directory\n    output.type = 'dir';\n  }\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize();\n  }\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode;\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime;\n    }\n  }\n  return output;\n};\nexport var withTimeout = withTimeoutOption(\n/*#__PURE__*/\n/**\n * @template T\n * @param {Promise<T>|T} promise\n * @param {AbortOptions} [_options]\n * @returns {Promise<T>}\n */\nfunction () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(promise, _options) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return promise;\n        case 2:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 3:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function (_x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}());\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs').Multicodecs} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\nexport var resolve = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cid, path, codecs, repo, options) {\n    var load, parts, value, lastCid, _loop;\n    return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          /**\n           * @param {CID} cid\n           */\n          load = /*#__PURE__*/function () {\n            var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid) {\n              var codec, block;\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.next = 2;\n                    return codecs.getCodec(cid.code);\n                  case 2:\n                    codec = _context3.sent;\n                    _context3.next = 5;\n                    return repo.blocks.get(cid, options);\n                  case 5:\n                    block = _context3.sent;\n                    return _context3.abrupt(\"return\", codec.decode(block));\n                  case 7:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _callee3);\n            }));\n            return function load(_x11) {\n              return _ref4.apply(this, arguments);\n            };\n          }();\n          parts = path.split('/').filter(Boolean);\n          _context5.next = 4;\n          return _awaitAsyncGenerator(load(cid));\n        case 4:\n          value = _context5.sent;\n          lastCid = cid; // End iteration if there isn't a CID to follow any more\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var key, link;\n            return _regeneratorRuntime().wrap(function _loop$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  key = parts.shift();\n                  if (key) {\n                    _context4.next = 3;\n                    break;\n                  }\n                  throw errCode(new Error(\"Could not resolve path \\\"\".concat(path, \"\\\"\")), 'ERR_INVALID_PATH');\n                case 3:\n                  if (!(cid.code === dagPB.code && Array.isArray(value.Links))) {\n                    _context4.next = 13;\n                    break;\n                  }\n                  link = value.Links.find(function ( /** @type {PBLink} */l) {\n                    return l.Name === key;\n                  });\n                  if (!link) {\n                    _context4.next = 13;\n                    break;\n                  }\n                  _context4.next = 8;\n                  return {\n                    value: link.Hash,\n                    remainderPath: parts.join('/')\n                  };\n                case 8:\n                  _context4.next = 10;\n                  return _awaitAsyncGenerator(load(link.Hash));\n                case 10:\n                  value = _context4.sent;\n                  lastCid = link.Hash;\n                  return _context4.abrupt(\"return\", 1);\n                case 13:\n                  if (!Object.prototype.hasOwnProperty.call(value, key)) {\n                    _context4.next = 19;\n                    break;\n                  }\n                  value = value[key];\n                  _context4.next = 17;\n                  return {\n                    value: value,\n                    remainderPath: parts.join('/')\n                  };\n                case 17:\n                  _context4.next = 20;\n                  break;\n                case 19:\n                  throw errCode(new Error(\"no link named \\\"\".concat(key, \"\\\" under \").concat(lastCid)), 'ERR_NO_LINK');\n                case 20:\n                  if (!CID.asCID(value)) {\n                    _context4.next = 25;\n                    break;\n                  }\n                  lastCid = value;\n                  _context4.next = 24;\n                  return _awaitAsyncGenerator(load(value));\n                case 24:\n                  value = _context4.sent;\n                case 25:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _loop);\n          });\n        case 7:\n          if (!parts.length) {\n            _context5.next = 13;\n            break;\n          }\n          return _context5.delegateYield(_loop(), \"t0\", 9);\n        case 9:\n          if (!_context5.t0) {\n            _context5.next = 11;\n            break;\n          }\n          return _context5.abrupt(\"continue\", 7);\n        case 11:\n          _context5.next = 7;\n          break;\n        case 13:\n          _context5.next = 15;\n          return {\n            value: value,\n            remainderPath: ''\n          };\n        case 15:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee4);\n  }));\n  return function resolve(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["isIpfs","CID","Key","errCode","withTimeoutOption","toCidAndPath","dagPB","ERR_BAD_PATH","OFFLINE_ERROR","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS","normalizePath","pathStr","cid","asCID","concat","str","toString","parse","_unused","path","Error","normalizeCidPath","Uint8Array","decode","indexOf","substring","length","charAt","resolvePath","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","repo","codecs","ipfsPath","options","_toCidAndPath","lastCid","lastRemainderPath","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","_step$value","value","remainderPath","_args","arguments","wrap","_callee$","_context","prev","next","undefined","startsWith","_asyncIterator","resolve","signal","sent","done","abrupt","t0","return","finish","t1","message","split","code","stop","_x6","_x7","_x8","apply","mapFile","file","type","output","name","size","unixfs","fileSize","mode","mtime","withTimeout","_ref3","_callee2","promise","_options","_callee2$","_context2","_x9","_x10","_ref","_wrapAsyncGenerator","_callee4","load","parts","_loop","_callee4$","_context5","_ref4","_callee3","codec","block","_callee3$","_context3","getCodec","blocks","get","_x11","filter","Boolean","_awaitAsyncGenerator","key","link","_loop$","_context4","shift","Array","isArray","Links","find","l","Name","Hash","join","Object","prototype","hasOwnProperty","call","delegateYield","_x","_x2","_x3","_x4","_x5"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/utils.js"],"sourcesContent":["/* eslint-disable no-unreachable */\n\nimport * as isIpfs from 'is-ipfs'\nimport { CID } from 'multiformats/cid'\nimport { Key } from 'interface-datastore/key'\nimport errCode from 'err-code'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path'\nimport * as dagPB from '@ipld/dag-pb'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\n\nexport const OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\nexport const MFS_ROOT_KEY = new Key('/local/filesroot')\nexport const MFS_MAX_CHUNK_SIZE = 262144\nexport const MFS_MAX_LINKS = 174\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\nexport const normalizePath = (pathStr) => {\n  const cid = CID.asCID(pathStr)\n\n  if (cid) {\n    return `/ipfs/${pathStr}`\n  }\n\n  const str = pathStr.toString()\n\n  try {\n    return `/ipfs/${CID.parse(str)}`\n  } catch {}\n\n  if (isIpfs.path(str)) {\n    return str\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH)\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n/**\n * @param {Uint8Array|CID|string} path\n */\nexport const normalizeCidPath = (path) => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString()\n  }\n\n  path = path.toString()\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\nexport const resolvePath = async function (repo, codecs, ipfsPath, options = {}) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (path) {\n    options.path = path\n  }\n\n  let lastCid = cid\n  let lastRemainderPath = options.path || ''\n\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1)\n  }\n\n  if (options.path) {\n    try {\n      for await (const { value, remainderPath } of resolve(cid, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!CID.asCID(value)) {\n          break\n        }\n\n        lastRemainderPath = remainderPath\n        lastCid = value\n      }\n    } catch (/** @type {any} */ err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`\n        err.code = 'ERR_NO_LINK'\n      }\n      throw err\n    }\n  }\n\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  }\n}\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\nexport const mapFile = (file) => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`)\n  }\n\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  }\n\n  if (file.type === 'directory') {\n    // @ts-expect-error - TS type can't be changed from File to Directory\n    output.type = 'dir'\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize()\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime\n    }\n  }\n\n  return output\n}\n\nexport const withTimeout = withTimeoutOption(\n  /**\n   * @template T\n   * @param {Promise<T>|T} promise\n   * @param {AbortOptions} [_options]\n   * @returns {Promise<T>}\n   */\n  async (promise, _options) => await promise\n)\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs').Multicodecs} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\nexport const resolve = async function * (cid, path, codecs, repo, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await repo.blocks.get(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    // special case for dag-pb, use the link name as the path segment\n    if (cid.code === dagPB.code && Array.isArray(value.Links)) {\n      const link = value.Links.find((/** @type {PBLink} */ l) => l.Name === key)\n\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        }\n\n        value = await load(link.Hash)\n        lastCid = link.Hash\n\n        continue\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    if (CID.asCID(value)) {\n      lastCid = value\n      value = await load(value)\n    }\n  }\n\n  yield {\n    value,\n    remainderPath: ''\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}