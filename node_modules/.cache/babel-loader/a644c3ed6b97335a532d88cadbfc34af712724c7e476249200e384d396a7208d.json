{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport * as hmac from '../hmac/index.js';\nvar cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    keySize: 32\n  }\n};\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\nexport function keyStretcher(_x, _x2, _x3) {\n  return _keyStretcher.apply(this, arguments);\n}\nfunction _keyStretcher() {\n  _keyStretcher = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cipherType, hash, secret) {\n    var cipher, allowed, cipherKeySize, ivSize, hmacKeySize, seed, resultLength, m, a, result, j, b, todo, half, resultBuffer, r1, r2, createKey;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          cipher = cipherMap[cipherType];\n          if (!(cipher == null)) {\n            _context.next = 4;\n            break;\n          }\n          allowed = Object.keys(cipherMap).join(' / ');\n          throw new CodeError(\"unknown cipher type '\".concat(cipherType, \"'. Must be \").concat(allowed), 'ERR_INVALID_CIPHER_TYPE');\n        case 4:\n          if (!(hash == null)) {\n            _context.next = 6;\n            break;\n          }\n          throw new CodeError('missing hash type', 'ERR_MISSING_HASH_TYPE');\n        case 6:\n          cipherKeySize = cipher.keySize;\n          ivSize = cipher.ivSize;\n          hmacKeySize = 20;\n          seed = uint8ArrayFromString('key expansion');\n          resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n          _context.next = 13;\n          return hmac.create(hash, secret);\n        case 13:\n          m = _context.sent;\n          _context.next = 16;\n          return m.digest(seed);\n        case 16:\n          a = _context.sent;\n          result = [];\n          j = 0;\n        case 19:\n          if (!(j < resultLength)) {\n            _context.next = 32;\n            break;\n          }\n          _context.next = 22;\n          return m.digest(uint8ArrayConcat([a, seed]));\n        case 22:\n          b = _context.sent;\n          todo = b.length;\n          if (j + todo > resultLength) {\n            todo = resultLength - j;\n          }\n          result.push(b);\n          j += todo;\n          _context.next = 29;\n          return m.digest(a);\n        case 29:\n          a = _context.sent;\n          _context.next = 19;\n          break;\n        case 32:\n          half = resultLength / 2;\n          resultBuffer = uint8ArrayConcat(result);\n          r1 = resultBuffer.subarray(0, half);\n          r2 = resultBuffer.subarray(half, resultLength);\n          createKey = function createKey(res) {\n            return {\n              iv: res.subarray(0, ivSize),\n              cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n              macKey: res.subarray(ivSize + cipherKeySize)\n            };\n          };\n          return _context.abrupt(\"return\", {\n            k1: createKey(r1),\n            k2: createKey(r2)\n          });\n        case 38:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _keyStretcher.apply(this, arguments);\n}","map":{"version":3,"names":["CodeError","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","hmac","cipherMap","ivSize","keySize","Blowfish","keyStretcher","_x","_x2","_x3","_keyStretcher","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","cipherType","hash","secret","cipher","allowed","cipherKeySize","hmacKeySize","seed","resultLength","m","a","result","j","b","todo","half","resultBuffer","r1","r2","createKey","wrap","_callee$","_context","prev","next","Object","keys","join","create","sent","digest","length","push","subarray","res","iv","cipherKey","macKey","abrupt","k1","k2","stop"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/crypto/src/keys/key-stretcher.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport * as hmac from '../hmac/index.js'\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    keySize: 32\n  }\n}\n\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\nexport async function keyStretcher (cipherType: 'AES-128' | 'AES-256' | 'Blowfish', hash: 'SHA1' | 'SHA256' | 'SHA512', secret: Uint8Array) {\n  const cipher = cipherMap[cipherType]\n\n  if (cipher == null) {\n    const allowed = Object.keys(cipherMap).join(' / ')\n    throw new CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, 'ERR_INVALID_CIPHER_TYPE')\n  }\n\n  if (hash == null) {\n    throw new CodeError('missing hash type', 'ERR_MISSING_HASH_TYPE')\n  }\n\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = uint8ArrayFromString('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  const m = await hmac.create(hash, secret)\n  let a = await m.digest(seed)\n\n  const result = []\n  let j = 0\n\n  while (j < resultLength) {\n    const b = await m.digest(uint8ArrayConcat([a, seed]))\n    let todo = b.length\n\n    if (j + todo > resultLength) {\n      todo = resultLength - j\n    }\n\n    result.push(b)\n    j += todo\n    a = await m.digest(a)\n  }\n\n  const half = resultLength / 2\n  const resultBuffer = uint8ArrayConcat(result)\n  const r1 = resultBuffer.subarray(0, half)\n  const r2 = resultBuffer.subarray(half, resultLength)\n\n  const createKey = (res: Uint8Array) => ({\n    iv: res.subarray(0, ivSize),\n    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n    macKey: res.subarray(ivSize + cipherKeySize)\n  })\n\n  return {\n    k1: createKey(r1),\n    k2: createKey(r2)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}