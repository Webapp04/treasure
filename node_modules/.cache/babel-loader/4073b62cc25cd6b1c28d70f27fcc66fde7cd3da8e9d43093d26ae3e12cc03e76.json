{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nimport pTimeout from 'p-timeout';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:websockets:socket');\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function socketToMaConn(stream, remoteAddr, options) {\n  var _options;\n  options = (_options = options) !== null && _options !== void 0 ? _options : {};\n  var maConn = {\n    sink: function sink(source) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _options2;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (((_options2 = options) === null || _options2 === void 0 ? void 0 : _options2.signal) != null) {\n                source = abortableSource(source, options.signal);\n              }\n              _context.prev = 1;\n              _context.next = 4;\n              return stream.sink(source);\n            case 4:\n              _context.next = 9;\n              break;\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](1);\n              if (_context.t0.type !== 'aborted') {\n                log.error(_context.t0);\n              }\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[1, 6]]);\n      }))();\n    },\n    source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,\n    remoteAddr: remoteAddr,\n    timeline: {\n      open: Date.now()\n    },\n    close: function close() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var start, _maConn$remoteAddr$to, host, port;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              start = Date.now();\n              _context2.prev = 1;\n              _context2.next = 4;\n              return pTimeout(stream.close(), {\n                milliseconds: CLOSE_TIMEOUT\n              });\n            case 4:\n              _context2.next = 11;\n              break;\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](1);\n              _maConn$remoteAddr$to = maConn.remoteAddr.toOptions(), host = _maConn$remoteAddr$to.host, port = _maConn$remoteAddr$to.port;\n              log('timeout closing stream to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n              stream.destroy();\n            case 11:\n              _context2.prev = 11;\n              maConn.timeline.close = Date.now();\n              return _context2.finish(11);\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[1, 6, 11, 14]]);\n      }))();\n    }\n  };\n  stream.socket.addEventListener('close', function () {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now();\n    }\n  }, {\n    once: true\n  });\n  return maConn;\n}","map":{"version":3,"names":["abortableSource","CLOSE_TIMEOUT","pTimeout","logger","log","socketToMaConn","stream","remoteAddr","options","_options","maConn","sink","source","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_options2","wrap","_callee$","_context","prev","next","signal","t0","type","error","stop","timeline","open","Date","now","close","_callee2","start","_maConn$remoteAddr$to","host","port","_callee2$","_context2","milliseconds","toOptions","destroy","finish","socket","addEventListener","once"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/websockets/src/socket-to-conn.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { CLOSE_TIMEOUT } from './constants.js'\nimport pTimeout from 'p-timeout'\nimport { logger } from '@libp2p/logger'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\n\nconst log = logger('libp2p:websockets:socket')\n\nexport interface SocketToConnOptions extends AbortOptions {\n  localAddr?: Multiaddr\n}\n\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function socketToMaConn (stream: DuplexWebSocket, remoteAddr: Multiaddr, options?: SocketToConnOptions): MultiaddrConnection {\n  options = options ?? {}\n\n  const maConn: MultiaddrConnection = {\n    async sink (source) {\n      if ((options?.signal) != null) {\n        source = abortableSource(source, options.signal)\n      }\n\n      try {\n        await stream.sink(source)\n      } catch (err: any) {\n        if (err.type !== 'aborted') {\n          log.error(err)\n        }\n      }\n    },\n\n    source: (options.signal != null) ? abortableSource(stream.source, options.signal) : stream.source,\n\n    remoteAddr,\n\n    timeline: { open: Date.now() },\n\n    async close () {\n      const start = Date.now()\n\n      try {\n        await pTimeout(stream.close(), {\n          milliseconds: CLOSE_TIMEOUT\n        })\n      } catch (err) {\n        const { host, port } = maConn.remoteAddr.toOptions()\n        log('timeout closing stream to %s:%s after %dms, destroying it manually',\n          host, port, Date.now() - start)\n\n        stream.destroy()\n      } finally {\n        maConn.timeline.close = Date.now()\n      }\n    }\n  }\n\n  stream.socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }, { once: true })\n\n  return maConn\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}