{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { logger } from '@libp2p/logger';\nimport { configure } from '../lib/configure.js';\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js';\nimport { textToUrlSafeRpc, rpcToText, rpcToBytes, rpcToBigInt } from '../lib/http-rpc-wire-format.js';\nimport { peerIdFromString } from '@libp2p/peer-id';\nvar log = logger('ipfs-http-client:pubsub:subscribe');\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker\n */\nexport var createSubscribe = function createSubscribe(options, subsTracker) {\n  return configure(function (api) {\n    /**\n     * @type {PubsubAPI[\"subscribe\"]}\n     */\n    function subscribe(_x, _x2) {\n      return _subscribe.apply(this, arguments);\n    }\n    function _subscribe() {\n      _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(topic, handler) {\n        var options,\n          done,\n          fail,\n          result,\n          ffWorkaround,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              // eslint-disable-line require-await\n              options.signal = subsTracker.subscribe(topic, handler, options.signal);\n\n              /** @type {(value?: any) => void} */\n\n              /** @type {(error: Error) => void} */\n              result = new Promise(function (resolve, reject) {\n                done = resolve;\n                fail = reject;\n              }); // In Firefox, the initial call to fetch does not resolve until some data\n              // is received. If this doesn't happen within 1 second assume success\n              ffWorkaround = setTimeout(function () {\n                return done();\n              }, 1000); // Do this async to not block Firefox\n              api.post('pubsub/sub', {\n                signal: options.signal,\n                searchParams: toUrlSearchParams(_objectSpread({\n                  arg: textToUrlSafeRpc(topic)\n                }, options)),\n                headers: options.headers\n              }).catch(function (err) {\n                // Initial subscribe fail, ensure we clean up\n                subsTracker.unsubscribe(topic, handler);\n                fail(err);\n              }).then(function (response) {\n                clearTimeout(ffWorkaround);\n                if (!response) {\n                  // if there was no response, the subscribe failed\n                  return;\n                }\n                readMessages(response, {\n                  onMessage: function onMessage(message) {\n                    if (!handler) {\n                      return;\n                    }\n                    if (typeof handler === 'function') {\n                      handler(message);\n                      return;\n                    }\n                    if (typeof handler.handleEvent === 'function') {\n                      handler.handleEvent(message);\n                    }\n                  },\n                  onEnd: function onEnd() {\n                    return subsTracker.unsubscribe(topic, handler);\n                  },\n                  onError: options.onError\n                });\n                done();\n              });\n              return _context.abrupt(\"return\", result);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _subscribe.apply(this, arguments);\n    }\n    return subscribe;\n  })(options);\n};\n\n/**\n * @param {import('ipfs-utils/src/types').ExtendedResponse} response\n * @param {object} options\n * @param {(message: Message) => void} options.onMessage\n * @param {() => void} options.onEnd\n * @param {ErrorHandlerFn} [options.onError]\n */\nfunction readMessages(_x3, _x4) {\n  return _readMessages.apply(this, arguments);\n}\n/**\n * @param {Error & {type?:string}} error\n * @returns {boolean}\n */\nfunction _readMessages() {\n  _readMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(response, _ref) {\n    var onMessage, onEnd, onError, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, msg, _msg$key, _msg$signature;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          onMessage = _ref.onMessage, onEnd = _ref.onEnd, onError = _ref.onError;\n          onError = onError || log;\n          _context2.prev = 2;\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context2.prev = 5;\n          _iterator = _asyncIterator(response.ndjson());\n        case 7:\n          _context2.next = 9;\n          return _iterator.next();\n        case 9:\n          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n            _context2.next = 24;\n            break;\n          }\n          msg = _step.value;\n          _context2.prev = 11;\n          if (msg.from) {\n            _context2.next = 14;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 21);\n        case 14:\n          if (msg.from != null && msg.seqno != null) {\n            onMessage({\n              type: 'signed',\n              from: peerIdFromString(msg.from),\n              data: rpcToBytes(msg.data),\n              sequenceNumber: rpcToBigInt(msg.seqno),\n              topic: rpcToText(msg.topicIDs[0]),\n              key: rpcToBytes((_msg$key = msg.key) !== null && _msg$key !== void 0 ? _msg$key : 'u'),\n              signature: rpcToBytes((_msg$signature = msg.signature) !== null && _msg$signature !== void 0 ? _msg$signature : 'u')\n            });\n          } else {\n            onMessage({\n              type: 'unsigned',\n              data: rpcToBytes(msg.data),\n              topic: rpcToText(msg.topicIDs[0])\n            });\n          }\n          _context2.next = 21;\n          break;\n        case 17:\n          _context2.prev = 17;\n          _context2.t0 = _context2[\"catch\"](11);\n          _context2.t0.message = \"Failed to parse pubsub message: \".concat(_context2.t0.message);\n          onError(_context2.t0, false, msg); // Not fatal\n        case 21:\n          _iteratorAbruptCompletion = false;\n          _context2.next = 7;\n          break;\n        case 24:\n          _context2.next = 30;\n          break;\n        case 26:\n          _context2.prev = 26;\n          _context2.t1 = _context2[\"catch\"](5);\n          _didIteratorError = true;\n          _iteratorError = _context2.t1;\n        case 30:\n          _context2.prev = 30;\n          _context2.prev = 31;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context2.next = 35;\n            break;\n          }\n          _context2.next = 35;\n          return _iterator.return();\n        case 35:\n          _context2.prev = 35;\n          if (!_didIteratorError) {\n            _context2.next = 38;\n            break;\n          }\n          throw _iteratorError;\n        case 38:\n          return _context2.finish(35);\n        case 39:\n          return _context2.finish(30);\n        case 40:\n          _context2.next = 45;\n          break;\n        case 42:\n          _context2.prev = 42;\n          _context2.t2 = _context2[\"catch\"](2);\n          if (!isAbortError(_context2.t2)) {\n            onError(_context2.t2, true); // Fatal\n          }\n        case 45:\n          _context2.prev = 45;\n          onEnd();\n          return _context2.finish(45);\n        case 48:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[2, 42, 45, 48], [5, 26, 30, 40], [11, 17], [31,, 35, 39]]);\n  }));\n  return _readMessages.apply(this, arguments);\n}\nvar isAbortError = function isAbortError(error) {\n  switch (error.type) {\n    case 'aborted':\n      return true;\n    // It is `abort` in Electron instead of `aborted`\n    case 'abort':\n      return true;\n    default:\n      // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n      // Temporarily use the name property instead.\n      return error.name === 'AbortError';\n  }\n};","map":{"version":3,"names":["logger","configure","toUrlSearchParams","textToUrlSafeRpc","rpcToText","rpcToBytes","rpcToBigInt","peerIdFromString","log","createSubscribe","options","subsTracker","api","subscribe","_x","_x2","_subscribe","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","topic","handler","done","fail","result","ffWorkaround","_args","wrap","_callee$","_context","prev","next","length","undefined","signal","Promise","resolve","reject","setTimeout","post","searchParams","_objectSpread","arg","headers","catch","err","unsubscribe","then","response","clearTimeout","readMessages","onMessage","message","handleEvent","onEnd","onError","abrupt","stop","_x3","_x4","_readMessages","_callee2","_ref","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","msg","_msg$key","_msg$signature","_callee2$","_context2","_asyncIterator","ndjson","sent","value","from","seqno","type","data","sequenceNumber","topicIDs","key","signature","t0","concat","t1","return","finish","t2","isAbortError","error","name"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-http-client/src/pubsub/subscribe.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { textToUrlSafeRpc, rpcToText, rpcToBytes, rpcToBigInt } from '../lib/http-rpc-wire-format.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\nconst log = logger('ipfs-http-client:pubsub:subscribe')\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker\n */\nexport const createSubscribe = (options, subsTracker) => {\n  return configure((api) => {\n    /**\n     * @type {PubsubAPI[\"subscribe\"]}\n     */\n    async function subscribe (topic, handler, options = {}) { // eslint-disable-line require-await\n      options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n      /** @type {(value?: any) => void} */\n      let done\n      /** @type {(error: Error) => void} */\n      let fail\n\n      const result = new Promise((resolve, reject) => {\n        done = resolve\n        fail = reject\n      })\n\n      // In Firefox, the initial call to fetch does not resolve until some data\n      // is received. If this doesn't happen within 1 second assume success\n      const ffWorkaround = setTimeout(() => done(), 1000)\n\n      // Do this async to not block Firefox\n      api.post('pubsub/sub', {\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: textToUrlSafeRpc(topic),\n          ...options\n        }),\n        headers: options.headers\n      })\n        .catch((err) => {\n          // Initial subscribe fail, ensure we clean up\n          subsTracker.unsubscribe(topic, handler)\n\n          fail(err)\n        })\n        .then((response) => {\n          clearTimeout(ffWorkaround)\n\n          if (!response) {\n            // if there was no response, the subscribe failed\n            return\n          }\n\n          readMessages(response, {\n            onMessage: (message) => {\n              if (!handler) {\n                return\n              }\n\n              if (typeof handler === 'function') {\n                handler(message)\n                return\n              }\n\n              if (typeof handler.handleEvent === 'function') {\n                handler.handleEvent(message)\n              }\n            },\n            onEnd: () => subsTracker.unsubscribe(topic, handler),\n            onError: options.onError\n          })\n\n          done()\n        })\n\n      return result\n    }\n    return subscribe\n  })(options)\n}\n\n/**\n * @param {import('ipfs-utils/src/types').ExtendedResponse} response\n * @param {object} options\n * @param {(message: Message) => void} options.onMessage\n * @param {() => void} options.onEnd\n * @param {ErrorHandlerFn} [options.onError]\n */\nasync function readMessages (response, { onMessage, onEnd, onError }) {\n  onError = onError || log\n\n  try {\n    for await (const msg of response.ndjson()) {\n      try {\n        if (!msg.from) {\n          continue\n        }\n\n        if (msg.from != null && msg.seqno != null) {\n          onMessage({\n            type: 'signed',\n            from: peerIdFromString(msg.from),\n            data: rpcToBytes(msg.data),\n            sequenceNumber: rpcToBigInt(msg.seqno),\n            topic: rpcToText(msg.topicIDs[0]),\n            key: rpcToBytes(msg.key ?? 'u'),\n            signature: rpcToBytes(msg.signature ?? 'u')\n          })\n        } else {\n          onMessage({\n            type: 'unsigned',\n            data: rpcToBytes(msg.data),\n            topic: rpcToText(msg.topicIDs[0])\n          })\n        }\n      } catch (/** @type {any} */ err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`\n        onError(err, false, msg) // Not fatal\n      }\n    }\n  } catch (/** @type {any} */ err) {\n    if (!isAbortError(err)) {\n      onError(err, true) // Fatal\n    }\n  } finally {\n    onEnd()\n  }\n}\n\n/**\n * @param {Error & {type?:string}} error\n * @returns {boolean}\n */\nconst isAbortError = error => {\n  switch (error.type) {\n    case 'aborted':\n      return true\n    // It is `abort` in Electron instead of `aborted`\n    case 'abort':\n      return true\n    default:\n      // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n      // Temporarily use the name property instead.\n      return error.name === 'AbortError'\n  }\n}\n"],"mappings":";;;;AAAA,SAASA,MAAM,QAAQ,gBAAgB;AACvC,SAASC,SAAS,QAAQ,qBAAqB;AAC/C,SAASC,iBAAiB,QAAQ,gCAAgC;AAClE,SAASC,gBAAgB,EAAEC,SAAS,EAAEC,UAAU,EAAEC,WAAW,QAAQ,gCAAgC;AACrG,SAASC,gBAAgB,QAAQ,iBAAiB;AAClD,IAAMC,GAAG,GAAGR,MAAM,CAAC,mCAAmC,CAAC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAMS,eAAe,GAAG,SAAlBA,eAAeA,CAAIC,OAAO,EAAEC,WAAW,EAAK;EACvD,OAAOV,SAAS,CAAC,UAACW,GAAG,EAAK;IACxB;AACJ;AACA;IAFI,SAGeC,SAASA,CAAAC,EAAA,EAAAC,GAAA;MAAA,OAAAC,UAAA,CAAAC,KAAA,OAAAC,SAAA;IAAA;IAAA,SAAAF,WAAA;MAAAA,UAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAxB,SAAAC,QAA0BC,KAAK,EAAEC,OAAO;QAAA,IAAAd,OAAA;UAAAe,IAAA;UAAAC,IAAA;UAAAC,MAAA;UAAAC,YAAA;UAAAC,KAAA,GAAAX,SAAA;QAAA,OAAAE,mBAAA,GAAAU,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAExB,OAAO,GAAAmB,KAAA,CAAAM,MAAA,QAAAN,KAAA,QAAAO,SAAA,GAAAP,KAAA,MAAG,CAAC,CAAC;cAAI;cACxDnB,OAAO,CAAC2B,MAAM,GAAG1B,WAAW,CAACE,SAAS,CAACU,KAAK,EAAEC,OAAO,EAAEd,OAAO,CAAC2B,MAAM,CAAC;;cAEtE;;cAEA;cAGMV,MAAM,GAAG,IAAIW,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;gBAC9Cf,IAAI,GAAGc,OAAO;gBACdb,IAAI,GAAGc,MAAM;cACf,CAAC,CAAC,EAEF;cACA;cACMZ,YAAY,GAAGa,UAAU,CAAC;gBAAA,OAAMhB,IAAI,CAAC,CAAC;cAAA,GAAE,IAAI,CAAC,EAEnD;cACAb,GAAG,CAAC8B,IAAI,CAAC,YAAY,EAAE;gBACrBL,MAAM,EAAE3B,OAAO,CAAC2B,MAAM;gBACtBM,YAAY,EAAEzC,iBAAiB,CAAA0C,aAAA;kBAC7BC,GAAG,EAAE1C,gBAAgB,CAACoB,KAAK;gBAAC,GACzBb,OAAO,CACX,CAAC;gBACFoC,OAAO,EAAEpC,OAAO,CAACoC;cACnB,CAAC,CAAC,CACCC,KAAK,CAAC,UAACC,GAAG,EAAK;gBACd;gBACArC,WAAW,CAACsC,WAAW,CAAC1B,KAAK,EAAEC,OAAO,CAAC;gBAEvCE,IAAI,CAACsB,GAAG,CAAC;cACX,CAAC,CAAC,CACDE,IAAI,CAAC,UAACC,QAAQ,EAAK;gBAClBC,YAAY,CAACxB,YAAY,CAAC;gBAE1B,IAAI,CAACuB,QAAQ,EAAE;kBACb;kBACA;gBACF;gBAEAE,YAAY,CAACF,QAAQ,EAAE;kBACrBG,SAAS,EAAE,SAAAA,UAACC,OAAO,EAAK;oBACtB,IAAI,CAAC/B,OAAO,EAAE;sBACZ;oBACF;oBAEA,IAAI,OAAOA,OAAO,KAAK,UAAU,EAAE;sBACjCA,OAAO,CAAC+B,OAAO,CAAC;sBAChB;oBACF;oBAEA,IAAI,OAAO/B,OAAO,CAACgC,WAAW,KAAK,UAAU,EAAE;sBAC7ChC,OAAO,CAACgC,WAAW,CAACD,OAAO,CAAC;oBAC9B;kBACF,CAAC;kBACDE,KAAK,EAAE,SAAAA,MAAA;oBAAA,OAAM9C,WAAW,CAACsC,WAAW,CAAC1B,KAAK,EAAEC,OAAO,CAAC;kBAAA;kBACpDkC,OAAO,EAAEhD,OAAO,CAACgD;gBACnB,CAAC,CAAC;gBAEFjC,IAAI,CAAC,CAAC;cACR,CAAC,CAAC;cAAA,OAAAO,QAAA,CAAA2B,MAAA,WAEGhC,MAAM;YAAA;YAAA;cAAA,OAAAK,QAAA,CAAA4B,IAAA;UAAA;QAAA,GAAAtC,OAAA;MAAA,CACd;MAAA,OAAAN,UAAA,CAAAC,KAAA,OAAAC,SAAA;IAAA;IACD,OAAOL,SAAS;EAClB,CAAC,CAAC,CAACH,OAAO,CAAC;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANA,SAOe2C,YAAYA,CAAAQ,GAAA,EAAAC,GAAA;EAAA,OAAAC,aAAA,CAAA9C,KAAA,OAAAC,SAAA;AAAA;AAyC3B;AACA;AACA;AACA;AAHA,SAAA6C,cAAA;EAAAA,aAAA,GAAA5C,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAzCA,SAAA2C,SAA6Bb,QAAQ,EAAAc,IAAA;IAAA,IAAAX,SAAA,EAAAG,KAAA,EAAAC,OAAA,EAAAQ,yBAAA,EAAAC,iBAAA,EAAAC,cAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAC,GAAA,EAAAC,QAAA,EAAAC,cAAA;IAAA,OAAArD,mBAAA,GAAAU,IAAA,UAAA4C,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAA1C,IAAA,GAAA0C,SAAA,CAAAzC,IAAA;QAAA;UAAIoB,SAAS,GAAAW,IAAA,CAATX,SAAS,EAAEG,KAAK,GAAAQ,IAAA,CAALR,KAAK,EAAEC,OAAO,GAAAO,IAAA,CAAPP,OAAO;UAChEA,OAAO,GAAGA,OAAO,IAAIlD,GAAG;UAAAmE,SAAA,CAAA1C,IAAA;UAAAiC,yBAAA;UAAAC,iBAAA;UAAAQ,SAAA,CAAA1C,IAAA;UAAAoC,SAAA,GAAAO,cAAA,CAGEzB,QAAQ,CAAC0B,MAAM,CAAC,CAAC;QAAA;UAAAF,SAAA,CAAAzC,IAAA;UAAA,OAAAmC,SAAA,CAAAnC,IAAA;QAAA;UAAA,MAAAgC,yBAAA,KAAAI,KAAA,GAAAK,SAAA,CAAAG,IAAA,EAAArD,IAAA;YAAAkD,SAAA,CAAAzC,IAAA;YAAA;UAAA;UAAxBqC,GAAG,GAAAD,KAAA,CAAAS,KAAA;UAAAJ,SAAA,CAAA1C,IAAA;UAAA,IAEXsC,GAAG,CAACS,IAAI;YAAAL,SAAA,CAAAzC,IAAA;YAAA;UAAA;UAAA,OAAAyC,SAAA,CAAAhB,MAAA;QAAA;UAIb,IAAIY,GAAG,CAACS,IAAI,IAAI,IAAI,IAAIT,GAAG,CAACU,KAAK,IAAI,IAAI,EAAE;YACzC3B,SAAS,CAAC;cACR4B,IAAI,EAAE,QAAQ;cACdF,IAAI,EAAEzE,gBAAgB,CAACgE,GAAG,CAACS,IAAI,CAAC;cAChCG,IAAI,EAAE9E,UAAU,CAACkE,GAAG,CAACY,IAAI,CAAC;cAC1BC,cAAc,EAAE9E,WAAW,CAACiE,GAAG,CAACU,KAAK,CAAC;cACtC1D,KAAK,EAAEnB,SAAS,CAACmE,GAAG,CAACc,QAAQ,CAAC,CAAC,CAAC,CAAC;cACjCC,GAAG,EAAEjF,UAAU,EAAAmE,QAAA,GAACD,GAAG,CAACe,GAAG,cAAAd,QAAA,cAAAA,QAAA,GAAI,GAAG,CAAC;cAC/Be,SAAS,EAAElF,UAAU,EAAAoE,cAAA,GAACF,GAAG,CAACgB,SAAS,cAAAd,cAAA,cAAAA,cAAA,GAAI,GAAG;YAC5C,CAAC,CAAC;UACJ,CAAC,MAAM;YACLnB,SAAS,CAAC;cACR4B,IAAI,EAAE,UAAU;cAChBC,IAAI,EAAE9E,UAAU,CAACkE,GAAG,CAACY,IAAI,CAAC;cAC1B5D,KAAK,EAAEnB,SAAS,CAACmE,GAAG,CAACc,QAAQ,CAAC,CAAC,CAAC;YAClC,CAAC,CAAC;UACJ;UAACV,SAAA,CAAAzC,IAAA;UAAA;QAAA;UAAAyC,SAAA,CAAA1C,IAAA;UAAA0C,SAAA,CAAAa,EAAA,GAAAb,SAAA;UAEDA,SAAA,CAAAa,EAAA,CAAIjC,OAAO,sCAAAkC,MAAA,CAAsCd,SAAA,CAAAa,EAAA,CAAIjC,OAAO,CAAE;UAC9DG,OAAO,CAAAiB,SAAA,CAAAa,EAAA,EAAM,KAAK,EAAEjB,GAAG,CAAC,EAAC;QAAA;UAAAL,yBAAA;UAAAS,SAAA,CAAAzC,IAAA;UAAA;QAAA;UAAAyC,SAAA,CAAAzC,IAAA;UAAA;QAAA;UAAAyC,SAAA,CAAA1C,IAAA;UAAA0C,SAAA,CAAAe,EAAA,GAAAf,SAAA;UAAAR,iBAAA;UAAAC,cAAA,GAAAO,SAAA,CAAAe,EAAA;QAAA;UAAAf,SAAA,CAAA1C,IAAA;UAAA0C,SAAA,CAAA1C,IAAA;UAAA,MAAAiC,yBAAA,IAAAG,SAAA,CAAAsB,MAAA;YAAAhB,SAAA,CAAAzC,IAAA;YAAA;UAAA;UAAAyC,SAAA,CAAAzC,IAAA;UAAA,OAAAmC,SAAA,CAAAsB,MAAA;QAAA;UAAAhB,SAAA,CAAA1C,IAAA;UAAA,KAAAkC,iBAAA;YAAAQ,SAAA,CAAAzC,IAAA;YAAA;UAAA;UAAA,MAAAkC,cAAA;QAAA;UAAA,OAAAO,SAAA,CAAAiB,MAAA;QAAA;UAAA,OAAAjB,SAAA,CAAAiB,MAAA;QAAA;UAAAjB,SAAA,CAAAzC,IAAA;UAAA;QAAA;UAAAyC,SAAA,CAAA1C,IAAA;UAAA0C,SAAA,CAAAkB,EAAA,GAAAlB,SAAA;UAI7B,IAAI,CAACmB,YAAY,CAAAnB,SAAA,CAAAkB,EAAI,CAAC,EAAE;YACtBnC,OAAO,CAAAiB,SAAA,CAAAkB,EAAA,EAAM,IAAI,CAAC,EAAC;UACrB;QAAC;UAAAlB,SAAA,CAAA1C,IAAA;UAEDwB,KAAK,CAAC,CAAC;UAAA,OAAAkB,SAAA,CAAAiB,MAAA;QAAA;QAAA;UAAA,OAAAjB,SAAA,CAAAf,IAAA;MAAA;IAAA,GAAAI,QAAA;EAAA,CAEV;EAAA,OAAAD,aAAA,CAAA9C,KAAA,OAAAC,SAAA;AAAA;AAMD,IAAM4E,YAAY,GAAG,SAAfA,YAAYA,CAAGC,KAAK,EAAI;EAC5B,QAAQA,KAAK,CAACb,IAAI;IAChB,KAAK,SAAS;MACZ,OAAO,IAAI;IACb;IACA,KAAK,OAAO;MACV,OAAO,IAAI;IACb;MACE;MACA;MACA,OAAOa,KAAK,CAACC,IAAI,KAAK,YAAY;EACtC;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}