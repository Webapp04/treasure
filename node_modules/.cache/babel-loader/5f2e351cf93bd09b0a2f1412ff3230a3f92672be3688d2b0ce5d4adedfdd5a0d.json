{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport { notFoundError } from 'datastore-core/errors';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport * as ipns from 'ipns';\nvar log = logger('ipfs:ipns:publisher');\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-keys').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nvar ERR_NOT_FOUND = notFoundError().code;\nvar defaultRecordLifetime = 60 * 60 * 1000;\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nexport var IpnsPublisher = /*#__PURE__*/function () {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  function IpnsPublisher(routing, datastore) {\n    _classCallCheck(this, IpnsPublisher);\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  _createClass(IpnsPublisher, [{\n    key: \"publishWithEOL\",\n    value: function () {\n      var _publishWithEOL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, value, lifetime, options) {\n        var record;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this._updateOrCreateRecord(peerId, value, lifetime, options);\n            case 2:\n              record = _context.sent;\n              return _context.abrupt(\"return\", this._putRecordToRouting(record, peerId, options));\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function publishWithEOL(_x, _x2, _x3, _x4) {\n        return _publishWithEOL.apply(this, arguments);\n      }\n      return publishWithEOL;\n    }()\n    /**\n     * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n     *\n     * @param {PeerId} peerId\n     * @param {Uint8Array} value\n     * @param {AbortOptions} options\n     */\n  }, {\n    key: \"publish\",\n    value: function publish(peerId, value, options) {\n      return this.publishWithEOL(peerId, value, defaultRecordLifetime, options);\n    }\n\n    /**\n     * @param {Uint8Array} record\n     * @param {PeerId} peerId\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"_putRecordToRouting\",\n    value: function () {\n      var _putRecordToRouting2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(record, peerId, options) {\n        var errMsg, routingKey;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (isPeerId(peerId)) {\n                _context2.next = 4;\n                break;\n              }\n              errMsg = 'peerId received is not valid';\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n            case 4:\n              if (!(peerId.publicKey == null)) {\n                _context2.next = 6;\n                break;\n              }\n              throw errcode(new Error('Public key was missing'), 'ERR_MISSING_PUBLIC_KEY');\n            case 6:\n              routingKey = ipns.peerIdToRoutingKey(peerId);\n              _context2.next = 9;\n              return this._publishEntry(routingKey, record, options);\n            case 9:\n              return _context2.abrupt(\"return\", record);\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _putRecordToRouting(_x5, _x6, _x7) {\n        return _putRecordToRouting2.apply(this, arguments);\n      }\n      return _putRecordToRouting;\n    }()\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} entry\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"_publishEntry\",\n    value: function () {\n      var _publishEntry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key, entry, options) {\n        var res, errMsg;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return this._routing.put(key, entry, options);\n            case 3:\n              res = _context3.sent;\n              log(\"ipns record for \".concat(uint8ArrayToString(key, 'base32'), \" was stored in the routing\"));\n              return _context3.abrupt(\"return\", res);\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3[\"catch\"](0);\n              errMsg = \"ipns record for \".concat(uint8ArrayToString(key, 'base32'), \" could not be stored in the routing - \").concat(_context3.t0.stack);\n              log.error(errMsg);\n              log.error(_context3.t0);\n              throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n            case 14:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[0, 8]]);\n      }));\n      function _publishEntry(_x8, _x9, _x10) {\n        return _publishEntry2.apply(this, arguments);\n      }\n      return _publishEntry;\n    }()\n    /**\n     * Returns the record this node has published corresponding to the given peer ID.\n     *\n     * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n     *\n     * @param {PeerId} peerId\n     * @param {object} options\n     * @param {boolean} [options.checkRouting]\n     */\n  }, {\n    key: \"_getPublished\",\n    value: function () {\n      var _getPublished2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId) {\n        var options,\n          errMsg,\n          checkRouting,\n          dsVal,\n          _errMsg,\n          routingKey,\n          res,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n              if (isPeerId(peerId)) {\n                _context4.next = 5;\n                break;\n              }\n              errMsg = 'peerId received is not valid';\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n            case 5:\n              checkRouting = options.checkRouting !== false;\n              _context4.prev = 6;\n              _context4.next = 9;\n              return this._datastore.get(ipns.getLocalKey(peerId.toBytes()));\n            case 9:\n              dsVal = _context4.sent;\n              return _context4.abrupt(\"return\", this._unmarshalData(dsVal));\n            case 13:\n              _context4.prev = 13;\n              _context4.t0 = _context4[\"catch\"](6);\n              if (!(_context4.t0.code !== ERR_NOT_FOUND)) {\n                _context4.next = 19;\n                break;\n              }\n              _errMsg = \"unexpected error getting the ipns record \".concat(peerId.toString(), \" from datastore\");\n              log.error(_errMsg);\n              throw errcode(new Error(_errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n            case 19:\n              if (checkRouting) {\n                _context4.next = 21;\n                break;\n              }\n              throw errcode(_context4.t0, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n            case 21:\n              _context4.prev = 21;\n              routingKey = ipns.peerIdToRoutingKey(peerId);\n              _context4.next = 25;\n              return this._routing.get(routingKey);\n            case 25:\n              res = _context4.sent;\n              return _context4.abrupt(\"return\", this._unmarshalData(res));\n            case 29:\n              _context4.prev = 29;\n              _context4.t1 = _context4[\"catch\"](21);\n              log.error(_context4.t1);\n              throw _context4.t1;\n            case 33:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[6, 13], [21, 29]]);\n      }));\n      function _getPublished(_x11) {\n        return _getPublished2.apply(this, arguments);\n      }\n      return _getPublished;\n    }()\n    /**\n     * @param {Uint8Array} data\n     */\n  }, {\n    key: \"_unmarshalData\",\n    value: function _unmarshalData(data) {\n      try {\n        return ipns.unmarshal(data);\n      } catch ( /** @type {any} */err) {\n        throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n      }\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @param {Uint8Array} value\n     * @param {number} lifetime\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"_updateOrCreateRecord\",\n    value: function () {\n      var _updateOrCreateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(peerId, value, lifetime, options) {\n        var errMsg, getPublishedOptions, record, _errMsg2, seqNumber, entryData, _errMsg3, data, _errMsg4;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (isPeerId(peerId)) {\n                _context5.next = 4;\n                break;\n              }\n              errMsg = 'peerId received is not valid';\n              log.error(errMsg);\n              throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n            case 4:\n              getPublishedOptions = {\n                checkRouting: true\n              };\n              /** @type {IPNSEntry | undefined} */\n              _context5.prev = 5;\n              _context5.next = 8;\n              return this._getPublished(peerId, getPublishedOptions);\n            case 8:\n              record = _context5.sent;\n              _context5.next = 17;\n              break;\n            case 11:\n              _context5.prev = 11;\n              _context5.t0 = _context5[\"catch\"](5);\n              if (!(_context5.t0.code !== ERR_NOT_FOUND)) {\n                _context5.next = 17;\n                break;\n              }\n              _errMsg2 = \"unexpected error when determining the last published IPNS record for \".concat(peerId.toString(), \" \").concat(_context5.t0.stack);\n              log.error(_errMsg2);\n              throw errcode(new Error(_errMsg2), 'ERR_DETERMINING_PUBLISHED_RECORD');\n            case 17:\n              // Determinate the record sequence number\n              seqNumber = 0n;\n              if (record && record.sequence !== undefined) {\n                // Increment if the published value is different\n                seqNumber = uint8ArrayEquals(record.value, value) ? record.sequence : record.sequence + BigInt(1);\n              }\n\n              /** @type {IPNSEntry} */\n              _context5.prev = 19;\n              _context5.next = 22;\n              return ipns.create(peerId, value, seqNumber, lifetime);\n            case 22:\n              entryData = _context5.sent;\n              _context5.next = 30;\n              break;\n            case 25:\n              _context5.prev = 25;\n              _context5.t1 = _context5[\"catch\"](19);\n              _errMsg3 = \"ipns record for \".concat(value, \" could not be created\");\n              log.error(_context5.t1);\n              throw errcode(new Error(_errMsg3), 'ERR_CREATING_IPNS_RECORD');\n            case 30:\n              _context5.prev = 30;\n              // Marshal record\n              data = ipns.marshal(entryData); // Store the new record\n              _context5.next = 34;\n              return this._datastore.put(ipns.getLocalKey(peerId.toBytes()), data, options);\n            case 34:\n              log(\"ipns record for \".concat(uint8ArrayToString(value, 'base32'), \" was stored in the datastore\"));\n              return _context5.abrupt(\"return\", data);\n            case 38:\n              _context5.prev = 38;\n              _context5.t2 = _context5[\"catch\"](30);\n              _errMsg4 = \"ipns record for \".concat(value, \" could not be stored in the datastore\");\n              log.error(_errMsg4);\n              throw errcode(new Error(_errMsg4), 'ERR_STORING_IN_DATASTORE');\n            case 43:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[5, 11], [19, 25], [30, 38]]);\n      }));\n      function _updateOrCreateRecord(_x12, _x13, _x14, _x15) {\n        return _updateOrCreateRecord2.apply(this, arguments);\n      }\n      return _updateOrCreateRecord;\n    }()\n  }]);\n  return IpnsPublisher;\n}();\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;","map":{"version":3,"names":["isPeerId","notFoundError","errcode","logger","toString","uint8ArrayToString","equals","uint8ArrayEquals","ipns","log","ERR_NOT_FOUND","code","defaultRecordLifetime","IpnsPublisher","routing","datastore","_classCallCheck","_routing","_datastore","_createClass","key","value","_publishWithEOL","_asyncToGenerator","_regeneratorRuntime","mark","_callee","peerId","lifetime","options","record","wrap","_callee$","_context","prev","next","_updateOrCreateRecord","sent","abrupt","_putRecordToRouting","stop","publishWithEOL","_x","_x2","_x3","_x4","apply","arguments","publish","_putRecordToRouting2","_callee2","errMsg","routingKey","_callee2$","_context2","error","Error","publicKey","peerIdToRoutingKey","_publishEntry","_x5","_x6","_x7","_publishEntry2","_callee3","entry","res","_callee3$","_context3","put","concat","t0","stack","_x8","_x9","_x10","_getPublished2","_callee4","checkRouting","dsVal","_errMsg","_args4","_callee4$","_context4","length","undefined","get","getLocalKey","toBytes","_unmarshalData","t1","_getPublished","_x11","data","unmarshal","err","_updateOrCreateRecord2","_callee5","getPublishedOptions","_errMsg2","seqNumber","entryData","_errMsg3","_errMsg4","_callee5$","_context5","sequence","BigInt","create","marshal","t2","_x12","_x13","_x14","_x15"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/ipns/publisher.js"],"sourcesContent":["import { isPeerId } from '@libp2p/interface-peer-id'\nimport { notFoundError } from 'datastore-core/errors'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport * as ipns from 'ipns'\n\nconst log = logger('ipfs:ipns:publisher')\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-keys').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst ERR_NOT_FOUND = notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nexport class IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publishWithEOL (peerId, value, lifetime, options) {\n    const record = await this._updateOrCreateRecord(peerId, value, lifetime, options)\n\n    return this._putRecordToRouting(record, peerId, options)\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} options\n   */\n  publish (peerId, value, options) {\n    return this.publishWithEOL(peerId, value, defaultRecordLifetime, options)\n  }\n\n  /**\n   * @param {Uint8Array} record\n   * @param {PeerId} peerId\n   * @param {AbortOptions} [options]\n   */\n  async _putRecordToRouting (record, peerId, options) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    if (peerId.publicKey == null) {\n      throw errcode(new Error('Public key was missing'), 'ERR_MISSING_PUBLIC_KEY')\n    }\n\n    const routingKey = ipns.peerIdToRoutingKey(peerId)\n\n    await this._publishEntry(routingKey, record, options)\n\n    return record\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} entry\n   * @param {AbortOptions} [options]\n   */\n  async _publishEntry (key, entry, options) {\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key, entry, options)\n      log(`ipns record for ${uint8ArrayToString(key, 'base32')} was stored in the routing`)\n\n      return res\n    } catch (/** @type {any} */err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key, 'base32')} could not be stored in the routing - ${err.stack}`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished (peerId, options = {}) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED')\n      }\n\n      // Try to get from routing\n      try {\n        const routingKey = ipns.peerIdToRoutingKey(peerId)\n        const res = await this._routing.get(routingKey)\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (/** @type {any} */ err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async _updateOrCreateRecord (peerId, value, lifetime, options) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    /** @type {IPNSEntry | undefined} */\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err.stack}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n\n\n    if (record && record.sequence !== undefined) {\n      // Increment if the published value is different\n      seqNumber = uint8ArrayEquals(record.value, value) ? record.sequence : record.sequence + BigInt(1)\n    }\n\n    /** @type {IPNSEntry} */\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(peerId, value, seqNumber, lifetime)\n    } catch (/** @type {any} */ err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.toBytes()), data, options)\n\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`)\n\n      return data\n    } catch (/** @type {any} */ err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}