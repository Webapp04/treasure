{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nexport var rawPipe = function rawPipe() {\n  var res;\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  while (fns.length > 0) {\n    res = fns.shift()(res);\n  }\n  return res;\n};\nexport var isIterable = function isIterable(obj) {\n  return obj != null && (typeof obj[Symbol.asyncIterator] === 'function' || typeof obj[Symbol.iterator] === 'function' || typeof obj.next === 'function' // Probably, right?\n  );\n};\n\nexport var isDuplex = function isDuplex(obj) {\n  return obj != null && typeof obj.sink === 'function' && isIterable(obj.source);\n};\nvar duplexPipelineFn = function duplexPipelineFn(duplex) {\n  return function (source) {\n    var p = duplex.sink(source);\n    if (p.then != null) {\n      var stream = pushable({\n        objectMode: true\n      });\n      p.then(function () {\n        stream.end();\n      }, function (err) {\n        stream.end(err);\n      });\n      var sourceWrap = /*#__PURE__*/function () {\n        var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(duplex.source), _awaitAsyncGenerator), \"t0\", 1);\n              case 1:\n                stream.end();\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n        return function sourceWrap() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      return merge(stream, sourceWrap());\n    }\n    return duplex.source;\n  };\n};\nexport function pipe(first) {\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    var duplex = first;\n    first = function first() {\n      return duplex.source;\n    };\n    // Iterable at start: wrap in function\n  } else if (isIterable(first)) {\n    var source = first;\n    first = function first() {\n      return source;\n    };\n  }\n  for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    rest[_key2 - 1] = arguments[_key2];\n  }\n  var fns = [first].concat(rest);\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink;\n    }\n  }\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (var i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i]);\n      }\n    }\n  }\n  return rawPipe.apply(void 0, _toConsumableArray(fns));\n}","map":{"version":3,"names":["pushable","merge","rawPipe","res","_len","arguments","length","fns","Array","_key","shift","isIterable","obj","Symbol","asyncIterator","iterator","next","isDuplex","sink","source","duplexPipelineFn","duplex","p","then","stream","objectMode","end","err","sourceWrap","_ref","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","delegateYield","_asyncGeneratorDelegate","_asyncIterator","_awaitAsyncGenerator","stop","apply","pipe","first","_len2","rest","_key2","concat","i","_toConsumableArray"],"sources":["/Users/apple/Documents/treasure/node_modules/it-pipe/src/index.ts"],"sourcesContent":["import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type * as it from 'it-stream-types'\n\nexport const rawPipe = (...fns: any) => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nexport const isIterable = (obj: any): obj is it.Source<any> => {\n  return obj != null && (\n    typeof obj[Symbol.asyncIterator] === 'function' ||\n    typeof obj[Symbol.iterator] === 'function' ||\n    typeof obj.next === 'function' // Probably, right?\n  )\n}\n\nexport const isDuplex = <TSource, TSink = TSource, RSink = Promise<void>> (obj: any): obj is it.Duplex<TSource, TSink, RSink> => {\n  return obj != null && typeof obj.sink === 'function' && isIterable(obj.source)\n}\n\nconst duplexPipelineFn = <TSource> (duplex: it.Duplex<TSource>) => {\n  return (source: any): it.Source<TSource> => {\n    const p = duplex.sink(source)\n\n    if (p.then != null) {\n      const stream = pushable<TSource>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      const sourceWrap = async function * () {\n        yield * duplex.source\n        stream.end()\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n\nexport type Source<A> = it.Source<A> | (() => it.Source<A>) | it.Duplex<A, any, any>\nexport type Transform<A, B> = it.Transform<A, B> | it.Duplex<B, A, any>\nexport type Sink<A, B> = it.Sink<A, B> | it.Duplex<any, A, B>\n\nexport function pipe<A> (\n  first: Source<A>\n): it.Source<A>\n\nexport function pipe<A, B> (\n  first: Source<A>,\n  second: Sink<A, B>\n): B\n\nexport function pipe<A, B, C> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Sink<B, C>\n): C\n\nexport function pipe<A, B, C, D> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Sink<C, D>\n): D\n\nexport function pipe<A, B, C, D, E> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Sink<D, E>\n): E\n\nexport function pipe<A, B, C, D, E, F> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Sink<E, F>\n): F\n\nexport function pipe<A, B, C, D, E, F, G> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Sink<F, G>\n): G\n\nexport function pipe<A, B, C, D, E, F, G, H> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Transform<F, G>,\n  eighth: Sink<G, H>\n): H\n\nexport function pipe<A, B, C, D, E, F, G, H, I> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Transform<F, G>,\n  eighth: Transform<G, H>,\n  ninth: Sink<H, I>\n): I\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Transform<F, G>,\n  eighth: Transform<G, H>,\n  ninth: Transform<H, I>,\n  tenth: Sink<I, J>\n): J\n\nexport function pipe (first: any, ...rest: any[]): any {\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}