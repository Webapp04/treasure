{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nexport var MessageCache = /*#__PURE__*/function () {\n  /**\n   * Holds history of messages in timebounded history arrays\n   */\n  function MessageCache(\n  /**\n   * The number of indices in the cache history used for gossiping. That means that a message\n   * won't get gossiped anymore when shift got called `gossip` many times after inserting the\n   * message in the cache.\n   */\n  gossip, historyCapacity, msgIdToStrFn) {\n    _classCallCheck(this, MessageCache);\n    this.gossip = gossip;\n    this.msgs = new Map();\n    this.history = [];\n    this.msgIdToStrFn = msgIdToStrFn;\n    for (var i = 0; i < historyCapacity; i++) {\n      this.history[i] = [];\n    }\n  }\n  _createClass(MessageCache, [{\n    key: \"size\",\n    get: function get() {\n      return this.msgs.size;\n    }\n    /**\n     * Adds a message to the current window and the cache\n     * Returns true if the message is not known and is inserted in the cache\n     */\n  }, {\n    key: \"put\",\n    value: function put(messageId, msg) {\n      var validated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var msgIdStr = messageId.msgIdStr;\n      // Don't add duplicate entries to the cache.\n      if (this.msgs.has(msgIdStr)) {\n        return false;\n      }\n      this.msgs.set(msgIdStr, {\n        message: msg,\n        validated: validated,\n        originatingPeers: new Set(),\n        iwantCounts: new Map()\n      });\n      this.history[0].push(_objectSpread(_objectSpread({}, messageId), {}, {\n        topic: msg.topic\n      }));\n      return true;\n    }\n  }, {\n    key: \"observeDuplicate\",\n    value: function observeDuplicate(msgId, fromPeerIdStr) {\n      var entry = this.msgs.get(msgId);\n      if (entry &&\n      // if the message is already validated, we don't need to store extra peers sending us\n      // duplicates as the message has already been forwarded\n      !entry.validated) {\n        entry.originatingPeers.add(fromPeerIdStr);\n      }\n    }\n    /**\n     * Retrieves a message from the cache by its ID, if it is still present\n     */\n  }, {\n    key: \"get\",\n    value: function get(msgId) {\n      var _this$msgs$get;\n      return (_this$msgs$get = this.msgs.get(this.msgIdToStrFn(msgId))) === null || _this$msgs$get === void 0 ? void 0 : _this$msgs$get.message;\n    }\n    /**\n     * Increases the iwant count for the given message by one and returns the message together\n     * with the iwant if the message exists.\n     */\n  }, {\n    key: \"getWithIWantCount\",\n    value: function getWithIWantCount(msgIdStr, p) {\n      var _msg$iwantCounts$get;\n      var msg = this.msgs.get(msgIdStr);\n      if (!msg) {\n        return null;\n      }\n      var count = ((_msg$iwantCounts$get = msg.iwantCounts.get(p)) !== null && _msg$iwantCounts$get !== void 0 ? _msg$iwantCounts$get : 0) + 1;\n      msg.iwantCounts.set(p, count);\n      return {\n        msg: msg.message,\n        count: count\n      };\n    }\n    /**\n     * Retrieves a list of message IDs for a set of topics\n     */\n  }, {\n    key: \"getGossipIDs\",\n    value: function getGossipIDs(topics) {\n      var _this = this;\n      var msgIdsByTopic = new Map();\n      for (var i = 0; i < this.gossip; i++) {\n        this.history[i].forEach(function (entry) {\n          var msg = _this.msgs.get(entry.msgIdStr);\n          if (msg && msg.validated && topics.has(entry.topic)) {\n            var msgIds = msgIdsByTopic.get(entry.topic);\n            if (!msgIds) {\n              msgIds = [];\n              msgIdsByTopic.set(entry.topic, msgIds);\n            }\n            msgIds.push(entry.msgId);\n          }\n        });\n      }\n      return msgIdsByTopic;\n    }\n    /**\n     * Gets a message with msgId and tags it as validated.\n     * This function also returns the known peers that have sent us this message. This is used to\n     * prevent us sending redundant messages to peers who have already propagated it.\n     */\n  }, {\n    key: \"validate\",\n    value: function validate(msgId) {\n      var entry = this.msgs.get(msgId);\n      if (!entry) {\n        return null;\n      }\n      var message = entry.message,\n        originatingPeers = entry.originatingPeers;\n      entry.validated = true;\n      // Clear the known peers list (after a message is validated, it is forwarded and we no\n      // longer need to store the originating peers).\n      entry.originatingPeers = new Set();\n      return {\n        message: message,\n        originatingPeers: originatingPeers\n      };\n    }\n    /**\n     * Shifts the current window, discarding messages older than this.history.length of the cache\n     */\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      var _this2 = this;\n      var last = this.history[this.history.length - 1];\n      last.forEach(function (entry) {\n        _this2.msgs.delete(entry.msgIdStr);\n      });\n      this.history.pop();\n      this.history.unshift([]);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(msgId) {\n      var entry = this.msgs.get(msgId);\n      if (!entry) {\n        return null;\n      }\n      // Keep the message on the history vector, it will be dropped on a shift()\n      this.msgs.delete(msgId);\n      return entry;\n    }\n  }]);\n  return MessageCache;\n}();","map":{"version":3,"names":["MessageCache","gossip","historyCapacity","msgIdToStrFn","_classCallCheck","msgs","Map","history","i","_createClass","key","get","size","value","put","messageId","msg","validated","arguments","length","undefined","msgIdStr","has","set","message","originatingPeers","Set","iwantCounts","push","_objectSpread","topic","observeDuplicate","msgId","fromPeerIdStr","entry","add","_this$msgs$get","getWithIWantCount","p","_msg$iwantCounts$get","count","getGossipIDs","topics","_this","msgIdsByTopic","forEach","msgIds","validate","shift","_this2","last","delete","pop","unshift","remove"],"sources":["../../src/message-cache.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}