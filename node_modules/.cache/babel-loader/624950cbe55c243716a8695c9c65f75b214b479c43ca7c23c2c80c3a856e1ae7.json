{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// @ts-expect-error Explicitly disable long.js support\n$protobuf.util.Long = undefined;\n$protobuf.configure();\nimport { Key } from 'interface-datastore/key';\nimport { Protocols } from './pb/proto-book.js';\nimport { Addresses } from './pb/address-book.js';\nimport { Peer } from './pb/peer.js';\nimport { Envelope } from './pb/envelope.js';\nimport { PeerRecord } from './pb/peer-record.js';\nimport { multiaddr } from '@multiformats/multiaddr';\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {import('../../src/types').MigrationProgressCallback} onProgress\n */\nfunction storePeerUnderSingleDatastoreKey(_x) {\n  return _storePeerUnderSingleDatastoreKey.apply(this, arguments);\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {import('../../src/types').MigrationProgressCallback} onProgress\n */\nfunction _storePeerUnderSingleDatastoreKey() {\n  _storePeerUnderSingleDatastoreKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backends) {\n    var onProgress,\n      peers,\n      keys,\n      _iteratorAbruptCompletion,\n      _didIteratorError,\n      _iteratorError,\n      _iterator,\n      _step,\n      _step$value,\n      key,\n      value,\n      keyStr,\n      _keyStr$split,\n      _keyStr$split2,\n      _,\n      prefix,\n      type,\n      peerId,\n      metadataKey,\n      protos,\n      addrs,\n      _i,\n      _keys,\n      _key,\n      _i2,\n      _Object$keys,\n      _peerId,\n      peer,\n      data,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          onProgress = _args.length > 1 && _args[1] !== undefined ? _args[1] : function () {};\n          onProgress(0, 'Storing each peerstore key under a single datastore key');\n          _context.next = 4;\n          return backends.datastore.open();\n        case 4:\n          /** @type {Record<string, any>} */\n          peers = {};\n          /** @type {Key[]} */\n          keys = [];\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 8;\n          _iterator = _asyncIterator(backends.datastore.query({\n            prefix: '/peers'\n          }));\n        case 10:\n          _context.next = 12;\n          return _iterator.next();\n        case 12:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 28;\n            break;\n          }\n          _step$value = _step.value, key = _step$value.key, value = _step$value.value;\n          keys.push(key);\n          keyStr = key.toString();\n          _keyStr$split = keyStr.split('/'), _keyStr$split2 = _slicedToArray(_keyStr$split, 5), _ = _keyStr$split2[0], prefix = _keyStr$split2[1], type = _keyStr$split2[2], peerId = _keyStr$split2[3], metadataKey = _keyStr$split2[4];\n          if (!(prefix !== 'peers')) {\n            _context.next = 19;\n            break;\n          }\n          return _context.abrupt(\"continue\", 25);\n        case 19:\n          if (['protos', 'addrs', 'metadata', 'keys'].includes(type)) {\n            _context.next = 21;\n            break;\n          }\n          return _context.abrupt(\"continue\", 25);\n        case 21:\n          if (peerId) {\n            _context.next = 23;\n            break;\n          }\n          return _context.abrupt(\"continue\", 25);\n        case 23:\n          peers[peerId] = peers[peerId] || {\n            addresses: [],\n            protocols: [],\n            metadata: []\n          };\n          if (type === 'protos') {\n            protos = Protocols.decode(value);\n            peers[peerId].protocols = protos.protocols.sort();\n          } else if (type === 'addrs') {\n            addrs = Addresses.decode(value);\n            peers[peerId].addresses = addrs.addrs.sort(function (a, b) {\n              return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString());\n            });\n            if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n              peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;\n            }\n          } else if (type === 'metadata') {\n            peers[peerId].metadata.push({\n              key: metadataKey,\n              value: value\n            });\n          } else if (type === 'keys') {\n            peers[peerId].pubKey = value;\n          }\n        case 25:\n          _iteratorAbruptCompletion = false;\n          _context.next = 10;\n          break;\n        case 28:\n          _context.next = 34;\n          break;\n        case 30:\n          _context.prev = 30;\n          _context.t0 = _context[\"catch\"](8);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n        case 34:\n          _context.prev = 34;\n          _context.prev = 35;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context.next = 39;\n            break;\n          }\n          _context.next = 39;\n          return _iterator.return();\n        case 39:\n          _context.prev = 39;\n          if (!_didIteratorError) {\n            _context.next = 42;\n            break;\n          }\n          throw _iteratorError;\n        case 42:\n          return _context.finish(39);\n        case 43:\n          return _context.finish(34);\n        case 44:\n          onProgress(33, 'Read peer data from store');\n          _i = 0, _keys = keys;\n        case 46:\n          if (!(_i < _keys.length)) {\n            _context.next = 53;\n            break;\n          }\n          _key = _keys[_i];\n          _context.next = 50;\n          return backends.datastore.delete(_key);\n        case 50:\n          _i++;\n          _context.next = 46;\n          break;\n        case 53:\n          onProgress(66, 'Removed existing peer data from store');\n          _i2 = 0, _Object$keys = Object.keys(peers);\n        case 55:\n          if (!(_i2 < _Object$keys.length)) {\n            _context.next = 65;\n            break;\n          }\n          _peerId = _Object$keys[_i2];\n          peer = peers[_peerId];\n          peer.metadata = peer.metadata.sort(function ( /** @type {{ key: string }} */a, /** @type {{ key: string }} */b) {\n            return a.key.localeCompare(b.key);\n          });\n          data = Peer.encode(peer).finish();\n          _context.next = 62;\n          return backends.datastore.put(new Key(\"/peers/\".concat(_peerId)), data);\n        case 62:\n          _i2++;\n          _context.next = 55;\n          break;\n        case 65:\n          _context.next = 67;\n          return backends.datastore.close();\n        case 67:\n          onProgress(100, 'Stored each peerstore key under a single datastore key');\n        case 68:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[8, 30, 34, 44], [35,, 39, 43]]);\n  }));\n  return _storePeerUnderSingleDatastoreKey.apply(this, arguments);\n}\nfunction storePeerUnderMultipleDatastoreKeys(_x2) {\n  return _storePeerUnderMultipleDatastoreKeys.apply(this, arguments);\n}\n/** @type {import('../../src/types').Migration} */\nfunction _storePeerUnderMultipleDatastoreKeys() {\n  _storePeerUnderMultipleDatastoreKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(backends) {\n    var onProgress,\n      peers,\n      keys,\n      _iteratorAbruptCompletion2,\n      _didIteratorError2,\n      _iteratorError2,\n      _iterator2,\n      _step2,\n      _step2$value,\n      key,\n      value,\n      keyStr,\n      _keyStr$split3,\n      _keyStr$split4,\n      _,\n      _prefix,\n      peerId,\n      _i3,\n      _keys2,\n      _key2,\n      _i4,\n      _Object$entries,\n      _Object$entries$_i,\n      _peerId2,\n      peer,\n      peerRecordEnvelope,\n      certifiedRecord,\n      envelope,\n      record,\n      _iterator3,\n      _step3,\n      _step3$value,\n      _key3,\n      _value,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          onProgress = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : function () {};\n          onProgress(0, 'Storing each peerstore key under a multiple datastore keys');\n          _context2.next = 4;\n          return backends.datastore.open();\n        case 4:\n          /** @type {Record<string, any>} */\n          peers = {};\n          /** @type {Key[]} */\n          keys = [];\n          _iteratorAbruptCompletion2 = false;\n          _didIteratorError2 = false;\n          _context2.prev = 8;\n          _iterator2 = _asyncIterator(backends.datastore.query({\n            prefix: '/peers'\n          }));\n        case 10:\n          _context2.next = 12;\n          return _iterator2.next();\n        case 12:\n          if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {\n            _context2.next = 21;\n            break;\n          }\n          _step2$value = _step2.value, key = _step2$value.key, value = _step2$value.value;\n          keys.push(key);\n          keyStr = key.toString();\n          _keyStr$split3 = keyStr.split('/'), _keyStr$split4 = _slicedToArray(_keyStr$split3, 3), _ = _keyStr$split4[0], _prefix = _keyStr$split4[1], peerId = _keyStr$split4[2];\n          peers[peerId] = Peer.decode(value);\n        case 18:\n          _iteratorAbruptCompletion2 = false;\n          _context2.next = 10;\n          break;\n        case 21:\n          _context2.next = 27;\n          break;\n        case 23:\n          _context2.prev = 23;\n          _context2.t0 = _context2[\"catch\"](8);\n          _didIteratorError2 = true;\n          _iteratorError2 = _context2.t0;\n        case 27:\n          _context2.prev = 27;\n          _context2.prev = 28;\n          if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n            _context2.next = 32;\n            break;\n          }\n          _context2.next = 32;\n          return _iterator2.return();\n        case 32:\n          _context2.prev = 32;\n          if (!_didIteratorError2) {\n            _context2.next = 35;\n            break;\n          }\n          throw _iteratorError2;\n        case 35:\n          return _context2.finish(32);\n        case 36:\n          return _context2.finish(27);\n        case 37:\n          onProgress(33, 'Read peer data from store');\n          _i3 = 0, _keys2 = keys;\n        case 39:\n          if (!(_i3 < _keys2.length)) {\n            _context2.next = 46;\n            break;\n          }\n          _key2 = _keys2[_i3];\n          _context2.next = 43;\n          return backends.datastore.delete(_key2);\n        case 43:\n          _i3++;\n          _context2.next = 39;\n          break;\n        case 46:\n          onProgress(66, 'Removed existing peer data from store');\n          _i4 = 0, _Object$entries = Object.entries(peers);\n        case 48:\n          if (!(_i4 < _Object$entries.length)) {\n            _context2.next = 83;\n            break;\n          }\n          _Object$entries$_i = _slicedToArray(_Object$entries[_i4], 2), _peerId2 = _Object$entries$_i[0], peer = _Object$entries$_i[1];\n          if (!(peer.protocols && peer.protocols.length > 0)) {\n            _context2.next = 53;\n            break;\n          }\n          _context2.next = 53;\n          return backends.datastore.put(new Key(\"/peers/protos/\".concat(_peerId2)), Protocols.encode({\n            protocols: peer.protocols\n          }).finish());\n        case 53:\n          if (!(peer.addresses && peer.addresses.length > 0)) {\n            _context2.next = 59;\n            break;\n          }\n          peerRecordEnvelope = peer.peerRecordEnvelope;\n          certifiedRecord = void 0;\n          if (peerRecordEnvelope) {\n            envelope = Envelope.decode(peerRecordEnvelope);\n            record = PeerRecord.decode(envelope.payload);\n            certifiedRecord = {\n              raw: peerRecordEnvelope,\n              seq: record.seq\n            };\n          }\n          _context2.next = 59;\n          return backends.datastore.put(new Key(\"/peers/addrs/\".concat(_peerId2)), Addresses.encode({\n            addrs: peer.addresses,\n            certifiedRecord: certifiedRecord\n          }).finish());\n        case 59:\n          if (!(peer.metadata && peer.metadata.length > 0)) {\n            _context2.next = 77;\n            break;\n          }\n          _iterator3 = _createForOfIteratorHelper(peer.metadata);\n          _context2.prev = 61;\n          _iterator3.s();\n        case 63:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 69;\n            break;\n          }\n          _step3$value = _step3.value, _key3 = _step3$value.key, _value = _step3$value.value;\n          _context2.next = 67;\n          return backends.datastore.put(new Key(\"/peers/metadata/\".concat(_peerId2, \"/\").concat(_key3)), _value);\n        case 67:\n          _context2.next = 63;\n          break;\n        case 69:\n          _context2.next = 74;\n          break;\n        case 71:\n          _context2.prev = 71;\n          _context2.t1 = _context2[\"catch\"](61);\n          _iterator3.e(_context2.t1);\n        case 74:\n          _context2.prev = 74;\n          _iterator3.f();\n          return _context2.finish(74);\n        case 77:\n          if (!peer.pubKey) {\n            _context2.next = 80;\n            break;\n          }\n          _context2.next = 80;\n          return backends.datastore.put(new Key(\"/peers/keys/\".concat(_peerId2)), peer.pubKey);\n        case 80:\n          _i4++;\n          _context2.next = 48;\n          break;\n        case 83:\n          _context2.next = 85;\n          return backends.datastore.close();\n        case 85:\n          onProgress(100, 'Stored each peerstore key under multiple datastore keys');\n        case 86:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[8, 23, 27, 37], [28,, 32, 36], [61, 71, 74, 77]]);\n  }));\n  return _storePeerUnderMultipleDatastoreKeys.apply(this, arguments);\n}\nexport var migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n};","map":{"version":3,"names":["$protobuf","util","Long","undefined","configure","Key","Protocols","Addresses","Peer","Envelope","PeerRecord","multiaddr","storePeerUnderSingleDatastoreKey","_x","_storePeerUnderSingleDatastoreKey","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","backends","onProgress","peers","keys","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","_step$value","key","value","keyStr","_keyStr$split","_keyStr$split2","_","prefix","type","peerId","metadataKey","protos","addrs","_i","_keys","_key","_i2","_Object$keys","_peerId","peer","data","_args","wrap","_callee$","_context","prev","next","length","datastore","open","_asyncIterator","query","sent","done","push","toString","split","_slicedToArray","abrupt","includes","addresses","protocols","metadata","decode","sort","a","b","localeCompare","certifiedRecord","raw","peerRecordEnvelope","pubKey","t0","return","finish","delete","Object","encode","put","concat","close","stop","storePeerUnderMultipleDatastoreKeys","_x2","_storePeerUnderMultipleDatastoreKeys","_callee2","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_step2$value","_keyStr$split3","_keyStr$split4","_prefix","_i3","_keys2","_key2","_i4","_Object$entries","_Object$entries$_i","_peerId2","envelope","record","_iterator3","_step3","_step3$value","_key3","_value","_args2","_callee2$","_context2","entries","payload","seq","_createForOfIteratorHelper","s","n","t1","e","f","migration","version","description","migrate","revert"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-repo-migrations/migrations/migration-12/index.js"],"sourcesContent":["import $protobuf from \"protobufjs/minimal.js\"\n\n// @ts-expect-error Explicitly disable long.js support\n$protobuf.util.Long = undefined\n$protobuf.configure()\n\nimport { Key } from 'interface-datastore/key'\nimport { Protocols } from './pb/proto-book.js'\nimport { Addresses } from './pb/address-book.js'\nimport { Peer } from './pb/peer.js'\nimport { Envelope } from './pb/envelope.js'\nimport { PeerRecord } from './pb/peer-record.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {import('../../src/types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderSingleDatastoreKey (backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a single datastore key')\n\n  await backends.datastore.open()\n\n  /** @type {Record<string, any>} */\n  const peers = {}\n  /** @type {Key[]} */\n  const keys = []\n\n  for await (const { key, value } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key)\n    const keyStr = key.toString()\n    const [_, prefix, type, peerId, metadataKey] = keyStr.split('/')\n\n    if (prefix !== 'peers') {\n      continue\n    }\n\n    if (!['protos', 'addrs', 'metadata', 'keys'].includes(type)) {\n      continue\n    }\n\n    if (!peerId) {\n      continue\n    }\n\n    peers[peerId] = peers[peerId] || {\n      addresses: [],\n      protocols: [],\n      metadata: []\n    }\n\n    if (type === 'protos') {\n      const protos = Protocols.decode(value)\n\n      peers[peerId].protocols = protos.protocols.sort()\n    } else if (type === 'addrs') {\n      const addrs = Addresses.decode(value)\n\n      peers[peerId].addresses = addrs.addrs.sort((a, b) => {\n        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString())\n      })\n\n      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw\n      }\n    } else if (type === 'metadata') {\n      peers[peerId].metadata.push({ key: metadataKey, value })\n    } else if (type === 'keys') {\n      peers[peerId].pubKey = value\n    }\n  }\n\n  onProgress(33, 'Read peer data from store')\n\n  for (const key of keys) {\n    await backends.datastore.delete(key)\n  }\n\n  onProgress(66, 'Removed existing peer data from store')\n\n  for (const peerId of Object.keys(peers)) {\n    const peer = peers[peerId]\n    peer.metadata = peer.metadata.sort((/** @type {{ key: string }} */ a, /** @type {{ key: string }} */ b) => a.key.localeCompare(b.key))\n\n    const data = Peer.encode(peer).finish()\n\n    await backends.datastore.put(new Key(`/peers/${peerId}`), data)\n  }\n\n  await backends.datastore.close()\n\n  onProgress(100, 'Stored each peerstore key under a single datastore key')\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {import('../../src/types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderMultipleDatastoreKeys (backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a multiple datastore keys')\n\n  await backends.datastore.open()\n\n  /** @type {Record<string, any>} */\n  const peers = {}\n  /** @type {Key[]} */\n  const keys = []\n\n  for await (const { key, value } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key)\n    const keyStr = key.toString()\n\n    const [_, _prefix, peerId] = keyStr.split('/')\n\n    peers[peerId] = Peer.decode(value)\n  }\n\n  onProgress(33, 'Read peer data from store')\n\n  for (const key of keys) {\n    await backends.datastore.delete(key)\n  }\n\n  onProgress(66, 'Removed existing peer data from store')\n\n  for (const [peerId, peer] of Object.entries(peers)) {\n    if (peer.protocols && peer.protocols.length > 0) {\n      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({\n        protocols: peer.protocols\n      }).finish())\n    }\n\n    if (peer.addresses && peer.addresses.length > 0) {\n      const peerRecordEnvelope = peer.peerRecordEnvelope\n      let certifiedRecord\n\n      if (peerRecordEnvelope) {\n        const envelope = Envelope.decode(peerRecordEnvelope)\n        const record = PeerRecord.decode(envelope.payload)\n\n        certifiedRecord = {\n          raw: peerRecordEnvelope,\n          seq: record.seq\n        }\n      }\n\n      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({\n        addrs: peer.addresses,\n        certifiedRecord\n      }).finish())\n    }\n\n    if (peer.metadata && peer.metadata.length > 0) {\n      for (const { key, value } of peer.metadata) {\n        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value)\n      }\n    }\n\n    if (peer.pubKey) {\n      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey)\n    }\n  }\n\n  await backends.datastore.close()\n\n  onProgress(100, 'Stored each peerstore key under multiple datastore keys')\n}\n\n/** @type {import('../../src/types').Migration} */\nexport const migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}