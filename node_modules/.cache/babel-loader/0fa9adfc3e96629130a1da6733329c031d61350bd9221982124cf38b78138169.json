{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { NotStartedError, AlreadyStartingError, AlreadyStartedError } from '../errors.js';\nimport { withTimeout } from '../utils.js';\n\n/**\n * @template T\n * @typedef {import('ipfs-core-types/src/utils').Await<T>} Await\n */\n/**\n * @template {(options:any) => any} T\n * @typedef {Parameters<T>[0]} Options\n */\n/**\n * @template {(options:any) => any} T\n * @typedef {ReturnType<T> extends ? Promise<infer U> ? U : ReturnType<T>} State\n */\n/**\n * Represents service state which can be not started in which case\n * it is instance of `Error`. Pending in which case it's promise or\n * ready in which case it is the value itself.\n *\n * @template T\n * @typedef {{ status: 'stopped' }\n * | { status: 'starting', ready: Await<T> }\n * | { status: 'started', value: T }\n * | { status: 'stopping', ready: Await<void> }\n * } ServiceState\n */\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template Options, T\n *\n * Allows you to create a handle to service that can be started or\n * stopped. It enables defining components that need to use service\n * functionality before service is started.\n *\n */\nexport var Service = /*#__PURE__*/function () {\n  /**\n   * Takes `activation` function that takes `options` and (async) returns\n   * an implementation.\n   *\n   * @private\n   * @param {(options:Options) => Await<T>} activate\n   * @param {(state:T) => Await<void>} [deactivate]\n   */\n  function Service(activate, deactivate) {\n    _classCallCheck(this, Service);\n    this.activate = activate;\n    this.deactivate = deactivate;\n\n    /**\n     * A state machine for this service.\n     *\n     * @private\n     * @type {ServiceState<T>}\n     */\n    this.state = {\n      status: 'stopped'\n    };\n  }\n\n  /**\n   * Allows you to asynchronously obtain service implementation. If service\n   * is starting it will await for completion. If service is stopped or stopping\n   * this will (async) throw exception. This allows components that need to use\n   * this service convenient API to do it.\n   *\n   * @param {AbortOptions} [options] - Abort options.\n   * @returns {Promise<T>}\n   */\n  _createClass(Service, [{\n    key: \"use\",\n    value: function () {\n      var _use = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Service.use(this, options);\n            case 2:\n              return _context.abrupt(\"return\", _context.sent);\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function use(_x) {\n        return _use.apply(this, arguments);\n      }\n      return use;\n    }()\n    /**\n     * @returns {T|null}\n     */\n  }, {\n    key: \"try\",\n    value: function _try() {\n      return Service.try(this);\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * Takes `activation` function that takes `options` and (async) returns\n     * an implementation.\n     *\n     * @template {(options:any) => Await<any>} T\n     *\n     * @param {object} config\n     * @param {T} config.start\n     * @param {(state:State<T>) => Await<void>} [config.stop]\n     * @returns {Service<Parameters<T>[0], State<T>>}\n     */\n    function create(_ref) {\n      var start = _ref.start,\n        stop = _ref.stop;\n      return new Service(start, stop);\n    }\n\n    /**\n     * Starts the service (by running actiavtion function). Will (async) throw\n     * unless service is stopped.\n     *\n     * @template Options, T\n     * @param {Service<Options, T>} service\n     * @param {Options} options\n     * @returns {Promise<T>}\n     */\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(service, options) {\n        var state, activate, promise, result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              state = service.state, activate = service.activate;\n              _context2.t0 = state.status;\n              _context2.next = _context2.t0 === 'stopped' ? 4 : _context2.t0 === 'starting' ? 18 : _context2.t0 === 'started' ? 19 : _context2.t0 === 'stopping' ? 20 : 25;\n              break;\n            case 4:\n              _context2.prev = 4;\n              promise = activate(options);\n              service.state = {\n                status: 'starting',\n                ready: promise\n              };\n              // Note: MUST await after state transition above otherwise race\n              // condition may occur.\n              _context2.next = 9;\n              return promise;\n            case 9:\n              result = _context2.sent;\n              service.state = {\n                status: 'started',\n                value: result\n              };\n              return _context2.abrupt(\"return\", result);\n            case 14:\n              _context2.prev = 14;\n              _context2.t1 = _context2[\"catch\"](4);\n              service.state = {\n                status: 'stopped'\n              };\n              throw _context2.t1;\n            case 18:\n              throw new AlreadyStartingError();\n            case 19:\n              throw new AlreadyStartedError();\n            case 20:\n              _context2.next = 22;\n              return state.ready;\n            case 22:\n              _context2.next = 24;\n              return Service.start(service, options);\n            case 24:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 25:\n              return _context2.abrupt(\"return\", Service.panic(service));\n            case 26:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[4, 14]]);\n      }));\n      function start(_x2, _x3) {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n    /**\n     * Stops the service by executing deactivation. If service is stopped\n     * or is stopping this is noop. If service is starting up when called\n     * it will await for start to complete and then retry stop afterwards.\n     * This may (async) throw if `deactivate` does.\n     *\n     * @template T\n     * @param {Service<any, T>} service\n     * @returns {Promise<void>}\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(service) {\n        var state, deactivate;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              state = service.state, deactivate = service.deactivate;\n              _context3.t0 = state.status;\n              _context3.next = _context3.t0 === 'stopped' ? 4 : _context3.t0 === 'starting' ? 5 : _context3.t0 === 'stopping' ? 15 : _context3.t0 === 'started' ? 18 : 23;\n              break;\n            case 4:\n              return _context3.abrupt(\"break\", 24);\n            case 5:\n              _context3.prev = 5;\n              _context3.next = 8;\n              return state.ready;\n            case 8:\n              _context3.next = 12;\n              break;\n            case 10:\n              _context3.prev = 10;\n              _context3.t1 = _context3[\"catch\"](5);\n            case 12:\n              _context3.next = 14;\n              return Service.stop(service);\n            case 14:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 15:\n              _context3.next = 17;\n              return state.ready;\n            case 17:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 18:\n              if (!deactivate) {\n                _context3.next = 21;\n                break;\n              }\n              _context3.next = 21;\n              return deactivate(state.value);\n            case 21:\n              service.state = {\n                status: 'stopped'\n              };\n              return _context3.abrupt(\"break\", 24);\n            case 23:\n              Service.panic(state);\n            case 24:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[5, 10]]);\n      }));\n      function stop(_x4) {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * @template T\n     * @param {Service<any, T>} service\n     * @returns {T|null}\n     */\n  }, {\n    key: \"try\",\n    value: function _try(_ref2) {\n      var state = _ref2.state;\n      switch (state.status) {\n        case 'started':\n          return state.value;\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * Unwraps state and returns underlying value. If state is in idle state it\n     * will throw an error. If state is pending it will wait and return the\n     * result or throw on failure. If state is ready returns result.\n     *\n     * @template T\n     * @param {Service<any, T>} service\n     * @param {AbortOptions} [options]\n     * @returns {Promise<T>}\n     */\n  }, {\n    key: \"use\",\n    value: function () {\n      var _use2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref3, options) {\n        var state;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              state = _ref3.state;\n              _context4.t0 = state.status;\n              _context4.next = _context4.t0 === 'started' ? 4 : _context4.t0 === 'starting' ? 5 : 8;\n              break;\n            case 4:\n              return _context4.abrupt(\"return\", state.value);\n            case 5:\n              _context4.next = 7;\n              return withTimeout(state.ready, options);\n            case 7:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 8:\n              throw new NotStartedError();\n            case 9:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function use(_x5, _x6) {\n        return _use2.apply(this, arguments);\n      }\n      return use;\n    }() // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * @private\n     * @param {Service<any, any>} service\n     * @returns {never}\n     */\n  }, {\n    key: \"panic\",\n    value: function panic(_ref4) {\n      var state = _ref4.state;\n      var status = JSON.stringify({\n        status: state.status\n      });\n      throw RangeError(\"Service in invalid state \".concat(status, \", should never happen if you see this please report a bug\"));\n    }\n  }]);\n  return Service;\n}();","map":{"version":3,"names":["NotStartedError","AlreadyStartingError","AlreadyStartedError","withTimeout","Service","activate","deactivate","_classCallCheck","state","status","_createClass","key","value","_use","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","wrap","_callee$","_context","prev","next","use","abrupt","sent","stop","_x","apply","arguments","_try","try","create","_ref","start","_start","_callee2","service","promise","result","_callee2$","_context2","t0","ready","t1","panic","_x2","_x3","_stop","_callee3","_callee3$","_context3","_x4","_ref2","_use2","_callee4","_ref3","_callee4$","_context4","_x5","_x6","_ref4","JSON","stringify","RangeError","concat"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/utils/service.js"],"sourcesContent":["import { NotStartedError, AlreadyStartingError, AlreadyStartedError } from '../errors.js'\nimport { withTimeout } from '../utils.js'\n\n/**\n * @template T\n * @typedef {import('ipfs-core-types/src/utils').Await<T>} Await\n */\n/**\n * @template {(options:any) => any} T\n * @typedef {Parameters<T>[0]} Options\n */\n/**\n * @template {(options:any) => any} T\n * @typedef {ReturnType<T> extends ? Promise<infer U> ? U : ReturnType<T>} State\n */\n/**\n * Represents service state which can be not started in which case\n * it is instance of `Error`. Pending in which case it's promise or\n * ready in which case it is the value itself.\n *\n * @template T\n * @typedef {{ status: 'stopped' }\n * | { status: 'starting', ready: Await<T> }\n * | { status: 'started', value: T }\n * | { status: 'stopping', ready: Await<void> }\n * } ServiceState\n */\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template Options, T\n *\n * Allows you to create a handle to service that can be started or\n * stopped. It enables defining components that need to use service\n * functionality before service is started.\n *\n */\nexport class Service {\n  /**\n   * Takes `activation` function that takes `options` and (async) returns\n   * an implementation.\n   *\n   * @template {(options:any) => Await<any>} T\n   *\n   * @param {object} config\n   * @param {T} config.start\n   * @param {(state:State<T>) => Await<void>} [config.stop]\n   * @returns {Service<Parameters<T>[0], State<T>>}\n   */\n  static create ({ start, stop }) {\n    return new Service(start, stop)\n  }\n\n  /**\n   * Starts the service (by running actiavtion function). Will (async) throw\n   * unless service is stopped.\n   *\n   * @template Options, T\n   * @param {Service<Options, T>} service\n   * @param {Options} options\n   * @returns {Promise<T>}\n   */\n  static async start (service, options) {\n    const { state, activate } = service\n    switch (state.status) {\n      // If service is in 'stopped' state we activate and transition to\n      // to 'pending' state. Once activation is complete transition state to\n      // 'started' state.\n      // Note: This is the only code that does state transitions from\n      // - stopped\n      // - started\n      // Which ensures no race conditions can occur.\n      case 'stopped': {\n        try {\n          const promise = activate(options)\n          service.state = { status: 'starting', ready: promise }\n          // Note: MUST await after state transition above otherwise race\n          // condition may occur.\n          const result = await promise\n          service.state = { status: 'started', value: result }\n          return result\n        // If failed to start, transiton from 'starting' to 'stopped'\n        // state.\n        } catch (/** @type {any} */ error) {\n          service.state = { status: 'stopped' }\n          throw error\n        }\n      }\n      case 'starting': {\n        throw new AlreadyStartingError()\n      }\n      case 'started': {\n        throw new AlreadyStartedError()\n      }\n      // If service is stopping we just wait for that to complete\n      // and try again.\n      case 'stopping': {\n        await state.ready\n        return await Service.start(service, options)\n      }\n      default: {\n        return Service.panic(service)\n      }\n    }\n  }\n\n  /**\n   * Stops the service by executing deactivation. If service is stopped\n   * or is stopping this is noop. If service is starting up when called\n   * it will await for start to complete and then retry stop afterwards.\n   * This may (async) throw if `deactivate` does.\n   *\n   * @template T\n   * @param {Service<any, T>} service\n   * @returns {Promise<void>}\n   */\n  static async stop (service) {\n    const { state, deactivate } = service\n    switch (state.status) {\n      // If stopped there's nothing to do.\n      case 'stopped': {\n        break\n      }\n      // If service is starting we await for it to complete\n      // and try again. That way\n      case 'starting': {\n        // We do not want to error stop if start failed.\n        try { await state.ready } catch (/** @type {any} */ _) {}\n        return await Service.stop(service)\n      }\n      // if service is stopping we just await for it to complete.\n      case 'stopping': {\n        return await state.ready\n      }\n      case 'started': {\n        if (deactivate) {\n          await deactivate(state.value)\n        }\n        service.state = { status: 'stopped' }\n        break\n      }\n      default: {\n        Service.panic(state)\n      }\n    }\n  }\n\n  /**\n   * @template T\n   * @param {Service<any, T>} service\n   * @returns {T|null}\n   */\n  static try ({ state }) {\n    switch (state.status) {\n      case 'started':\n        return state.value\n      default:\n        return null\n    }\n  }\n\n  /**\n   * Unwraps state and returns underlying value. If state is in idle state it\n   * will throw an error. If state is pending it will wait and return the\n   * result or throw on failure. If state is ready returns result.\n   *\n   * @template T\n   * @param {Service<any, T>} service\n   * @param {AbortOptions} [options]\n   * @returns {Promise<T>}\n   */\n  static async use ({ state }, options) {\n    switch (state.status) {\n      case 'started':\n        return state.value\n      case 'starting':\n        return await withTimeout(state.ready, options)\n      default:\n        throw new NotStartedError()\n    }\n  }\n\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * @private\n   * @param {Service<any, any>} service\n   * @returns {never}\n   */\n  static panic ({ state }) {\n    const status = JSON.stringify({ status: state.status })\n    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`)\n  }\n\n  /**\n   * Takes `activation` function that takes `options` and (async) returns\n   * an implementation.\n   *\n   * @private\n   * @param {(options:Options) => Await<T>} activate\n   * @param {(state:T) => Await<void>} [deactivate]\n   */\n  constructor (activate, deactivate) {\n    this.activate = activate\n    this.deactivate = deactivate\n\n    /**\n     * A state machine for this service.\n     *\n     * @private\n     * @type {ServiceState<T>}\n     */\n    this.state = { status: 'stopped' }\n  }\n\n  /**\n   * Allows you to asynchronously obtain service implementation. If service\n   * is starting it will await for completion. If service is stopped or stopping\n   * this will (async) throw exception. This allows components that need to use\n   * this service convenient API to do it.\n   *\n   * @param {AbortOptions} [options] - Abort options.\n   * @returns {Promise<T>}\n   */\n  async use (options) {\n    return await Service.use(this, options)\n  }\n\n  /**\n   * @returns {T|null}\n   */\n  try () {\n    return Service.try(this)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}