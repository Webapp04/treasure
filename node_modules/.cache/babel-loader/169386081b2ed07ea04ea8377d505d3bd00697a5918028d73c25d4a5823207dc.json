{"ast":null,"code":"import _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\";\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport var format = function format(link, base) {\n  var bytes = link.bytes,\n    version = link.version;\n  switch (version) {\n    case 0:\n      return toStringV0(bytes, baseCache(link), /** @type {API.MultibaseEncoder<\"z\">} */base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, baseCache(link), /** @type {API.MultibaseEncoder<Prefix>} */base || base32.encoder);\n  }\n};\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport var toJSON = function toJSON(link) {\n  return {\n    '/': format(link)\n  };\n};\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport var fromJSON = function fromJSON(json) {\n  return CID.parse(json['/']);\n};\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nvar cache = new WeakMap();\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nvar baseCache = function baseCache(cid) {\n  var baseCache = cache.get(cid);\n  if (baseCache == null) {\n    var _baseCache = new Map();\n    cache.set(cid, _baseCache);\n    return _baseCache;\n  }\n  return baseCache;\n};\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport var CID = /*#__PURE__*/function (_Symbol$toStringTag, _Symbol$for) {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  function CID(version, code, multihash, bytes) {\n    _classCallCheck(this, CID);\n    /** @readonly */\n    this.code = code;\n    /** @readonly */\n    this.version = version;\n    /** @readonly */\n    this.multihash = multihash;\n    /** @readonly */\n    this.bytes = bytes;\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes;\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  _createClass(CID, [{\n    key: \"asCID\",\n    get: function get() {\n      return this;\n    }\n\n    // ArrayBufferView\n  }, {\n    key: \"byteOffset\",\n    get: function get() {\n      return this.bytes.byteOffset;\n    }\n\n    // ArrayBufferView\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      return this.bytes.byteLength;\n    }\n\n    /**\n     * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n     */\n  }, {\n    key: \"toV0\",\n    value: function toV0() {\n      switch (this.version) {\n        case 0:\n          {\n            return (/** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */this\n            );\n          }\n        case 1:\n          {\n            var code = this.code,\n              multihash = this.multihash;\n            if (code !== DAG_PB_CODE) {\n              throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n            }\n\n            // sha2-256\n            if (multihash.code !== SHA_256_CODE) {\n              throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n            }\n            return (/** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */\n              CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */multihash)\n            );\n          }\n        default:\n          {\n            throw Error(\"Can not convert CID version \".concat(this.version, \" to version 0. This is a bug please report\"));\n          }\n      }\n    }\n\n    /**\n     * @returns {CID<Data, Format, Alg, 1>}\n     */\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      switch (this.version) {\n        case 0:\n          {\n            var _this$multihash = this.multihash,\n              code = _this$multihash.code,\n              digest = _this$multihash.digest;\n            var multihash = Digest.create(code, digest);\n            return (/** @type {CID<Data, Format, Alg, 1>} */\n              CID.createV1(this.code, multihash)\n            );\n          }\n        case 1:\n          {\n            return (/** @type {CID<Data, Format, Alg, 1>} */this\n            );\n          }\n        default:\n          {\n            throw Error(\"Can not convert CID version \".concat(this.version, \" to version 1. This is a bug please report\"));\n          }\n      }\n    }\n\n    /**\n     * @param {unknown} other\n     * @returns {other is CID<Data, Format, Alg, Version>}\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return CID.equals(this, other);\n    }\n\n    /**\n     * @template {unknown} Data\n     * @template {number} Format\n     * @template {number} Alg\n     * @template {API.Version} Version\n     * @param {API.Link<Data, Format, Alg, Version>} self\n     * @param {unknown} other\n     * @returns {other is CID}\n     */\n  }, {\n    key: \"toString\",\n    value:\n    /**\n     * @param {API.MultibaseEncoder<string>} [base]\n     * @returns {string}\n     */\n    function toString(base) {\n      return format(this, base);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        '/': format(this)\n      };\n    }\n  }, {\n    key: \"link\",\n    value: function link() {\n      return this;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'CID';\n    }\n\n    // Legacy\n  }, {\n    key: _Symbol$for,\n    value: function value() {\n      return \"CID(\".concat(this.toString(), \")\");\n    }\n\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     *\n     * @template {unknown} Data\n     * @template {number} Format\n     * @template {number} Alg\n     * @template {API.Version} Version\n     * @template {unknown} U\n     * @param {API.Link<Data, Format, Alg, Version>|U} input\n     * @returns {CID<Data, Format, Alg, Version>|null}\n     */\n  }], [{\n    key: \"equals\",\n    value: function equals(self, other) {\n      var unknown = /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */\n      other;\n      return unknown && self.code === unknown.code && self.version === unknown.version && Digest.equals(self.multihash, unknown.multihash);\n    }\n  }, {\n    key: \"asCID\",\n    value: function asCID(input) {\n      if (input == null) {\n        return null;\n      }\n      var value = /** @type {any} */input;\n      if (value instanceof CID) {\n        // If value is instance of CID then we're all set.\n        return value;\n      } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {\n        // If value isn't instance of this CID class but `this.asCID === this` or\n        // `value['/'] === value.bytes` is true it is CID instance coming from a\n        // different implementation (diff version or duplicate). In that case we\n        // rebase it to this `CID` implementation so caller is guaranteed to get\n        // instance with expected API.\n        var version = value.version,\n          code = value.code,\n          multihash = value.multihash,\n          bytes = value.bytes;\n        return new CID(version, code, /** @type {API.MultihashDigest<Alg>} */multihash, bytes || encodeCID(version, code, multihash.bytes));\n      } else if (value[cidSymbol] === true) {\n        // If value is a CID from older implementation that used to be tagged via\n        // symbol we still rebase it to the this `CID` implementation by\n        // delegating that to a constructor.\n        var _version = value.version,\n          _multihash = value.multihash,\n          _code = value.code;\n        var digest = /** @type {API.MultihashDigest<Alg>} */\n        Digest.decode(_multihash);\n        return CID.create(_version, _code, digest);\n      } else {\n        // Otherwise value is not a CID (or an incompatible version of it) in\n        // which case we return `null`.\n        return null;\n      }\n    }\n\n    /**\n     *\n     * @template {unknown} Data\n     * @template {number} Format\n     * @template {number} Alg\n     * @template {API.Version} Version\n     * @param {Version} version - Version of the CID\n     * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n     * @returns {CID<Data, Format, Alg, Version>}\n     */\n  }, {\n    key: \"create\",\n    value: function create(version, code, digest) {\n      if (typeof code !== 'number') {\n        throw new Error('String codecs are no longer supported');\n      }\n      if (!(digest.bytes instanceof Uint8Array)) {\n        throw new Error('Invalid digest');\n      }\n      switch (version) {\n        case 0:\n          {\n            if (code !== DAG_PB_CODE) {\n              throw new Error(\"Version 0 CID must use dag-pb (code: \".concat(DAG_PB_CODE, \") block encoding\"));\n            } else {\n              return new CID(version, code, digest, digest.bytes);\n            }\n          }\n        case 1:\n          {\n            var bytes = encodeCID(version, code, digest.bytes);\n            return new CID(version, code, digest, bytes);\n          }\n        default:\n          {\n            throw new Error('Invalid version');\n          }\n      }\n    }\n\n    /**\n     * Simplified version of `create` for CIDv0.\n     *\n     * @template {unknown} [T=unknown]\n     * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n     * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n     */\n  }, {\n    key: \"createV0\",\n    value: function createV0(digest) {\n      return CID.create(0, DAG_PB_CODE, digest);\n    }\n\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @template {unknown} Data\n     * @template {number} Code\n     * @template {number} Alg\n     * @param {Code} code - Content encoding format code.\n     * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n     * @returns {CID<Data, Code, Alg, 1>}\n     */\n  }, {\n    key: \"createV1\",\n    value: function createV1(code, digest) {\n      return CID.create(1, code, digest);\n    }\n\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     *\n     * @template {unknown} Data\n     * @template {number} Code\n     * @template {number} Alg\n     * @template {API.Version} Ver\n     * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n     * @returns {CID<Data, Code, Alg, Ver>}\n     */\n  }, {\n    key: \"decode\",\n    value: function decode(bytes) {\n      var _CID$decodeFirst = CID.decodeFirst(bytes),\n        _CID$decodeFirst2 = _slicedToArray(_CID$decodeFirst, 2),\n        cid = _CID$decodeFirst2[0],\n        remainder = _CID$decodeFirst2[1];\n      if (remainder.length) {\n        throw new Error('Incorrect length');\n      }\n      return cid;\n    }\n\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     *\n     * @template {unknown} T\n     * @template {number} C\n     * @template {number} A\n     * @template {API.Version} V\n     * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n     * @returns {[CID<T, C, A, V>, Uint8Array]}\n     */\n  }, {\n    key: \"decodeFirst\",\n    value: function decodeFirst(bytes) {\n      var specs = CID.inspectBytes(bytes);\n      var prefixSize = specs.size - specs.multihashSize;\n      var multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n      if (multihashBytes.byteLength !== specs.multihashSize) {\n        throw new Error('Incorrect length');\n      }\n      var digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n      var digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n      var cid = specs.version === 0 ? CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */digest) : CID.createV1(specs.codec, digest);\n      return [/** @type {CID<T, C, A, V>} */cid, bytes.subarray(specs.size)];\n    }\n\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     *\n     * @template {unknown} T\n     * @template {number} C\n     * @template {number} A\n     * @template {API.Version} V\n     * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n     * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n     */\n  }, {\n    key: \"inspectBytes\",\n    value: function inspectBytes(initialBytes) {\n      var offset = 0;\n      var next = function next() {\n        var _varint$decode = varint.decode(initialBytes.subarray(offset)),\n          _varint$decode2 = _slicedToArray(_varint$decode, 2),\n          i = _varint$decode2[0],\n          length = _varint$decode2[1];\n        offset += length;\n        return i;\n      };\n      var version = /** @type {V} */next();\n      var codec = /** @type {C} */DAG_PB_CODE;\n      if ( /** @type {number} */version === 18) {\n        // CIDv0\n        version = /** @type {V} */0;\n        offset = 0;\n      } else {\n        codec = /** @type {C} */next();\n      }\n      if (version !== 0 && version !== 1) {\n        throw new RangeError(\"Invalid CID version \".concat(version));\n      }\n      var prefixSize = offset;\n      var multihashCode = /** @type {A} */next(); // multihash code\n      var digestSize = next(); // multihash length\n      var size = offset + digestSize;\n      var multihashSize = size - prefixSize;\n      return {\n        version: version,\n        codec: codec,\n        multihashCode: multihashCode,\n        digestSize: digestSize,\n        multihashSize: multihashSize,\n        size: size\n      };\n    }\n\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     *\n     * @template {string} Prefix\n     * @template {unknown} Data\n     * @template {number} Code\n     * @template {number} Alg\n     * @template {API.Version} Ver\n     * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n     * @param {API.MultibaseDecoder<Prefix>} [base]\n     * @returns {CID<Data, Code, Alg, Ver>}\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(source, base) {\n      var _parseCIDtoBytes = parseCIDtoBytes(source, base),\n        _parseCIDtoBytes2 = _slicedToArray(_parseCIDtoBytes, 2),\n        prefix = _parseCIDtoBytes2[0],\n        bytes = _parseCIDtoBytes2[1];\n      var cid = CID.decode(bytes);\n      if (cid.version === 0 && source[0] !== 'Q') {\n        throw Error('Version 0 CID string must not include multibase prefix');\n      }\n\n      // Cache string representation to avoid computing it on `this.toString()`\n      baseCache(cid).set(prefix, source);\n      return cid;\n    }\n  }]);\n  return CID;\n}(Symbol.toStringTag, Symbol.for('nodejs.util.inspect.custom'));\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nvar parseCIDtoBytes = function parseCIDtoBytes(source, base) {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q':\n      {\n        var decoder = base || base58btc;\n        return [/** @type {Prefix} */base58btc.prefix, decoder.decode(\"\".concat(base58btc.prefix).concat(source))];\n      }\n    case base58btc.prefix:\n      {\n        var _decoder = base || base58btc;\n        return [/** @type {Prefix} */base58btc.prefix, _decoder.decode(source)];\n      }\n    case base32.prefix:\n      {\n        var _decoder2 = base || base32;\n        return [/** @type {Prefix} */base32.prefix, _decoder2.decode(source)];\n      }\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n        return [/** @type {Prefix} */source[0], base.decode(source)];\n      }\n  }\n};\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nvar toStringV0 = function toStringV0(bytes, cache, base) {\n  var prefix = base.prefix;\n  if (prefix !== base58btc.prefix) {\n    throw Error(\"Cannot string encode V0 in \".concat(base.name, \" encoding\"));\n  }\n  var cid = cache.get(prefix);\n  if (cid == null) {\n    var _cid = base.encode(bytes).slice(1);\n    cache.set(prefix, _cid);\n    return _cid;\n  } else {\n    return cid;\n  }\n};\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nvar toStringV1 = function toStringV1(bytes, cache, base) {\n  var prefix = base.prefix;\n  var cid = cache.get(prefix);\n  if (cid == null) {\n    var _cid2 = base.encode(bytes);\n    cache.set(prefix, _cid2);\n    return _cid2;\n  } else {\n    return cid;\n  }\n};\nvar DAG_PB_CODE = 0x70;\nvar SHA_256_CODE = 0x12;\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nvar encodeCID = function encodeCID(version, code, multihash) {\n  var codeOffset = varint.encodingLength(version);\n  var hashOffset = codeOffset + varint.encodingLength(code);\n  var bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nvar cidSymbol = Symbol.for('@ipld/js-cid/CID');","map":{"version":3,"names":["varint","Digest","base58btc","base32","coerce","API","format","link","base","bytes","version","toStringV0","baseCache","encoder","toStringV1","toJSON","fromJSON","json","CID","parse","cache","WeakMap","cid","get","Map","set","_Symbol$toStringTag","_Symbol$for","code","multihash","_classCallCheck","_createClass","key","byteOffset","byteLength","value","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","concat","toV1","_this$multihash","digest","create","createV1","equals","other","toString","self","unknown","asCID","input","encodeCID","cidSymbol","decode","Uint8Array","_CID$decodeFirst","decodeFirst","_CID$decodeFirst2","_slicedToArray","remainder","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","codec","initialBytes","offset","next","_varint$decode","_varint$decode2","i","RangeError","source","_parseCIDtoBytes","parseCIDtoBytes","_parseCIDtoBytes2","prefix","Symbol","toStringTag","for","decoder","name","encode","slice","codeOffset","encodingLength","hashOffset","encodeTo"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/multistream-select/node_modules/multiformats/src/cid.js"],"sourcesContent":["import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}