{"ast":null,"code":"import _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport errCode from 'err-code';\nimport { NotEnabledError } from '../errors.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { CID } from 'multiformats/cid';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base36 } from 'multiformats/bases/base36';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { peerIdFromString } from '@libp2p/peer-id';\n\n/**\n * @typedef {import('@libp2p/interface-dht').QueryEvent} QueryEvent\n * @typedef {import('./network').Network} Network\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nvar IPNS_PREFIX = '/ipns/';\n\n/**\n * @param {string} str\n */\nfunction toDHTKey(str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length);\n  }\n\n  /** @type {Uint8Array|undefined} */\n  var buf;\n  if (str[0] === '1' || str[0] === 'Q') {\n    // ed25519 key or hash of rsa key\n    str = \"z\".concat(str);\n  }\n  if (str[0] === 'z') {\n    buf = base58btc.decode(str);\n  }\n  if (str[0] === 'k') {\n    // base36 encoded string\n    buf = base36.decode(str);\n  }\n  if (!buf) {\n    throw new Error('Could not parse string');\n  }\n  if (buf[0] !== 0x01 && buf[1] !== 0x72) {\n    // prefix key with CIDv1 and libp2p-key codec\n    buf = uint8ArrayConcat([[0x01, 0x72], buf]);\n  }\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length);\n  }\n  return uint8ArrayConcat([uint8ArrayFromString(IPNS_PREFIX), buf.subarray(2)]);\n}\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {PeerId} config.peerId\n */\nexport function createDht(_ref2) {\n  var network = _ref2.network,\n    repo = _ref2.repo,\n    peerId = _ref2.peerId;\n  var _get$put$findProvs$fi = {\n      /**\n       * @type {import('ipfs-core-types/src/dht').API<{}>[\"get\"]}\n       */\n      get: function get(key) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var _yield$_awaitAsyncGen, libp2p, dhtKey;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _awaitAsyncGenerator(use(network, peerId, options));\n              case 2:\n                _yield$_awaitAsyncGen = _context.sent;\n                libp2p = _yield$_awaitAsyncGen.libp2p;\n                dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n                if (!(libp2p.dht == null)) {\n                  _context.next = 7;\n                  break;\n                }\n                throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n              case 7:\n                return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(libp2p.dht.get(dhtKey, options)), _awaitAsyncGenerator), \"t0\", 8);\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }))();\n      },\n      /**\n       * @type {import('ipfs-core-types/src/dht').API<{}>[\"put\"]}\n       */\n      put: function put(key, value, options) {\n        return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _yield$_awaitAsyncGen2, libp2p, dhtKey;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _awaitAsyncGenerator(use(network, peerId, options));\n              case 2:\n                _yield$_awaitAsyncGen2 = _context2.sent;\n                libp2p = _yield$_awaitAsyncGen2.libp2p;\n                dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n                if (!(libp2p.dht == null)) {\n                  _context2.next = 7;\n                  break;\n                }\n                throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n              case 7:\n                return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(libp2p.dht.put(dhtKey, value, options)), _awaitAsyncGenerator), \"t0\", 8);\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }))();\n      },\n      /**\n       * @type {import('ipfs-core-types/src/dht').API<{}>[\"findProvs\"]}\n       */\n      findProvs: function findProvs(cid) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var _yield$_awaitAsyncGen3, libp2p;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _awaitAsyncGenerator(use(network, peerId, options));\n              case 2:\n                _yield$_awaitAsyncGen3 = _context3.sent;\n                libp2p = _yield$_awaitAsyncGen3.libp2p;\n                if (!(libp2p.dht == null)) {\n                  _context3.next = 6;\n                  break;\n                }\n                throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n              case 6:\n                return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(libp2p.dht.findProviders(cid, {\n                  signal: options.signal\n                })), _awaitAsyncGenerator), \"t0\", 7);\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3);\n        }))();\n      },\n      /**\n       * @type {import('ipfs-core-types/src/dht').API<{}>[\"findPeer\"]}\n       */\n      findPeer: function findPeer(peerIdToFind) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          var _yield$_awaitAsyncGen4, libp2p;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return _awaitAsyncGenerator(use(network, peerId, options));\n              case 2:\n                _yield$_awaitAsyncGen4 = _context4.sent;\n                libp2p = _yield$_awaitAsyncGen4.libp2p;\n                if (!(libp2p.dht == null)) {\n                  _context4.next = 6;\n                  break;\n                }\n                throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n              case 6:\n                return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(libp2p.dht.findPeer(peerIdToFind, {\n                  signal: options.signal\n                })), _awaitAsyncGenerator), \"t0\", 7);\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4);\n        }))();\n      },\n      /**\n       * @type {import('ipfs-core-types/src/dht').API<{}>[\"provide\"]}\n       */\n      provide: function provide(cid) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          recursive: false\n        };\n        return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n          var _yield$_awaitAsyncGen5, libp2p, hasBlock;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _awaitAsyncGenerator(use(network, peerId, options));\n              case 2:\n                _yield$_awaitAsyncGen5 = _context5.sent;\n                libp2p = _yield$_awaitAsyncGen5.libp2p;\n                _context5.next = 6;\n                return _awaitAsyncGenerator(repo.blocks.has(cid));\n              case 6:\n                hasBlock = _context5.sent;\n                if (hasBlock) {\n                  _context5.next = 9;\n                  break;\n                }\n                throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n              case 9:\n                if (!options.recursive) {\n                  _context5.next = 11;\n                  break;\n                }\n                throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n              case 11:\n                if (!(libp2p.dht == null)) {\n                  _context5.next = 13;\n                  break;\n                }\n                throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n              case 13:\n                return _context5.delegateYield(_asyncGeneratorDelegate(_asyncIterator(libp2p.dht.provide(cid)), _awaitAsyncGenerator), \"t0\", 14);\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }, _callee5);\n        }))();\n      },\n      /**\n       * @type {import('ipfs-core-types/src/dht').API<{}>[\"query\"]}\n       */\n      query: function query(peerIdToQuery) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          var _yield$_awaitAsyncGen6, libp2p, bytes, asCid;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return _awaitAsyncGenerator(use(network, peerId, options));\n              case 2:\n                _yield$_awaitAsyncGen6 = _context6.sent;\n                libp2p = _yield$_awaitAsyncGen6.libp2p;\n                asCid = CID.asCID(peerIdToQuery);\n                if (asCid != null) {\n                  bytes = asCid.multihash.bytes;\n                } else {\n                  bytes = peerIdFromString(peerIdToQuery.toString()).toBytes();\n                }\n                if (!(libp2p.dht == null)) {\n                  _context6.next = 8;\n                  break;\n                }\n                throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n              case 8:\n                return _context6.delegateYield(_asyncGeneratorDelegate(_asyncIterator(libp2p.dht.getClosestPeers(bytes, options)), _awaitAsyncGenerator), \"t0\", 9);\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6);\n        }))();\n      }\n    },\n    get = _get$put$findProvs$fi.get,\n    put = _get$put$findProvs$fi.put,\n    findProvs = _get$put$findProvs$fi.findProvs,\n    findPeer = _get$put$findProvs$fi.findPeer,\n    provide = _get$put$findProvs$fi.provide,\n    query = _get$put$findProvs$fi.query;\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  };\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {PeerId} peerId\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n * @returns {Promise<Network>}\n */\nvar use = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(network, peerId, options) {\n    var net, fn;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.next = 2;\n          return network.use(options);\n        case 2:\n          net = _context8.sent;\n          if (!(net.libp2p.dht != null)) {\n            _context8.next = 7;\n            break;\n          }\n          return _context8.abrupt(\"return\", net);\n        case 7:\n          fn = /*#__PURE__*/function () {\n            var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n              return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                while (1) switch (_context7.prev = _context7.next) {\n                  case 0:\n                    _context7.next = 2;\n                    return {\n                      from: peerId,\n                      name: 'QUERY_ERROR',\n                      type: 3,\n                      error: new NotEnabledError('dht not enabled')\n                    };\n                  case 2:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }, _callee7);\n            }));\n            return function fn() {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          return _context8.abrupt(\"return\", {\n            libp2p: {\n              dht: {\n                // @ts-expect-error incomplete implementation\n                get: fn,\n                // @ts-expect-error incomplete implementation\n                put: fn,\n                // @ts-expect-error incomplete implementation\n                findProviders: fn,\n                // @ts-expect-error incomplete implementation\n                findPeer: fn,\n                // @ts-expect-error incomplete implementation\n                provide: fn,\n                // @ts-expect-error incomplete implementation\n                getClosestPeers: fn\n              }\n            }\n          });\n        case 9:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return function use(_x, _x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["errCode","NotEnabledError","withTimeoutOption","CID","base58btc","base36","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","peerIdFromString","IPNS_PREFIX","toDHTKey","str","startsWith","substring","length","buf","decode","Error","subarray","createDht","_ref2","network","repo","peerId","_get$put$findProvs$fi","get","key","options","arguments","undefined","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","_yield$_awaitAsyncGen","libp2p","dhtKey","wrap","_callee$","_context","prev","next","_awaitAsyncGenerator","use","sent","Uint8Array","dht","delegateYield","_asyncGeneratorDelegate","_asyncIterator","stop","put","value","_callee2","_yield$_awaitAsyncGen2","_callee2$","_context2","findProvs","cid","_callee3","_yield$_awaitAsyncGen3","_callee3$","_context3","findProviders","signal","findPeer","peerIdToFind","_callee4","_yield$_awaitAsyncGen4","_callee4$","_context4","provide","recursive","_callee5","_yield$_awaitAsyncGen5","hasBlock","_callee5$","_context5","blocks","has","query","peerIdToQuery","_callee6","_yield$_awaitAsyncGen6","bytes","asCid","_callee6$","_context6","asCID","multihash","toString","toBytes","getClosestPeers","_ref3","_asyncToGenerator","_callee8","net","fn","_callee8$","_context8","abrupt","_ref","_callee7","_callee7$","_context7","from","name","type","error","apply","_x","_x2","_x3"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/dht.js"],"sourcesContent":["import errCode from 'err-code'\nimport { NotEnabledError } from '../errors.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { CID } from 'multiformats/cid'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base36 } from 'multiformats/bases/base36'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('@libp2p/interface-dht').QueryEvent} QueryEvent\n * @typedef {import('./network').Network} Network\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nconst IPNS_PREFIX = '/ipns/'\n\n/**\n * @param {string} str\n */\nfunction toDHTKey (str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length)\n  }\n\n  /** @type {Uint8Array|undefined} */\n  let buf\n\n  if (str[0] === '1' || str[0] === 'Q') {\n    // ed25519 key or hash of rsa key\n    str = `z${str}`\n  }\n\n  if (str[0] === 'z') {\n    buf = base58btc.decode(str)\n  }\n\n  if (str[0] === 'k') {\n    // base36 encoded string\n    buf = base36.decode(str)\n  }\n\n  if (!buf) {\n    throw new Error('Could not parse string')\n  }\n\n  if (buf[0] !== 0x01 && buf[1] !== 0x72) {\n    // prefix key with CIDv1 and libp2p-key codec\n    buf = uint8ArrayConcat([\n      [0x01, 0x72],\n      buf\n    ])\n  }\n\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length)\n  }\n\n  return uint8ArrayConcat([\n    uint8ArrayFromString(IPNS_PREFIX),\n    buf.subarray(2)\n  ])\n}\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {PeerId} config.peerId\n */\nexport function createDht ({ network, repo, peerId }) {\n  const { get, put, findProvs, findPeer, provide, query } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"get\"]}\n     */\n    async * get (key, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.get(dhtKey, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"put\"]}\n     */\n    async * put (key, value, options) {\n      const { libp2p } = await use(network, peerId, options)\n\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.put(dhtKey, value, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findProvs\"]}\n     */\n    async * findProvs (cid, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.findProviders(cid, {\n        signal: options.signal\n      })\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findPeer\"]}\n     */\n    async * findPeer (peerIdToFind, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.findPeer(peerIdToFind, {\n        signal: options.signal\n      })\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"provide\"]}\n     */\n    async * provide (cid, options = { recursive: false }) {\n      const { libp2p } = await use(network, peerId, options)\n\n      // ensure blocks are actually local\n      const hasBlock = await repo.blocks.has(cid)\n\n      if (!hasBlock) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET')\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.provide(cid)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"query\"]}\n     */\n    async * query (peerIdToQuery, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n      let bytes\n      const asCid = CID.asCID(peerIdToQuery)\n\n      if (asCid != null) {\n        bytes = asCid.multihash.bytes\n      } else {\n        bytes = peerIdFromString(peerIdToQuery.toString()).toBytes()\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.getClosestPeers(bytes, options)\n    }\n  }\n\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  }\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {PeerId} peerId\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n * @returns {Promise<Network>}\n */\nconst use = async (network, peerId, options) => {\n  const net = await network.use(options)\n  if (net.libp2p.dht != null) {\n    return net\n  } else {\n    const fn = async function * () {\n      yield {\n        from: peerId,\n        name: 'QUERY_ERROR',\n        type: 3,\n        error: new NotEnabledError('dht not enabled')\n      }\n    }\n\n    return {\n      libp2p: {\n        dht: {\n          // @ts-expect-error incomplete implementation\n          get: fn,\n          // @ts-expect-error incomplete implementation\n          put: fn,\n          // @ts-expect-error incomplete implementation\n          findProviders: fn,\n          // @ts-expect-error incomplete implementation\n          findPeer: fn,\n          // @ts-expect-error incomplete implementation\n          provide: fn,\n          // @ts-expect-error incomplete implementation\n          getClosestPeers: fn\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}