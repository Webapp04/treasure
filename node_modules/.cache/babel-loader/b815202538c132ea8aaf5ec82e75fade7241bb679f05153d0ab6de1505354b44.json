{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _require = require('abstract-level'),\n  AbstractIterator = _require.AbstractIterator;\nvar createKeyRange = require('./util/key-range');\nvar deserialize = require('./util/deserialize');\nvar kCache = Symbol('cache');\nvar kFinished = Symbol('finished');\nvar kOptions = Symbol('options');\nvar kCurrentOptions = Symbol('currentOptions');\nvar kPosition = Symbol('position');\nvar kLocation = Symbol('location');\nvar kFirst = Symbol('first');\nvar emptyOptions = {};\nvar Iterator = /*#__PURE__*/function (_AbstractIterator) {\n  _inherits(Iterator, _AbstractIterator);\n  var _super = _createSuper(Iterator);\n  function Iterator(db, location, options) {\n    var _this;\n    _classCallCheck(this, Iterator);\n    _this = _super.call(this, db, options);\n    _this[kCache] = [];\n    _this[kFinished] = _this.limit === 0;\n    _this[kOptions] = options;\n    _this[kCurrentOptions] = _objectSpread({}, options);\n    _this[kPosition] = undefined;\n    _this[kLocation] = location;\n    _this[kFirst] = true;\n    return _this;\n  }\n\n  // Note: if called by _all() then size can be Infinity. This is an internal\n  // detail; by design AbstractIterator.nextv() does not support Infinity.\n  _createClass(Iterator, [{\n    key: \"_nextv\",\n    value: function _nextv(size, options, callback) {\n      var _this2 = this;\n      this[kFirst] = false;\n      if (this[kFinished]) {\n        return this.nextTick(callback, null, []);\n      } else if (this[kCache].length > 0) {\n        // TODO: mixing next and nextv is not covered by test suite\n        size = Math.min(size, this[kCache].length);\n        return this.nextTick(callback, null, this[kCache].splice(0, size));\n      }\n\n      // Adjust range by what we already visited\n      if (this[kPosition] !== undefined) {\n        if (this[kOptions].reverse) {\n          this[kCurrentOptions].lt = this[kPosition];\n          this[kCurrentOptions].lte = undefined;\n        } else {\n          this[kCurrentOptions].gt = this[kPosition];\n          this[kCurrentOptions].gte = undefined;\n        }\n      }\n      var keyRange;\n      try {\n        keyRange = createKeyRange(this[kCurrentOptions]);\n      } catch (_) {\n        // The lower key is greater than the upper key.\n        // IndexedDB throws an error, but we'll just return 0 results.\n        this[kFinished] = true;\n        return this.nextTick(callback, null, []);\n      }\n      var transaction = this.db.db.transaction([this[kLocation]], 'readonly');\n      var store = transaction.objectStore(this[kLocation]);\n      var entries = [];\n      if (!this[kOptions].reverse) {\n        var keys;\n        var values;\n        var complete = function complete() {\n          // Wait for both requests to complete\n          if (keys === undefined || values === undefined) return;\n          var length = Math.max(keys.length, values.length);\n          if (length === 0 || size === Infinity) {\n            _this2[kFinished] = true;\n          } else {\n            _this2[kPosition] = keys[length - 1];\n          }\n\n          // Resize\n          entries.length = length;\n\n          // Merge keys and values\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            var value = values[i];\n            entries[i] = [_this2[kOptions].keys && key !== undefined ? deserialize(key) : undefined, _this2[kOptions].values && value !== undefined ? deserialize(value) : undefined];\n          }\n          maybeCommit(transaction);\n        };\n\n        // If keys were not requested and size is Infinity, we don't have to keep\n        // track of position and can thus skip getting keys.\n        if (this[kOptions].keys || size < Infinity) {\n          store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = function (ev) {\n            keys = ev.target.result;\n            complete();\n          };\n        } else {\n          keys = [];\n          this.nextTick(complete);\n        }\n        if (this[kOptions].values) {\n          store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = function (ev) {\n            values = ev.target.result;\n            complete();\n          };\n        } else {\n          values = [];\n          this.nextTick(complete);\n        }\n      } else {\n        // Can't use getAll() in reverse, so use a slower cursor that yields one item at a time\n        // TODO: test if all target browsers support openKeyCursor\n        var method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor';\n        store[method](keyRange, 'prev').onsuccess = function (ev) {\n          var cursor = ev.target.result;\n          if (cursor) {\n            var key = cursor.key,\n              value = cursor.value;\n            _this2[kPosition] = key;\n            entries.push([_this2[kOptions].keys && key !== undefined ? deserialize(key) : undefined, _this2[kOptions].values && value !== undefined ? deserialize(value) : undefined]);\n            if (entries.length < size) {\n              cursor.continue();\n            } else {\n              maybeCommit(transaction);\n            }\n          } else {\n            _this2[kFinished] = true;\n          }\n        };\n      }\n\n      // If an error occurs (on the request), the transaction will abort.\n      transaction.onabort = function () {\n        callback(transaction.error || new Error('aborted by user'));\n        callback = null;\n      };\n      transaction.oncomplete = function () {\n        callback(null, entries);\n        callback = null;\n      };\n    }\n  }, {\n    key: \"_next\",\n    value: function _next(callback) {\n      var _this3 = this;\n      if (this[kCache].length > 0) {\n        var _this$kCache$shift = this[kCache].shift(),\n          _this$kCache$shift2 = _slicedToArray(_this$kCache$shift, 2),\n          key = _this$kCache$shift2[0],\n          value = _this$kCache$shift2[1];\n        this.nextTick(callback, null, key, value);\n      } else if (this[kFinished]) {\n        this.nextTick(callback);\n      } else {\n        var size = Math.min(100, this.limit - this.count);\n        if (this[kFirst]) {\n          // It's common to only want one entry initially or after a seek()\n          this[kFirst] = false;\n          size = 1;\n        }\n        this._nextv(size, emptyOptions, function (err, entries) {\n          if (err) return callback(err);\n          _this3[kCache] = entries;\n          _this3._next(callback);\n        });\n      }\n    }\n  }, {\n    key: \"_all\",\n    value: function _all(options, callback) {\n      this[kFirst] = false;\n\n      // TODO: mixing next and all is not covered by test suite\n      var cache = this[kCache].splice(0, this[kCache].length);\n      var size = this.limit - this.count - cache.length;\n      if (size <= 0) {\n        return this.nextTick(callback, null, cache);\n      }\n      this._nextv(size, emptyOptions, function (err, entries) {\n        if (err) return callback(err);\n        if (cache.length > 0) entries = cache.concat(entries);\n        callback(null, entries);\n      });\n    }\n  }, {\n    key: \"_seek\",\n    value: function _seek(target, options) {\n      this[kFirst] = true;\n      this[kCache] = [];\n      this[kFinished] = false;\n      this[kPosition] = undefined;\n\n      // TODO: not covered by test suite\n      this[kCurrentOptions] = _objectSpread({}, this[kOptions]);\n      var keyRange;\n      try {\n        keyRange = createKeyRange(this[kOptions]);\n      } catch (_) {\n        this[kFinished] = true;\n        return;\n      }\n      if (keyRange !== null && !keyRange.includes(target)) {\n        this[kFinished] = true;\n      } else if (this[kOptions].reverse) {\n        this[kCurrentOptions].lte = target;\n      } else {\n        this[kCurrentOptions].gte = target;\n      }\n    }\n  }]);\n  return Iterator;\n}(AbstractIterator);\nexports.Iterator = Iterator;\nfunction maybeCommit(transaction) {\n  // Commit (meaning close) now instead of waiting for auto-commit\n  if (typeof transaction.commit === 'function') {\n    transaction.commit();\n  }\n}","map":{"version":3,"names":["_slicedToArray","require","default","_objectSpread","_classCallCheck","_createClass","_inherits","_createSuper","_require","AbstractIterator","createKeyRange","deserialize","kCache","Symbol","kFinished","kOptions","kCurrentOptions","kPosition","kLocation","kFirst","emptyOptions","Iterator","_AbstractIterator","_super","db","location","options","_this","call","limit","undefined","key","value","_nextv","size","callback","_this2","nextTick","length","Math","min","splice","reverse","lt","lte","gt","gte","keyRange","_","transaction","store","objectStore","entries","keys","values","complete","max","Infinity","i","maybeCommit","getAllKeys","onsuccess","ev","target","result","getAll","method","openKeyCursor","cursor","push","continue","onabort","error","Error","oncomplete","_next","_this3","_this$kCache$shift","shift","_this$kCache$shift2","count","err","_all","cache","concat","_seek","includes","exports","commit"],"sources":["/Users/apple/Documents/treasure/node_modules/browser-level/iterator.js"],"sourcesContent":["'use strict'\n\nconst { AbstractIterator } = require('abstract-level')\nconst createKeyRange = require('./util/key-range')\nconst deserialize = require('./util/deserialize')\n\nconst kCache = Symbol('cache')\nconst kFinished = Symbol('finished')\nconst kOptions = Symbol('options')\nconst kCurrentOptions = Symbol('currentOptions')\nconst kPosition = Symbol('position')\nconst kLocation = Symbol('location')\nconst kFirst = Symbol('first')\nconst emptyOptions = {}\n\nclass Iterator extends AbstractIterator {\n  constructor (db, location, options) {\n    super(db, options)\n\n    this[kCache] = []\n    this[kFinished] = this.limit === 0\n    this[kOptions] = options\n    this[kCurrentOptions] = { ...options }\n    this[kPosition] = undefined\n    this[kLocation] = location\n    this[kFirst] = true\n  }\n\n  // Note: if called by _all() then size can be Infinity. This is an internal\n  // detail; by design AbstractIterator.nextv() does not support Infinity.\n  _nextv (size, options, callback) {\n    this[kFirst] = false\n\n    if (this[kFinished]) {\n      return this.nextTick(callback, null, [])\n    } else if (this[kCache].length > 0) {\n      // TODO: mixing next and nextv is not covered by test suite\n      size = Math.min(size, this[kCache].length)\n      return this.nextTick(callback, null, this[kCache].splice(0, size))\n    }\n\n    // Adjust range by what we already visited\n    if (this[kPosition] !== undefined) {\n      if (this[kOptions].reverse) {\n        this[kCurrentOptions].lt = this[kPosition]\n        this[kCurrentOptions].lte = undefined\n      } else {\n        this[kCurrentOptions].gt = this[kPosition]\n        this[kCurrentOptions].gte = undefined\n      }\n    }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kCurrentOptions])\n    } catch (_) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just return 0 results.\n      this[kFinished] = true\n      return this.nextTick(callback, null, [])\n    }\n\n    const transaction = this.db.db.transaction([this[kLocation]], 'readonly')\n    const store = transaction.objectStore(this[kLocation])\n    const entries = []\n\n    if (!this[kOptions].reverse) {\n      let keys\n      let values\n\n      const complete = () => {\n        // Wait for both requests to complete\n        if (keys === undefined || values === undefined) return\n\n        const length = Math.max(keys.length, values.length)\n\n        if (length === 0 || size === Infinity) {\n          this[kFinished] = true\n        } else {\n          this[kPosition] = keys[length - 1]\n        }\n\n        // Resize\n        entries.length = length\n\n        // Merge keys and values\n        for (let i = 0; i < length; i++) {\n          const key = keys[i]\n          const value = values[i]\n\n          entries[i] = [\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ]\n        }\n\n        maybeCommit(transaction)\n      }\n\n      // If keys were not requested and size is Infinity, we don't have to keep\n      // track of position and can thus skip getting keys.\n      if (this[kOptions].keys || size < Infinity) {\n        store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          keys = ev.target.result\n          complete()\n        }\n      } else {\n        keys = []\n        this.nextTick(complete)\n      }\n\n      if (this[kOptions].values) {\n        store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          values = ev.target.result\n          complete()\n        }\n      } else {\n        values = []\n        this.nextTick(complete)\n      }\n    } else {\n      // Can't use getAll() in reverse, so use a slower cursor that yields one item at a time\n      // TODO: test if all target browsers support openKeyCursor\n      const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor'\n\n      store[method](keyRange, 'prev').onsuccess = (ev) => {\n        const cursor = ev.target.result\n\n        if (cursor) {\n          const { key, value } = cursor\n          this[kPosition] = key\n\n          entries.push([\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ])\n\n          if (entries.length < size) {\n            cursor.continue()\n          } else {\n            maybeCommit(transaction)\n          }\n        } else {\n          this[kFinished] = true\n        }\n      }\n    }\n\n    // If an error occurs (on the request), the transaction will abort.\n    transaction.onabort = () => {\n      callback(transaction.error || new Error('aborted by user'))\n      callback = null\n    }\n\n    transaction.oncomplete = () => {\n      callback(null, entries)\n      callback = null\n    }\n  }\n\n  _next (callback) {\n    if (this[kCache].length > 0) {\n      const [key, value] = this[kCache].shift()\n      this.nextTick(callback, null, key, value)\n    } else if (this[kFinished]) {\n      this.nextTick(callback)\n    } else {\n      let size = Math.min(100, this.limit - this.count)\n\n      if (this[kFirst]) {\n        // It's common to only want one entry initially or after a seek()\n        this[kFirst] = false\n        size = 1\n      }\n\n      this._nextv(size, emptyOptions, (err, entries) => {\n        if (err) return callback(err)\n        this[kCache] = entries\n        this._next(callback)\n      })\n    }\n  }\n\n  _all (options, callback) {\n    this[kFirst] = false\n\n    // TODO: mixing next and all is not covered by test suite\n    const cache = this[kCache].splice(0, this[kCache].length)\n    const size = this.limit - this.count - cache.length\n\n    if (size <= 0) {\n      return this.nextTick(callback, null, cache)\n    }\n\n    this._nextv(size, emptyOptions, (err, entries) => {\n      if (err) return callback(err)\n      if (cache.length > 0) entries = cache.concat(entries)\n      callback(null, entries)\n    })\n  }\n\n  _seek (target, options) {\n    this[kFirst] = true\n    this[kCache] = []\n    this[kFinished] = false\n    this[kPosition] = undefined\n\n    // TODO: not covered by test suite\n    this[kCurrentOptions] = { ...this[kOptions] }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kOptions])\n    } catch (_) {\n      this[kFinished] = true\n      return\n    }\n\n    if (keyRange !== null && !keyRange.includes(target)) {\n      this[kFinished] = true\n    } else if (this[kOptions].reverse) {\n      this[kCurrentOptions].lte = target\n    } else {\n      this[kCurrentOptions].gte = target\n    }\n  }\n}\n\nexports.Iterator = Iterator\n\nfunction maybeCommit (transaction) {\n  // Commit (meaning close) now instead of waiting for auto-commit\n  if (typeof transaction.commit === 'function') {\n    transaction.commit()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}