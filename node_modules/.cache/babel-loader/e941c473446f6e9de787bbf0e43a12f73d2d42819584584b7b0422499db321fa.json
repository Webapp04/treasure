{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CID } from 'multiformats/cid';\nimport { configure } from '../lib/configure.js';\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request';\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js';\nimport { abortSignal } from '../lib/abort-signal.js';\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} options\n */\nexport var createPut = function createPut(codecs, options) {\n  var fn = configure(function (api) {\n    /**\n     * @type {DAGAPI[\"put\"]}\n     */\n    var put = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dagNode) {\n        var options,\n          settings,\n          serialized,\n          storeCodec,\n          controller,\n          signal,\n          res,\n          data,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              settings = _objectSpread({\n                storeCodec: 'dag-cbor',\n                hashAlg: 'sha2-256'\n              }, options);\n              if (!settings.inputCodec) {\n                _context.next = 8;\n                break;\n              }\n              if (dagNode instanceof Uint8Array) {\n                _context.next = 5;\n                break;\n              }\n              throw new Error('Can only inputCodec on raw bytes that can be decoded');\n            case 5:\n              serialized = dagNode;\n              _context.next = 13;\n              break;\n            case 8:\n              _context.next = 10;\n              return codecs.getCodec(settings.storeCodec);\n            case 10:\n              storeCodec = _context.sent;\n              serialized = storeCodec.encode(dagNode);\n              // now we have a serialized form, the server should be told to receive it\n              // in that format\n              settings.inputCodec = settings.storeCodec;\n            case 13:\n              // allow aborting requests on body errors\n              controller = new AbortController();\n              signal = abortSignal(controller.signal, settings.signal);\n              _context.t0 = api;\n              _context.t1 = _objectSpread;\n              _context.t2 = {\n                timeout: settings.timeout,\n                signal: signal,\n                searchParams: toUrlSearchParams(settings)\n              };\n              _context.next = 20;\n              return multipartRequest([serialized], controller, settings.headers);\n            case 20:\n              _context.t3 = _context.sent;\n              _context.t4 = (0, _context.t1)(_context.t2, _context.t3);\n              _context.next = 24;\n              return _context.t0.post.call(_context.t0, 'dag/put', _context.t4);\n            case 24:\n              res = _context.sent;\n              _context.next = 27;\n              return res.json();\n            case 27:\n              data = _context.sent;\n              return _context.abrupt(\"return\", CID.parse(data.Cid['/']));\n            case 29:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function put(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    return put;\n  });\n  return fn(options);\n};","map":{"version":3,"names":["CID","configure","multipartRequest","toUrlSearchParams","abortSignal","createPut","codecs","options","fn","api","put","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","dagNode","settings","serialized","storeCodec","controller","signal","res","data","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","_objectSpread","hashAlg","inputCodec","Uint8Array","Error","getCodec","sent","encode","AbortController","t0","t1","t2","timeout","searchParams","headers","t3","t4","post","call","json","abrupt","parse","Cid","stop","_x","apply"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-http-client/src/dag/put.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { abortSignal } from '../lib/abort-signal.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} options\n */\nexport const createPut = (codecs, options) => {\n  const fn = configure((api) => {\n    /**\n     * @type {DAGAPI[\"put\"]}\n     */\n    const put = async (dagNode, options = {}) => {\n      const settings = {\n        storeCodec: 'dag-cbor',\n        hashAlg: 'sha2-256',\n        ...options\n      }\n\n      let serialized\n\n      if (settings.inputCodec) {\n        // if you supply an inputCodec, we assume you're passing in a raw, encoded\n        // block using that codec, so we'll just pass that on to the server and let\n        // it deal with the decode/encode/store cycle\n        if (!(dagNode instanceof Uint8Array)) {\n          throw new Error('Can only inputCodec on raw bytes that can be decoded')\n        }\n        serialized = dagNode\n      } else {\n        // if you don't supply an inputCodec, we assume you've passed in a JavaScript\n        // object you want to have encoded using storeCodec, so we'll prepare it for\n        // you if we have the codec\n        const storeCodec = await codecs.getCodec(settings.storeCodec)\n        serialized = storeCodec.encode(dagNode)\n        // now we have a serialized form, the server should be told to receive it\n        // in that format\n        settings.inputCodec = settings.storeCodec\n      }\n\n      // allow aborting requests on body errors\n      const controller = new AbortController()\n      const signal = abortSignal(controller.signal, settings.signal)\n\n      const res = await api.post('dag/put', {\n        timeout: settings.timeout,\n        signal,\n        searchParams: toUrlSearchParams(settings),\n        ...(\n          await multipartRequest([serialized], controller, settings.headers)\n        )\n      })\n      const data = await res.json()\n\n      return CID.parse(data.Cid['/'])\n    }\n\n    return put\n  })\n\n  return fn(options)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}