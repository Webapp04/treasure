{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport * as dagPB from '@ipld/dag-pb';\nimport { notFoundError } from 'datastore-core/errors';\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path';\nimport { CID } from 'multiformats/cid';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nvar ERR_NOT_FOUND = notFoundError().code;\nexport var Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nexport function createRefs(_ref) {\n  var repo = _ref.repo,\n    codecs = _ref.codecs,\n    resolve = _ref.resolve,\n    preload = _ref.preload;\n  /**\n   * @type {import('ipfs-core-types/src/refs').API<{}>[\"refs\"]}\n   */\n  function refs(_x) {\n    return _refs.apply(this, arguments);\n  }\n  function _refs() {\n    _refs = _wrapAsyncGenerator(function (ipfsPath) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var controller, signals, rawPaths, paths, _iterator3, _step3, path;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(options.maxDepth === 0)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              if (!(options.edges && options.format && options.format !== Format.default)) {\n                _context.next = 4;\n                break;\n              }\n              throw new Error('Cannot set edges to true and also specify format');\n            case 4:\n              options.format = options.edges ? Format.edges : options.format;\n              if (typeof options.maxDepth !== 'number') {\n                options.maxDepth = options.recursive ? Infinity : 1;\n              }\n              if (options.timeout) {\n                controller = new TimeoutController(options.timeout);\n                signals = [controller.signal];\n                if (options.signal) {\n                  signals.push(options.signal);\n                }\n                options.signal = anySignal(signals);\n              }\n\n              /** @type {(string|CID)[]} */\n              rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n              paths = rawPaths.map(function (p) {\n                return getFullPath(preload, p, options);\n              });\n              _iterator3 = _createForOfIteratorHelper(paths);\n              _context.prev = 10;\n              _iterator3.s();\n            case 12:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 24;\n                break;\n              }\n              path = _step3.value;\n              _context.prev = 14;\n              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(refsStream(resolve, repo, codecs, path, options)), _awaitAsyncGenerator), \"t0\", 16);\n            case 16:\n              _context.next = 22;\n              break;\n            case 18:\n              _context.prev = 18;\n              _context.t1 = _context[\"catch\"](14);\n              _context.next = 22;\n              return {\n                ref: '',\n                err: _context.t1.message\n              };\n            case 22:\n              _context.next = 12;\n              break;\n            case 24:\n              _context.next = 29;\n              break;\n            case 26:\n              _context.prev = 26;\n              _context.t2 = _context[\"catch\"](10);\n              _iterator3.e(_context.t2);\n            case 29:\n              _context.prev = 29;\n              _iterator3.f();\n              return _context.finish(29);\n            case 32:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[10, 26, 29, 32], [14, 18]]);\n      })();\n    });\n    return _refs.apply(this, arguments);\n  }\n  return refs;\n}\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath(preload, ipfsPath, options) {\n  var _toCidAndPath = toCidAndPath(ipfsPath),\n    cid = _toCidAndPath.cid,\n    path = _toCidAndPath.path;\n  if (options.preload !== false) {\n    preload(cid);\n  }\n  return \"/ipfs/\".concat(cid).concat(path || '');\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction refsStream(_x2, _x3, _x4, _x5, _x6) {\n  return _refsStream.apply(this, arguments);\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction _refsStream() {\n  _refsStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resolve, repo, codecs, path, options) {\n    var resPath, _toCidAndPath2, cid, maxDepth, unique, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, obj;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _awaitAsyncGenerator(resolve(path, options));\n        case 2:\n          resPath = _context2.sent;\n          _toCidAndPath2 = toCidAndPath(resPath), cid = _toCidAndPath2.cid;\n          maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n          unique = options.unique || false; // Traverse the DAG, converting it into a stream\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context2.prev = 8;\n          _iterator = _asyncIterator(objectStream(repo, codecs, cid, maxDepth, unique, options));\n        case 10:\n          _context2.next = 12;\n          return _awaitAsyncGenerator(_iterator.next());\n        case 12:\n          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n            _context2.next = 23;\n            break;\n          }\n          obj = _step.value;\n          if (obj.parent) {\n            _context2.next = 16;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 20);\n        case 16:\n          if (!obj.isDuplicate) {\n            _context2.next = 18;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 20);\n        case 18:\n          _context2.next = 20;\n          return {\n            ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n          };\n        case 20:\n          _iteratorAbruptCompletion = false;\n          _context2.next = 10;\n          break;\n        case 23:\n          _context2.next = 29;\n          break;\n        case 25:\n          _context2.prev = 25;\n          _context2.t0 = _context2[\"catch\"](8);\n          _didIteratorError = true;\n          _iteratorError = _context2.t0;\n        case 29:\n          _context2.prev = 29;\n          _context2.prev = 30;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context2.next = 34;\n            break;\n          }\n          _context2.next = 34;\n          return _awaitAsyncGenerator(_iterator.return());\n        case 34:\n          _context2.prev = 34;\n          if (!_didIteratorError) {\n            _context2.next = 37;\n            break;\n          }\n          throw _iteratorError;\n        case 37:\n          return _context2.finish(34);\n        case 38:\n          return _context2.finish(29);\n        case 39:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[8, 25, 29, 39], [30,, 34, 38]]);\n  }));\n  return _refsStream.apply(this, arguments);\n}\nfunction formatLink(srcCid, dstCid) {\n  var linkName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Format.default;\n  var out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nfunction objectStream(_x7, _x8, _x9, _x10, _x11, _x12) {\n  return _objectStream.apply(this, arguments);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nfunction _objectStream() {\n  _objectStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n    var seen, traverseLevel, _traverseLevel;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _traverseLevel = function _traverseLevel3() {\n            _traverseLevel = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(parent, depth) {\n              var nextLevelDepth, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, link;\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    nextLevelDepth = depth + 1; // Check the depth\n                    if (!(nextLevelDepth > maxDepth)) {\n                      _context3.next = 3;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\");\n                  case 3:\n                    _context3.prev = 3;\n                    // Look at each link, parent and the new depth\n                    _iteratorAbruptCompletion2 = false;\n                    _didIteratorError2 = false;\n                    _context3.prev = 6;\n                    _iterator2 = _asyncIterator(getLinks(repo, codecs, parent.cid, options));\n                  case 8:\n                    _context3.next = 10;\n                    return _awaitAsyncGenerator(_iterator2.next());\n                  case 10:\n                    if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {\n                      _context3.next = 19;\n                      break;\n                    }\n                    link = _step2.value;\n                    _context3.next = 14;\n                    return {\n                      parent: parent,\n                      node: link,\n                      isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n                    };\n                  case 14:\n                    if (uniqueOnly) {\n                      seen.add(link.cid.toString());\n                    }\n                    return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(traverseLevel(link, nextLevelDepth)), _awaitAsyncGenerator), \"t0\", 16);\n                  case 16:\n                    _iteratorAbruptCompletion2 = false;\n                    _context3.next = 8;\n                    break;\n                  case 19:\n                    _context3.next = 25;\n                    break;\n                  case 21:\n                    _context3.prev = 21;\n                    _context3.t1 = _context3[\"catch\"](6);\n                    _didIteratorError2 = true;\n                    _iteratorError2 = _context3.t1;\n                  case 25:\n                    _context3.prev = 25;\n                    _context3.prev = 26;\n                    if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                      _context3.next = 30;\n                      break;\n                    }\n                    _context3.next = 30;\n                    return _awaitAsyncGenerator(_iterator2.return());\n                  case 30:\n                    _context3.prev = 30;\n                    if (!_didIteratorError2) {\n                      _context3.next = 33;\n                      break;\n                    }\n                    throw _iteratorError2;\n                  case 33:\n                    return _context3.finish(30);\n                  case 34:\n                    return _context3.finish(25);\n                  case 35:\n                    _context3.next = 41;\n                    break;\n                  case 37:\n                    _context3.prev = 37;\n                    _context3.t2 = _context3[\"catch\"](3);\n                    if (_context3.t2.code === ERR_NOT_FOUND) {\n                      _context3.t2.message = \"Could not find object with CID: \".concat(parent.cid);\n                    }\n                    throw _context3.t2;\n                  case 41:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _callee3, null, [[3, 37], [6, 21, 25, 35], [26,, 30, 34]]);\n            }));\n            return _traverseLevel.apply(this, arguments);\n          };\n          traverseLevel = function _traverseLevel2(_x17, _x18) {\n            return _traverseLevel.apply(this, arguments);\n          };\n          // eslint-disable-line require-await\n          seen = new Set();\n          /**\n           * @param {Node} parent\n           * @param {number} depth\n           * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n           */\n          return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(traverseLevel({\n            cid: rootCid\n          }, 0)), _awaitAsyncGenerator), \"t0\", 4);\n        case 4:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _objectStream.apply(this, arguments);\n}\nfunction getLinks(_x13, _x14, _x15, _x16) {\n  return _getLinks.apply(this, arguments);\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nfunction _getLinks() {\n  _getLinks = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(repo, codecs, cid, options) {\n    var block, codec, value, isDagPb, base, _iterator4, _step4, _step4$value, name, _cid, match, index;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return _awaitAsyncGenerator(repo.blocks.get(cid, options));\n        case 2:\n          block = _context5.sent;\n          _context5.next = 5;\n          return _awaitAsyncGenerator(codecs.getCodec(cid.code));\n        case 5:\n          codec = _context5.sent;\n          value = codec.decode(block);\n          isDagPb = cid.code === dagPB.code;\n          /** @type {Array<string|number>} */\n          base = [];\n          _iterator4 = _createForOfIteratorHelper(links(value, base));\n          _context5.prev = 10;\n          _iterator4.s();\n        case 12:\n          if ((_step4 = _iterator4.n()).done) {\n            _context5.next = 26;\n            break;\n          }\n          _step4$value = _slicedToArray(_step4.value, 2), name = _step4$value[0], _cid = _step4$value[1];\n          if (!isDagPb) {\n            _context5.next = 22;\n            break;\n          }\n          match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n          if (!match) {\n            _context5.next = 22;\n            break;\n          }\n          index = Number(match[1]);\n          if (!(index < value.Links.length)) {\n            _context5.next = 22;\n            break;\n          }\n          _context5.next = 21;\n          return {\n            name: value.Links[index].Name,\n            cid: _cid\n          };\n        case 21:\n          return _context5.abrupt(\"continue\", 24);\n        case 22:\n          _context5.next = 24;\n          return {\n            name: name,\n            cid: _cid\n          };\n        case 24:\n          _context5.next = 12;\n          break;\n        case 26:\n          _context5.next = 31;\n          break;\n        case 28:\n          _context5.prev = 28;\n          _context5.t0 = _context5[\"catch\"](10);\n          _iterator4.e(_context5.t0);\n        case 31:\n          _context5.prev = 31;\n          _iterator4.f();\n          return _context5.finish(31);\n        case 34:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5, null, [[10, 28, 31, 34]]);\n  }));\n  return _getLinks.apply(this, arguments);\n}\nvar links = /*#__PURE__*/_regeneratorRuntime().mark(function links(source, base) {\n  var _i, _Object$entries, _Object$entries$_i, key, value, path, _iterator5, _step5, _step5$value, index, element, elementPath, cid, _cid2;\n  return _regeneratorRuntime().wrap(function links$(_context6) {\n    while (1) switch (_context6.prev = _context6.next) {\n      case 0:\n        if (!(source == null)) {\n          _context6.next = 2;\n          break;\n        }\n        return _context6.abrupt(\"return\");\n      case 2:\n        if (!(source instanceof Uint8Array)) {\n          _context6.next = 4;\n          break;\n        }\n        return _context6.abrupt(\"return\");\n      case 4:\n        _i = 0, _Object$entries = Object.entries(source);\n      case 5:\n        if (!(_i < _Object$entries.length)) {\n          _context6.next = 46;\n          break;\n        }\n        _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];\n        path = [].concat(_toConsumableArray(base), [key]);\n        if (!(value != null && typeof value === 'object')) {\n          _context6.next = 43;\n          break;\n        }\n        if (!Array.isArray(value)) {\n          _context6.next = 36;\n          break;\n        }\n        _iterator5 = _createForOfIteratorHelper(value.entries());\n        _context6.prev = 11;\n        _iterator5.s();\n      case 13:\n        if ((_step5 = _iterator5.n()).done) {\n          _context6.next = 26;\n          break;\n        }\n        _step5$value = _slicedToArray(_step5.value, 2), index = _step5$value[0], element = _step5$value[1];\n        elementPath = [].concat(_toConsumableArray(path), [index]);\n        cid = CID.asCID(element); // eslint-disable-next-line max-depth\n        if (!cid) {\n          _context6.next = 22;\n          break;\n        }\n        _context6.next = 20;\n        return [elementPath.join('/'), cid];\n      case 20:\n        _context6.next = 24;\n        break;\n      case 22:\n        if (!(typeof element === 'object')) {\n          _context6.next = 24;\n          break;\n        }\n        return _context6.delegateYield(links(element, elementPath), \"t0\", 24);\n      case 24:\n        _context6.next = 13;\n        break;\n      case 26:\n        _context6.next = 31;\n        break;\n      case 28:\n        _context6.prev = 28;\n        _context6.t1 = _context6[\"catch\"](11);\n        _iterator5.e(_context6.t1);\n      case 31:\n        _context6.prev = 31;\n        _iterator5.f();\n        return _context6.finish(31);\n      case 34:\n        _context6.next = 43;\n        break;\n      case 36:\n        _cid2 = CID.asCID(value);\n        if (!_cid2) {\n          _context6.next = 42;\n          break;\n        }\n        _context6.next = 40;\n        return [path.join('/'), _cid2];\n      case 40:\n        _context6.next = 43;\n        break;\n      case 42:\n        return _context6.delegateYield(links(value, path), \"t2\", 43);\n      case 43:\n        _i++;\n        _context6.next = 5;\n        break;\n      case 46:\n        return _context6.abrupt(\"return\", []);\n      case 47:\n      case \"end\":\n        return _context6.stop();\n    }\n  }, links, null, [[11, 28, 31, 34]]);\n});","map":{"version":3,"names":["dagPB","notFoundError","toCidAndPath","CID","TimeoutController","anySignal","ERR_NOT_FOUND","code","Format","default","edges","createRefs","_ref","repo","codecs","resolve","preload","refs","_x","_refs","apply","arguments","_wrapAsyncGenerator","ipfsPath","options","length","undefined","_regeneratorRuntime","mark","_callee","controller","signals","rawPaths","paths","_iterator3","_step3","path","wrap","_callee$","_context","prev","next","maxDepth","abrupt","format","Error","recursive","Infinity","timeout","signal","push","Array","isArray","map","p","getFullPath","_createForOfIteratorHelper","s","n","done","value","delegateYield","_asyncGeneratorDelegate","_asyncIterator","refsStream","_awaitAsyncGenerator","t1","ref","err","message","t2","e","f","finish","stop","_toCidAndPath","cid","concat","_x2","_x3","_x4","_x5","_x6","_refsStream","_callee2","resPath","_toCidAndPath2","unique","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","obj","_callee2$","_context2","sent","objectStream","parent","isDuplicate","formatLink","node","name","t0","return","srcCid","dstCid","linkName","out","replace","toString","_x7","_x8","_x9","_x10","_x11","_x12","_objectStream","_callee4","rootCid","uniqueOnly","seen","traverseLevel","_traverseLevel","_callee4$","_context4","_traverseLevel3","_callee3","depth","nextLevelDepth","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","link","_callee3$","_context3","getLinks","has","add","_traverseLevel2","_x17","_x18","Set","_x13","_x14","_x15","_x16","_getLinks","_callee5","block","codec","isDagPb","base","_iterator4","_step4","_step4$value","_cid","match","index","_callee5$","_context5","blocks","get","getCodec","decode","links","_slicedToArray","Number","Links","Name","source","_i","_Object$entries","_Object$entries$_i","key","_iterator5","_step5","_step5$value","element","elementPath","_cid2","links$","_context6","Uint8Array","Object","entries","_toConsumableArray","asCID","join"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/refs/index.js"],"sourcesContent":["import * as dagPB from '@ipld/dag-pb'\nimport { notFoundError } from 'datastore-core/errors'\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path'\nimport { CID } from 'multiformats/cid'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\n\nconst ERR_NOT_FOUND = notFoundError().code\n\nexport const Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nexport function createRefs ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API<{}>[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout)\n      const signals = [controller.signal]\n\n      if (options.signal) {\n        signals.push(options.signal)\n      }\n\n      options.signal = anySignal(signals)\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      try {\n        yield * refsStream(resolve, repo, codecs, path, options)\n      } catch (/** @type {any} */ err) {\n        yield {\n          ref: '',\n          err: err.message\n        }\n      }\n    }\n  }\n\n  return refs\n}\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options)\n  const {\n    cid\n  } = toCidAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly, options) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (/** @type {any} */ err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPB.code\n  /** @type {Array<string|number>} */\n  const base = []\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}