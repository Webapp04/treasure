{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport errCode from 'err-code';\nimport { OPEN, CLOSING, CLOSED } from '@libp2p/interface-connection/status';\nimport { symbol } from '@libp2p/interface-connection';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:connection');\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport var ConnectionImpl = /*#__PURE__*/function (_Symbol$toStringTag) {\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  function ConnectionImpl(init) {\n    _classCallCheck(this, ConnectionImpl);\n    var remoteAddr = init.remoteAddr,\n      remotePeer = init.remotePeer,\n      newStream = init.newStream,\n      close = init.close,\n      getStreams = init.getStreams,\n      stat = init.stat;\n    this.id = \"\".concat(parseInt(String(Math.random() * 1e9)).toString(36)).concat(Date.now());\n    this.remoteAddr = remoteAddr;\n    this.remotePeer = remotePeer;\n    this.stat = _objectSpread(_objectSpread({}, stat), {}, {\n      status: OPEN\n    });\n    this._newStream = newStream;\n    this._close = close;\n    this._getStreams = getStreams;\n    this.tags = [];\n    this._closing = false;\n  }\n  _createClass(ConnectionImpl, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'Connection';\n    }\n  }, {\n    key: symbol,\n    get: function get() {\n      return true;\n    }\n    /**\n     * Get all the streams of the muxer\n     */\n  }, {\n    key: \"streams\",\n    get: function get() {\n      return this._getStreams();\n    }\n    /**\n     * Create a new stream from this connection\n     */\n  }, {\n    key: \"newStream\",\n    value: function () {\n      var _newStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(protocols, options) {\n        var stream;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.stat.status === CLOSING)) {\n                _context.next = 2;\n                break;\n              }\n              throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED');\n            case 2:\n              if (!(this.stat.status === CLOSED)) {\n                _context.next = 4;\n                break;\n              }\n              throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED');\n            case 4:\n              if (!Array.isArray(protocols)) {\n                protocols = [protocols];\n              }\n              _context.next = 7;\n              return this._newStream(protocols, options);\n            case 7:\n              stream = _context.sent;\n              stream.stat.direction = 'outbound';\n              return _context.abrupt(\"return\", stream);\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function newStream(_x, _x2) {\n        return _newStream.apply(this, arguments);\n      }\n      return newStream;\n    }()\n    /**\n     * Add a stream when it is opened to the registry\n     */\n  }, {\n    key: \"addStream\",\n    value: function addStream(stream) {\n      stream.stat.direction = 'inbound';\n    }\n    /**\n     * Remove stream registry after it is closed\n     */\n  }, {\n    key: \"removeStream\",\n    value: function removeStream(id) {}\n    /**\n     * Close the connection\n     */\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this.stat.status === CLOSED || this._closing)) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              this.stat.status = CLOSING;\n              // close all streams - this can throw if we're not multiplexed\n              try {\n                this.streams.forEach(function (s) {\n                  return s.close();\n                });\n              } catch (err) {\n                log.error(err);\n              }\n              // Close raw connection\n              this._closing = true;\n              _context2.next = 7;\n              return this._close();\n            case 7:\n              this._closing = false;\n              this.stat.timeline.close = Date.now();\n              this.stat.status = CLOSED;\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n  }]);\n  return ConnectionImpl;\n}(Symbol.toStringTag);\nexport function createConnection(init) {\n  return new ConnectionImpl(init);\n}","map":{"version":3,"names":["errCode","OPEN","CLOSING","CLOSED","symbol","logger","log","ConnectionImpl","_Symbol$toStringTag","init","_classCallCheck","remoteAddr","remotePeer","newStream","close","getStreams","stat","id","concat","parseInt","String","Math","random","toString","Date","now","_objectSpread","status","_newStream","_close","_getStreams","tags","_closing","_createClass","key","get","value","_asyncToGenerator","_regeneratorRuntime","mark","_callee","protocols","options","stream","wrap","_callee$","_context","prev","next","Error","Array","isArray","sent","direction","abrupt","stop","_x","_x2","apply","arguments","addStream","removeStream","_callee2","_callee2$","_context2","streams","forEach","s","err","error","timeline","Symbol","toStringTag","createConnection"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/connection/src/index.ts"],"sourcesContent":["import type { Multiaddr } from '@multiformats/multiaddr'\nimport errCode from 'err-code'\nimport { OPEN, CLOSING, CLOSED } from '@libp2p/interface-connection/status'\nimport { symbol } from '@libp2p/interface-connection'\nimport type { Connection, ConnectionStat, Stream } from '@libp2p/interface-connection'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { logger } from '@libp2p/logger'\nimport type { AbortOptions } from '@libp2p/interfaces'\n\nconst log = logger('libp2p:connection')\n\ninterface ConnectionInit {\n  remoteAddr: Multiaddr\n  remotePeer: PeerId\n  newStream: (protocols: string[], options?: AbortOptions) => Promise<Stream>\n  close: () => Promise<void>\n  getStreams: () => Stream[]\n  stat: ConnectionStat\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl implements Connection {\n  /**\n   * Connection identifier.\n   */\n  public readonly id: string\n\n  /**\n   * Observed multiaddr of the remote peer\n   */\n  public readonly remoteAddr: Multiaddr\n\n  /**\n   * Remote peer id\n   */\n  public readonly remotePeer: PeerId\n\n  /**\n   * Connection metadata\n   */\n  public readonly stat: ConnectionStat\n\n  /**\n   * User provided tags\n   *\n   */\n  public tags: string[]\n\n  /**\n   * Reference to the new stream function of the multiplexer\n   */\n  private readonly _newStream: (protocols: string[], options?: AbortOptions) => Promise<Stream>\n\n  /**\n   * Reference to the close function of the raw connection\n   */\n  private readonly _close: () => Promise<void>\n\n  /**\n   * Reference to the getStreams function of the muxer\n   */\n  private readonly _getStreams: () => Stream[]\n\n  private _closing: boolean\n\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  constructor (init: ConnectionInit) {\n    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init\n\n    this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`\n    this.remoteAddr = remoteAddr\n    this.remotePeer = remotePeer\n    this.stat = {\n      ...stat,\n      status: OPEN\n    }\n    this._newStream = newStream\n    this._close = close\n    this._getStreams = getStreams\n    this.tags = []\n    this._closing = false\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Connection'\n  }\n\n  get [symbol] () {\n    return true\n  }\n\n  /**\n   * Get all the streams of the muxer\n   */\n  get streams () {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   */\n  async newStream (protocols: string | string[], options?: AbortOptions): Promise<Stream> {\n    if (this.stat.status === CLOSING) {\n      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED')\n    }\n\n    if (this.stat.status === CLOSED) {\n      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED')\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    const stream = await this._newStream(protocols, options)\n\n    stream.stat.direction = 'outbound'\n\n    return stream\n  }\n\n  /**\n   * Add a stream when it is opened to the registry\n   */\n  addStream (stream: Stream) {\n    stream.stat.direction = 'inbound'\n  }\n\n  /**\n   * Remove stream registry after it is closed\n   */\n  removeStream (id: string) {\n\n  }\n\n  /**\n   * Close the connection\n   */\n  async close () {\n    if (this.stat.status === CLOSED || this._closing) {\n      return\n    }\n\n    this.stat.status = CLOSING\n\n    // close all streams - this can throw if we're not multiplexed\n    try {\n      this.streams.forEach(s => s.close())\n    } catch (err) {\n      log.error(err)\n    }\n\n    // Close raw connection\n    this._closing = true\n    await this._close()\n    this._closing = false\n\n    this.stat.timeline.close = Date.now()\n    this.stat.status = CLOSED\n  }\n}\n\nexport function createConnection (init: ConnectionInit): Connection {\n  return new ConnectionImpl(init)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}