{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as mss from '@libp2p/multistream-select';\nimport { pipe } from 'it-pipe';\n// @ts-expect-error mutable-proxy does not export types\nimport mutableProxy from 'mutable-proxy';\nimport { codes } from './errors.js';\nimport { createConnection } from '@libp2p/connection';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { isInitializable } from '@libp2p/components';\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { setMaxListeners } from 'events';\nvar log = logger('libp2p:upgrader');\nfunction findIncomingStreamLimit(protocol, registrar) {\n  try {\n    var _registrar$getHandler = registrar.getHandler(protocol),\n      options = _registrar$getHandler.options;\n    return options.maxInboundStreams;\n  } catch (err) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err;\n    }\n  }\n  return DEFAULT_MAX_INBOUND_STREAMS;\n}\nfunction findOutgoingStreamLimit(protocol, registrar) {\n  try {\n    var _registrar$getHandler2 = registrar.getHandler(protocol),\n      options = _registrar$getHandler2.options;\n    return options.maxOutboundStreams;\n  } catch (err) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err;\n    }\n  }\n  return DEFAULT_MAX_OUTBOUND_STREAMS;\n}\nfunction countStreams(protocol, direction, connection) {\n  var streamCount = 0;\n  connection.streams.forEach(function (stream) {\n    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {\n      streamCount++;\n    }\n  });\n  return streamCount;\n}\nexport var DefaultUpgrader = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(DefaultUpgrader, _EventEmitter);\n  var _super = _createSuper(DefaultUpgrader);\n  function DefaultUpgrader(components, init) {\n    var _this;\n    _classCallCheck(this, DefaultUpgrader);\n    _this = _super.call(this);\n    _this.components = components;\n    _this.connectionEncryption = new Map();\n    init.connectionEncryption.forEach(function (encrypter) {\n      _this.connectionEncryption.set(encrypter.protocol, encrypter);\n    });\n    _this.muxers = new Map();\n    init.muxers.forEach(function (muxer) {\n      _this.muxers.set(muxer.protocol, muxer);\n    });\n    _this.inboundUpgradeTimeout = init.inboundUpgradeTimeout;\n    return _this;\n  }\n  /**\n   * Upgrades an inbound connection\n   */\n  _createClass(DefaultUpgrader, [{\n    key: \"upgradeInbound\",\n    value: function () {\n      var _upgradeInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(maConn) {\n        var encryptedConn, remotePeer, upgradedConn, muxerFactory, cryptoProtocol, setPeer, proxyPeer, metrics, timeoutController, abortableStream, _mutableProxy, idString, protectedConn, protector, _yield$this$_encryptI, multiplexed;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              metrics = this.components.getMetrics();\n              timeoutController = new TimeoutController(this.inboundUpgradeTimeout);\n              try {\n                // fails on node < 15.4\n                setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, timeoutController.signal);\n              } catch (_unused) {}\n              _context.prev = 3;\n              abortableStream = abortableDuplex(maConn, timeoutController.signal);\n              maConn.source = abortableStream.source;\n              maConn.sink = abortableStream.sink;\n              _context.next = 9;\n              return this.components.getConnectionGater().denyInboundConnection(maConn);\n            case 9:\n              if (!_context.sent) {\n                _context.next = 11;\n                break;\n              }\n              throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n            case 11:\n              if (metrics != null) {\n                _mutableProxy = mutableProxy();\n                setPeer = _mutableProxy.setTarget;\n                proxyPeer = _mutableProxy.proxy;\n                idString = \"\".concat((Math.random() * 1e9).toString(36)).concat(Date.now());\n                setPeer({\n                  toString: function toString() {\n                    return idString;\n                  }\n                });\n                metrics.trackStream({\n                  stream: maConn,\n                  remotePeer: proxyPeer\n                });\n              }\n              log('starting the inbound connection upgrade');\n              // Protect\n              protectedConn = maConn;\n              protector = this.components.getConnectionProtector();\n              if (!(protector != null)) {\n                _context.next = 20;\n                break;\n              }\n              log('protecting the inbound connection');\n              _context.next = 19;\n              return protector.protect(maConn);\n            case 19:\n              protectedConn = _context.sent;\n            case 20:\n              _context.prev = 20;\n              _context.next = 23;\n              return this._encryptInbound(protectedConn);\n            case 23:\n              _yield$this$_encryptI = _context.sent;\n              encryptedConn = _yield$this$_encryptI.conn;\n              remotePeer = _yield$this$_encryptI.remotePeer;\n              cryptoProtocol = _yield$this$_encryptI.protocol;\n              _context.next = 29;\n              return this.components.getConnectionGater().denyInboundEncryptedConnection(remotePeer, _objectSpread(_objectSpread({}, protectedConn), encryptedConn));\n            case 29:\n              if (!_context.sent) {\n                _context.next = 31;\n                break;\n              }\n              throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n            case 31:\n              if (!(this.muxers.size > 0)) {\n                _context.next = 39;\n                break;\n              }\n              _context.next = 34;\n              return this._multiplexInbound(_objectSpread(_objectSpread({}, protectedConn), encryptedConn), this.muxers);\n            case 34:\n              multiplexed = _context.sent;\n              muxerFactory = multiplexed.muxerFactory;\n              upgradedConn = multiplexed.stream;\n              _context.next = 40;\n              break;\n            case 39:\n              upgradedConn = encryptedConn;\n            case 40:\n              _context.next = 48;\n              break;\n            case 42:\n              _context.prev = 42;\n              _context.t0 = _context[\"catch\"](20);\n              log.error('Failed to upgrade inbound connection', _context.t0);\n              _context.next = 47;\n              return maConn.close(_context.t0);\n            case 47:\n              throw _context.t0;\n            case 48:\n              _context.next = 50;\n              return this.components.getConnectionGater().denyInboundUpgradedConnection(remotePeer, _objectSpread(_objectSpread({}, protectedConn), encryptedConn));\n            case 50:\n              if (!_context.sent) {\n                _context.next = 52;\n                break;\n              }\n              throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n            case 52:\n              if (metrics != null) {\n                metrics.updatePlaceholder(proxyPeer, remotePeer);\n                setPeer(remotePeer);\n              }\n              log('Successfully upgraded inbound connection');\n              return _context.abrupt(\"return\", this._createConnection({\n                cryptoProtocol: cryptoProtocol,\n                direction: 'inbound',\n                maConn: maConn,\n                upgradedConn: upgradedConn,\n                muxerFactory: muxerFactory,\n                remotePeer: remotePeer\n              }));\n            case 55:\n              _context.prev = 55;\n              timeoutController.clear();\n              return _context.finish(55);\n            case 58:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3,, 55, 58], [20, 42]]);\n      }));\n      function upgradeInbound(_x) {\n        return _upgradeInbound.apply(this, arguments);\n      }\n      return upgradeInbound;\n    }()\n    /**\n     * Upgrades an outbound connection\n     */\n  }, {\n    key: \"upgradeOutbound\",\n    value: function () {\n      var _upgradeOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(maConn) {\n        var idStr, remotePeerId, encryptedConn, remotePeer, upgradedConn, cryptoProtocol, muxerFactory, setPeer, proxyPeer, metrics, _mutableProxy2, idString, protectedConn, protector, _yield$this$_encryptO, multiplexed;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              idStr = maConn.remoteAddr.getPeerId();\n              if (!(idStr == null)) {\n                _context2.next = 3;\n                break;\n              }\n              throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n            case 3:\n              remotePeerId = peerIdFromString(idStr);\n              _context2.next = 6;\n              return this.components.getConnectionGater().denyOutboundConnection(remotePeerId, maConn);\n            case 6:\n              if (!_context2.sent) {\n                _context2.next = 8;\n                break;\n              }\n              throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n            case 8:\n              metrics = this.components.getMetrics();\n              if (metrics != null) {\n                _mutableProxy2 = mutableProxy();\n                setPeer = _mutableProxy2.setTarget;\n                proxyPeer = _mutableProxy2.proxy;\n                idString = \"\".concat((Math.random() * 1e9).toString(36)).concat(Date.now());\n                setPeer({\n                  toB58String: function toB58String() {\n                    return idString;\n                  }\n                });\n                metrics.trackStream({\n                  stream: maConn,\n                  remotePeer: proxyPeer\n                });\n              }\n              log('Starting the outbound connection upgrade');\n              // Protect\n              protectedConn = maConn;\n              protector = this.components.getConnectionProtector();\n              if (!(protector != null)) {\n                _context2.next = 17;\n                break;\n              }\n              _context2.next = 16;\n              return protector.protect(maConn);\n            case 16:\n              protectedConn = _context2.sent;\n            case 17:\n              _context2.prev = 17;\n              _context2.next = 20;\n              return this._encryptOutbound(protectedConn, remotePeerId);\n            case 20:\n              _yield$this$_encryptO = _context2.sent;\n              encryptedConn = _yield$this$_encryptO.conn;\n              remotePeer = _yield$this$_encryptO.remotePeer;\n              cryptoProtocol = _yield$this$_encryptO.protocol;\n              _context2.next = 26;\n              return this.components.getConnectionGater().denyOutboundEncryptedConnection(remotePeer, _objectSpread(_objectSpread({}, protectedConn), encryptedConn));\n            case 26:\n              if (!_context2.sent) {\n                _context2.next = 28;\n                break;\n              }\n              throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n            case 28:\n              if (!(this.muxers.size > 0)) {\n                _context2.next = 36;\n                break;\n              }\n              _context2.next = 31;\n              return this._multiplexOutbound(_objectSpread(_objectSpread({}, protectedConn), encryptedConn), this.muxers);\n            case 31:\n              multiplexed = _context2.sent;\n              muxerFactory = multiplexed.muxerFactory;\n              upgradedConn = multiplexed.stream;\n              _context2.next = 37;\n              break;\n            case 36:\n              upgradedConn = encryptedConn;\n            case 37:\n              _context2.next = 45;\n              break;\n            case 39:\n              _context2.prev = 39;\n              _context2.t0 = _context2[\"catch\"](17);\n              log.error('Failed to upgrade outbound connection', _context2.t0);\n              _context2.next = 44;\n              return maConn.close(_context2.t0);\n            case 44:\n              throw _context2.t0;\n            case 45:\n              _context2.next = 47;\n              return this.components.getConnectionGater().denyOutboundUpgradedConnection(remotePeer, _objectSpread(_objectSpread({}, protectedConn), encryptedConn));\n            case 47:\n              if (!_context2.sent) {\n                _context2.next = 49;\n                break;\n              }\n              throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n            case 49:\n              if (metrics != null) {\n                metrics.updatePlaceholder(proxyPeer, remotePeer);\n                setPeer(remotePeer);\n              }\n              log('Successfully upgraded outbound connection');\n              return _context2.abrupt(\"return\", this._createConnection({\n                cryptoProtocol: cryptoProtocol,\n                direction: 'outbound',\n                maConn: maConn,\n                upgradedConn: upgradedConn,\n                muxerFactory: muxerFactory,\n                remotePeer: remotePeer\n              }));\n            case 52:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[17, 39]]);\n      }));\n      function upgradeOutbound(_x2) {\n        return _upgradeOutbound.apply(this, arguments);\n      }\n      return upgradeOutbound;\n    }()\n    /**\n     * A convenience method for generating a new `Connection`\n     */\n  }, {\n    key: \"_createConnection\",\n    value: function _createConnection(opts) {\n      var _this2 = this,\n        _muxer,\n        _newStream;\n      var cryptoProtocol = opts.cryptoProtocol,\n        direction = opts.direction,\n        maConn = opts.maConn,\n        upgradedConn = opts.upgradedConn,\n        remotePeer = opts.remotePeer,\n        muxerFactory = opts.muxerFactory;\n      var muxer;\n      var newStream;\n      var connection; // eslint-disable-line prefer-const\n      if (muxerFactory != null) {\n        // Create the muxer\n        muxer = muxerFactory.createStreamMuxer({\n          direction: direction,\n          // Run anytime a remote stream is created\n          onIncomingStream: function onIncomingStream(muxedStream) {\n            if (connection == null) {\n              return;\n            }\n            void Promise.resolve().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n              var protocols, _yield$mss$handle, stream, protocol, metrics, incomingLimit, streamCount;\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    protocols = _this2.components.getRegistrar().getProtocols();\n                    _context3.next = 3;\n                    return mss.handle(muxedStream, protocols);\n                  case 3:\n                    _yield$mss$handle = _context3.sent;\n                    stream = _yield$mss$handle.stream;\n                    protocol = _yield$mss$handle.protocol;\n                    log('%s: incoming stream opened on %s', direction, protocol);\n                    metrics = _this2.components.getMetrics();\n                    if (metrics != null) {\n                      metrics.trackStream({\n                        stream: stream,\n                        remotePeer: remotePeer,\n                        protocol: protocol\n                      });\n                    }\n                    if (!(connection == null)) {\n                      _context3.next = 11;\n                      break;\n                    }\n                    return _context3.abrupt(\"return\");\n                  case 11:\n                    incomingLimit = findIncomingStreamLimit(protocol, _this2.components.getRegistrar());\n                    streamCount = countStreams(protocol, 'inbound', connection);\n                    if (!(streamCount === incomingLimit)) {\n                      _context3.next = 16;\n                      break;\n                    }\n                    muxedStream.abort(errCode(new Error(\"Too many inbound protocol streams for protocol \\\"\".concat(protocol, \"\\\" - limit \").concat(incomingLimit)), codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));\n                    return _context3.abrupt(\"return\");\n                  case 16:\n                    // after the handshake the returned stream can have early data so override\n                    // the souce/sink\n                    muxedStream.source = stream.source;\n                    muxedStream.sink = stream.sink;\n                    muxedStream.stat.protocol = protocol;\n                    // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                    // the peerstore should ensure that the peer is registered with that protocol\n                    _this2.components.getPeerStore().protoBook.add(remotePeer, [protocol]).catch(function (err) {\n                      return log.error(err);\n                    });\n                    connection.addStream(muxedStream);\n                    _this2._onStream({\n                      connection: connection,\n                      stream: muxedStream,\n                      protocol: protocol\n                    });\n                  case 22:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _callee3);\n            }))).catch(function (err) {\n              log.error(err);\n              if (muxedStream.stat.timeline.close == null) {\n                muxedStream.close();\n              }\n            });\n          },\n          // Run anytime a stream closes\n          onStreamEnd: function onStreamEnd(muxedStream) {\n            var _connection;\n            (_connection = connection) === null || _connection === void 0 ? void 0 : _connection.removeStream(muxedStream.id);\n          }\n        });\n        if (isInitializable(muxer)) {\n          muxer.init(this.components);\n        }\n        newStream = /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(protocols) {\n            var options,\n              muxedStream,\n              metrics,\n              controller,\n              _yield$mss$select,\n              stream,\n              protocol,\n              outgoingLimit,\n              streamCount,\n              err,\n              _args4 = arguments;\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                  if (!(muxer == null)) {\n                    _context4.next = 3;\n                    break;\n                  }\n                  throw errCode(new Error('Stream is not multiplexed'), codes.ERR_MUXER_UNAVAILABLE);\n                case 3:\n                  log('%s: starting new stream on %s', direction, protocols);\n                  muxedStream = muxer.newStream();\n                  metrics = _this2.components.getMetrics();\n                  _context4.prev = 6;\n                  if (options.signal == null) {\n                    log('No abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols);\n                    controller = new TimeoutController(30000);\n                    options.signal = controller.signal;\n                    try {\n                      // fails on node < 15.4\n                      setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, controller.signal);\n                    } catch (_unused2) {}\n                  }\n                  _context4.next = 10;\n                  return mss.select(muxedStream, protocols, options);\n                case 10:\n                  _yield$mss$select = _context4.sent;\n                  stream = _yield$mss$select.stream;\n                  protocol = _yield$mss$select.protocol;\n                  if (metrics != null) {\n                    metrics.trackStream({\n                      stream: stream,\n                      remotePeer: remotePeer,\n                      protocol: protocol\n                    });\n                  }\n                  outgoingLimit = findOutgoingStreamLimit(protocol, _this2.components.getRegistrar());\n                  streamCount = countStreams(protocol, 'outbound', connection);\n                  if (!(streamCount === outgoingLimit)) {\n                    _context4.next = 20;\n                    break;\n                  }\n                  err = errCode(new Error(\"Too many outbound protocol streams for protocol \\\"\".concat(protocol, \"\\\" - limit \").concat(outgoingLimit)), codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);\n                  muxedStream.abort(err);\n                  throw err;\n                case 20:\n                  // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                  // the peerstore should ensure that the peer is registered with that protocol\n                  _this2.components.getPeerStore().protoBook.add(remotePeer, [protocol]).catch(function (err) {\n                    return log.error(err);\n                  });\n                  // after the handshake the returned stream can have early data so override\n                  // the souce/sink\n                  muxedStream.source = stream.source;\n                  muxedStream.sink = stream.sink;\n                  muxedStream.stat.protocol = protocol;\n                  return _context4.abrupt(\"return\", muxedStream);\n                case 27:\n                  _context4.prev = 27;\n                  _context4.t0 = _context4[\"catch\"](6);\n                  log.error('could not create new stream', _context4.t0);\n                  if (muxedStream.stat.timeline.close == null) {\n                    muxedStream.close();\n                  }\n                  if (!(_context4.t0.code != null)) {\n                    _context4.next = 33;\n                    break;\n                  }\n                  throw _context4.t0;\n                case 33:\n                  throw errCode(_context4.t0, codes.ERR_UNSUPPORTED_PROTOCOL);\n                case 34:\n                  _context4.prev = 34;\n                  if (controller != null) {\n                    controller.clear();\n                  }\n                  return _context4.finish(34);\n                case 37:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4, null, [[6, 27, 34, 37]]);\n          }));\n          return function newStream(_x3) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n        // Pipe all data through the muxer\n        pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n      }\n      var _timeline = maConn.timeline;\n      maConn.timeline = new Proxy(_timeline, {\n        set: function set() {\n          if (connection != null && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) != null && _timeline.close == null) {\n            // Wait for close to finish before notifying of the closure\n            _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n              return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                while (1) switch (_context5.prev = _context5.next) {\n                  case 0:\n                    _context5.prev = 0;\n                    if (!(connection.stat.status === 'OPEN')) {\n                      _context5.next = 4;\n                      break;\n                    }\n                    _context5.next = 4;\n                    return connection.close();\n                  case 4:\n                    _context5.next = 9;\n                    break;\n                  case 6:\n                    _context5.prev = 6;\n                    _context5.t0 = _context5[\"catch\"](0);\n                    log.error(_context5.t0);\n                  case 9:\n                    _context5.prev = 9;\n                    _this2.dispatchEvent(new CustomEvent('connectionEnd', {\n                      detail: connection\n                    }));\n                    return _context5.finish(9);\n                  case 12:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }, _callee5, null, [[0, 6, 9, 12]]);\n            }))().catch(function (err) {\n              log.error(err);\n            });\n          }\n          return Reflect.set.apply(Reflect, arguments);\n        }\n      });\n      maConn.timeline.upgraded = Date.now();\n      var errConnectionNotMultiplexed = function errConnectionNotMultiplexed() {\n        throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n      };\n      // Create the connection\n      connection = createConnection({\n        remoteAddr: maConn.remoteAddr,\n        remotePeer: remotePeer,\n        stat: {\n          status: 'OPEN',\n          direction: direction,\n          timeline: maConn.timeline,\n          multiplexer: (_muxer = muxer) === null || _muxer === void 0 ? void 0 : _muxer.protocol,\n          encryption: cryptoProtocol\n        },\n        newStream: (_newStream = newStream) !== null && _newStream !== void 0 ? _newStream : errConnectionNotMultiplexed,\n        getStreams: function getStreams() {\n          return muxer != null ? muxer.streams : errConnectionNotMultiplexed();\n        },\n        close: function () {\n          var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n            return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n              while (1) switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.next = 2;\n                  return maConn.close();\n                case 2:\n                  // Ensure remaining streams are closed\n                  if (muxer != null) {\n                    muxer.close();\n                  }\n                case 3:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }, _callee6);\n          }));\n          function close() {\n            return _close.apply(this, arguments);\n          }\n          return close;\n        }()\n      });\n      this.dispatchEvent(new CustomEvent('connection', {\n        detail: connection\n      }));\n      return connection;\n    }\n    /**\n     * Routes incoming streams to the correct handler\n     */\n  }, {\n    key: \"_onStream\",\n    value: function _onStream(opts) {\n      var connection = opts.connection,\n        stream = opts.stream,\n        protocol = opts.protocol;\n      var _this$components$getR = this.components.getRegistrar().getHandler(protocol),\n        handler = _this$components$getR.handler;\n      handler({\n        connection: connection,\n        stream: stream\n      });\n    }\n    /**\n     * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n     */\n  }, {\n    key: \"_encryptInbound\",\n    value: function () {\n      var _encryptInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(connection) {\n        var protocols, _yield$mss$handle2, stream, protocol, encrypter;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              protocols = Array.from(this.connectionEncryption.keys());\n              log('handling inbound crypto protocol selection', protocols);\n              _context7.prev = 2;\n              _context7.next = 5;\n              return mss.handle(connection, protocols, {\n                writeBytes: true\n              });\n            case 5:\n              _yield$mss$handle2 = _context7.sent;\n              stream = _yield$mss$handle2.stream;\n              protocol = _yield$mss$handle2.protocol;\n              encrypter = this.connectionEncryption.get(protocol);\n              if (!(encrypter == null)) {\n                _context7.next = 11;\n                break;\n              }\n              throw new Error(\"no crypto module found for \".concat(protocol));\n            case 11:\n              log('encrypting inbound connection...');\n              _context7.t0 = _objectSpread;\n              _context7.t1 = _objectSpread;\n              _context7.t2 = {};\n              _context7.next = 17;\n              return encrypter.secureInbound(this.components.getPeerId(), stream);\n            case 17:\n              _context7.t3 = _context7.sent;\n              _context7.t4 = (0, _context7.t1)(_context7.t2, _context7.t3);\n              _context7.t5 = {};\n              _context7.t6 = {\n                protocol: protocol\n              };\n              return _context7.abrupt(\"return\", (0, _context7.t0)(_context7.t4, _context7.t5, _context7.t6));\n            case 24:\n              _context7.prev = 24;\n              _context7.t7 = _context7[\"catch\"](2);\n              throw errCode(_context7.t7, codes.ERR_ENCRYPTION_FAILED);\n            case 27:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[2, 24]]);\n      }));\n      function _encryptInbound(_x4) {\n        return _encryptInbound2.apply(this, arguments);\n      }\n      return _encryptInbound;\n    }()\n    /**\n     * Attempts to encrypt the given `connection` with the provided connection encrypters.\n     * The first `ConnectionEncrypter` module to succeed will be used\n     */\n  }, {\n    key: \"_encryptOutbound\",\n    value: function () {\n      var _encryptOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(connection, remotePeerId) {\n        var protocols, _yield$mss$select2, stream, protocol, encrypter;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              protocols = Array.from(this.connectionEncryption.keys());\n              log('selecting outbound crypto protocol', protocols);\n              _context8.prev = 2;\n              _context8.next = 5;\n              return mss.select(connection, protocols, {\n                writeBytes: true\n              });\n            case 5:\n              _yield$mss$select2 = _context8.sent;\n              stream = _yield$mss$select2.stream;\n              protocol = _yield$mss$select2.protocol;\n              encrypter = this.connectionEncryption.get(protocol);\n              if (!(encrypter == null)) {\n                _context8.next = 11;\n                break;\n              }\n              throw new Error(\"no crypto module found for \".concat(protocol));\n            case 11:\n              log('encrypting outbound connection to %p', remotePeerId);\n              _context8.t0 = _objectSpread;\n              _context8.t1 = _objectSpread;\n              _context8.t2 = {};\n              _context8.next = 17;\n              return encrypter.secureOutbound(this.components.getPeerId(), stream, remotePeerId);\n            case 17:\n              _context8.t3 = _context8.sent;\n              _context8.t4 = (0, _context8.t1)(_context8.t2, _context8.t3);\n              _context8.t5 = {};\n              _context8.t6 = {\n                protocol: protocol\n              };\n              return _context8.abrupt(\"return\", (0, _context8.t0)(_context8.t4, _context8.t5, _context8.t6));\n            case 24:\n              _context8.prev = 24;\n              _context8.t7 = _context8[\"catch\"](2);\n              throw errCode(_context8.t7, codes.ERR_ENCRYPTION_FAILED);\n            case 27:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 24]]);\n      }));\n      function _encryptOutbound(_x5, _x6) {\n        return _encryptOutbound2.apply(this, arguments);\n      }\n      return _encryptOutbound;\n    }()\n    /**\n     * Selects one of the given muxers via multistream-select. That\n     * muxer will be used for all future streams on the connection.\n     */\n  }, {\n    key: \"_multiplexOutbound\",\n    value: function () {\n      var _multiplexOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(connection, muxers) {\n        var protocols, _yield$mss$select3, stream, protocol, muxerFactory;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              protocols = Array.from(muxers.keys());\n              log('outbound selecting muxer %s', protocols);\n              _context9.prev = 2;\n              _context9.next = 5;\n              return mss.select(connection, protocols, {\n                writeBytes: true\n              });\n            case 5:\n              _yield$mss$select3 = _context9.sent;\n              stream = _yield$mss$select3.stream;\n              protocol = _yield$mss$select3.protocol;\n              log('%s selected as muxer protocol', protocol);\n              muxerFactory = muxers.get(protocol);\n              return _context9.abrupt(\"return\", {\n                stream: stream,\n                muxerFactory: muxerFactory\n              });\n            case 13:\n              _context9.prev = 13;\n              _context9.t0 = _context9[\"catch\"](2);\n              log.error('error multiplexing outbound stream', _context9.t0);\n              throw errCode(_context9.t0, codes.ERR_MUXER_UNAVAILABLE);\n            case 17:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, null, [[2, 13]]);\n      }));\n      function _multiplexOutbound(_x7, _x8) {\n        return _multiplexOutbound2.apply(this, arguments);\n      }\n      return _multiplexOutbound;\n    }()\n    /**\n     * Registers support for one of the given muxers via multistream-select. The\n     * selected muxer will be used for all future streams on the connection.\n     */\n  }, {\n    key: \"_multiplexInbound\",\n    value: function () {\n      var _multiplexInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(connection, muxers) {\n        var protocols, _yield$mss$handle3, stream, protocol, muxerFactory;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              protocols = Array.from(muxers.keys());\n              log('inbound handling muxers %s', protocols);\n              _context10.prev = 2;\n              _context10.next = 5;\n              return mss.handle(connection, protocols, {\n                writeBytes: true\n              });\n            case 5:\n              _yield$mss$handle3 = _context10.sent;\n              stream = _yield$mss$handle3.stream;\n              protocol = _yield$mss$handle3.protocol;\n              muxerFactory = muxers.get(protocol);\n              return _context10.abrupt(\"return\", {\n                stream: stream,\n                muxerFactory: muxerFactory\n              });\n            case 12:\n              _context10.prev = 12;\n              _context10.t0 = _context10[\"catch\"](2);\n              log.error('error multiplexing inbound stream', _context10.t0);\n              throw errCode(_context10.t0, codes.ERR_MUXER_UNAVAILABLE);\n            case 16:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, null, [[2, 12]]);\n      }));\n      function _multiplexInbound(_x9, _x10) {\n        return _multiplexInbound2.apply(this, arguments);\n      }\n      return _multiplexInbound;\n    }()\n  }]);\n  return DefaultUpgrader;\n}(EventEmitter);","map":{"version":3,"names":["logger","errCode","mss","pipe","mutableProxy","codes","createConnection","CustomEvent","EventEmitter","peerIdFromString","isInitializable","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","TimeoutController","abortableDuplex","setMaxListeners","log","findIncomingStreamLimit","protocol","registrar","_registrar$getHandler","getHandler","options","maxInboundStreams","err","code","ERR_NO_HANDLER_FOR_PROTOCOL","findOutgoingStreamLimit","_registrar$getHandler2","maxOutboundStreams","countStreams","direction","connection","streamCount","streams","forEach","stream","stat","DefaultUpgrader","_EventEmitter","_inherits","_super","_createSuper","components","init","_this","_classCallCheck","call","connectionEncryption","Map","encrypter","set","muxers","muxer","inboundUpgradeTimeout","_createClass","key","value","_upgradeInbound","_asyncToGenerator","_regeneratorRuntime","mark","_callee","maConn","encryptedConn","remotePeer","upgradedConn","muxerFactory","cryptoProtocol","setPeer","proxyPeer","metrics","timeoutController","abortableStream","_mutableProxy","idString","protectedConn","protector","_yield$this$_encryptI","multiplexed","wrap","_callee$","_context","prev","next","getMetrics","Infinity","signal","_unused","source","sink","getConnectionGater","denyInboundConnection","sent","Error","ERR_CONNECTION_INTERCEPTED","setTarget","proxy","concat","Math","random","toString","Date","now","trackStream","getConnectionProtector","protect","_encryptInbound","conn","denyInboundEncryptedConnection","_objectSpread","size","_multiplexInbound","t0","error","close","denyInboundUpgradedConnection","updatePlaceholder","abrupt","_createConnection","clear","finish","stop","upgradeInbound","_x","apply","arguments","_upgradeOutbound","_callee2","idStr","remotePeerId","_mutableProxy2","_yield$this$_encryptO","_callee2$","_context2","remoteAddr","getPeerId","ERR_INVALID_MULTIADDR","denyOutboundConnection","toB58String","_encryptOutbound","denyOutboundEncryptedConnection","_multiplexOutbound","denyOutboundUpgradedConnection","upgradeOutbound","_x2","opts","_this2","_muxer","_newStream","newStream","createStreamMuxer","onIncomingStream","muxedStream","Promise","resolve","then","_callee3","protocols","_yield$mss$handle","incomingLimit","_callee3$","_context3","getRegistrar","getProtocols","handle","abort","ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS","getPeerStore","protoBook","add","catch","addStream","_onStream","timeline","onStreamEnd","_connection","removeStream","id","_ref2","_callee4","controller","_yield$mss$select","outgoingLimit","_args4","_callee4$","_context4","length","undefined","ERR_MUXER_UNAVAILABLE","_unused2","select","ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS","ERR_UNSUPPORTED_PROTOCOL","_x3","_timeline","Proxy","_callee5","_callee5$","_context5","status","dispatchEvent","detail","Reflect","upgraded","errConnectionNotMultiplexed","ERR_CONNECTION_NOT_MULTIPLEXED","multiplexer","encryption","getStreams","_close","_callee6","_callee6$","_context6","_this$components$getR","handler","_encryptInbound2","_callee7","_yield$mss$handle2","_callee7$","_context7","Array","from","keys","writeBytes","get","t1","t2","secureInbound","t3","t4","t5","t6","t7","ERR_ENCRYPTION_FAILED","_x4","_encryptOutbound2","_callee8","_yield$mss$select2","_callee8$","_context8","secureOutbound","_x5","_x6","_multiplexOutbound2","_callee9","_yield$mss$select3","_callee9$","_context9","_x7","_x8","_multiplexInbound2","_callee10","_yield$mss$handle3","_callee10$","_context10","_x9","_x10"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/upgrader.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport * as mss from '@libp2p/multistream-select'\nimport { pipe } from 'it-pipe'\n// @ts-expect-error mutable-proxy does not export types\nimport mutableProxy from 'mutable-proxy'\nimport { codes } from './errors.js'\nimport { createConnection } from '@libp2p/connection'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { MultiaddrConnection, Connection, Stream } from '@libp2p/interface-connection'\nimport type { ConnectionEncrypter, SecuredConnection } from '@libp2p/interface-connection-encrypter'\nimport type { StreamMuxer, StreamMuxerFactory } from '@libp2p/interface-stream-muxer'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Upgrader, UpgraderEvents } from '@libp2p/interface-transport'\nimport type { Duplex } from 'it-stream-types'\nimport { Components, isInitializable } from '@libp2p/components'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Registrar } from '@libp2p/interface-registrar'\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { setMaxListeners } from 'events'\n\nconst log = logger('libp2p:upgrader')\n\ninterface CreateConectionOptions {\n  cryptoProtocol: string\n  direction: 'inbound' | 'outbound'\n  maConn: MultiaddrConnection\n  upgradedConn: Duplex<Uint8Array>\n  remotePeer: PeerId\n  muxerFactory?: StreamMuxerFactory\n}\n\ninterface OnStreamOptions {\n  connection: Connection\n  stream: Stream\n  protocol: string\n}\n\nexport interface CryptoResult extends SecuredConnection {\n  protocol: string\n}\n\nexport interface UpgraderInit {\n  connectionEncryption: ConnectionEncrypter[]\n  muxers: StreamMuxerFactory[]\n\n  /**\n   * An amount of ms by which an inbound connection upgrade\n   * must complete\n   */\n  inboundUpgradeTimeout: number\n}\n\nfunction findIncomingStreamLimit (protocol: string, registrar: Registrar) {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxInboundStreams\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS\n}\n\nfunction findOutgoingStreamLimit (protocol: string, registrar: Registrar) {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxOutboundStreams\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_OUTBOUND_STREAMS\n}\n\nfunction countStreams (protocol: string, direction: 'inbound' | 'outbound', connection: Connection) {\n  let streamCount = 0\n\n  connection.streams.forEach(stream => {\n    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {\n      streamCount++\n    }\n  })\n\n  return streamCount\n}\n\nexport class DefaultUpgrader extends EventEmitter<UpgraderEvents> implements Upgrader {\n  private readonly components: Components\n  private readonly connectionEncryption: Map<string, ConnectionEncrypter>\n  private readonly muxers: Map<string, StreamMuxerFactory>\n  private readonly inboundUpgradeTimeout: number\n\n  constructor (components: Components, init: UpgraderInit) {\n    super()\n\n    this.components = components\n    this.connectionEncryption = new Map()\n\n    init.connectionEncryption.forEach(encrypter => {\n      this.connectionEncryption.set(encrypter.protocol, encrypter)\n    })\n\n    this.muxers = new Map()\n\n    init.muxers.forEach(muxer => {\n      this.muxers.set(muxer.protocol, muxer)\n    })\n\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout\n  }\n\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound (maConn: MultiaddrConnection): Promise<Connection> {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn: Duplex<Uint8Array>\n    let muxerFactory: StreamMuxerFactory | undefined\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n    const metrics = this.components.getMetrics()\n\n    const timeoutController = new TimeoutController(this.inboundUpgradeTimeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal)\n    } catch {}\n\n    try {\n      const abortableStream = abortableDuplex(maConn, timeoutController.signal)\n      maConn.source = abortableStream.source\n      maConn.sink = abortableStream.sink\n\n      if (await this.components.getConnectionGater().denyInboundConnection(maConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      if (metrics != null) {\n        ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n        const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n        setPeer({ toString: () => idString })\n        metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n      }\n\n      log('starting the inbound connection upgrade')\n\n      // Protect\n      let protectedConn = maConn\n      const protector = this.components.getConnectionProtector()\n\n      if (protector != null) {\n        log('protecting the inbound connection')\n        protectedConn = await protector.protect(maConn)\n      }\n\n      try {\n        // Encrypt the connection\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = await this._encryptInbound(protectedConn))\n\n        if (await this.components.getConnectionGater().denyInboundEncryptedConnection(remotePeer, {\n          ...protectedConn,\n          ...encryptedConn\n        })) {\n          throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n        }\n\n        // Multiplex the connection\n        if (this.muxers.size > 0) {\n          const multiplexed = await this._multiplexInbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.muxers)\n          muxerFactory = multiplexed.muxerFactory\n          upgradedConn = multiplexed.stream\n        } else {\n          upgradedConn = encryptedConn\n        }\n      } catch (err: any) {\n        log.error('Failed to upgrade inbound connection', err)\n        await maConn.close(err)\n        throw err\n      }\n\n      if (await this.components.getConnectionGater().denyInboundUpgradedConnection(remotePeer, {\n        ...protectedConn,\n        ...encryptedConn\n      })) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      if (metrics != null) {\n        metrics.updatePlaceholder(proxyPeer, remotePeer)\n        setPeer(remotePeer)\n      }\n\n      log('Successfully upgraded inbound connection')\n\n      return this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        muxerFactory,\n        remotePeer\n      })\n    } finally {\n      timeoutController.clear()\n    }\n  }\n\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound (maConn: MultiaddrConnection): Promise<Connection> {\n    const idStr = maConn.remoteAddr.getPeerId()\n    if (idStr == null) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR)\n    }\n\n    const remotePeerId = peerIdFromString(idStr)\n\n    if (await this.components.getConnectionGater().denyOutboundConnection(remotePeerId, maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let muxerFactory\n    let setPeer\n    let proxyPeer\n    const metrics = this.components.getMetrics()\n\n    if (metrics != null) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n      setPeer({ toB58String: () => idString })\n      metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    const protector = this.components.getConnectionProtector()\n\n    if (protector != null) {\n      protectedConn = await protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(protectedConn, remotePeerId))\n\n      if (await this.components.getConnectionGater().denyOutboundEncryptedConnection(remotePeer, {\n        ...protectedConn,\n        ...encryptedConn\n      })) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      // Multiplex the connection\n      if (this.muxers.size > 0) {\n        const multiplexed = await this._multiplexOutbound({\n          ...protectedConn,\n          ...encryptedConn\n        }, this.muxers)\n        muxerFactory = multiplexed.muxerFactory\n        upgradedConn = multiplexed.stream\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err: any) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (await this.components.getConnectionGater().denyOutboundUpgradedConnection(remotePeer, {\n      ...protectedConn,\n      ...encryptedConn\n    })) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    if (metrics != null) {\n      metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection (opts: CreateConectionOptions): Connection {\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory\n    } = opts\n\n    let muxer: StreamMuxer | undefined\n    let newStream: ((multicodecs: string[], options?: AbortOptions) => Promise<Stream>) | undefined\n    let connection: Connection // eslint-disable-line prefer-const\n\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return\n          }\n\n          void Promise.resolve()\n            .then(async () => {\n              const protocols = this.components.getRegistrar().getProtocols()\n              const { stream, protocol } = await mss.handle(muxedStream, protocols)\n              log('%s: incoming stream opened on %s', direction, protocol)\n\n              const metrics = this.components.getMetrics()\n\n              if (metrics != null) {\n                metrics.trackStream({ stream, remotePeer, protocol })\n              }\n\n              if (connection == null) {\n                return\n              }\n\n              const incomingLimit = findIncomingStreamLimit(protocol, this.components.getRegistrar())\n              const streamCount = countStreams(protocol, 'inbound', connection)\n\n              if (streamCount === incomingLimit) {\n                muxedStream.abort(errCode(new Error(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`), codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS))\n\n                return\n              }\n\n              // after the handshake the returned stream can have early data so override\n              // the souce/sink\n              muxedStream.source = stream.source\n              muxedStream.sink = stream.sink\n              muxedStream.stat.protocol = protocol\n\n              // If a protocol stream has been successfully negotiated and is to be passed to the application,\n              // the peerstore should ensure that the peer is registered with that protocol\n              this.components.getPeerStore().protoBook.add(remotePeer, [protocol]).catch(err => log.error(err))\n\n              connection.addStream(muxedStream)\n              this._onStream({ connection, stream: muxedStream, protocol })\n            })\n            .catch(err => {\n              log.error(err)\n\n              if (muxedStream.stat.timeline.close == null) {\n                muxedStream.close()\n              }\n            })\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection?.removeStream(muxedStream.id)\n        }\n      })\n\n      if (isInitializable(muxer)) {\n        muxer.init(this.components)\n      }\n\n      newStream = async (protocols: string[], options: AbortOptions = {}): Promise<Stream> => {\n        if (muxer == null) {\n          throw errCode(new Error('Stream is not multiplexed'), codes.ERR_MUXER_UNAVAILABLE)\n        }\n\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const metrics = this.components.getMetrics()\n        let controller: TimeoutController | undefined\n\n        try {\n          if (options.signal == null) {\n            log('No abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols)\n\n            controller = new TimeoutController(30000)\n            options.signal = controller.signal\n\n            try {\n              // fails on node < 15.4\n              setMaxListeners?.(Infinity, controller.signal)\n            } catch {}\n          }\n\n          const { stream, protocol } = await mss.select(muxedStream, protocols, options)\n\n          if (metrics != null) {\n            metrics.trackStream({ stream, remotePeer, protocol })\n          }\n\n          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.getRegistrar())\n          const streamCount = countStreams(protocol, 'outbound', connection)\n\n          if (streamCount === outgoingLimit) {\n            const err = errCode(new Error(`Too many outbound protocol streams for protocol \"${protocol}\" - limit ${outgoingLimit}`), codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS)\n            muxedStream.abort(err)\n\n            throw err\n          }\n\n          // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peerstore should ensure that the peer is registered with that protocol\n          this.components.getPeerStore().protoBook.add(remotePeer, [protocol]).catch(err => log.error(err))\n\n          // after the handshake the returned stream can have early data so override\n          // the souce/sink\n          muxedStream.source = stream.source\n          muxedStream.sink = stream.sink\n          muxedStream.stat.protocol = protocol\n\n          return muxedStream\n        } catch (err: any) {\n          log.error('could not create new stream', err)\n\n          if (muxedStream.stat.timeline.close == null) {\n            muxedStream.close()\n          }\n\n          if (err.code != null) {\n            throw err\n          }\n\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        } finally {\n          if (controller != null) {\n            controller.clear()\n          }\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection != null && args[1] === 'close' && args[2] != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'OPEN') {\n                await connection.close()\n              }\n            } catch (err: any) {\n              log.error(err)\n            } finally {\n              this.dispatchEvent(new CustomEvent<Connection>('connectionEnd', {\n                detail: connection\n              }))\n            }\n          })().catch(err => {\n            log.error(err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED)\n    }\n\n    // Create the connection\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer: remotePeer,\n      stat: {\n        status: 'OPEN',\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: muxer?.protocol,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close()\n        // Ensure remaining streams are closed\n        if (muxer != null) {\n          muxer.close()\n        }\n      }\n    })\n\n    this.dispatchEvent(new CustomEvent<Connection>('connection', {\n      detail: connection\n    }))\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   */\n  _onStream (opts: OnStreamOptions): void {\n    const { connection, stream, protocol } = opts\n    const { handler } = this.components.getRegistrar().getHandler(protocol)\n\n    handler({ connection, stream })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound (connection: Duplex<Uint8Array>): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      })\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      log('encrypting inbound connection...')\n\n      return {\n        ...await encrypter.secureInbound(this.components.getPeerId(), stream),\n        protocol\n      }\n    } catch (err: any) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound (connection: MultiaddrConnection, remotePeerId: PeerId): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        writeBytes: true\n      })\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      log('encrypting outbound connection to %p', remotePeerId)\n\n      return {\n        ...await encrypter.secureOutbound(this.components.getPeerId(), stream, remotePeerId),\n        protocol\n      }\n    } catch (err: any) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{ stream: Duplex<Uint8Array>, muxerFactory?: StreamMuxerFactory}> {\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        writeBytes: true\n      })\n      log('%s selected as muxer protocol', protocol)\n      const muxerFactory = muxers.get(protocol)\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      log.error('error multiplexing outbound stream', err)\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{ stream: Duplex<Uint8Array>, muxerFactory?: StreamMuxerFactory}> {\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      })\n      const muxerFactory = muxers.get(protocol)\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      log.error('error multiplexing inbound stream', err)\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}