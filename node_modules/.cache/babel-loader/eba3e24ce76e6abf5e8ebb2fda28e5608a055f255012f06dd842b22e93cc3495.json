{"ast":null,"code":"export var symbol = Symbol.for('@libp2p/transport');\nexport function isTransport(other) {\n  return other != null && Boolean(other[symbol]);\n}","map":{"version":3,"names":["symbol","Symbol","for","isTransport","other","Boolean"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/interface-transport/src/index.ts"],"sourcesContent":["import type { AbortOptions } from '@libp2p/interfaces'\nimport type { EventEmitter } from '@libp2p/interfaces/events'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Connection, MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Duplex } from 'it-stream-types'\n\nexport const symbol = Symbol.for('@libp2p/transport')\n\nexport interface ConnectionHandler { (connection: Connection): void }\n\nexport interface MultiaddrFilter { (multiaddrs: Multiaddr[]): Multiaddr[] }\n\nexport interface CreateListenerOptions {\n  handler?: ConnectionHandler\n  upgrader: Upgrader\n}\n\nexport interface DialOptions extends AbortOptions {\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport is understood as something that offers a dial and listen interface to establish connections.\n */\nexport interface Transport {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [symbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial: (ma: Multiaddr, options: DialOptions) => Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener: (options: CreateListenerOptions) => Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid addresses for the transport\n   */\n  filter: MultiaddrFilter\n}\n\nexport interface ListenerEvents {\n  'connection': CustomEvent<Connection>\n  'listening': CustomEvent\n  'error': CustomEvent<Error>\n  'close': CustomEvent\n}\n\nexport interface Listener extends EventEmitter<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen: (multiaddr: Multiaddr) => Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs: () => Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close: () => Promise<void>\n}\n\nexport interface UpgraderEvents {\n  'connection': CustomEvent<Connection>\n  'connectionEnd': CustomEvent<Connection>\n}\n\nexport interface Upgrader extends EventEmitter<UpgraderEvents> {\n  /**\n   * Upgrades an outbound connection on `transport.dial`.\n   */\n  upgradeOutbound: (maConn: MultiaddrConnection) => Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection on transport listener.\n   */\n  upgradeInbound: (maConn: MultiaddrConnection) => Promise<Connection>\n}\n\nexport interface ProtocolHandler {\n  (stream: Duplex<Uint8Array>, connection: Connection): void\n}\n\nexport function isTransport (other: any): other is Transport {\n  return other != null && Boolean(other[symbol])\n}\n\nexport interface TransportManagerEvents {\n  'listener:listening': CustomEvent<Listener>\n  'listener:close': CustomEvent<Listener>\n}\n\nexport interface TransportManager extends EventEmitter<TransportManagerEvents> {\n  add: (transport: Transport) => void\n  dial: (ma: Multiaddr, options?: any) => Promise<Connection>\n  getAddrs: () => Multiaddr[]\n  getTransports: () => Transport[]\n  transportForMultiaddr: (ma: Multiaddr) => Transport | undefined\n  listen: (addrs: Multiaddr[]) => Promise<void>\n  remove: (key: string) => Promise<void>\n  removeAll: () => Promise<void>\n}\n"],"mappings":"AAMA,OAAO,IAAMA,MAAM,GAAGC,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC;AA0FrD,OAAM,SAAUC,WAAWA,CAAEC,KAAU;EACrC,OAAOA,KAAK,IAAI,IAAI,IAAIC,OAAO,CAACD,KAAK,CAACJ,MAAM,CAAC,CAAC;AAChD"},"metadata":{},"sourceType":"module","externalDependencies":[]}