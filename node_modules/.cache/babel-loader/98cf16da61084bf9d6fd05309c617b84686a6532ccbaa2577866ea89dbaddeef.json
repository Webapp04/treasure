{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { unmarshalPublicKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { pb } from './proto/payload.js';\nvar NoiseHandshakePayloadProto = pb.NoiseHandshakePayload;\nexport function getPayload(_x, _x2, _x3) {\n  return _getPayload.apply(this, arguments);\n}\nfunction _getPayload() {\n  _getPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(localPeer, staticPublicKey, earlyData) {\n    var signedPayload, earlyDataPayload;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return signPayload(localPeer, getHandshakePayload(staticPublicKey));\n        case 2:\n          signedPayload = _context.sent;\n          earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : new Uint8Array(0);\n          if (!(localPeer.publicKey == null)) {\n            _context.next = 6;\n            break;\n          }\n          throw new Error('PublicKey was missing from local PeerId');\n        case 6:\n          return _context.abrupt(\"return\", createHandshakePayload(localPeer.publicKey, signedPayload, earlyDataPayload));\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _getPayload.apply(this, arguments);\n}\nexport function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  return NoiseHandshakePayloadProto.encode({\n    identityKey: libp2pPublicKey,\n    identitySig: signedPayload,\n    data: earlyData !== null && earlyData !== void 0 ? earlyData : new Uint8Array(0)\n  }).subarray();\n}\nexport function signPayload(_x4, _x5) {\n  return _signPayload.apply(this, arguments);\n}\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, payload) {\n    var privateKey;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(peerId.privateKey == null)) {\n            _context2.next = 2;\n            break;\n          }\n          throw new Error('PrivateKey was missing from PeerId');\n        case 2:\n          _context2.next = 4;\n          return unmarshalPrivateKey(peerId.privateKey);\n        case 4:\n          privateKey = _context2.sent;\n          _context2.next = 7;\n          return privateKey.sign(payload);\n        case 7:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _signPayload.apply(this, arguments);\n}\nexport function getPeerIdFromPayload(_x6) {\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\nfunction _getPeerIdFromPayload() {\n  _getPeerIdFromPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return peerIdFromKeys(payload.identityKey);\n        case 2:\n          return _context3.abrupt(\"return\", _context3.sent);\n        case 3:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\nexport function decodePayload(payload) {\n  return NoiseHandshakePayloadProto.decode(payload);\n}\nexport function getHandshakePayload(publicKey) {\n  var prefix = uint8ArrayFromString('noise-libp2p-static-key:');\n  return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport function verifySignedPayload(_x7, _x8, _x9) {\n  return _verifySignedPayload.apply(this, arguments);\n}\nfunction _verifySignedPayload() {\n  _verifySignedPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(noiseStaticKey, payload, remotePeer) {\n    var payloadPeerId, generatedPayload, publicKey, valid;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return peerIdFromKeys(payload.identityKey);\n        case 2:\n          payloadPeerId = _context4.sent;\n          if (payloadPeerId.equals(remotePeer)) {\n            _context4.next = 5;\n            break;\n          }\n          throw new Error(\"Peer ID doesn't match libp2p public key.\");\n        case 5:\n          generatedPayload = getHandshakePayload(noiseStaticKey);\n          if (!(payloadPeerId.publicKey == null)) {\n            _context4.next = 8;\n            break;\n          }\n          throw new Error('PublicKey was missing from PeerId');\n        case 8:\n          if (!(payload.identitySig == null)) {\n            _context4.next = 10;\n            break;\n          }\n          throw new Error('Signature was missing from message');\n        case 10:\n          publicKey = unmarshalPublicKey(payloadPeerId.publicKey);\n          _context4.next = 13;\n          return publicKey.verify(generatedPayload, payload.identitySig);\n        case 13:\n          valid = _context4.sent;\n          if (valid) {\n            _context4.next = 16;\n            break;\n          }\n          throw new Error(\"Static key doesn't match to peer that signed payload!\");\n        case 16:\n          return _context4.abrupt(\"return\", payloadPeerId);\n        case 17:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _verifySignedPayload.apply(this, arguments);\n}\nexport function isValidPublicKey(pk) {\n  if (!(pk instanceof Uint8Array)) {\n    return false;\n  }\n  if (pk.length !== 32) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["unmarshalPublicKey","unmarshalPrivateKey","peerIdFromKeys","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","pb","NoiseHandshakePayloadProto","NoiseHandshakePayload","getPayload","_x","_x2","_x3","_getPayload","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","localPeer","staticPublicKey","earlyData","signedPayload","earlyDataPayload","wrap","_callee$","_context","prev","next","signPayload","getHandshakePayload","sent","Uint8Array","publicKey","Error","abrupt","createHandshakePayload","stop","libp2pPublicKey","encode","identityKey","identitySig","data","subarray","_x4","_x5","_signPayload","_callee2","peerId","payload","privateKey","_callee2$","_context2","sign","getPeerIdFromPayload","_x6","_getPeerIdFromPayload","_callee3","_callee3$","_context3","decodePayload","decode","prefix","length","verifySignedPayload","_x7","_x8","_x9","_verifySignedPayload","_callee4","noiseStaticKey","remotePeer","payloadPeerId","generatedPayload","valid","_callee4$","_context4","equals","verify","isValidPublicKey","pk"],"sources":["/Users/apple/Documents/treasure/node_modules/@chainsafe/libp2p-noise/src/utils.ts"],"sourcesContent":["import { unmarshalPublicKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { bytes } from './@types/basic.js'\nimport { pb } from './proto/payload.js'\n\nconst NoiseHandshakePayloadProto = pb.NoiseHandshakePayload\n\nexport async function getPayload (\n  localPeer: PeerId,\n  staticPublicKey: bytes,\n  earlyData?: bytes\n): Promise<bytes> {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey))\n  const earlyDataPayload = earlyData ?? new Uint8Array(0)\n\n  if (localPeer.publicKey == null) {\n    throw new Error('PublicKey was missing from local PeerId')\n  }\n\n  return createHandshakePayload(\n    localPeer.publicKey,\n    signedPayload,\n    earlyDataPayload\n  )\n}\n\nexport function createHandshakePayload (\n  libp2pPublicKey: Uint8Array,\n  signedPayload: Uint8Array,\n  earlyData?: Uint8Array\n): bytes {\n  return NoiseHandshakePayloadProto.encode({\n    identityKey: libp2pPublicKey,\n    identitySig: signedPayload,\n    data: earlyData ?? new Uint8Array(0)\n  }).subarray()\n}\n\nexport async function signPayload (peerId: PeerId, payload: bytes): Promise<bytes> {\n  if (peerId.privateKey == null) {\n    throw new Error('PrivateKey was missing from PeerId')\n  }\n\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n\n  return await privateKey.sign(payload)\n}\n\nexport async function getPeerIdFromPayload (payload: pb.NoiseHandshakePayload): Promise<PeerId> {\n  return await peerIdFromKeys(payload.identityKey)\n}\n\nexport function decodePayload (payload: bytes|Uint8Array): pb.NoiseHandshakePayload {\n  return NoiseHandshakePayloadProto.decode(payload)\n}\n\nexport function getHandshakePayload (publicKey: bytes): bytes {\n  const prefix = uint8ArrayFromString('noise-libp2p-static-key:')\n  return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length)\n}\n\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport async function verifySignedPayload (\n  noiseStaticKey: bytes,\n  payload: pb.NoiseHandshakePayload,\n  remotePeer: PeerId\n): Promise<PeerId> {\n  // Unmarshaling from PublicKey protobuf\n  const payloadPeerId = await peerIdFromKeys(payload.identityKey)\n  if (!payloadPeerId.equals(remotePeer)) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\")\n  }\n  const generatedPayload = getHandshakePayload(noiseStaticKey)\n\n  if (payloadPeerId.publicKey == null) {\n    throw new Error('PublicKey was missing from PeerId')\n  }\n\n  if (payload.identitySig == null) {\n    throw new Error('Signature was missing from message')\n  }\n\n  const publicKey = unmarshalPublicKey(payloadPeerId.publicKey)\n\n  const valid = await publicKey.verify(generatedPayload, payload.identitySig)\n\n  if (!valid) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\")\n  }\n\n  return payloadPeerId\n}\n\nexport function isValidPublicKey (pk: bytes): boolean {\n  if (!(pk instanceof Uint8Array)) {\n    return false\n  }\n\n  if (pk.length !== 32) {\n    return false\n  }\n\n  return true\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}