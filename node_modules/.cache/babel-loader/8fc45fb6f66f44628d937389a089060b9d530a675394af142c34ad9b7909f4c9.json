{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport drain from 'it-drain';\nimport first from 'it-first';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport { Identify } from './pb/message.js';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { MULTICODEC_IDENTIFY, MULTICODEC_IDENTIFY_PUSH, IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION } from './consts.js';\nimport { codes } from '../errors.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { setMaxListeners } from 'events';\nvar log = logger('libp2p:identify');\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nvar MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;\nexport var IdentifyService = /*#__PURE__*/function () {\n  function IdentifyService(components, init) {\n    var _this = this;\n    _classCallCheck(this, IdentifyService);\n    this.components = components;\n    this.started = false;\n    this.init = init;\n    this.identifyProtocolStr = \"/\".concat(init.protocolPrefix, \"/\").concat(MULTICODEC_IDENTIFY_PROTOCOL_NAME, \"/\").concat(MULTICODEC_IDENTIFY_PROTOCOL_VERSION);\n    this.identifyPushProtocolStr = \"/\".concat(init.protocolPrefix, \"/\").concat(MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, \"/\").concat(MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION);\n    // Store self host metadata\n    this.host = _objectSpread({\n      protocolVersion: \"\".concat(init.protocolPrefix, \"/\").concat(IDENTIFY_PROTOCOL_VERSION)\n    }, init.host);\n    // When a new connection happens, trigger identify\n    this.components.getConnectionManager().addEventListener('peer:connect', function (evt) {\n      var connection = evt.detail;\n      _this.identify(connection).catch(log.error);\n    });\n    // When self multiaddrs change, trigger identify-push\n    this.components.getPeerStore().addEventListener('change:multiaddrs', function (evt) {\n      var peerId = evt.detail.peerId;\n      if (_this.components.getPeerId().equals(peerId)) {\n        void _this.pushToPeerStore().catch(function (err) {\n          return log.error(err);\n        });\n      }\n    });\n    // When self protocols change, trigger identify-push\n    this.components.getPeerStore().addEventListener('change:protocols', function (evt) {\n      var peerId = evt.detail.peerId;\n      if (_this.components.getPeerId().equals(peerId)) {\n        void _this.pushToPeerStore().catch(function (err) {\n          return log.error(err);\n        });\n      }\n    });\n  }\n  _createClass(IdentifyService, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.started) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              _context.next = 4;\n              return this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), 'AgentVersion', uint8ArrayFromString(this.host.agentVersion));\n            case 4:\n              _context.next = 6;\n              return this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), 'ProtocolVersion', uint8ArrayFromString(this.host.protocolVersion));\n            case 6:\n              _context.next = 8;\n              return this.components.getRegistrar().handle(this.identifyProtocolStr, function (data) {\n                void _this2._handleIdentify(data).catch(function (err) {\n                  log.error(err);\n                });\n              }, {\n                maxInboundStreams: this.init.maxInboundStreams,\n                maxOutboundStreams: this.init.maxOutboundStreams\n              });\n            case 8:\n              _context.next = 10;\n              return this.components.getRegistrar().handle(this.identifyPushProtocolStr, function (data) {\n                void _this2._handlePush(data).catch(function (err) {\n                  log.error(err);\n                });\n              }, {\n                maxInboundStreams: this.init.maxPushIncomingStreams,\n                maxOutboundStreams: this.init.maxPushOutgoingStreams\n              });\n            case 10:\n              this.started = true;\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.components.getRegistrar().unhandle(this.identifyProtocolStr);\n            case 2:\n              _context2.next = 4;\n              return this.components.getRegistrar().unhandle(this.identifyPushProtocolStr);\n            case 4:\n              this.started = false;\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Send an Identify Push update to the list of connections\n     */\n  }, {\n    key: \"push\",\n    value: function () {\n      var _push = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(connections) {\n        var _this3 = this;\n        var signedPeerRecord, listenAddrs, protocols, pushes;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.components.getPeerStore().addressBook.getRawEnvelope(this.components.getPeerId());\n            case 2:\n              signedPeerRecord = _context4.sent;\n              listenAddrs = this.components.getAddressManager().getAddresses().map(function (ma) {\n                return ma.bytes;\n              });\n              _context4.next = 6;\n              return this.components.getPeerStore().protoBook.get(this.components.getPeerId());\n            case 6:\n              protocols = _context4.sent;\n              pushes = connections.map( /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(connection) {\n                  var stream, timeoutController, source;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        timeoutController = new TimeoutController(_this3.init.timeout);\n                        try {\n                          // fails on node < 15.4\n                          setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, timeoutController.signal);\n                        } catch (_unused) {}\n                        _context3.prev = 2;\n                        _context3.next = 5;\n                        return connection.newStream([_this3.identifyPushProtocolStr], {\n                          signal: timeoutController.signal\n                        });\n                      case 5:\n                        stream = _context3.sent;\n                        // make stream abortable\n                        source = abortableDuplex(stream, timeoutController.signal);\n                        _context3.next = 9;\n                        return pipe([Identify.encode({\n                          listenAddrs: listenAddrs,\n                          signedPeerRecord: signedPeerRecord,\n                          protocols: protocols\n                        })], lp.encode(), source, drain);\n                      case 9:\n                        _context3.next = 14;\n                        break;\n                      case 11:\n                        _context3.prev = 11;\n                        _context3.t0 = _context3[\"catch\"](2);\n                        // Just log errors\n                        log.error('could not push identify update to peer', _context3.t0);\n                      case 14:\n                        _context3.prev = 14;\n                        if (stream != null) {\n                          stream.close();\n                        }\n                        timeoutController.clear();\n                        return _context3.finish(14);\n                      case 18:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3, null, [[2, 11, 14, 18]]);\n                }));\n                return function (_x2) {\n                  return _ref.apply(this, arguments);\n                };\n              }());\n              _context4.next = 10;\n              return Promise.all(pushes);\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function push(_x) {\n        return _push.apply(this, arguments);\n      }\n      return push;\n    }()\n    /**\n     * Calls `push` on all peer connections\n     */\n  }, {\n    key: \"pushToPeerStore\",\n    value: function () {\n      var _pushToPeerStore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var connections, _iterator, _step, conn, peerId, peer;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (this.isStarted()) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 2:\n              connections = [];\n              _iterator = _createForOfIteratorHelper(this.components.getConnectionManager().getConnections());\n              _context5.prev = 4;\n              _iterator.s();\n            case 6:\n              if ((_step = _iterator.n()).done) {\n                _context5.next = 17;\n                break;\n              }\n              conn = _step.value;\n              peerId = conn.remotePeer;\n              _context5.next = 11;\n              return this.components.getPeerStore().get(peerId);\n            case 11:\n              peer = _context5.sent;\n              if (peer.protocols.includes(this.identifyPushProtocolStr)) {\n                _context5.next = 14;\n                break;\n              }\n              return _context5.abrupt(\"continue\", 15);\n            case 14:\n              connections.push(conn);\n            case 15:\n              _context5.next = 6;\n              break;\n            case 17:\n              _context5.next = 22;\n              break;\n            case 19:\n              _context5.prev = 19;\n              _context5.t0 = _context5[\"catch\"](4);\n              _iterator.e(_context5.t0);\n            case 22:\n              _context5.prev = 22;\n              _iterator.f();\n              return _context5.finish(22);\n            case 25:\n              _context5.next = 27;\n              return this.push(connections);\n            case 27:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[4, 19, 22, 25]]);\n      }));\n      function pushToPeerStore() {\n        return _pushToPeerStore.apply(this, arguments);\n      }\n      return pushToPeerStore;\n    }()\n  }, {\n    key: \"_identify\",\n    value: function () {\n      var _identify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(connection) {\n        var options,\n          timeoutController,\n          signal,\n          stream,\n          _this$init$maxIdentif,\n          source,\n          data,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n              signal = options.signal;\n              // create a timeout if no abort signal passed\n              if (signal == null) {\n                timeoutController = new TimeoutController(this.init.timeout);\n                signal = timeoutController.signal;\n                try {\n                  // fails on node < 15.4\n                  setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, timeoutController.signal);\n                } catch (_unused2) {}\n              }\n              _context7.prev = 3;\n              _context7.next = 6;\n              return connection.newStream([this.identifyProtocolStr], {\n                signal: signal\n              });\n            case 6:\n              stream = _context7.sent;\n              // make stream abortable\n              source = abortableDuplex(stream, signal);\n              _context7.next = 10;\n              return pipe([], source, lp.decode({\n                maxDataLength: (_this$init$maxIdentif = this.init.maxIdentifyMessageSize) !== null && _this$init$maxIdentif !== void 0 ? _this$init$maxIdentif : MAX_IDENTIFY_MESSAGE_SIZE\n              }), /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(source) {\n                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                    while (1) switch (_context6.prev = _context6.next) {\n                      case 0:\n                        _context6.next = 2;\n                        return first(source);\n                      case 2:\n                        return _context6.abrupt(\"return\", _context6.sent);\n                      case 3:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }, _callee6);\n                }));\n                return function (_x4) {\n                  return _ref2.apply(this, arguments);\n                };\n              }());\n            case 10:\n              data = _context7.sent;\n              if (!(data == null)) {\n                _context7.next = 13;\n                break;\n              }\n              throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n            case 13:\n              _context7.prev = 13;\n              return _context7.abrupt(\"return\", Identify.decode(data));\n            case 17:\n              _context7.prev = 17;\n              _context7.t0 = _context7[\"catch\"](13);\n              throw errCode(_context7.t0, codes.ERR_INVALID_MESSAGE);\n            case 20:\n              _context7.prev = 20;\n              if (timeoutController != null) {\n                timeoutController.clear();\n              }\n              if (stream != null) {\n                stream.close();\n              }\n              return _context7.finish(20);\n            case 24:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[3,, 20, 24], [13, 17]]);\n      }));\n      function _identify(_x3) {\n        return _identify2.apply(this, arguments);\n      }\n      return _identify;\n    }()\n    /**\n     * Requests the `Identify` message from peer associated with the given `connection`.\n     * If the identified peer does not match the `PeerId` associated with the connection,\n     * an error will be thrown.\n     */\n  }, {\n    key: \"identify\",\n    value: function () {\n      var _identify3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(connection) {\n        var options,\n          message,\n          publicKey,\n          listenAddrs,\n          protocols,\n          observedAddr,\n          signedPeerRecord,\n          agentVersion,\n          protocolVersion,\n          id,\n          cleanObservedAddr,\n          envelope,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n              _context8.next = 3;\n              return this._identify(connection, options);\n            case 3:\n              message = _context8.sent;\n              publicKey = message.publicKey, listenAddrs = message.listenAddrs, protocols = message.protocols, observedAddr = message.observedAddr, signedPeerRecord = message.signedPeerRecord, agentVersion = message.agentVersion, protocolVersion = message.protocolVersion;\n              if (!(publicKey == null)) {\n                _context8.next = 7;\n                break;\n              }\n              throw errCode(new Error('public key was missing from identify message'), codes.ERR_MISSING_PUBLIC_KEY);\n            case 7:\n              _context8.next = 9;\n              return peerIdFromKeys(publicKey);\n            case 9:\n              id = _context8.sent;\n              if (connection.remotePeer.equals(id)) {\n                _context8.next = 12;\n                break;\n              }\n              throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n            case 12:\n              if (!this.components.getPeerId().equals(id)) {\n                _context8.next = 14;\n                break;\n              }\n              throw errCode(new Error('identified peer is our own peer id?'), codes.ERR_INVALID_PEER);\n            case 14:\n              // Get the observedAddr if there is one\n              cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);\n              if (!(signedPeerRecord != null)) {\n                _context8.next = 43;\n                break;\n              }\n              log('received signed peer record from %p', id);\n              _context8.prev = 17;\n              _context8.next = 20;\n              return RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);\n            case 20:\n              envelope = _context8.sent;\n              if (envelope.peerId.equals(id)) {\n                _context8.next = 23;\n                break;\n              }\n              throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n            case 23:\n              _context8.next = 25;\n              return this.components.getPeerStore().addressBook.consumePeerRecord(envelope);\n            case 25:\n              if (!_context8.sent) {\n                _context8.next = 36;\n                break;\n              }\n              _context8.next = 28;\n              return this.components.getPeerStore().protoBook.set(id, protocols);\n            case 28:\n              if (!(agentVersion != null)) {\n                _context8.next = 31;\n                break;\n              }\n              _context8.next = 31;\n              return this.components.getPeerStore().metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion));\n            case 31:\n              if (!(protocolVersion != null)) {\n                _context8.next = 34;\n                break;\n              }\n              _context8.next = 34;\n              return this.components.getPeerStore().metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion));\n            case 34:\n              log('identify completed for peer %p and protocols %o', id, protocols);\n              return _context8.abrupt(\"return\");\n            case 36:\n              _context8.next = 41;\n              break;\n            case 38:\n              _context8.prev = 38;\n              _context8.t0 = _context8[\"catch\"](17);\n              log('received invalid envelope, discard it and fallback to listenAddrs is available', _context8.t0);\n            case 41:\n              _context8.next = 44;\n              break;\n            case 43:\n              log('no signed peer record received from %p', id);\n            case 44:\n              log('falling back to legacy addresses from %p', id);\n              // LEGACY: Update peers data in PeerStore\n              _context8.prev = 45;\n              _context8.next = 48;\n              return this.components.getPeerStore().addressBook.set(id, listenAddrs.map(function (addr) {\n                return multiaddr(addr);\n              }));\n            case 48:\n              _context8.next = 53;\n              break;\n            case 50:\n              _context8.prev = 50;\n              _context8.t1 = _context8[\"catch\"](45);\n              log.error('received invalid addrs', _context8.t1);\n            case 53:\n              _context8.next = 55;\n              return this.components.getPeerStore().protoBook.set(id, protocols);\n            case 55:\n              if (!(agentVersion != null)) {\n                _context8.next = 58;\n                break;\n              }\n              _context8.next = 58;\n              return this.components.getPeerStore().metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion));\n            case 58:\n              if (!(protocolVersion != null)) {\n                _context8.next = 61;\n                break;\n              }\n              _context8.next = 61;\n              return this.components.getPeerStore().metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion));\n            case 61:\n              log('identify completed for peer %p and protocols %o', id, protocols);\n              // TODO: Add and score our observed addr\n              log('received observed address of %s', cleanObservedAddr === null || cleanObservedAddr === void 0 ? void 0 : cleanObservedAddr.toString());\n              // this.components.getAddressManager().addObservedAddr(observedAddr)\n            case 63:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[17, 38], [45, 50]]);\n      }));\n      function identify(_x5) {\n        return _identify3.apply(this, arguments);\n      }\n      return identify;\n    }()\n    /**\n     * Sends the `Identify` response with the Signed Peer Record\n     * to the requesting peer over the given `connection`\n     */\n  }, {\n    key: \"_handleIdentify\",\n    value: function () {\n      var _handleIdentify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(data) {\n        var connection, stream, timeoutController, _this$components$getP, publicKey, peerData, multiaddrs, signedPeerRecord, peerRecord, envelope, message, source;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              connection = data.connection, stream = data.stream;\n              timeoutController = new TimeoutController(this.init.timeout);\n              try {\n                // fails on node < 15.4\n                setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, timeoutController.signal);\n              } catch (_unused3) {}\n              _context9.prev = 3;\n              publicKey = (_this$components$getP = this.components.getPeerId().publicKey) !== null && _this$components$getP !== void 0 ? _this$components$getP : new Uint8Array(0);\n              _context9.next = 7;\n              return this.components.getPeerStore().get(this.components.getPeerId());\n            case 7:\n              peerData = _context9.sent;\n              multiaddrs = this.components.getAddressManager().getAddresses().map(function (ma) {\n                return ma.decapsulateCode(protocols('p2p').code);\n              });\n              signedPeerRecord = peerData.peerRecordEnvelope;\n              if (!(multiaddrs.length > 0 && signedPeerRecord == null)) {\n                _context9.next = 18;\n                break;\n              }\n              peerRecord = new PeerRecord({\n                peerId: this.components.getPeerId(),\n                multiaddrs: multiaddrs\n              });\n              _context9.next = 14;\n              return RecordEnvelope.seal(peerRecord, this.components.getPeerId());\n            case 14:\n              envelope = _context9.sent;\n              _context9.next = 17;\n              return this.components.getPeerStore().addressBook.consumePeerRecord(envelope);\n            case 17:\n              signedPeerRecord = envelope.marshal().subarray();\n            case 18:\n              message = Identify.encode({\n                protocolVersion: this.host.protocolVersion,\n                agentVersion: this.host.agentVersion,\n                publicKey: publicKey,\n                listenAddrs: multiaddrs.map(function (addr) {\n                  return addr.bytes;\n                }),\n                signedPeerRecord: signedPeerRecord,\n                observedAddr: connection.remoteAddr.bytes,\n                protocols: peerData.protocols\n              }); // make stream abortable\n              source = abortableDuplex(stream, timeoutController.signal);\n              _context9.next = 22;\n              return pipe([message], lp.encode(), source, drain);\n            case 22:\n              _context9.next = 27;\n              break;\n            case 24:\n              _context9.prev = 24;\n              _context9.t0 = _context9[\"catch\"](3);\n              log.error('could not respond to identify request', _context9.t0);\n            case 27:\n              _context9.prev = 27;\n              stream.close();\n              timeoutController.clear();\n              return _context9.finish(27);\n            case 31:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[3, 24, 27, 31]]);\n      }));\n      function _handleIdentify(_x6) {\n        return _handleIdentify2.apply(this, arguments);\n      }\n      return _handleIdentify;\n    }()\n    /**\n     * Reads the Identify Push message from the given `connection`\n     */\n  }, {\n    key: \"_handlePush\",\n    value: function () {\n      var _handlePush2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(data) {\n        var connection, stream, timeoutController, message, _this$init$maxIdentif2, source, _data, id, envelope;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              connection = data.connection, stream = data.stream;\n              timeoutController = new TimeoutController(this.init.timeout);\n              try {\n                // fails on node < 15.4\n                setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, timeoutController.signal);\n              } catch (_unused4) {}\n              _context11.prev = 3;\n              // make stream abortable\n              source = abortableDuplex(stream, timeoutController.signal);\n              _context11.next = 7;\n              return pipe([], source, lp.decode({\n                maxDataLength: (_this$init$maxIdentif2 = this.init.maxIdentifyMessageSize) !== null && _this$init$maxIdentif2 !== void 0 ? _this$init$maxIdentif2 : MAX_IDENTIFY_MESSAGE_SIZE\n              }), /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(source) {\n                  return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n                    while (1) switch (_context10.prev = _context10.next) {\n                      case 0:\n                        _context10.next = 2;\n                        return first(source);\n                      case 2:\n                        return _context10.abrupt(\"return\", _context10.sent);\n                      case 3:\n                      case \"end\":\n                        return _context10.stop();\n                    }\n                  }, _callee10);\n                }));\n                return function (_x8) {\n                  return _ref3.apply(this, arguments);\n                };\n              }());\n            case 7:\n              _data = _context11.sent;\n              if (_data != null) {\n                message = Identify.decode(_data);\n              }\n              _context11.next = 14;\n              break;\n            case 11:\n              _context11.prev = 11;\n              _context11.t0 = _context11[\"catch\"](3);\n              return _context11.abrupt(\"return\", log.error('received invalid message', _context11.t0));\n            case 14:\n              _context11.prev = 14;\n              stream.close();\n              timeoutController.clear();\n              return _context11.finish(14);\n            case 18:\n              if (!(message == null)) {\n                _context11.next = 20;\n                break;\n              }\n              return _context11.abrupt(\"return\", log.error('received invalid message'));\n            case 20:\n              id = connection.remotePeer;\n              if (!this.components.getPeerId().equals(id)) {\n                _context11.next = 24;\n                break;\n              }\n              log('received push from ourselves?');\n              return _context11.abrupt(\"return\");\n            case 24:\n              log('received push from %p', id);\n              if (!(message.signedPeerRecord != null)) {\n                _context11.next = 48;\n                break;\n              }\n              log('received signedPeerRecord in push');\n              _context11.prev = 27;\n              _context11.next = 30;\n              return RecordEnvelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);\n            case 30:\n              envelope = _context11.sent;\n              _context11.next = 33;\n              return this.components.getPeerStore().addressBook.consumePeerRecord(envelope);\n            case 33:\n              if (!_context11.sent) {\n                _context11.next = 40;\n                break;\n              }\n              log('consumed signedPeerRecord sent in push');\n              _context11.next = 37;\n              return this.components.getPeerStore().protoBook.set(id, message.protocols);\n            case 37:\n              return _context11.abrupt(\"return\");\n            case 40:\n              log('failed to consume signedPeerRecord sent in push');\n            case 41:\n              _context11.next = 46;\n              break;\n            case 43:\n              _context11.prev = 43;\n              _context11.t1 = _context11[\"catch\"](27);\n              log('received invalid envelope, discard it and fallback to listenAddrs is available', _context11.t1);\n            case 46:\n              _context11.next = 49;\n              break;\n            case 48:\n              log('did not receive signedPeerRecord in push');\n            case 49:\n              _context11.prev = 49;\n              _context11.next = 52;\n              return this.components.getPeerStore().addressBook.set(id, message.listenAddrs.map(function (addr) {\n                return multiaddr(addr);\n              }));\n            case 52:\n              _context11.next = 57;\n              break;\n            case 54:\n              _context11.prev = 54;\n              _context11.t2 = _context11[\"catch\"](49);\n              log.error('received invalid addrs', _context11.t2);\n            case 57:\n              _context11.prev = 57;\n              _context11.next = 60;\n              return this.components.getPeerStore().protoBook.set(id, message.protocols);\n            case 60:\n              _context11.next = 65;\n              break;\n            case 62:\n              _context11.prev = 62;\n              _context11.t3 = _context11[\"catch\"](57);\n              log.error('received invalid protocols', _context11.t3);\n            case 65:\n              log('handled push from %p', id);\n            case 66:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[3, 11, 14, 18], [27, 43], [49, 54], [57, 62]]);\n      }));\n      function _handlePush(_x7) {\n        return _handlePush2.apply(this, arguments);\n      }\n      return _handlePush;\n    }()\n    /**\n     * Takes the `addr` and converts it to a Multiaddr if possible\n     */\n  }], [{\n    key: \"getCleanMultiaddr\",\n    value: function getCleanMultiaddr(addr) {\n      if (addr != null && addr.length > 0) {\n        try {\n          return multiaddr(addr);\n        } catch (_unused5) {}\n      }\n    }\n  }]);\n  return IdentifyService;\n}();\n/**\n * The protocols the IdentifyService supports\n */\nexport var multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nexport var Message = {\n  Identify: Identify\n};","map":{"version":3,"names":["logger","errCode","lp","pipe","drain","first","fromString","uint8ArrayFromString","multiaddr","protocols","Identify","RecordEnvelope","PeerRecord","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION","codes","peerIdFromKeys","TimeoutController","abortableDuplex","setMaxListeners","log","MAX_IDENTIFY_MESSAGE_SIZE","IdentifyService","components","init","_this","_classCallCheck","started","identifyProtocolStr","concat","protocolPrefix","identifyPushProtocolStr","host","_objectSpread","protocolVersion","getConnectionManager","addEventListener","evt","connection","detail","identify","catch","error","getPeerStore","peerId","getPeerId","equals","pushToPeerStore","err","_createClass","key","value","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this2","wrap","_callee$","_context","prev","next","abrupt","metadataBook","setValue","agentVersion","getRegistrar","handle","data","_handleIdentify","maxInboundStreams","maxOutboundStreams","_handlePush","maxPushIncomingStreams","maxPushOutgoingStreams","stop","start","apply","arguments","_stop","_callee2","_callee2$","_context2","unhandle","_push","_callee4","connections","_this3","signedPeerRecord","listenAddrs","pushes","_callee4$","_context4","addressBook","getRawEnvelope","sent","getAddressManager","getAddresses","map","ma","bytes","protoBook","get","_ref","_callee3","stream","timeoutController","source","_callee3$","_context3","timeout","Infinity","signal","_unused","newStream","encode","t0","close","clear","finish","_x2","Promise","all","push","_x","_pushToPeerStore","_callee5","_iterator","_step","conn","peer","_callee5$","_context5","_createForOfIteratorHelper","getConnections","s","n","done","remotePeer","includes","e","f","_identify2","_callee7","options","_this$init$maxIdentif","_args7","_callee7$","_context7","length","undefined","_unused2","decode","maxDataLength","maxIdentifyMessageSize","_ref2","_callee6","_callee6$","_context6","_x4","Error","ERR_CONNECTION_ENDED","ERR_INVALID_MESSAGE","_identify","_x3","_identify3","_callee8","message","publicKey","observedAddr","id","cleanObservedAddr","envelope","_args8","_callee8$","_context8","ERR_MISSING_PUBLIC_KEY","ERR_INVALID_PEER","getCleanMultiaddr","openAndCertify","DOMAIN","consumePeerRecord","set","addr","t1","toString","_x5","_handleIdentify2","_callee9","_this$components$getP","peerData","multiaddrs","peerRecord","_callee9$","_context9","_unused3","Uint8Array","decapsulateCode","code","peerRecordEnvelope","seal","marshal","subarray","remoteAddr","_x6","_handlePush2","_callee11","_this$init$maxIdentif2","_data","_callee11$","_context11","_unused4","_ref3","_callee10","_callee10$","_context10","_x8","t2","t3","_x7","_unused5","multicodecs","IDENTIFY","IDENTIFY_PUSH","Message"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/identify/index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport drain from 'it-drain'\nimport first from 'it-first'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport { Identify } from './pb/message.js'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} from './consts.js'\nimport { codes } from '../errors.js'\nimport type { IncomingStreamData } from '@libp2p/interface-registrar'\nimport type { Connection, Stream } from '@libp2p/interface-connection'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport type { Components } from '@libp2p/components'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { setMaxListeners } from 'events'\n\nconst log = logger('libp2p:identify')\n\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nconst MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8\n\nexport interface HostProperties {\n  agentVersion: string\n}\n\nexport interface IdentifyServiceInit {\n  /**\n   * The prefix to use for the protocol (default: 'ipfs')\n   */\n  protocolPrefix: string\n\n  /**\n   * What details we should send as part of an identify message\n   */\n  host: HostProperties\n\n  /**\n   * How long we should wait for a remote peer to send their identify response\n   */\n  timeout: number\n\n  /**\n   * Identify responses larger than this in bytes will be rejected (default: 8192)\n   */\n  maxIdentifyMessageSize?: number\n\n  maxInboundStreams: number\n  maxOutboundStreams: number\n\n  maxPushIncomingStreams: number\n  maxPushOutgoingStreams: number\n}\n\nexport class IdentifyService implements Startable {\n  private readonly components: Components\n  private readonly identifyProtocolStr: string\n  private readonly identifyPushProtocolStr: string\n  private readonly host: {\n    protocolVersion: string\n    agentVersion: string\n  }\n\n  private readonly init: IdentifyServiceInit\n  private started: boolean\n\n  constructor (components: Components, init: IdentifyServiceInit) {\n    this.components = components\n    this.started = false\n    this.init = init\n\n    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`\n    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...init.host\n    }\n\n    // When a new connection happens, trigger identify\n    this.components.getConnectionManager().addEventListener('peer:connect', (evt) => {\n      const connection = evt.detail\n      this.identify(connection).catch(log.error)\n    })\n\n    // When self multiaddrs change, trigger identify-push\n    this.components.getPeerStore().addEventListener('change:multiaddrs', (evt) => {\n      const { peerId } = evt.detail\n\n      if (this.components.getPeerId().equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err))\n      }\n    })\n\n    // When self protocols change, trigger identify-push\n    this.components.getPeerStore().addEventListener('change:protocols', (evt) => {\n      const { peerId } = evt.detail\n\n      if (this.components.getPeerId().equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err))\n      }\n    })\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    if (this.started) {\n      return\n    }\n\n    await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), 'AgentVersion', uint8ArrayFromString(this.host.agentVersion))\n    await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), 'ProtocolVersion', uint8ArrayFromString(this.host.protocolVersion))\n\n    await this.components.getRegistrar().handle(this.identifyProtocolStr, (data) => {\n      void this._handleIdentify(data).catch(err => {\n        log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    })\n    await this.components.getRegistrar().handle(this.identifyPushProtocolStr, (data) => {\n      void this._handlePush(data).catch(err => {\n        log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.init.maxPushIncomingStreams,\n      maxOutboundStreams: this.init.maxPushOutgoingStreams\n    })\n\n    this.started = true\n  }\n\n  async stop () {\n    await this.components.getRegistrar().unhandle(this.identifyProtocolStr)\n    await this.components.getRegistrar().unhandle(this.identifyPushProtocolStr)\n\n    this.started = false\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   */\n  async push (connections: Connection[]): Promise<void> {\n    const signedPeerRecord = await this.components.getPeerStore().addressBook.getRawEnvelope(this.components.getPeerId())\n    const listenAddrs = this.components.getAddressManager().getAddresses().map((ma) => ma.bytes)\n    const protocols = await this.components.getPeerStore().protoBook.get(this.components.getPeerId())\n\n    const pushes = connections.map(async connection => {\n      let stream: Stream | undefined\n      const timeoutController = new TimeoutController(this.init.timeout)\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n\n      try {\n        stream = await connection.newStream([this.identifyPushProtocolStr], {\n          signal: timeoutController.signal\n        })\n\n        // make stream abortable\n        const source = abortableDuplex(stream, timeoutController.signal)\n\n        await pipe(\n          [Identify.encode({\n            listenAddrs,\n            signedPeerRecord,\n            protocols\n          })],\n          lp.encode(),\n          source,\n          drain\n        )\n      } catch (err: any) {\n        // Just log errors\n        log.error('could not push identify update to peer', err)\n      } finally {\n        if (stream != null) {\n          stream.close()\n        }\n\n        timeoutController.clear()\n      }\n    })\n\n    await Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` on all peer connections\n   */\n  async pushToPeerStore () {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return\n    }\n\n    const connections: Connection[] = []\n\n    for (const conn of this.components.getConnectionManager().getConnections()) {\n      const peerId = conn.remotePeer\n      const peer = await this.components.getPeerStore().get(peerId)\n\n      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {\n        continue\n      }\n\n      connections.push(conn)\n    }\n\n    await this.push(connections)\n  }\n\n  async _identify (connection: Connection, options: AbortOptions = {}): Promise<Identify> {\n    let timeoutController\n    let signal = options.signal\n    let stream: Stream | undefined\n\n    // create a timeout if no abort signal passed\n    if (signal == null) {\n      timeoutController = new TimeoutController(this.init.timeout)\n      signal = timeoutController.signal\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream([this.identifyProtocolStr], {\n        signal\n      })\n\n      // make stream abortable\n      const source = abortableDuplex(stream, signal)\n\n      const data = await pipe(\n        [],\n        source,\n        lp.decode({\n          maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n        }),\n        async (source) => await first(source)\n      )\n\n      if (data == null) {\n        throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED)\n      }\n\n      try {\n        return Identify.decode(data)\n      } catch (err: any) {\n        throw errCode(err, codes.ERR_INVALID_MESSAGE)\n      }\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n\n      if (stream != null) {\n        stream.close()\n      }\n    }\n  }\n\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   */\n  async identify (connection: Connection, options: AbortOptions = {}): Promise<void> {\n    const message = await this._identify(connection, options)\n\n    const {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord,\n      agentVersion,\n      protocolVersion\n    } = message\n\n    if (publicKey == null) {\n      throw errCode(new Error('public key was missing from identify message'), codes.ERR_MISSING_PUBLIC_KEY)\n    }\n\n    const id = await peerIdFromKeys(publicKey)\n\n    if (!connection.remotePeer.equals(id)) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n    }\n\n    if (this.components.getPeerId().equals(id)) {\n      throw errCode(new Error('identified peer is our own peer id?'), codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr)\n\n    if (signedPeerRecord != null) {\n      log('received signed peer record from %p', id)\n\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN)\n\n        if (!envelope.peerId.equals(id)) {\n          throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n        }\n\n        if (await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {\n          await this.components.getPeerStore().protoBook.set(id, protocols)\n\n          if (agentVersion != null) {\n            await this.components.getPeerStore().metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion))\n          }\n\n          if (protocolVersion != null) {\n            await this.components.getPeerStore().metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion))\n          }\n\n          log('identify completed for peer %p and protocols %o', id, protocols)\n\n          return\n        }\n      } catch (err: any) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n      }\n    } else {\n      log('no signed peer record received from %p', id)\n    }\n\n    log('falling back to legacy addresses from %p', id)\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.components.getPeerStore().addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err: any) {\n      log.error('received invalid addrs', err)\n    }\n\n    await this.components.getPeerStore().protoBook.set(id, protocols)\n\n    if (agentVersion != null) {\n      await this.components.getPeerStore().metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion))\n    }\n\n    if (protocolVersion != null) {\n      await this.components.getPeerStore().metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion))\n    }\n\n    log('identify completed for peer %p and protocols %o', id, protocols)\n\n    // TODO: Add and score our observed addr\n    log('received observed address of %s', cleanObservedAddr?.toString())\n    // this.components.getAddressManager().addObservedAddr(observedAddr)\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async _handleIdentify (data: IncomingStreamData) {\n    const { connection, stream } = data\n    const timeoutController = new TimeoutController(this.init.timeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal)\n    } catch {}\n\n    try {\n      const publicKey = this.components.getPeerId().publicKey ?? new Uint8Array(0)\n      const peerData = await this.components.getPeerStore().get(this.components.getPeerId())\n      const multiaddrs = this.components.getAddressManager().getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n      let signedPeerRecord = peerData.peerRecordEnvelope\n\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.components.getPeerId(),\n          multiaddrs\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.components.getPeerId())\n        await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)\n        signedPeerRecord = envelope.marshal().subarray()\n      }\n\n      const message = Identify.encode({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey,\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr: connection.remoteAddr.bytes,\n        protocols: peerData.protocols\n      })\n\n      // make stream abortable\n      const source = abortableDuplex(stream, timeoutController.signal)\n\n      await pipe(\n        [message],\n        lp.encode(),\n        source,\n        drain\n      )\n    } catch (err: any) {\n      log.error('could not respond to identify request', err)\n    } finally {\n      stream.close()\n      timeoutController.clear()\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async _handlePush (data: IncomingStreamData) {\n    const { connection, stream } = data\n    const timeoutController = new TimeoutController(this.init.timeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal)\n    } catch {}\n\n    let message: Identify | undefined\n    try {\n      // make stream abortable\n      const source = abortableDuplex(stream, timeoutController.signal)\n\n      const data = await pipe(\n        [],\n        source,\n        lp.decode({\n          maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n        }),\n        async (source) => await first(source)\n      )\n\n      if (data != null) {\n        message = Identify.decode(data)\n      }\n    } catch (err: any) {\n      return log.error('received invalid message', err)\n    } finally {\n      stream.close()\n      timeoutController.clear()\n    }\n\n    if (message == null) {\n      return log.error('received invalid message')\n    }\n\n    const id = connection.remotePeer\n\n    if (this.components.getPeerId().equals(id)) {\n      log('received push from ourselves?')\n      return\n    }\n\n    log('received push from %p', id)\n\n    if (message.signedPeerRecord != null) {\n      log('received signedPeerRecord in push')\n\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN)\n\n        if (await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {\n          log('consumed signedPeerRecord sent in push')\n\n          await this.components.getPeerStore().protoBook.set(id, message.protocols)\n          return\n        } else {\n          log('failed to consume signedPeerRecord sent in push')\n        }\n      } catch (err: any) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n      }\n    } else {\n      log('did not receive signedPeerRecord in push')\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.components.getPeerStore().addressBook.set(id,\n        message.listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err: any) {\n      log.error('received invalid addrs', err)\n    }\n\n    // Update the protocols\n    try {\n      await this.components.getPeerStore().protoBook.set(id, message.protocols)\n    } catch (err: any) {\n      log.error('received invalid protocols', err)\n    }\n\n    log('handled push from %p', id)\n  }\n\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   */\n  static getCleanMultiaddr (addr: Uint8Array | string | null | undefined) {\n    if (addr != null && addr.length > 0) {\n      try {\n        return multiaddr(addr)\n      } catch {\n\n      }\n    }\n  }\n}\n\n/**\n * The protocols the IdentifyService supports\n */\nexport const multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\n\nexport const Message = { Identify }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}