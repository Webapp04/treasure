{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { ConsumableBuffer } from './consumable-buffer.js';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nexport function wrapHash(hashFn) {\n  function hashing(value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value;\n    } else {\n      return new InfiniteHash(value, hashFn);\n    }\n  }\n  return hashing;\n}\nexport var InfiniteHash = /*#__PURE__*/function () {\n  function InfiniteHash(value, hashFn) {\n    _classCallCheck(this, InfiniteHash);\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays');\n    }\n    this._value = value;\n    this._hashFn = hashFn;\n    this._depth = -1;\n    this._availableBits = 0;\n    this._currentBufferIndex = 0;\n    this._buffers = [];\n  }\n  _createClass(InfiniteHash, [{\n    key: \"take\",\n    value: function () {\n      var _take = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bits) {\n        var pendingBits, result, hash, available, took;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              pendingBits = bits;\n            case 1:\n              if (!(this._availableBits < pendingBits)) {\n                _context.next = 6;\n                break;\n              }\n              _context.next = 4;\n              return this._produceMoreBits();\n            case 4:\n              _context.next = 1;\n              break;\n            case 6:\n              result = 0;\n              while (pendingBits > 0) {\n                hash = this._buffers[this._currentBufferIndex];\n                available = Math.min(hash.availableBits(), pendingBits);\n                took = hash.take(available);\n                result = (result << available) + took;\n                pendingBits -= available;\n                this._availableBits -= available;\n                if (hash.availableBits() === 0) {\n                  this._currentBufferIndex++;\n                }\n              }\n              return _context.abrupt(\"return\", result);\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function take(_x) {\n        return _take.apply(this, arguments);\n      }\n      return take;\n    }()\n  }, {\n    key: \"untake\",\n    value: function untake(bits) {\n      var pendingBits = bits;\n      while (pendingBits > 0) {\n        var hash = this._buffers[this._currentBufferIndex];\n        var availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n        hash.untake(availableForUntake);\n        pendingBits -= availableForUntake;\n        this._availableBits += availableForUntake;\n        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n          this._depth--;\n          this._currentBufferIndex--;\n        }\n      }\n    }\n  }, {\n    key: \"_produceMoreBits\",\n    value: function () {\n      var _produceMoreBits2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var value, hashValue, buffer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this._depth++;\n              value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;\n              _context2.next = 4;\n              return this._hashFn(value);\n            case 4:\n              hashValue = _context2.sent;\n              buffer = new ConsumableBuffer(hashValue);\n              this._buffers.push(buffer);\n              this._availableBits += buffer.availableBits();\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _produceMoreBits() {\n        return _produceMoreBits2.apply(this, arguments);\n      }\n      return _produceMoreBits;\n    }()\n  }]);\n  return InfiniteHash;\n}();","map":{"version":3,"names":["ConsumableBuffer","concat","uint8ArrayConcat","wrapHash","hashFn","hashing","value","InfiniteHash","_classCallCheck","Uint8Array","Error","_value","_hashFn","_depth","_availableBits","_currentBufferIndex","_buffers","_createClass","key","_take","_asyncToGenerator","_regeneratorRuntime","mark","_callee","bits","pendingBits","result","hash","available","took","wrap","_callee$","_context","prev","next","_produceMoreBits","Math","min","availableBits","take","abrupt","stop","_x","apply","arguments","untake","availableForUntake","totalBits","_produceMoreBits2","_callee2","hashValue","buffer","_callee2$","_context2","from","sent","push"],"sources":["/Users/apple/Documents/treasure/node_modules/hamt-sharding/src/consumable-hash.ts"],"sourcesContent":["import { ConsumableBuffer } from './consumable-buffer.js'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n  function hashing (value: InfiniteHash | Uint8Array) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}