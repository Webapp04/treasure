{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { concat } from 'uint8arrays/concat';\nimport { equals as _equals } from 'uint8arrays/equals';\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc';\nvar symbol = Symbol.for('@achingbrain/uint8arraylist');\nfunction findBufAndOffset(bufs, index) {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds');\n  }\n  var offset = 0;\n  var _iterator = _createForOfIteratorHelper(bufs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var buf = _step.value;\n      var bufEnd = offset + buf.byteLength;\n      if (index < bufEnd) {\n        return {\n          buf: buf,\n          index: index - offset\n        };\n      }\n      offset = bufEnd;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList(value) {\n  return Boolean(value === null || value === void 0 ? void 0 : value[symbol]);\n}\nexport var Uint8ArrayList = /*#__PURE__*/function (_Symbol$iterator) {\n  function Uint8ArrayList() {\n    _classCallCheck(this, Uint8ArrayList);\n    // Define symbol\n    Object.defineProperty(this, symbol, {\n      value: true\n    });\n    this.bufs = [];\n    this.length = 0;\n    for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n      data[_key] = arguments[_key];\n    }\n    if (data.length > 0) {\n      this.appendAll(data);\n    }\n  }\n  _createClass(Uint8ArrayList, [{\n    key: _Symbol$iterator,\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {\n      return _regeneratorRuntime().wrap(function value$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            return _context.delegateYield(this.bufs, \"t0\", 1);\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }, value, this);\n    })\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      return this.length;\n    }\n    /**\n     * Add one or more `bufs` to the end of this Uint8ArrayList\n     */\n  }, {\n    key: \"append\",\n    value: function append() {\n      for (var _len2 = arguments.length, bufs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        bufs[_key2] = arguments[_key2];\n      }\n      this.appendAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the end of this Uint8ArrayList\n     */\n  }, {\n    key: \"appendAll\",\n    value: function appendAll(bufs) {\n      var length = 0;\n      var _iterator2 = _createForOfIteratorHelper(bufs),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var buf = _step2.value;\n          if (buf instanceof Uint8Array) {\n            length += buf.byteLength;\n            this.bufs.push(buf);\n          } else if (isUint8ArrayList(buf)) {\n            var _this$bufs;\n            length += buf.byteLength;\n            (_this$bufs = this.bufs).push.apply(_this$bufs, _toConsumableArray(buf.bufs));\n          } else {\n            throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this.length += length;\n    }\n    /**\n     * Add one or more `bufs` to the start of this Uint8ArrayList\n     */\n  }, {\n    key: \"prepend\",\n    value: function prepend() {\n      for (var _len3 = arguments.length, bufs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        bufs[_key3] = arguments[_key3];\n      }\n      this.prependAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the start of this Uint8ArrayList\n     */\n  }, {\n    key: \"prependAll\",\n    value: function prependAll(bufs) {\n      var length = 0;\n      var _iterator3 = _createForOfIteratorHelper(bufs.reverse()),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var buf = _step3.value;\n          if (buf instanceof Uint8Array) {\n            length += buf.byteLength;\n            this.bufs.unshift(buf);\n          } else if (isUint8ArrayList(buf)) {\n            var _this$bufs2;\n            length += buf.byteLength;\n            (_this$bufs2 = this.bufs).unshift.apply(_this$bufs2, _toConsumableArray(buf.bufs));\n          } else {\n            throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      this.length += length;\n    }\n    /**\n     * Read the value at `index`\n     */\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      var res = findBufAndOffset(this.bufs, index);\n      return res.buf[res.index];\n    }\n    /**\n     * Set the value at `index` to `value`\n     */\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      var res = findBufAndOffset(this.bufs, index);\n      res.buf[res.index] = value;\n    }\n    /**\n     * Copy bytes from `buf` to the index specified by `offset`\n     */\n  }, {\n    key: \"write\",\n    value: function write(buf) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (buf instanceof Uint8Array) {\n        for (var i = 0; i < buf.length; i++) {\n          this.set(offset + i, buf[i]);\n        }\n      } else if (isUint8ArrayList(buf)) {\n        for (var _i = 0; _i < buf.length; _i++) {\n          this.set(offset + _i, buf.get(_i));\n        }\n      } else {\n        throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n      }\n    }\n    /**\n     * Remove bytes from the front of the pool\n     */\n  }, {\n    key: \"consume\",\n    value: function consume(bytes) {\n      // first, normalize the argument, in accordance with how Buffer does it\n      bytes = Math.trunc(bytes);\n      // do nothing if not a positive number\n      if (Number.isNaN(bytes) || bytes <= 0) {\n        return;\n      }\n      // if consuming all bytes, skip iterating\n      if (bytes === this.byteLength) {\n        this.bufs = [];\n        this.length = 0;\n        return;\n      }\n      while (this.bufs.length > 0) {\n        if (bytes >= this.bufs[0].byteLength) {\n          bytes -= this.bufs[0].byteLength;\n          this.length -= this.bufs[0].byteLength;\n          this.bufs.shift();\n        } else {\n          this.bufs[0] = this.bufs[0].subarray(bytes);\n          this.length -= bytes;\n          break;\n        }\n      }\n    }\n    /**\n     * Extracts a section of an array and returns a new array.\n     *\n     * This is a copy operation as it is with Uint8Arrays and Arrays\n     * - note this is different to the behaviour of Node Buffers.\n     */\n  }, {\n    key: \"slice\",\n    value: function slice(beginInclusive, endExclusive) {\n      var _this$_subList = this._subList(beginInclusive, endExclusive),\n        bufs = _this$_subList.bufs,\n        length = _this$_subList.length;\n      return concat(bufs, length);\n    }\n    /**\n     * Returns a alloc from the given start and end element index.\n     *\n     * In the best case where the data extracted comes from a single Uint8Array\n     * internally this is a no-copy operation otherwise it is a copy operation.\n     */\n  }, {\n    key: \"subarray\",\n    value: function subarray(beginInclusive, endExclusive) {\n      var _this$_subList2 = this._subList(beginInclusive, endExclusive),\n        bufs = _this$_subList2.bufs,\n        length = _this$_subList2.length;\n      if (bufs.length === 1) {\n        return bufs[0];\n      }\n      return concat(bufs, length);\n    }\n    /**\n     * Returns a allocList from the given start and end element index.\n     *\n     * This is a no-copy operation.\n     */\n  }, {\n    key: \"sublist\",\n    value: function sublist(beginInclusive, endExclusive) {\n      var _this$_subList3 = this._subList(beginInclusive, endExclusive),\n        bufs = _this$_subList3.bufs,\n        length = _this$_subList3.length;\n      var list = new Uint8ArrayList();\n      list.length = length;\n      // don't loop, just set the bufs\n      list.bufs = bufs;\n      return list;\n    }\n  }, {\n    key: \"_subList\",\n    value: function _subList(beginInclusive, endExclusive) {\n      var _beginInclusive, _endExclusive;\n      beginInclusive = (_beginInclusive = beginInclusive) !== null && _beginInclusive !== void 0 ? _beginInclusive : 0;\n      endExclusive = (_endExclusive = endExclusive) !== null && _endExclusive !== void 0 ? _endExclusive : this.length;\n      if (beginInclusive < 0) {\n        beginInclusive = this.length + beginInclusive;\n      }\n      if (endExclusive < 0) {\n        endExclusive = this.length + endExclusive;\n      }\n      if (beginInclusive < 0 || endExclusive > this.length) {\n        throw new RangeError('index is out of bounds');\n      }\n      if (beginInclusive === endExclusive) {\n        return {\n          bufs: [],\n          length: 0\n        };\n      }\n      if (beginInclusive === 0 && endExclusive === this.length) {\n        return {\n          bufs: _toConsumableArray(this.bufs),\n          length: this.length\n        };\n      }\n      var bufs = [];\n      var offset = 0;\n      for (var i = 0; i < this.bufs.length; i++) {\n        var buf = this.bufs[i];\n        var bufStart = offset;\n        var bufEnd = bufStart + buf.byteLength;\n        // for next loop\n        offset = bufEnd;\n        if (beginInclusive >= bufEnd) {\n          // start after this buf\n          continue;\n        }\n        var sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n        var sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n        if (sliceStartInBuf && sliceEndsInBuf) {\n          // slice is wholly contained within this buffer\n          if (beginInclusive === bufStart && endExclusive === bufEnd) {\n            // requested whole buffer\n            bufs.push(buf);\n            break;\n          }\n          // requested part of buffer\n          var start = beginInclusive - bufStart;\n          bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n          break;\n        }\n        if (sliceStartInBuf) {\n          // slice starts in this buffer\n          if (beginInclusive === 0) {\n            // requested whole buffer\n            bufs.push(buf);\n            continue;\n          }\n          // requested part of buffer\n          bufs.push(buf.subarray(beginInclusive - bufStart));\n          continue;\n        }\n        if (sliceEndsInBuf) {\n          if (endExclusive === bufEnd) {\n            // requested whole buffer\n            bufs.push(buf);\n            break;\n          }\n          // requested part of buffer\n          bufs.push(buf.subarray(0, endExclusive - bufStart));\n          break;\n        }\n        // slice started before this buffer and ends after it\n        bufs.push(buf);\n      }\n      return {\n        bufs: bufs,\n        length: endExclusive - beginInclusive\n      };\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(search) {\n      var _offset;\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n        throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n      }\n      var needle = search instanceof Uint8Array ? search : search.subarray();\n      offset = Number((_offset = offset) !== null && _offset !== void 0 ? _offset : 0);\n      if (isNaN(offset)) {\n        offset = 0;\n      }\n      if (offset < 0) {\n        offset = this.length + offset;\n      }\n      if (offset < 0) {\n        offset = 0;\n      }\n      if (search.length === 0) {\n        return offset > this.length ? this.length : offset;\n      }\n      // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n      var M = needle.byteLength;\n      if (M === 0) {\n        throw new TypeError('search must be at least 1 byte long');\n      }\n      // radix\n      var radix = 256;\n      var rightmostPositions = new Int32Array(radix);\n      // position of the rightmost occurrence of the byte c in the pattern\n      for (var c = 0; c < radix; c++) {\n        // -1 for bytes not in pattern\n        rightmostPositions[c] = -1;\n      }\n      for (var j = 0; j < M; j++) {\n        // rightmost position for bytes in pattern\n        rightmostPositions[needle[j]] = j;\n      }\n      // Return offset of first match, -1 if no match\n      var right = rightmostPositions;\n      var lastIndex = this.byteLength - needle.byteLength;\n      var lastPatIndex = needle.byteLength - 1;\n      var skip;\n      for (var i = offset; i <= lastIndex; i += skip) {\n        skip = 0;\n        for (var _j = lastPatIndex; _j >= 0; _j--) {\n          var char = this.get(i + _j);\n          if (needle[_j] !== char) {\n            skip = Math.max(1, _j - right[char]);\n            break;\n          }\n        }\n        if (skip === 0) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"getInt8\",\n    value: function getInt8(byteOffset) {\n      var buf = this.subarray(byteOffset, byteOffset + 1);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getInt8(0);\n    }\n  }, {\n    key: \"setInt8\",\n    value: function setInt8(byteOffset, value) {\n      var buf = allocUnsafe(1);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setInt8(0, value);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getInt16\",\n    value: function getInt16(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 2);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getInt16(0, littleEndian);\n    }\n  }, {\n    key: \"setInt16\",\n    value: function setInt16(byteOffset, value, littleEndian) {\n      var buf = alloc(2);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setInt16(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getInt32\",\n    value: function getInt32(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 4);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getInt32(0, littleEndian);\n    }\n  }, {\n    key: \"setInt32\",\n    value: function setInt32(byteOffset, value, littleEndian) {\n      var buf = alloc(4);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setInt32(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getBigInt64\",\n    value: function getBigInt64(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 8);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getBigInt64(0, littleEndian);\n    }\n  }, {\n    key: \"setBigInt64\",\n    value: function setBigInt64(byteOffset, value, littleEndian) {\n      var buf = alloc(8);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setBigInt64(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getUint8\",\n    value: function getUint8(byteOffset) {\n      var buf = this.subarray(byteOffset, byteOffset + 1);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getUint8(0);\n    }\n  }, {\n    key: \"setUint8\",\n    value: function setUint8(byteOffset, value) {\n      var buf = allocUnsafe(1);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setUint8(0, value);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getUint16\",\n    value: function getUint16(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 2);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getUint16(0, littleEndian);\n    }\n  }, {\n    key: \"setUint16\",\n    value: function setUint16(byteOffset, value, littleEndian) {\n      var buf = alloc(2);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setUint16(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getUint32\",\n    value: function getUint32(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 4);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getUint32(0, littleEndian);\n    }\n  }, {\n    key: \"setUint32\",\n    value: function setUint32(byteOffset, value, littleEndian) {\n      var buf = alloc(4);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setUint32(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getBigUint64\",\n    value: function getBigUint64(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 8);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getBigUint64(0, littleEndian);\n    }\n  }, {\n    key: \"setBigUint64\",\n    value: function setBigUint64(byteOffset, value, littleEndian) {\n      var buf = alloc(8);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setBigUint64(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getFloat32\",\n    value: function getFloat32(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 4);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getFloat32(0, littleEndian);\n    }\n  }, {\n    key: \"setFloat32\",\n    value: function setFloat32(byteOffset, value, littleEndian) {\n      var buf = alloc(4);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setFloat32(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"getFloat64\",\n    value: function getFloat64(byteOffset, littleEndian) {\n      var buf = this.subarray(byteOffset, byteOffset + 8);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      return view.getFloat64(0, littleEndian);\n    }\n  }, {\n    key: \"setFloat64\",\n    value: function setFloat64(byteOffset, value, littleEndian) {\n      var buf = alloc(8);\n      var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n      view.setFloat64(0, value, littleEndian);\n      this.write(buf, byteOffset);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other == null) {\n        return false;\n      }\n      if (!(other instanceof Uint8ArrayList)) {\n        return false;\n      }\n      if (other.bufs.length !== this.bufs.length) {\n        return false;\n      }\n      for (var i = 0; i < this.bufs.length; i++) {\n        if (!_equals(this.bufs[i], other.bufs[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n     * method if you know the total size of all the Uint8Arrays ahead of time.\n     */\n  }], [{\n    key: \"fromUint8Arrays\",\n    value: function fromUint8Arrays(bufs, length) {\n      var list = new Uint8ArrayList();\n      list.bufs = bufs;\n      if (length == null) {\n        length = bufs.reduce(function (acc, curr) {\n          return acc + curr.byteLength;\n        }, 0);\n      }\n      list.length = length;\n      return list;\n    }\n  }]);\n  return Uint8ArrayList;\n}(Symbol.iterator);\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/","map":{"version":3,"names":["concat","equals","allocUnsafe","alloc","symbol","Symbol","for","findBufAndOffset","bufs","index","RangeError","offset","_iterator","_createForOfIteratorHelper","_step","s","n","done","buf","value","bufEnd","byteLength","err","e","f","isUint8ArrayList","Boolean","Uint8ArrayList","_Symbol$iterator","_classCallCheck","Object","defineProperty","length","_len","arguments","data","Array","_key","appendAll","_createClass","key","_regeneratorRuntime","mark","wrap","value$","_context","prev","next","delegateYield","stop","get","append","_len2","_key2","_iterator2","_step2","Uint8Array","push","_this$bufs","apply","_toConsumableArray","Error","prepend","_len3","_key3","prependAll","_iterator3","reverse","_step3","unshift","_this$bufs2","res","set","write","undefined","i","consume","bytes","Math","trunc","Number","isNaN","shift","subarray","slice","beginInclusive","endExclusive","_this$_subList","_subList","_this$_subList2","sublist","_this$_subList3","list","_beginInclusive","_endExclusive","bufStart","sliceStartInBuf","sliceEndsInBuf","start","indexOf","search","_offset","TypeError","needle","M","radix","rightmostPositions","Int32Array","c","j","right","lastIndex","lastPatIndex","skip","char","max","getInt8","byteOffset","view","DataView","buffer","setInt8","getInt16","littleEndian","setInt16","getInt32","setInt32","getBigInt64","setBigInt64","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","getBigUint64","setBigUint64","getFloat32","setFloat32","getFloat64","setFloat64","other","fromUint8Arrays","reduce","acc","curr","iterator"],"sources":["/Users/apple/Documents/treasure/node_modules/uint8arraylist/src/index.ts"],"sourcesContent":["import { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number) {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n\n  constructor (...data: Appendable[]) {\n    // Define symbol\n    Object.defineProperty(this, symbol, { value: true })\n\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] () {\n    yield * this.bufs\n  }\n\n  get byteLength () {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]) {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]) {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]) {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]) {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number) {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number) {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0) {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number) {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = bufs\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number) {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: [...this.bufs], length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}