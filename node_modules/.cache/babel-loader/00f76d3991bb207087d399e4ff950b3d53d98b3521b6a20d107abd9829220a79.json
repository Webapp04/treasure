{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Identify;\n(function (Identify) {\n  var _codec;\n  Identify.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.protocolVersion != null) {\n          writer.uint32(42);\n          writer.string(obj.protocolVersion);\n        }\n        if (obj.agentVersion != null) {\n          writer.uint32(50);\n          writer.string(obj.agentVersion);\n        }\n        if (obj.publicKey != null) {\n          writer.uint32(10);\n          writer.bytes(obj.publicKey);\n        }\n        if (obj.listenAddrs != null) {\n          var _iterator = _createForOfIteratorHelper(obj.listenAddrs),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var value = _step.value;\n              writer.uint32(18);\n              writer.bytes(value);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"listenAddrs\" was not found in object');\n        }\n        if (obj.observedAddr != null) {\n          writer.uint32(34);\n          writer.bytes(obj.observedAddr);\n        }\n        if (obj.protocols != null) {\n          var _iterator2 = _createForOfIteratorHelper(obj.protocols),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _value = _step2.value;\n              writer.uint32(26);\n              writer.string(_value);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"protocols\" was not found in object');\n        }\n        if (obj.signedPeerRecord != null) {\n          writer.uint32(66);\n          writer.bytes(obj.signedPeerRecord);\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var _obj$listenAddrs, _obj$protocols, _obj$listenAddrs2, _obj$protocols2;\n        var obj = {};\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 5:\n              obj.protocolVersion = reader.string();\n              break;\n            case 6:\n              obj.agentVersion = reader.string();\n              break;\n            case 1:\n              obj.publicKey = reader.bytes();\n              break;\n            case 2:\n              obj.listenAddrs = (_obj$listenAddrs = obj.listenAddrs) !== null && _obj$listenAddrs !== void 0 ? _obj$listenAddrs : [];\n              obj.listenAddrs.push(reader.bytes());\n              break;\n            case 4:\n              obj.observedAddr = reader.bytes();\n              break;\n            case 3:\n              obj.protocols = (_obj$protocols = obj.protocols) !== null && _obj$protocols !== void 0 ? _obj$protocols : [];\n              obj.protocols.push(reader.string());\n              break;\n            case 8:\n              obj.signedPeerRecord = reader.bytes();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        obj.listenAddrs = (_obj$listenAddrs2 = obj.listenAddrs) !== null && _obj$listenAddrs2 !== void 0 ? _obj$listenAddrs2 : [];\n        obj.protocols = (_obj$protocols2 = obj.protocols) !== null && _obj$protocols2 !== void 0 ? _obj$protocols2 : [];\n        if (obj.listenAddrs == null) {\n          throw new Error('Protocol error: value for required field \"listenAddrs\" was not found in protobuf');\n        }\n        if (obj.protocols == null) {\n          throw new Error('Protocol error: value for required field \"protocols\" was not found in protobuf');\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Identify.encode = function (obj) {\n    return encodeMessage(obj, Identify.codec());\n  };\n  Identify.decode = function (buf) {\n    return decodeMessage(buf, Identify.codec());\n  };\n})(Identify || (Identify = {}));","map":{"version":3,"names":["encodeMessage","decodeMessage","message","Identify","_codec","codec","obj","writer","opts","arguments","length","undefined","lengthDelimited","fork","protocolVersion","uint32","string","agentVersion","publicKey","bytes","listenAddrs","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","e","f","Error","observedAddr","protocols","_iterator2","_step2","signedPeerRecord","ldelim","reader","_obj$listenAddrs","_obj$protocols","_obj$listenAddrs2","_obj$protocols2","end","len","pos","tag","push","skipType","encode","decode","buf"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/identify/pb/message.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface Identify {\n  protocolVersion?: string\n  agentVersion?: string\n  publicKey?: Uint8Array\n  listenAddrs: Uint8Array[]\n  observedAddr?: Uint8Array\n  protocols: string[]\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace Identify {\n  let _codec: Codec<Identify>\n\n  export const codec = (): Codec<Identify> => {\n    if (_codec == null) {\n      _codec = message<Identify>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.protocolVersion != null) {\n          writer.uint32(42)\n          writer.string(obj.protocolVersion)\n        }\n\n        if (obj.agentVersion != null) {\n          writer.uint32(50)\n          writer.string(obj.agentVersion)\n        }\n\n        if (obj.publicKey != null) {\n          writer.uint32(10)\n          writer.bytes(obj.publicKey)\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            writer.uint32(18)\n            writer.bytes(value)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"listenAddrs\" was not found in object')\n        }\n\n        if (obj.observedAddr != null) {\n          writer.uint32(34)\n          writer.bytes(obj.observedAddr)\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            writer.uint32(26)\n            writer.string(value)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"protocols\" was not found in object')\n        }\n\n        if (obj.signedPeerRecord != null) {\n          writer.uint32(66)\n          writer.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 5:\n              obj.protocolVersion = reader.string()\n              break\n            case 6:\n              obj.agentVersion = reader.string()\n              break\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.listenAddrs = obj.listenAddrs ?? []\n              obj.listenAddrs.push(reader.bytes())\n              break\n            case 4:\n              obj.observedAddr = reader.bytes()\n              break\n            case 3:\n              obj.protocols = obj.protocols ?? []\n              obj.protocols.push(reader.string())\n              break\n            case 8:\n              obj.signedPeerRecord = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        obj.listenAddrs = obj.listenAddrs ?? []\n        obj.protocols = obj.protocols ?? []\n\n        if (obj.listenAddrs == null) {\n          throw new Error('Protocol error: value for required field \"listenAddrs\" was not found in protobuf')\n        }\n\n        if (obj.protocols == null) {\n          throw new Error('Protocol error: value for required field \"protocols\" was not found in protobuf')\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Identify): Uint8Array => {\n    return encodeMessage(obj, Identify.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Identify => {\n    return decodeMessage(buf, Identify.codec())\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}