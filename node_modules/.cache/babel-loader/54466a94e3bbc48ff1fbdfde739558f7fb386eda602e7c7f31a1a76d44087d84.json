{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as ipns from 'ipns';\nimport { importKey } from '@libp2p/crypto/keys';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { TimeoutController } from 'timeout-abort-controller';\nvar log = logger('ipfs:ipns:republisher');\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nvar minute = 60 * 1000;\nvar hour = 60 * minute;\nvar defaultBroadcastInterval = 4 * hour;\nvar defaultRecordLifetime = 24 * hour;\nexport var IpnsRepublisher = /*#__PURE__*/function () {\n  /**\n   * @param {import('./publisher').IpnsPublisher} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  function IpnsRepublisher(publisher, datastore, peerId, keychain) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      pass: ''\n    };\n    _classCallCheck(this, IpnsRepublisher);\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n  _createClass(IpnsRepublisher, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this = this;\n        var republishHandle, pass, firstRun;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!this._republishHandle) {\n                _context4.next = 2;\n                break;\n              }\n              throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n            case 2:\n              // TODO: this handler should be isolated in another module\n              republishHandle = {\n                /** @type {null|(() => Promise<void>)} */\n                _task: null,\n                /** @type {null|Promise<void>} */\n                _inflightTask: null,\n                /** @type {null|NodeJS.Timeout} */\n                _timeoutId: null,\n                /**\n                 * @param {function(): number} period\n                 */\n                runPeriodically: function runPeriodically(period) {\n                  republishHandle._timeoutId = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          republishHandle._timeoutId = null;\n                          _context.prev = 1;\n                          // @ts-expect-error - _task could be null\n                          republishHandle._inflightTask = republishHandle._task();\n                          _context.next = 5;\n                          return republishHandle._inflightTask;\n                        case 5:\n                          // Schedule next\n                          if (republishHandle._task) {\n                            republishHandle.runPeriodically(period);\n                          }\n                          _context.next = 11;\n                          break;\n                        case 8:\n                          _context.prev = 8;\n                          _context.t0 = _context[\"catch\"](1);\n                          log.error(_context.t0);\n                        case 11:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee, null, [[1, 8]]);\n                  })), period());\n                },\n                cancel: function () {\n                  var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) switch (_context2.prev = _context2.next) {\n                        case 0:\n                          // do not run again\n                          if (republishHandle._timeoutId != null) {\n                            clearTimeout(republishHandle._timeoutId);\n                          }\n                          republishHandle._task = null;\n\n                          // wait for the currently in flight task to complete\n                          _context2.next = 4;\n                          return republishHandle._inflightTask;\n                        case 4:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }, _callee2);\n                  }));\n                  function cancel() {\n                    return _cancel.apply(this, arguments);\n                  }\n                  return cancel;\n                }()\n              };\n              pass = this._options.pass;\n              firstRun = true;\n              republishHandle._task = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                var timeoutController;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      timeoutController = new TimeoutController(30000);\n                      _context3.prev = 1;\n                      _context3.next = 4;\n                      return _this._republishEntries(_this._peerId, pass, {\n                        signal: timeoutController.signal\n                      });\n                    case 4:\n                      _context3.prev = 4;\n                      timeoutController.clear();\n                      return _context3.finish(4);\n                    case 7:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3, null, [[1,, 4, 7]]);\n              }));\n              republishHandle.runPeriodically(function () {\n                if (firstRun) {\n                  firstRun = false;\n                  return _this._options.initialBroadcastInterval || minute;\n                }\n                return _this._options.broadcastInterval || defaultBroadcastInterval;\n              });\n              this._republishHandle = republishHandle;\n            case 8:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var republishHandle;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              republishHandle = this._republishHandle;\n              if (republishHandle) {\n                _context5.next = 3;\n                break;\n              }\n              throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n            case 3:\n              this._republishHandle = null;\n              _context5.next = 6;\n              return republishHandle.cancel();\n            case 6:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * @param {PeerId} peerId\n     * @param {string} pass\n     * @param {AbortOptions} options\n     */\n  }, {\n    key: \"_republishEntries\",\n    value: function () {\n      var _republishEntries2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(peerId, pass, options) {\n        var errMsg, keys, _iterator, _step, key, pem, privKey, peerIdKey;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.prev = 0;\n              _context6.next = 3;\n              return this._republishEntry(peerId, options);\n            case 3:\n              _context6.next = 10;\n              break;\n            case 5:\n              _context6.prev = 5;\n              _context6.t0 = _context6[\"catch\"](0);\n              errMsg = 'cannot republish entry for the node\\'s private key';\n              log.error(errMsg);\n              return _context6.abrupt(\"return\");\n            case 10:\n              if (!pass) {\n                _context6.next = 48;\n                break;\n              }\n              _context6.prev = 11;\n              _context6.next = 14;\n              return this._keychain.listKeys();\n            case 14:\n              keys = _context6.sent;\n              _iterator = _createForOfIteratorHelper(keys);\n              _context6.prev = 16;\n              _iterator.s();\n            case 18:\n              if ((_step = _iterator.n()).done) {\n                _context6.next = 35;\n                break;\n              }\n              key = _step.value;\n              if (!(key.name === 'self')) {\n                _context6.next = 22;\n                break;\n              }\n              return _context6.abrupt(\"continue\", 33);\n            case 22:\n              _context6.next = 24;\n              return this._keychain.exportKey(key.name, pass);\n            case 24:\n              pem = _context6.sent;\n              _context6.next = 27;\n              return importKey(pem, pass);\n            case 27:\n              privKey = _context6.sent;\n              _context6.next = 30;\n              return peerIdFromKeys(privKey.public.bytes, privKey.bytes);\n            case 30:\n              peerIdKey = _context6.sent;\n              _context6.next = 33;\n              return this._republishEntry(peerIdKey, options);\n            case 33:\n              _context6.next = 18;\n              break;\n            case 35:\n              _context6.next = 40;\n              break;\n            case 37:\n              _context6.prev = 37;\n              _context6.t1 = _context6[\"catch\"](16);\n              _iterator.e(_context6.t1);\n            case 40:\n              _context6.prev = 40;\n              _iterator.f();\n              return _context6.finish(40);\n            case 43:\n              _context6.next = 48;\n              break;\n            case 45:\n              _context6.prev = 45;\n              _context6.t2 = _context6[\"catch\"](11);\n              log.error(_context6.t2);\n            case 48:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[0, 5], [11, 45], [16, 37, 40, 43]]);\n      }));\n      function _republishEntries(_x, _x2, _x3) {\n        return _republishEntries2.apply(this, arguments);\n      }\n      return _republishEntries;\n    }()\n    /**\n     * @param {PeerId} peerId\n     * @param {AbortOptions} options\n     */\n  }, {\n    key: \"_republishEntry\",\n    value: function () {\n      var _republishEntry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(peerId, options) {\n        var value;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              _context7.next = 3;\n              return this._getPreviousValue(peerId);\n            case 3:\n              value = _context7.sent;\n              _context7.next = 6;\n              return this._publisher.publishWithEOL(peerId, value, defaultRecordLifetime, options);\n            case 6:\n              _context7.next = 13;\n              break;\n            case 8:\n              _context7.prev = 8;\n              _context7.t0 = _context7[\"catch\"](0);\n              if (!(_context7.t0.code === 'ERR_NO_ENTRY_FOUND')) {\n                _context7.next = 12;\n                break;\n              }\n              return _context7.abrupt(\"return\");\n            case 12:\n              throw _context7.t0;\n            case 13:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[0, 8]]);\n      }));\n      function _republishEntry(_x4, _x5) {\n        return _republishEntry2.apply(this, arguments);\n      }\n      return _republishEntry;\n    }()\n    /**\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"_getPreviousValue\",\n    value: function () {\n      var _getPreviousValue2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(peerId) {\n        var dsVal, record;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (isPeerId(peerId)) {\n                _context8.next = 2;\n                break;\n              }\n              throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n            case 2:\n              _context8.prev = 2;\n              _context8.next = 5;\n              return this._datastore.get(ipns.getLocalKey(peerId.toBytes()));\n            case 5:\n              dsVal = _context8.sent;\n              if (dsVal instanceof Uint8Array) {\n                _context8.next = 8;\n                break;\n              }\n              throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD');\n            case 8:\n              _context8.prev = 8;\n              record = ipns.unmarshal(dsVal);\n              return _context8.abrupt(\"return\", record.value);\n            case 13:\n              _context8.prev = 13;\n              _context8.t0 = _context8[\"catch\"](8);\n              log.error(_context8.t0);\n              throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n            case 17:\n              _context8.next = 24;\n              break;\n            case 19:\n              _context8.prev = 19;\n              _context8.t1 = _context8[\"catch\"](2);\n              if (!(_context8.t1 && _context8.t1.notFound)) {\n                _context8.next = 23;\n                break;\n              }\n              throw errcode(new Error(\"no previous entry for record with id: \".concat(peerId.toString())), 'ERR_NO_ENTRY_FOUND');\n            case 23:\n              throw _context8.t1;\n            case 24:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 19], [8, 13]]);\n      }));\n      function _getPreviousValue(_x6) {\n        return _getPreviousValue2.apply(this, arguments);\n      }\n      return _getPreviousValue;\n    }()\n  }]);\n  return IpnsRepublisher;\n}();","map":{"version":3,"names":["ipns","importKey","isPeerId","errcode","logger","peerIdFromKeys","TimeoutController","log","minute","hour","defaultBroadcastInterval","defaultRecordLifetime","IpnsRepublisher","publisher","datastore","peerId","keychain","options","arguments","length","undefined","pass","_classCallCheck","_publisher","_datastore","_peerId","_keychain","_options","_republishHandle","_createClass","key","value","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee4","_this","republishHandle","firstRun","wrap","_callee4$","_context4","prev","next","Error","_task","_inflightTask","_timeoutId","runPeriodically","period","setTimeout","_callee","_callee$","_context","t0","error","stop","cancel","_cancel","_callee2","_callee2$","_context2","clearTimeout","apply","_callee3","timeoutController","_callee3$","_context3","_republishEntries","signal","clear","finish","initialBroadcastInterval","broadcastInterval","start","_stop","_callee5","_callee5$","_context5","_republishEntries2","_callee6","errMsg","keys","_iterator","_step","pem","privKey","peerIdKey","_callee6$","_context6","_republishEntry","abrupt","listKeys","sent","_createForOfIteratorHelper","s","n","done","name","exportKey","public","bytes","t1","e","f","t2","_x","_x2","_x3","_republishEntry2","_callee7","_callee7$","_context7","_getPreviousValue","publishWithEOL","code","_x4","_x5","_getPreviousValue2","_callee8","dsVal","record","_callee8$","_context8","get","getLocalKey","toBytes","Uint8Array","unmarshal","notFound","concat","toString","_x6"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/ipns/republisher.js"],"sourcesContent":["import * as ipns from 'ipns'\nimport { importKey } from '@libp2p/crypto/keys'\nimport { isPeerId } from '@libp2p/interface-peer-id'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { TimeoutController } from 'timeout-abort-controller'\n\nconst log = logger('ipfs:ipns:republisher')\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst minute = 60 * 1000\nconst hour = 60 * minute\n\nconst defaultBroadcastInterval = 4 * hour\nconst defaultRecordLifetime = 24 * hour\n\nexport class IpnsRepublisher {\n  /**\n   * @param {import('./publisher').IpnsPublisher} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (publisher, datastore, peerId, keychain, options = { pass: '' }) {\n    this._publisher = publisher\n    this._datastore = datastore\n    this._peerId = peerId\n    this._keychain = keychain\n    this._options = options\n    this._republishHandle = null\n  }\n\n  async start () { // eslint-disable-line require-await\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING')\n    }\n\n    // TODO: this handler should be isolated in another module\n    const republishHandle = {\n      /** @type {null|(() => Promise<void>)} */\n      _task: null,\n      /** @type {null|Promise<void>} */\n      _inflightTask: null,\n      /** @type {null|NodeJS.Timeout} */\n      _timeoutId: null,\n      /**\n       * @param {function(): number} period\n       */\n      runPeriodically: (period) => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null\n\n          try {\n            // @ts-expect-error - _task could be null\n            republishHandle._inflightTask = republishHandle._task()\n            await republishHandle._inflightTask\n\n            // Schedule next\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period)\n            }\n          } catch (/** @type {any} */ err) {\n            log.error(err)\n          }\n        }, period())\n      },\n      cancel: async () => {\n        // do not run again\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId)\n        }\n        republishHandle._task = null\n\n        // wait for the currently in flight task to complete\n        await republishHandle._inflightTask\n      }\n    }\n\n    const { pass } = this._options\n    let firstRun = true\n\n    republishHandle._task = async () => {\n      const timeoutController = new TimeoutController(30000)\n\n      try {\n        await this._republishEntries(this._peerId, pass, {\n          signal: timeoutController.signal\n        })\n      } finally {\n        timeoutController.clear()\n      }\n    }\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false\n        return this._options.initialBroadcastInterval || minute\n      }\n\n      return this._options.broadcastInterval || defaultBroadcastInterval\n    })\n\n    this._republishHandle = republishHandle\n  }\n\n  async stop () {\n    const republishHandle = this._republishHandle\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING')\n    }\n\n    this._republishHandle = null\n\n    await republishHandle.cancel()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string} pass\n   * @param {AbortOptions} options\n   */\n  async _republishEntries (peerId, pass, options) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(peerId, options)\n    } catch (/** @type {any} */ err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key'\n\n      log.error(errMsg)\n      return\n    }\n\n    // keychain needs pass to get the cryptographic keys\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys()\n\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue\n          }\n\n          const pem = await this._keychain.exportKey(key.name, pass)\n          const privKey = await importKey(pem, pass)\n          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes)\n\n          await this._republishEntry(peerIdKey, options)\n        }\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n      }\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {AbortOptions} options\n   */\n  async _republishEntry (peerId, options) {\n    try {\n      const value = await this._getPreviousValue(peerId)\n      await this._publisher.publishWithEOL(peerId, value, defaultRecordLifetime, options)\n    } catch (/** @type {any} */ err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _getPreviousValue (peerId) {\n    if (!(isPeerId(peerId))) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID')\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()))\n\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD')\n      }\n\n      // unmarshal data\n      try {\n        const record = ipns.unmarshal(dsVal)\n\n        return record.value\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD')\n      }\n    } catch (/** @type {any} */ err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.toString()}`), 'ERR_NO_ENTRY_FOUND')\n      }\n\n      throw err\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}