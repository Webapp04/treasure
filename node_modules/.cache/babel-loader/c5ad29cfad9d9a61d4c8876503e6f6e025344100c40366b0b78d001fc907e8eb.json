{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { abortableSource } from 'abortable-iterator';\nimport { pushable } from 'it-pushable';\nimport errCode from 'err-code';\nimport { MAX_MSG_SIZE } from './restrict-size.js';\nimport { anySignal } from 'any-signal';\nimport { InitiatorMessageTypes, ReceiverMessageTypes } from './message-types.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:mplex:stream');\nvar ERR_STREAM_RESET = 'ERR_STREAM_RESET';\nvar ERR_STREAM_ABORT = 'ERR_STREAM_ABORT';\nvar ERR_SINK_ENDED = 'ERR_SINK_ENDED';\nvar ERR_DOUBLE_SINK = 'ERR_DOUBLE_SINK';\nexport function createStream(options) {\n  var id = options.id,\n    name = options.name,\n    send = options.send,\n    onEnd = options.onEnd,\n    _options$type = options.type,\n    type = _options$type === void 0 ? 'initiator' : _options$type,\n    _options$maxMsgSize = options.maxMsgSize,\n    maxMsgSize = _options$maxMsgSize === void 0 ? MAX_MSG_SIZE : _options$maxMsgSize;\n  var abortController = new AbortController();\n  var resetController = new AbortController();\n  var closeController = new AbortController();\n  var Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes;\n  var externalId = type === 'initiator' ? \"i\".concat(id) : \"r\".concat(id);\n  var streamName = \"\".concat(name == null ? id : name);\n  var sourceEnded = false;\n  var sinkEnded = false;\n  var sinkSunk = false;\n  var endErr;\n  var timeline = {\n    open: Date.now()\n  };\n  var onSourceEnd = function onSourceEnd(err) {\n    if (sourceEnded) {\n      return;\n    }\n    sourceEnded = true;\n    log.trace('%s stream %s source end - err: %o', type, streamName, err);\n    if (err != null && endErr == null) {\n      endErr = err;\n    }\n    if (sinkEnded) {\n      stream.stat.timeline.close = Date.now();\n      if (onEnd != null) {\n        onEnd(endErr);\n      }\n    }\n  };\n  var onSinkEnd = function onSinkEnd(err) {\n    if (sinkEnded) {\n      return;\n    }\n    sinkEnded = true;\n    log.trace('%s stream %s sink end - err: %o', type, streamName, err);\n    if (err != null && endErr == null) {\n      endErr = err;\n    }\n    if (sourceEnded) {\n      timeline.close = Date.now();\n      if (onEnd != null) {\n        onEnd(endErr);\n      }\n    }\n  };\n  var streamSource = pushable({\n    onEnd: onSourceEnd\n  });\n  var stream = {\n    // Close for both Reading and Writing\n    close: function close() {\n      log.trace('%s stream %s close', type, streamName);\n      stream.closeRead();\n      stream.closeWrite();\n    },\n    // Close for reading\n    closeRead: function closeRead() {\n      log.trace('%s stream %s closeRead', type, streamName);\n      if (sourceEnded) {\n        return;\n      }\n      streamSource.end();\n    },\n    // Close for writing\n    closeWrite: function closeWrite() {\n      log.trace('%s stream %s closeWrite', type, streamName);\n      if (sinkEnded) {\n        return;\n      }\n      closeController.abort();\n      try {\n        send({\n          id: id,\n          type: Types.CLOSE\n        });\n      } catch (err) {\n        log.trace('%s stream %s error sending close', type, name, err);\n      }\n      onSinkEnd();\n    },\n    // Close for reading and writing (local error)\n    abort: function abort(err) {\n      log.trace('%s stream %s abort', type, streamName, err);\n      // End the source with the passed error\n      streamSource.end(err);\n      abortController.abort();\n      onSinkEnd(err);\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: function reset() {\n      var err = errCode(new Error('stream reset'), ERR_STREAM_RESET);\n      resetController.abort();\n      streamSource.end(err);\n      onSinkEnd(err);\n    },\n    sink: function () {\n      var _sink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n        var uint8ArrayList, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, data;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!sinkSunk) {\n                _context.next = 2;\n                break;\n              }\n              throw errCode(new Error('sink already called on stream'), ERR_DOUBLE_SINK);\n            case 2:\n              sinkSunk = true;\n              if (!sinkEnded) {\n                _context.next = 5;\n                break;\n              }\n              throw errCode(new Error('stream closed for writing'), ERR_SINK_ENDED);\n            case 5:\n              source = abortableSource(source, anySignal([abortController.signal, resetController.signal, closeController.signal]));\n              _context.prev = 6;\n              if (type === 'initiator') {\n                // If initiator, open a new stream\n                send({\n                  id: id,\n                  type: InitiatorMessageTypes.NEW_STREAM,\n                  data: new Uint8ArrayList(uint8ArrayFromString(streamName))\n                });\n              }\n              uint8ArrayList = new Uint8ArrayList();\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context.prev = 11;\n              _iterator = _asyncIterator(source);\n            case 13:\n              _context.next = 15;\n              return _iterator.next();\n            case 15:\n              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                _context.next = 34;\n                break;\n              }\n              data = _step.value;\n              if (!(data.length <= maxMsgSize)) {\n                _context.next = 21;\n                break;\n              }\n              send({\n                id: id,\n                type: Types.MESSAGE,\n                data: data instanceof Uint8ArrayList ? data : new Uint8ArrayList(data)\n              });\n              _context.next = 31;\n              break;\n            case 21:\n              uint8ArrayList.append(data);\n            case 22:\n              if (!(uint8ArrayList.length !== 0)) {\n                _context.next = 31;\n                break;\n              }\n              if (!(uint8ArrayList.length <= maxMsgSize)) {\n                _context.next = 27;\n                break;\n              }\n              send({\n                id: id,\n                type: Types.MESSAGE,\n                data: uint8ArrayList.sublist()\n              });\n              uint8ArrayList.consume(uint8ArrayList.length);\n              return _context.abrupt(\"break\", 31);\n            case 27:\n              send({\n                id: id,\n                type: Types.MESSAGE,\n                data: uint8ArrayList.sublist(0, maxMsgSize)\n              });\n              uint8ArrayList.consume(maxMsgSize);\n              _context.next = 22;\n              break;\n            case 31:\n              _iteratorAbruptCompletion = false;\n              _context.next = 13;\n              break;\n            case 34:\n              _context.next = 40;\n              break;\n            case 36:\n              _context.prev = 36;\n              _context.t0 = _context[\"catch\"](11);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n            case 40:\n              _context.prev = 40;\n              _context.prev = 41;\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context.next = 45;\n                break;\n              }\n              _context.next = 45;\n              return _iterator.return();\n            case 45:\n              _context.prev = 45;\n              if (!_didIteratorError) {\n                _context.next = 48;\n                break;\n              }\n              throw _iteratorError;\n            case 48:\n              return _context.finish(45);\n            case 49:\n              return _context.finish(40);\n            case 50:\n              _context.next = 63;\n              break;\n            case 52:\n              _context.prev = 52;\n              _context.t1 = _context[\"catch\"](6);\n              if (!(_context.t1.type === 'aborted' && _context.t1.message === 'The operation was aborted')) {\n                _context.next = 59;\n                break;\n              }\n              if (!closeController.signal.aborted) {\n                _context.next = 57;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 57:\n              if (resetController.signal.aborted) {\n                _context.t1.message = 'stream reset';\n                _context.t1.code = ERR_STREAM_RESET;\n              }\n              if (abortController.signal.aborted) {\n                _context.t1.message = 'stream aborted';\n                _context.t1.code = ERR_STREAM_ABORT;\n              }\n            case 59:\n              // Send no more data if this stream was remotely reset\n              if (_context.t1.code === ERR_STREAM_RESET) {\n                log.trace('%s stream %s reset', type, name);\n              } else {\n                log.trace('%s stream %s error', type, name, _context.t1);\n                try {\n                  send({\n                    id: id,\n                    type: Types.RESET\n                  });\n                } catch (err) {\n                  log.trace('%s stream %s error sending reset', type, name, err);\n                }\n              }\n              streamSource.end(_context.t1);\n              onSinkEnd(_context.t1);\n              return _context.abrupt(\"return\");\n            case 63:\n              try {\n                send({\n                  id: id,\n                  type: Types.CLOSE\n                });\n              } catch (err) {\n                log.trace('%s stream %s error sending close', type, name, err);\n              }\n              onSinkEnd();\n            case 65:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[6, 52], [11, 36, 40, 50], [41,, 45, 49]]);\n      }));\n      function sink(_x) {\n        return _sink.apply(this, arguments);\n      }\n      return sink;\n    }(),\n    source: streamSource,\n    sourcePush: function sourcePush(data) {\n      streamSource.push(data);\n    },\n    sourceReadableLength: function sourceReadableLength() {\n      return streamSource.readableLength;\n    },\n    stat: {\n      direction: type === 'initiator' ? 'outbound' : 'inbound',\n      timeline: timeline\n    },\n    metadata: {},\n    id: externalId\n  };\n  return stream;\n}","map":{"version":3,"names":["abortableSource","pushable","errCode","MAX_MSG_SIZE","anySignal","InitiatorMessageTypes","ReceiverMessageTypes","fromString","uint8ArrayFromString","Uint8ArrayList","logger","log","ERR_STREAM_RESET","ERR_STREAM_ABORT","ERR_SINK_ENDED","ERR_DOUBLE_SINK","createStream","options","id","name","send","onEnd","_options$type","type","_options$maxMsgSize","maxMsgSize","abortController","AbortController","resetController","closeController","Types","externalId","concat","streamName","sourceEnded","sinkEnded","sinkSunk","endErr","timeline","open","Date","now","onSourceEnd","err","trace","stream","stat","close","onSinkEnd","streamSource","closeRead","closeWrite","end","abort","CLOSE","reset","Error","sink","_sink","_asyncToGenerator","_regeneratorRuntime","mark","_callee","source","uint8ArrayList","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","data","wrap","_callee$","_context","prev","next","signal","NEW_STREAM","_asyncIterator","sent","done","value","length","MESSAGE","append","sublist","consume","abrupt","t0","return","finish","t1","message","aborted","code","RESET","stop","_x","apply","arguments","sourcePush","push","sourceReadableLength","readableLength","direction","metadata"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/mplex/src/stream.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { pushable } from 'it-pushable'\nimport errCode from 'err-code'\nimport { MAX_MSG_SIZE } from './restrict-size.js'\nimport { anySignal } from 'any-signal'\nimport { InitiatorMessageTypes, ReceiverMessageTypes } from './message-types.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { logger } from '@libp2p/logger'\nimport type { Message } from './message-types.js'\nimport type { StreamTimeline } from '@libp2p/interface-connection'\nimport type { Source } from 'it-stream-types'\nimport type { MplexStream } from './mplex.js'\n\nconst log = logger('libp2p:mplex:stream')\n\nconst ERR_STREAM_RESET = 'ERR_STREAM_RESET'\nconst ERR_STREAM_ABORT = 'ERR_STREAM_ABORT'\nconst ERR_SINK_ENDED = 'ERR_SINK_ENDED'\nconst ERR_DOUBLE_SINK = 'ERR_DOUBLE_SINK'\n\nexport interface Options {\n  id: number\n  send: (msg: Message) => void\n  name?: string\n  onEnd?: (err?: Error) => void\n  type?: 'initiator' | 'receiver'\n  maxMsgSize?: number\n}\n\nexport function createStream (options: Options): MplexStream {\n  const { id, name, send, onEnd, type = 'initiator', maxMsgSize = MAX_MSG_SIZE } = options\n\n  const abortController = new AbortController()\n  const resetController = new AbortController()\n  const closeController = new AbortController()\n  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes\n  const externalId = type === 'initiator' ? (`i${id}`) : `r${id}`\n  const streamName = `${name == null ? id : name}`\n\n  let sourceEnded = false\n  let sinkEnded = false\n  let sinkSunk = false\n  let endErr: Error | undefined\n\n  const timeline: StreamTimeline = {\n    open: Date.now()\n  }\n\n  const onSourceEnd = (err?: Error) => {\n    if (sourceEnded) {\n      return\n    }\n\n    sourceEnded = true\n    log.trace('%s stream %s source end - err: %o', type, streamName, err)\n\n    if (err != null && endErr == null) {\n      endErr = err\n    }\n\n    if (sinkEnded) {\n      stream.stat.timeline.close = Date.now()\n\n      if (onEnd != null) {\n        onEnd(endErr)\n      }\n    }\n  }\n\n  const onSinkEnd = (err?: Error) => {\n    if (sinkEnded) {\n      return\n    }\n\n    sinkEnded = true\n    log.trace('%s stream %s sink end - err: %o', type, streamName, err)\n\n    if (err != null && endErr == null) {\n      endErr = err\n    }\n\n    if (sourceEnded) {\n      timeline.close = Date.now()\n\n      if (onEnd != null) {\n        onEnd(endErr)\n      }\n    }\n  }\n\n  const streamSource = pushable<Uint8ArrayList>({\n    onEnd: onSourceEnd\n  })\n\n  const stream: MplexStream = {\n    // Close for both Reading and Writing\n    close: () => {\n      log.trace('%s stream %s close', type, streamName)\n\n      stream.closeRead()\n      stream.closeWrite()\n    },\n\n    // Close for reading\n    closeRead: () => {\n      log.trace('%s stream %s closeRead', type, streamName)\n\n      if (sourceEnded) {\n        return\n      }\n\n      streamSource.end()\n    },\n\n    // Close for writing\n    closeWrite: () => {\n      log.trace('%s stream %s closeWrite', type, streamName)\n\n      if (sinkEnded) {\n        return\n      }\n\n      closeController.abort()\n\n      try {\n        send({ id, type: Types.CLOSE })\n      } catch (err) {\n        log.trace('%s stream %s error sending close', type, name, err)\n      }\n\n      onSinkEnd()\n    },\n\n    // Close for reading and writing (local error)\n    abort: (err: Error) => {\n      log.trace('%s stream %s abort', type, streamName, err)\n      // End the source with the passed error\n      streamSource.end(err)\n      abortController.abort()\n      onSinkEnd(err)\n    },\n\n    // Close immediately for reading and writing (remote error)\n    reset: () => {\n      const err = errCode(new Error('stream reset'), ERR_STREAM_RESET)\n      resetController.abort()\n      streamSource.end(err)\n      onSinkEnd(err)\n    },\n\n    sink: async (source: Source<Uint8ArrayList | Uint8Array>) => {\n      if (sinkSunk) {\n        throw errCode(new Error('sink already called on stream'), ERR_DOUBLE_SINK)\n      }\n\n      sinkSunk = true\n\n      if (sinkEnded) {\n        throw errCode(new Error('stream closed for writing'), ERR_SINK_ENDED)\n      }\n\n      source = abortableSource(source, anySignal([\n        abortController.signal,\n        resetController.signal,\n        closeController.signal\n      ]))\n\n      try {\n        if (type === 'initiator') { // If initiator, open a new stream\n          send({ id, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(uint8ArrayFromString(streamName)) })\n        }\n\n        const uint8ArrayList = new Uint8ArrayList()\n\n        for await (const data of source) {\n          if (data.length <= maxMsgSize) {\n            send({ id, type: Types.MESSAGE, data: data instanceof Uint8ArrayList ? data : new Uint8ArrayList(data) })\n          } else {\n            uint8ArrayList.append(data)\n\n            while (uint8ArrayList.length !== 0) {\n              // eslint-disable-next-line max-depth\n              if (uint8ArrayList.length <= maxMsgSize) {\n                send({ id, type: Types.MESSAGE, data: uint8ArrayList.sublist() })\n                uint8ArrayList.consume(uint8ArrayList.length)\n                break\n              }\n              send({ id, type: Types.MESSAGE, data: uint8ArrayList.sublist(0, maxMsgSize) })\n              uint8ArrayList.consume(maxMsgSize)\n            }\n          }\n        }\n      } catch (err: any) {\n        if (err.type === 'aborted' && err.message === 'The operation was aborted') {\n          if (closeController.signal.aborted) {\n            return\n          }\n\n          if (resetController.signal.aborted) {\n            err.message = 'stream reset'\n            err.code = ERR_STREAM_RESET\n          }\n\n          if (abortController.signal.aborted) {\n            err.message = 'stream aborted'\n            err.code = ERR_STREAM_ABORT\n          }\n        }\n\n        // Send no more data if this stream was remotely reset\n        if (err.code === ERR_STREAM_RESET) {\n          log.trace('%s stream %s reset', type, name)\n        } else {\n          log.trace('%s stream %s error', type, name, err)\n          try {\n            send({ id, type: Types.RESET })\n          } catch (err) {\n            log.trace('%s stream %s error sending reset', type, name, err)\n          }\n        }\n\n        streamSource.end(err)\n        onSinkEnd(err)\n        return\n      }\n\n      try {\n        send({ id, type: Types.CLOSE })\n      } catch (err) {\n        log.trace('%s stream %s error sending close', type, name, err)\n      }\n\n      onSinkEnd()\n    },\n\n    source: streamSource,\n\n    sourcePush: (data: Uint8ArrayList) => {\n      streamSource.push(data)\n    },\n\n    sourceReadableLength () {\n      return streamSource.readableLength\n    },\n\n    stat: {\n      direction: type === 'initiator' ? 'outbound' : 'inbound',\n      timeline\n    },\n\n    metadata: {},\n\n    id: externalId\n  }\n\n  return stream\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}