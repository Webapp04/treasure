{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { ipfsCore as pkgversion } from '../version.js';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { NotStartedError } from '../errors.js';\nimport errCode from 'err-code';\nimport { logger } from '@libp2p/logger';\nvar log = logger('ipfs:components:id');\n\n/**\n * @typedef {import('libp2p').Libp2p} Libp2p\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @param {object} config\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\nexport function createId(_ref) {\n  var peerId = _ref.peerId,\n    network = _ref.network;\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"id\"]}\n   */\n  function id() {\n    return _id.apply(this, arguments);\n  }\n  function _id() {\n    _id = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var options,\n        net,\n        libp2p,\n        peerIdToId,\n        peer,\n        agentVersion,\n        protocolVersion,\n        idStr,\n        publicKeyStr,\n        _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n            // eslint-disable-line require-await\n            net = network.try();\n            if (net) {\n              _context.next = 8;\n              break;\n            }\n            if (!options.peerId) {\n              _context.next = 5;\n              break;\n            }\n            throw new NotStartedError();\n          case 5:\n            if (!(peerId.publicKey == null)) {\n              _context.next = 7;\n              break;\n            }\n            throw errCode(new Error('Public key missing'), 'ERR_MISSING_PUBLIC_KEY');\n          case 7:\n            return _context.abrupt(\"return\", {\n              id: peerId,\n              publicKey: uint8ArrayToString(peerId.publicKey, 'base64pad'),\n              addresses: [],\n              agentVersion: \"js-ipfs/\".concat(pkgversion),\n              protocolVersion: '9000',\n              protocols: []\n            });\n          case 8:\n            libp2p = net.libp2p;\n            peerIdToId = options.peerId ? options.peerId : peerId;\n            _context.next = 12;\n            return findPeer(peerIdToId, libp2p, options);\n          case 12:\n            peer = _context.sent;\n            agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') || new Uint8Array());\n            protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') || new Uint8Array());\n            idStr = peer.id.toString();\n            publicKeyStr = peer.publicKey ? uint8ArrayToString(peer.publicKey, 'base64pad') : '';\n            return _context.abrupt(\"return\", {\n              id: peerIdToId,\n              publicKey: publicKeyStr,\n              addresses: (peer.addresses || []).map(function (ma) {\n                var str = ma.toString();\n\n                // some relay-style transports add our peer id to the ma for us\n                // so don't double-add\n                if (str.endsWith(\"/p2p/\".concat(idStr))) {\n                  return str;\n                }\n                return \"\".concat(str, \"/p2p/\").concat(idStr);\n              }).sort().map(function (ma) {\n                return multiaddr(ma);\n              }),\n              agentVersion: agentVersion,\n              protocolVersion: protocolVersion,\n              protocols: (peer.protocols || []).sort()\n            });\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return _id.apply(this, arguments);\n  }\n  return withTimeoutOption(id);\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nfunction findPeer(_x, _x2, _x3) {\n  return _findPeer.apply(this, arguments);\n}\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nfunction _findPeer() {\n  _findPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, libp2p, options) {\n    var peer, publicKey;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return libp2p.peerStore.get(peerId);\n        case 2:\n          peer = _context2.sent;\n          if (peer) {\n            _context2.next = 7;\n            break;\n          }\n          _context2.next = 6;\n          return findPeerOnDht(peerId, libp2p, options);\n        case 6:\n          peer = _context2.sent;\n        case 7:\n          if (!peerId.publicKey) {\n            _context2.next = 11;\n            break;\n          }\n          _context2.t0 = peerId.publicKey;\n          _context2.next = 14;\n          break;\n        case 11:\n          _context2.next = 13;\n          return libp2p.peerStore.keyBook.get(peerId);\n        case 13:\n          _context2.t0 = _context2.sent;\n        case 14:\n          publicKey = _context2.t0;\n          if (!(publicKey == null)) {\n            _context2.next = 25;\n            break;\n          }\n          _context2.prev = 16;\n          _context2.next = 19;\n          return libp2p.getPublicKey(peerId, options);\n        case 19:\n          publicKey = _context2.sent;\n          _context2.next = 25;\n          break;\n        case 22:\n          _context2.prev = 22;\n          _context2.t1 = _context2[\"catch\"](16);\n          log.error('Could not load public key for', peerId.toString(), _context2.t1);\n        case 25:\n          return _context2.abrupt(\"return\", _objectSpread(_objectSpread({}, peer), {}, {\n            publicKey: publicKey,\n            metadata: peer.metadata || new Map(),\n            addresses: peer.addresses.map(function (addr) {\n              return addr.multiaddr;\n            })\n          }));\n        case 26:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[16, 22]]);\n  }));\n  return _findPeer.apply(this, arguments);\n}\nfunction findPeerOnDht(_x4, _x5, _x6) {\n  return _findPeerOnDht.apply(this, arguments);\n}\nfunction _findPeerOnDht() {\n  _findPeerOnDht = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peerId, libp2p, options) {\n    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, event, peer;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!(libp2p.dht == null)) {\n            _context3.next = 2;\n            break;\n          }\n          throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n        case 2:\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context3.prev = 4;\n          _iterator = _asyncIterator(libp2p.dht.findPeer(peerId, options));\n        case 6:\n          _context3.next = 8;\n          return _iterator.next();\n        case 8:\n          if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {\n            _context3.next = 15;\n            break;\n          }\n          event = _step.value;\n          if (!(event.name === 'FINAL_PEER')) {\n            _context3.next = 12;\n            break;\n          }\n          return _context3.abrupt(\"break\", 15);\n        case 12:\n          _iteratorAbruptCompletion = false;\n          _context3.next = 6;\n          break;\n        case 15:\n          _context3.next = 21;\n          break;\n        case 17:\n          _context3.prev = 17;\n          _context3.t0 = _context3[\"catch\"](4);\n          _didIteratorError = true;\n          _iteratorError = _context3.t0;\n        case 21:\n          _context3.prev = 21;\n          _context3.prev = 22;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context3.next = 26;\n            break;\n          }\n          _context3.next = 26;\n          return _iterator.return();\n        case 26:\n          _context3.prev = 26;\n          if (!_didIteratorError) {\n            _context3.next = 29;\n            break;\n          }\n          throw _iteratorError;\n        case 29:\n          return _context3.finish(26);\n        case 30:\n          return _context3.finish(21);\n        case 31:\n          _context3.next = 33;\n          return libp2p.peerStore.get(peerId);\n        case 33:\n          peer = _context3.sent;\n          if (peer) {\n            _context3.next = 36;\n            break;\n          }\n          throw errCode(new Error('Could not find peer'), 'ERR_NOT_FOUND');\n        case 36:\n          return _context3.abrupt(\"return\", peer);\n        case 37:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[4, 17, 21, 31], [22,, 26, 30]]);\n  }));\n  return _findPeerOnDht.apply(this, arguments);\n}","map":{"version":3,"names":["ipfsCore","pkgversion","multiaddr","withTimeoutOption","toString","uint8ArrayToString","NotStartedError","errCode","logger","log","createId","_ref","peerId","network","id","_id","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","net","libp2p","peerIdToId","peer","agentVersion","protocolVersion","idStr","publicKeyStr","_args","wrap","_callee$","_context","prev","next","length","undefined","try","publicKey","Error","abrupt","addresses","concat","protocols","findPeer","sent","metadata","get","Uint8Array","map","ma","str","endsWith","sort","stop","_x","_x2","_x3","_findPeer","_callee2","_callee2$","_context2","peerStore","findPeerOnDht","t0","keyBook","getPublicKey","t1","error","_objectSpread","Map","addr","_x4","_x5","_x6","_findPeerOnDht","_callee3","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","event","_callee3$","_context3","dht","_asyncIterator","done","value","name","return","finish"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/id.js"],"sourcesContent":["import { ipfsCore as pkgversion } from '../version.js'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NotStartedError } from '../errors.js'\nimport errCode from 'err-code'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipfs:components:id')\n\n/**\n * @typedef {import('libp2p').Libp2p} Libp2p\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @param {object} config\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\nexport function createId ({ peerId, network }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"id\"]}\n   */\n  async function id (options = {}) { // eslint-disable-line require-await\n    const net = network.try()\n\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError()\n      }\n\n      if (peerId.publicKey == null) {\n        throw errCode(new Error('Public key missing'), 'ERR_MISSING_PUBLIC_KEY')\n      }\n\n      return {\n        id: peerId,\n        publicKey: uint8ArrayToString(peerId.publicKey, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      }\n    }\n\n    const { libp2p } = net\n    const peerIdToId = options.peerId ? options.peerId : peerId\n    const peer = await findPeer(peerIdToId, libp2p, options)\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') || new Uint8Array())\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') || new Uint8Array())\n    const idStr = peer.id.toString()\n    const publicKeyStr = peer.publicKey ? uint8ArrayToString(peer.publicKey, 'base64pad') : ''\n\n    return {\n      id: peerIdToId,\n      publicKey: publicKeyStr,\n      addresses: (peer.addresses || [])\n        .map(ma => {\n          const str = ma.toString()\n\n          // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n          if (str.endsWith(`/p2p/${idStr}`)) {\n            return str\n          }\n\n          return `${str}/p2p/${idStr}`\n        })\n        .sort()\n        .map(ma => multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (peer.protocols || []).sort()\n    }\n  }\n\n  return withTimeoutOption(id)\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeer (peerId, libp2p, options) {\n  let peer = await libp2p.peerStore.get(peerId)\n\n  if (!peer) {\n    peer = await findPeerOnDht(peerId, libp2p, options)\n  }\n\n  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId)\n\n  if (publicKey == null) {\n    try {\n      publicKey = await libp2p.getPublicKey(peerId, options)\n    } catch (err) {\n      log.error('Could not load public key for', peerId.toString(), err)\n    }\n  }\n\n  return {\n    ...peer,\n    publicKey,\n    metadata: peer.metadata || new Map(),\n    addresses: peer.addresses.map(addr => addr.multiaddr)\n  }\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeerOnDht (peerId, libp2p, options) {\n  if (libp2p.dht == null) {\n    throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n  }\n\n  for await (const event of libp2p.dht.findPeer(peerId, options)) {\n    if (event.name === 'FINAL_PEER') {\n      break\n    }\n  }\n\n  const peer = await libp2p.peerStore.get(peerId)\n\n  if (!peer) {\n    throw errCode(new Error('Could not find peer'), 'ERR_NOT_FOUND')\n  }\n\n  return peer\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}