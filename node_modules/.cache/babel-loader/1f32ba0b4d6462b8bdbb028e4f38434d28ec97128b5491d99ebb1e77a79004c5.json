{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Bucket, createHAMT } from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('../types').ExporterOptions} ExporterOptions\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\n/**\n * @param {Uint8Array} buf\n */\nvar hashFn = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(buf) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return murmur3128.encode(buf);\n        case 2:\n          return _context.abrupt(\"return\", _context.sent.slice(0, 8).reverse());\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function hashFn(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {PBLink[]} links\n * @param {Bucket<boolean>} bucket\n * @param {Bucket<boolean>} rootBucket\n */\nvar addLinksToHamtBucket = function addLinksToHamtBucket(links, bucket, rootBucket) {\n  return Promise.all(links.map(function (link) {\n    if (link.Name == null) {\n      // TODO(@rvagg): what do? this is technically possible\n      throw new Error('Unexpected Link without a Name');\n    }\n    if (link.Name.length === 2) {\n      var pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\n/**\n * @param {number} position\n */\nvar toPrefix = function toPrefix(position) {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\n/**\n * @param {import('hamt-sharding').BucketPosition<boolean>} position\n */\nvar toBucketPath = function toBucketPath(position) {\n  var bucket = position.bucket;\n  var path = [];\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n  path.push(bucket);\n  return path.reverse();\n};\n\n/**\n * @typedef {import('../types').ShardTraversalContext} ShardTraversalContext\n *\n * @param {PBNode} node\n * @param {string} name\n * @param {Blockstore} blockstore\n * @param {ShardTraversalContext} [context]\n * @param {ExporterOptions} [options]\n * @returns {Promise<CID|null>}\n */\nvar findShardCid = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(node, name, blockstore, context, options) {\n    var rootBucket, position, prefix, bucketPath, link, block;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!context) {\n            rootBucket = createHAMT({\n              hashFn: hashFn\n            });\n            context = {\n              rootBucket: rootBucket,\n              hamtDepth: 1,\n              lastBucket: rootBucket\n            };\n          }\n          _context2.next = 3;\n          return addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n        case 3:\n          _context2.next = 5;\n          return context.rootBucket._findNewBucketAndPos(name);\n        case 5:\n          position = _context2.sent;\n          prefix = toPrefix(position.pos);\n          bucketPath = toBucketPath(position);\n          if (bucketPath.length > context.hamtDepth) {\n            context.lastBucket = bucketPath[context.hamtDepth];\n            prefix = toPrefix(context.lastBucket._posAtParent);\n          }\n          link = node.Links.find(function (link) {\n            if (link.Name == null) {\n              return false;\n            }\n            var entryPrefix = link.Name.substring(0, 2);\n            var entryName = link.Name.substring(2);\n            if (entryPrefix !== prefix) {\n              // not the entry or subshard we're looking for\n              return false;\n            }\n            if (entryName && entryName !== name) {\n              // not the entry we're looking for\n              return false;\n            }\n            return true;\n          });\n          if (link) {\n            _context2.next = 12;\n            break;\n          }\n          return _context2.abrupt(\"return\", null);\n        case 12:\n          if (!(link.Name != null && link.Name.substring(2) === name)) {\n            _context2.next = 14;\n            break;\n          }\n          return _context2.abrupt(\"return\", link.Hash);\n        case 14:\n          context.hamtDepth++;\n          _context2.next = 17;\n          return blockstore.get(link.Hash, options);\n        case 17:\n          block = _context2.sent;\n          node = decode(block);\n          return _context2.abrupt(\"return\", findShardCid(node, name, blockstore, context, options));\n        case 20:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function findShardCid(_x2, _x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport default findShardCid;","map":{"version":3,"names":["Bucket","createHAMT","decode","murmur3128","hashFn","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","buf","wrap","_callee$","_context","prev","next","encode","abrupt","sent","slice","reverse","stop","_x","apply","arguments","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","Error","length","pos","parseInt","_putObjectAt","hash","_options","bits","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","findShardCid","_ref2","_callee2","node","name","blockstore","context","options","prefix","bucketPath","block","_callee2$","_context2","hamtDepth","lastBucket","Links","_findNewBucketAndPos","_posAtParent","find","entryPrefix","entryName","Hash","get","_x2","_x3","_x4","_x5","_x6"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js"],"sourcesContent":["\nimport { Bucket, createHAMT } from 'hamt-sharding'\nimport { decode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('../types').ExporterOptions} ExporterOptions\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\n/**\n * @param {Uint8Array} buf\n */\nconst hashFn = async function (buf) {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\n/**\n * @param {PBLink[]} links\n * @param {Bucket<boolean>} bucket\n * @param {Bucket<boolean>} rootBucket\n */\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(\n    links.map(link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === 2) {\n        const pos = parseInt(link.Name, 16)\n\n        return bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n      }\n\n      return rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\n/**\n * @param {number} position\n */\nconst toPrefix = (position) => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\n/**\n * @param {import('hamt-sharding').BucketPosition<boolean>} position\n */\nconst toBucketPath = (position) => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\n/**\n * @typedef {import('../types').ShardTraversalContext} ShardTraversalContext\n *\n * @param {PBNode} node\n * @param {string} name\n * @param {Blockstore} blockstore\n * @param {ShardTraversalContext} [context]\n * @param {ExporterOptions} [options]\n * @returns {Promise<CID|null>}\n */\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = createHAMT({\n      hashFn\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, 2)\n    const entryName = link.Name.substring(2)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (!link) {\n    return null\n  }\n\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n"],"mappings":";;AACA,SAASA,MAAM,EAAEC,UAAU,QAAQ,eAAe;AAClD,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,UAAU,QAAQ,uBAAuB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAMC,MAAM;EAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,QAAgBC,GAAG;IAAA,OAAAH,mBAAA,GAAAI,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OAClBZ,UAAU,CAACa,MAAM,CAACN,GAAG,CAAC;QAAA;UAAA,OAAAG,QAAA,CAAAI,MAAA,WAAAJ,QAAA,CAAAK,IAAA,CAIjCC,KAAK,CAAC,CAAC,EAAE,CAAC,EAEVC,OAAO;QAAA;QAAA;UAAA,OAAAP,QAAA,CAAAQ,IAAA;MAAA;IAAA,GAAAZ,OAAA;EAAA,CACX;EAAA,gBARKL,MAAMA,CAAAkB,EAAA;IAAA,OAAAjB,IAAA,CAAAkB,KAAA,OAAAC,SAAA;EAAA;AAAA,GAQX;;AAED;AACA;AACA;AACA;AACA;AACA,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIC,KAAK,EAAEC,MAAM,EAAEC,UAAU,EAAK;EAC1D,OAAOC,OAAO,CAACC,GAAG,CAChBJ,KAAK,CAACK,GAAG,CAAC,UAAAC,IAAI,EAAI;IAChB,IAAIA,IAAI,CAACC,IAAI,IAAI,IAAI,EAAE;MACrB;MACA,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IACnD;IACA,IAAIF,IAAI,CAACC,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;MAC1B,IAAMC,GAAG,GAAGC,QAAQ,CAACL,IAAI,CAACC,IAAI,EAAE,EAAE,CAAC;MAEnC,OAAON,MAAM,CAACW,YAAY,CAACF,GAAG,EAAE,IAAIpC,MAAM,CAAC;QACzCuC,IAAI,EAAEX,UAAU,CAACY,QAAQ,CAACD,IAAI;QAC9BE,IAAI,EAAEb,UAAU,CAACY,QAAQ,CAACC;MAC5B,CAAC,EAAEd,MAAM,EAAES,GAAG,CAAC,CAAC;IAClB;IAEA,OAAOR,UAAU,CAACc,GAAG,CAACV,IAAI,CAACC,IAAI,CAACU,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC;EACrD,CAAC,CACH,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,IAAMC,QAAQ,GAAG,SAAXA,QAAQA,CAAIC,QAAQ,EAAK;EAC7B,OAAOA,QAAQ,CACZC,QAAQ,CAAC,EAAE,CAAC,CACZC,WAAW,CAAC,CAAC,CACbC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAChBL,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;AACpB,CAAC;;AAED;AACA;AACA;AACA,IAAMM,YAAY,GAAG,SAAfA,YAAYA,CAAIJ,QAAQ,EAAK;EACjC,IAAIlB,MAAM,GAAGkB,QAAQ,CAAClB,MAAM;EAC5B,IAAMuB,IAAI,GAAG,EAAE;EAEf,OAAOvB,MAAM,CAACwB,OAAO,EAAE;IACrBD,IAAI,CAACE,IAAI,CAACzB,MAAM,CAAC;IAEjBA,MAAM,GAAGA,MAAM,CAACwB,OAAO;EACzB;EAEAD,IAAI,CAACE,IAAI,CAACzB,MAAM,CAAC;EAEjB,OAAOuB,IAAI,CAAC9B,OAAO,CAAC,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMiC,YAAY;EAAA,IAAAC,KAAA,GAAAhD,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAA+C,SAAOC,IAAI,EAAEC,IAAI,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO;IAAA,IAAAhC,UAAA,EAAAiB,QAAA,EAAAgB,MAAA,EAAAC,UAAA,EAAA9B,IAAA,EAAA+B,KAAA;IAAA,OAAAxD,mBAAA,GAAAI,IAAA,UAAAqD,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAnD,IAAA,GAAAmD,SAAA,CAAAlD,IAAA;QAAA;UAClE,IAAI,CAAC4C,OAAO,EAAE;YACN/B,UAAU,GAAG3B,UAAU,CAAC;cAC5BG,MAAM,EAANA;YACF,CAAC,CAAC;YAEFuD,OAAO,GAAG;cACR/B,UAAU,EAAVA,UAAU;cACVsC,SAAS,EAAE,CAAC;cACZC,UAAU,EAAEvC;YACd,CAAC;UACH;UAACqC,SAAA,CAAAlD,IAAA;UAAA,OAEKU,oBAAoB,CAAC+B,IAAI,CAACY,KAAK,EAAET,OAAO,CAACQ,UAAU,EAAER,OAAO,CAAC/B,UAAU,CAAC;QAAA;UAAAqC,SAAA,CAAAlD,IAAA;UAAA,OAEvD4C,OAAO,CAAC/B,UAAU,CAACyC,oBAAoB,CAACZ,IAAI,CAAC;QAAA;UAA9DZ,QAAQ,GAAAoB,SAAA,CAAA/C,IAAA;UACV2C,MAAM,GAAGjB,QAAQ,CAACC,QAAQ,CAACT,GAAG,CAAC;UAC7B0B,UAAU,GAAGb,YAAY,CAACJ,QAAQ,CAAC;UAEzC,IAAIiB,UAAU,CAAC3B,MAAM,GAAGwB,OAAO,CAACO,SAAS,EAAE;YACzCP,OAAO,CAACQ,UAAU,GAAGL,UAAU,CAACH,OAAO,CAACO,SAAS,CAAC;YAElDL,MAAM,GAAGjB,QAAQ,CAACe,OAAO,CAACQ,UAAU,CAACG,YAAY,CAAC;UACpD;UAEMtC,IAAI,GAAGwB,IAAI,CAACY,KAAK,CAACG,IAAI,CAAC,UAAAvC,IAAI,EAAI;YACnC,IAAIA,IAAI,CAACC,IAAI,IAAI,IAAI,EAAE;cACrB,OAAO,KAAK;YACd;YAEA,IAAMuC,WAAW,GAAGxC,IAAI,CAACC,IAAI,CAACU,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;YAC7C,IAAM8B,SAAS,GAAGzC,IAAI,CAACC,IAAI,CAACU,SAAS,CAAC,CAAC,CAAC;YAExC,IAAI6B,WAAW,KAAKX,MAAM,EAAE;cAC1B;cACA,OAAO,KAAK;YACd;YAEA,IAAIY,SAAS,IAAIA,SAAS,KAAKhB,IAAI,EAAE;cACnC;cACA,OAAO,KAAK;YACd;YAEA,OAAO,IAAI;UACb,CAAC,CAAC;UAAA,IAEGzB,IAAI;YAAAiC,SAAA,CAAAlD,IAAA;YAAA;UAAA;UAAA,OAAAkD,SAAA,CAAAhD,MAAA,WACA,IAAI;QAAA;UAAA,MAGTe,IAAI,CAACC,IAAI,IAAI,IAAI,IAAID,IAAI,CAACC,IAAI,CAACU,SAAS,CAAC,CAAC,CAAC,KAAKc,IAAI;YAAAQ,SAAA,CAAAlD,IAAA;YAAA;UAAA;UAAA,OAAAkD,SAAA,CAAAhD,MAAA,WAC/Ce,IAAI,CAAC0C,IAAI;QAAA;UAGlBf,OAAO,CAACO,SAAS,EAAE;UAAAD,SAAA,CAAAlD,IAAA;UAAA,OAEC2C,UAAU,CAACiB,GAAG,CAAC3C,IAAI,CAAC0C,IAAI,EAAEd,OAAO,CAAC;QAAA;UAAhDG,KAAK,GAAAE,SAAA,CAAA/C,IAAA;UACXsC,IAAI,GAAGtD,MAAM,CAAC6D,KAAK,CAAC;UAAA,OAAAE,SAAA,CAAAhD,MAAA,WAEboC,YAAY,CAACG,IAAI,EAAEC,IAAI,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO,CAAC;QAAA;QAAA;UAAA,OAAAK,SAAA,CAAA5C,IAAA;MAAA;IAAA,GAAAkC,QAAA;EAAA,CAC9D;EAAA,gBA5DKF,YAAYA,CAAAuB,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;IAAA,OAAA1B,KAAA,CAAA/B,KAAA,OAAAC,SAAA;EAAA;AAAA,GA4DjB;AAED,eAAe6B,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}