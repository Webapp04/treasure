{"ast":null,"code":"import _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { pbStream } from 'it-pb-stream';\nimport { duplexPair } from 'it-pair/duplex';\nimport { pipe } from 'it-pipe';\nimport { encode, decode } from 'it-length-prefixed';\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js';\nimport { stablelib } from './crypto/stablelib.js';\nimport { decryptStream, encryptStream } from './crypto/streaming.js';\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js';\nimport { XXHandshake } from './handshake-xx.js';\nimport { getPayload } from './utils.js';\nexport var Noise = /*#__PURE__*/function () {\n  /**\n   * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  function Noise(staticNoiseKey, earlyData) {\n    var crypto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stablelib;\n    var prologueBytes = arguments.length > 3 ? arguments[3] : undefined;\n    _classCallCheck(this, Noise);\n    this.protocol = '/noise';\n    this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : new Uint8Array(0);\n    this.crypto = crypto;\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);\n    } else {\n      this.staticKeys = this.crypto.generateX25519KeyPair();\n    }\n    this.prologue = prologueBytes !== null && prologueBytes !== void 0 ? prologueBytes : new Uint8Array(0);\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecuredConnection>}\n   */\n  _createClass(Noise, [{\n    key: \"secureOutbound\",\n    value: function () {\n      var _secureOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              wrappedConnection = pbStream(connection, {\n                lengthEncoder: uint16BEEncode,\n                lengthDecoder: uint16BEDecode,\n                maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n              });\n              _context.next = 3;\n              return this.performHandshake({\n                connection: wrappedConnection,\n                isInitiator: true,\n                localPeer: localPeer,\n                remotePeer: remotePeer\n              });\n            case 3:\n              handshake = _context.sent;\n              _context.next = 6;\n              return this.createSecureConnection(wrappedConnection, handshake);\n            case 6:\n              conn = _context.sent;\n              return _context.abrupt(\"return\", {\n                conn: conn,\n                remoteEarlyData: handshake.remoteEarlyData,\n                remotePeer: handshake.remotePeer\n              });\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function secureOutbound(_x, _x2, _x3) {\n        return _secureOutbound.apply(this, arguments);\n      }\n      return secureOutbound;\n    }()\n    /**\n     * Decrypt incoming data (handshake as responder).\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecuredConnection>}\n     */\n  }, {\n    key: \"secureInbound\",\n    value: function () {\n      var _secureInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              wrappedConnection = pbStream(connection, {\n                lengthEncoder: uint16BEEncode,\n                lengthDecoder: uint16BEDecode,\n                maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n              });\n              _context2.next = 3;\n              return this.performHandshake({\n                connection: wrappedConnection,\n                isInitiator: false,\n                localPeer: localPeer,\n                remotePeer: remotePeer\n              });\n            case 3:\n              handshake = _context2.sent;\n              _context2.next = 6;\n              return this.createSecureConnection(wrappedConnection, handshake);\n            case 6:\n              conn = _context2.sent;\n              return _context2.abrupt(\"return\", {\n                conn: conn,\n                remoteEarlyData: handshake.remoteEarlyData,\n                remotePeer: handshake.remotePeer\n              });\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function secureInbound(_x4, _x5, _x6) {\n        return _secureInbound.apply(this, arguments);\n      }\n      return secureInbound;\n    }()\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     *\n     * @param {HandshakeParams} params\n     */\n  }, {\n    key: \"performHandshake\",\n    value: function () {\n      var _performHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {\n        var payload;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n            case 2:\n              payload = _context3.sent;\n              _context3.next = 5;\n              return this.performXXHandshake(params, payload);\n            case 5:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function performHandshake(_x7) {\n        return _performHandshake.apply(this, arguments);\n      }\n      return performHandshake;\n    }()\n  }, {\n    key: \"performXXHandshake\",\n    value: function () {\n      var _performXXHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params, payload) {\n        var isInitiator, remotePeer, connection, handshake;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              isInitiator = params.isInitiator, remotePeer = params.remotePeer, connection = params.connection;\n              handshake = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);\n              _context4.prev = 2;\n              _context4.next = 5;\n              return handshake.propose();\n            case 5:\n              _context4.next = 7;\n              return handshake.exchange();\n            case 7:\n              _context4.next = 9;\n              return handshake.finish();\n            case 9:\n              _context4.next = 16;\n              break;\n            case 11:\n              _context4.prev = 11;\n              _context4.t0 = _context4[\"catch\"](2);\n              if (!(_context4.t0 instanceof Error)) {\n                _context4.next = 16;\n                break;\n              }\n              _context4.t0.message = \"Error occurred during XX handshake: \".concat(_context4.t0.message);\n              throw _context4.t0;\n            case 16:\n              return _context4.abrupt(\"return\", handshake);\n            case 17:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[2, 11]]);\n      }));\n      function performXXHandshake(_x8, _x9) {\n        return _performXXHandshake.apply(this, arguments);\n      }\n      return performXXHandshake;\n    }()\n  }, {\n    key: \"createSecureConnection\",\n    value: function () {\n      var _createSecureConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(connection, handshake) {\n        var _duplexPair, _duplexPair2, secure, user, network;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              // Create encryption box/unbox wrapper\n              _duplexPair = duplexPair(), _duplexPair2 = _slicedToArray(_duplexPair, 2), secure = _duplexPair2[0], user = _duplexPair2[1];\n              network = connection.unwrap();\n              _context5.next = 4;\n              return pipe(secure,\n              // write to wrapper\n              encryptStream(handshake),\n              // data is encrypted\n              encode({\n                lengthEncoder: uint16BEEncode\n              }),\n              // prefix with message length\n              network,\n              // send to the remote peer\n              decode({\n                lengthDecoder: uint16BEDecode\n              }),\n              // read message length prefix\n              decryptStream(handshake),\n              // decrypt the incoming data\n              secure // pipe to the wrapper\n              );\n            case 4:\n              return _context5.abrupt(\"return\", user);\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      function createSecureConnection(_x10, _x11) {\n        return _createSecureConnection.apply(this, arguments);\n      }\n      return createSecureConnection;\n    }()\n  }]);\n  return Noise;\n}();","map":{"version":3,"names":["pbStream","duplexPair","pipe","encode","decode","NOISE_MSG_MAX_LENGTH_BYTES","stablelib","decryptStream","encryptStream","uint16BEDecode","uint16BEEncode","XXHandshake","getPayload","Noise","staticNoiseKey","earlyData","crypto","arguments","length","undefined","prologueBytes","_classCallCheck","protocol","Uint8Array","staticKeys","generateX25519KeyPairFromSeed","generateX25519KeyPair","prologue","_createClass","key","value","_secureOutbound","_asyncToGenerator","_regeneratorRuntime","mark","_callee","localPeer","connection","remotePeer","wrappedConnection","handshake","conn","wrap","_callee$","_context","prev","next","lengthEncoder","lengthDecoder","maxDataLength","performHandshake","isInitiator","sent","createSecureConnection","abrupt","remoteEarlyData","stop","secureOutbound","_x","_x2","_x3","apply","_secureInbound","_callee2","_callee2$","_context2","secureInbound","_x4","_x5","_x6","_performHandshake","_callee3","params","payload","_callee3$","_context3","publicKey","performXXHandshake","_x7","_performXXHandshake","_callee4","_callee4$","_context4","propose","exchange","finish","t0","Error","message","concat","_x8","_x9","_createSecureConnection","_callee5","_duplexPair","_duplexPair2","secure","user","network","_callee5$","_context5","_slicedToArray","unwrap","_x10","_x11"],"sources":["/Users/apple/Documents/treasure/node_modules/@chainsafe/libp2p-noise/src/noise.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport type { SecuredConnection } from '@libp2p/interface-connection-encrypter'\nimport { pbStream, ProtobufStream } from 'it-pb-stream'\nimport { duplexPair } from 'it-pair/duplex'\nimport { pipe } from 'it-pipe'\nimport { encode, decode } from 'it-length-prefixed'\nimport type { Duplex } from 'it-stream-types'\nimport type { bytes } from './@types/basic.js'\nimport type { IHandshake } from './@types/handshake-interface.js'\nimport type { INoiseConnection, KeyPair } from './@types/libp2p.js'\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js'\nimport type { ICryptoInterface } from './crypto.js'\nimport { stablelib } from './crypto/stablelib.js'\nimport { decryptStream, encryptStream } from './crypto/streaming.js'\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js'\nimport { XXHandshake } from './handshake-xx.js'\nimport { getPayload } from './utils.js'\n\ninterface HandshakeParams {\n  connection: ProtobufStream\n  isInitiator: boolean\n  localPeer: PeerId\n  remotePeer?: PeerId\n}\n\nexport class Noise implements INoiseConnection {\n  public protocol = '/noise'\n  public crypto: ICryptoInterface\n\n  private readonly prologue: Uint8Array\n  private readonly staticKeys: KeyPair\n  private readonly earlyData?: bytes\n\n  /**\n   * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  constructor (staticNoiseKey?: bytes, earlyData?: bytes, crypto: ICryptoInterface = stablelib, prologueBytes?: Uint8Array) {\n    this.earlyData = earlyData ?? new Uint8Array(0)\n    this.crypto = crypto\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey)\n    } else {\n      this.staticKeys = this.crypto.generateX25519KeyPair()\n    }\n    this.prologue = prologueBytes ?? new Uint8Array(0)\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecuredConnection>}\n   */\n  public async secureOutbound (localPeer: PeerId, connection: Duplex<Uint8Array>, remotePeer?: PeerId): Promise<SecuredConnection> {\n    const wrappedConnection = pbStream(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecuredConnection>}\n   */\n  public async secureInbound (localPeer: PeerId, connection: Duplex<Uint8Array>, remotePeer?: PeerId): Promise<SecuredConnection> {\n    const wrappedConnection = pbStream(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    }\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n  private async performHandshake (params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData)\n\n    // run XX handshake\n    return await this.performXXHandshake(params, payload)\n  }\n\n  private async performXXHandshake (\n    params: HandshakeParams,\n    payload: bytes\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params\n    const handshake = new XXHandshake(\n      isInitiator,\n      payload,\n      this.prologue,\n      this.crypto,\n      this.staticKeys,\n      connection,\n      remotePeer\n    )\n\n    try {\n      await handshake.propose()\n      await handshake.exchange()\n      await handshake.finish()\n    } catch (e: unknown) {\n      if (e instanceof Error) {\n        e.message = `Error occurred during XX handshake: ${e.message}`\n        throw e\n      }\n    }\n\n    return handshake\n  }\n\n  private async createSecureConnection (\n    connection: ProtobufStream,\n    handshake: IHandshake\n  ): Promise<Duplex<Uint8Array>> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = duplexPair<Uint8Array>()\n    const network = connection.unwrap()\n\n    await pipe(\n      secure, // write to wrapper\n      encryptStream(handshake), // data is encrypted\n      encode({ lengthEncoder: uint16BEEncode }), // prefix with message length\n      network, // send to the remote peer\n      decode({ lengthDecoder: uint16BEDecode }), // read message length prefix\n      decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n    )\n\n    return user\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}