{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _defineProperty = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ViewportList = void 0;\nvar jsx_runtime_1 = require(\"react/jsx-runtime\");\nvar react_1 = require(\"react\");\nvar IS_SSR = typeof window === 'undefined';\nvar IS_TOUCH_DEVICE = !IS_SSR && function () {\n  try {\n    return 'ontouchstart' in window || navigator.maxTouchPoints;\n  } catch (_a) {\n    return false;\n  }\n}();\nvar IS_OVERFLOW_ANCHOR_SUPPORTED = !IS_SSR && function () {\n  try {\n    return window.CSS.supports('overflow-anchor: auto');\n  } catch (_a) {\n    return false;\n  }\n}();\nvar SHOULD_DELAY_SCROLL = IS_TOUCH_DEVICE && !IS_OVERFLOW_ANCHOR_SUPPORTED;\nvar PROP_NAME_FOR_Y_AXIS = {\n  top: 'top',\n  bottom: 'bottom',\n  clientHeight: 'clientHeight',\n  scrollHeight: 'scrollHeight',\n  scrollTop: 'scrollTop',\n  overflowY: 'overflowY',\n  height: 'height',\n  minHeight: 'minHeight',\n  maxHeight: 'maxHeight',\n  marginTop: 'marginTop'\n};\nvar PROP_NAME_FOR_X_AXIS = {\n  top: 'left',\n  bottom: 'right',\n  scrollHeight: 'scrollWidth',\n  clientHeight: 'clientWidth',\n  scrollTop: 'scrollLeft',\n  overflowY: 'overflowX',\n  minHeight: 'minWidth',\n  height: 'width',\n  maxHeight: 'maxWidth',\n  marginTop: 'marginLeft'\n};\nvar normalizeValue = function normalizeValue(min, value) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  return Math.max(Math.min(value, max), min);\n};\nvar getDiff = function getDiff(value1, value2, step) {\n  return Math.ceil(Math.abs(value1 - value2) / step);\n};\nvar useIsomorphicLayoutEffect = IS_SSR ? react_1.useEffect : react_1.useLayoutEffect;\nvar generateArray = function generateArray(from, to, generate) {\n  var array = [];\n  for (var index = from; index < to; index++) {\n    array.push(generate(index));\n  }\n  return array;\n};\nvar findElement = function findElement(_ref) {\n  var fromElement = _ref.fromElement,\n    toElement = _ref.toElement,\n    fromIndex = _ref.fromIndex,\n    _ref$asc = _ref.asc,\n    asc = _ref$asc === void 0 ? true : _ref$asc,\n    compare = _ref.compare;\n  var index = fromIndex;\n  var element = fromElement;\n  while (element && element !== toElement) {\n    if (compare(element, index)) {\n      return [element, index];\n    }\n    if (asc) {\n      index++;\n      element = element.nextSibling;\n    } else {\n      index--;\n      element = element.previousSibling;\n    }\n  }\n  return [null, -1];\n};\nvar SCROLLABLE_REGEXP = /auto|scroll/gi;\nvar findNearestScrollableElement = function findNearestScrollableElement(propName, node) {\n  if (!node || node === document.body || node === document.documentElement) {\n    return document.documentElement;\n  }\n  var style = window.getComputedStyle(node);\n  if (SCROLLABLE_REGEXP.test(style[propName.overflowY]) || SCROLLABLE_REGEXP.test(style.overflow)) {\n    return node;\n  }\n  return findNearestScrollableElement(propName, node.parentNode);\n};\nvar getStyle = function getStyle(propName, size) {\n  var _ref2;\n  var marginTop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return _ref2 = {\n    padding: 0,\n    margin: 0,\n    border: 'none',\n    visibility: 'hidden',\n    overflowAnchor: 'none'\n  }, _defineProperty(_ref2, propName.minHeight, size), _defineProperty(_ref2, propName.height, size), _defineProperty(_ref2, propName.maxHeight, size), _defineProperty(_ref2, propName.marginTop, marginTop), _ref2;\n};\nvar ViewportListInner = function ViewportListInner(_ref3, ref) {\n  var _ref3$items = _ref3.items,\n    items = _ref3$items === void 0 ? [] : _ref3$items,\n    count = _ref3.count,\n    children = _ref3.children,\n    viewportRef = _ref3.viewportRef,\n    _ref3$itemSize = _ref3.itemSize,\n    itemSize = _ref3$itemSize === void 0 ? 0 : _ref3$itemSize,\n    _ref3$itemMargin = _ref3.itemMargin,\n    itemMargin = _ref3$itemMargin === void 0 ? -1 : _ref3$itemMargin,\n    _ref3$overscan = _ref3.overscan,\n    overscan = _ref3$overscan === void 0 ? 1 : _ref3$overscan,\n    _ref3$axis = _ref3.axis,\n    axis = _ref3$axis === void 0 ? 'y' : _ref3$axis,\n    _ref3$initialIndex = _ref3.initialIndex,\n    initialIndex = _ref3$initialIndex === void 0 ? -1 : _ref3$initialIndex,\n    _ref3$initialAlignToT = _ref3.initialAlignToTop,\n    initialAlignToTop = _ref3$initialAlignToT === void 0 ? true : _ref3$initialAlignToT,\n    _ref3$initialOffset = _ref3.initialOffset,\n    initialOffset = _ref3$initialOffset === void 0 ? 0 : _ref3$initialOffset,\n    _ref3$initialDelay = _ref3.initialDelay,\n    initialDelay = _ref3$initialDelay === void 0 ? -1 : _ref3$initialDelay,\n    _ref3$initialPrerende = _ref3.initialPrerender,\n    initialPrerender = _ref3$initialPrerende === void 0 ? 0 : _ref3$initialPrerende,\n    onViewportIndexesChange = _ref3.onViewportIndexesChange,\n    _ref3$overflowAnchor = _ref3.overflowAnchor,\n    overflowAnchor = _ref3$overflowAnchor === void 0 ? 'auto' : _ref3$overflowAnchor,\n    _ref3$withCache = _ref3.withCache,\n    withCache = _ref3$withCache === void 0 ? true : _ref3$withCache,\n    _ref3$scrollThreshold = _ref3.scrollThreshold,\n    scrollThreshold = _ref3$scrollThreshold === void 0 ? 0 : _ref3$scrollThreshold,\n    _ref3$renderSpacer = _ref3.renderSpacer,\n    renderSpacer = _ref3$renderSpacer === void 0 ? function (_ref4) {\n      var ref = _ref4.ref,\n        style = _ref4.style;\n      return (0, jsx_runtime_1.jsx)(\"div\", {\n        ref: ref,\n        style: style\n      }, void 0);\n    } : _ref3$renderSpacer,\n    _ref3$indexesShift = _ref3.indexesShift,\n    indexesShift = _ref3$indexesShift === void 0 ? 0 : _ref3$indexesShift,\n    _ref3$getItemBounding = _ref3.getItemBoundingClientRect,\n    getItemBoundingClientRect = _ref3$getItemBounding === void 0 ? function (element) {\n      return element.getBoundingClientRect();\n    } : _ref3$getItemBounding;\n  var propName = axis === 'y' ? PROP_NAME_FOR_Y_AXIS : PROP_NAME_FOR_X_AXIS;\n  var withCount = typeof count === 'number';\n  var maxIndex = (withCount ? count : items.length) - 1;\n  var _ref5 = (0, react_1.useState)(function () {\n      return [normalizeValue(0, itemSize), normalizeValue(-1, itemMargin)];\n    }),\n    _ref6 = _slicedToArray(_ref5, 2),\n    _ref6$ = _slicedToArray(_ref6[0], 2),\n    estimatedItemHeight = _ref6$[0],\n    estimatedItemMargin = _ref6$[1],\n    setItemDimensions = _ref6[1];\n  var itemHeightWithMargin = normalizeValue(0, estimatedItemHeight + estimatedItemMargin);\n  var overscanSize = normalizeValue(0, Math.ceil(overscan * itemHeightWithMargin));\n  var _ref7 = (0, react_1.useState)([initialIndex - initialPrerender, initialIndex + initialPrerender]),\n    _ref8 = _slicedToArray(_ref7, 2),\n    indexes = _ref8[0],\n    setIndexes = _ref8[1];\n  var anchorElementRef = (0, react_1.useRef)(null);\n  var anchorIndexRef = (0, react_1.useRef)(-1);\n  var topSpacerRef = (0, react_1.useRef)(null);\n  var bottomSpacerRef = (0, react_1.useRef)(null);\n  var ignoreOverflowAnchorRef = (0, react_1.useRef)(false);\n  var lastIndexesShiftRef = (0, react_1.useRef)(indexesShift);\n  var cacheRef = (0, react_1.useRef)([]);\n  var scrollToIndexOptionsRef = (0, react_1.useRef)(initialIndex >= 0 ? {\n    index: initialIndex,\n    alignToTop: initialAlignToTop,\n    offset: initialOffset,\n    delay: initialDelay,\n    prerender: initialPrerender\n  } : null);\n  var scrollToIndexTimeoutIdRef = (0, react_1.useRef)(null);\n  var marginTopRef = (0, react_1.useRef)(0);\n  var viewportIndexesRef = (0, react_1.useRef)([-1, -1]);\n  var scrollTopRef = (0, react_1.useRef)(null);\n  var _ref9 = (0, react_1.useMemo)(function () {\n      indexes[0] = normalizeValue(0, indexes[0], maxIndex);\n      indexes[1] = normalizeValue(indexes[0], indexes[1], maxIndex);\n      var shift = indexesShift - lastIndexesShiftRef.current;\n      lastIndexesShiftRef.current = indexesShift;\n      var topSpacer = topSpacerRef.current;\n      if (topSpacer && shift) {\n        indexes[0] = normalizeValue(0, indexes[0] + shift, maxIndex);\n        indexes[1] = normalizeValue(indexes[0], indexes[1] + shift, maxIndex);\n        anchorElementRef.current = topSpacer.nextSibling;\n        anchorIndexRef.current = indexes[0];\n        ignoreOverflowAnchorRef.current = true;\n      }\n      return indexes;\n    }, [indexesShift, indexes, maxIndex]),\n    _ref10 = _slicedToArray(_ref9, 2),\n    startIndex = _ref10[0],\n    endIndex = _ref10[1];\n  var topSpacerStyle = (0, react_1.useMemo)(function () {\n    return getStyle(propName, (withCache ? cacheRef.current : []).slice(0, startIndex).reduce(function (sum, next) {\n      return sum + (next - estimatedItemHeight);\n    }, startIndex * itemHeightWithMargin), marginTopRef.current);\n  }, [propName, withCache, startIndex, itemHeightWithMargin, estimatedItemHeight]);\n  var bottomSpacerStyle = (0, react_1.useMemo)(function () {\n    return getStyle(propName, (withCache ? cacheRef.current : []).slice(endIndex + 1, maxIndex + 1).reduce(function (sum, next) {\n      return sum + (next - estimatedItemHeight);\n    }, itemHeightWithMargin * (maxIndex - endIndex)));\n  }, [propName, withCache, endIndex, maxIndex, itemHeightWithMargin, estimatedItemHeight]);\n  var getViewport = (0, react_1.useMemo)(function () {\n    var autoViewport = null;\n    return function () {\n      if (viewportRef) {\n        if (viewportRef.current === document.body) {\n          return document.documentElement;\n        }\n        return viewportRef.current;\n      }\n      if (autoViewport && autoViewport.isConnected) {\n        return autoViewport;\n      }\n      var topSpacer = topSpacerRef.current;\n      if (!topSpacer) {\n        return null;\n      }\n      autoViewport = findNearestScrollableElement(propName, topSpacer.parentNode);\n      return autoViewport;\n    };\n  }, [propName, viewportRef]);\n  var mainFrameRef = (0, react_1.useRef)(function () {});\n  var getScrollPositionRef = (0, react_1.useRef)(function () {\n    return {\n      index: -1,\n      offset: 0\n    };\n  });\n  useIsomorphicLayoutEffect(function () {\n    mainFrameRef.current = function () {\n      var _limits, _limitsWithOverscanSi;\n      var viewport = getViewport();\n      var topSpacer = topSpacerRef.current;\n      var bottomSpacer = bottomSpacerRef.current;\n      if (!viewport || !topSpacer || !bottomSpacer) {\n        return;\n      }\n      var topElement = topSpacer.nextSibling;\n      var bottomElement = bottomSpacer.previousSibling;\n      var viewportRect = viewport.getBoundingClientRect();\n      var topSpacerRect = topSpacer.getBoundingClientRect();\n      var bottomSpacerRect = bottomSpacer.getBoundingClientRect();\n      var limits = (_limits = {}, _defineProperty(_limits, propName.top, viewport === document.documentElement ? 0 : viewportRect[propName.top]), _defineProperty(_limits, propName.bottom, viewport === document.documentElement ? document.documentElement[propName.clientHeight] : viewportRect[propName.bottom]), _limits);\n      var limitsWithOverscanSize = (_limitsWithOverscanSi = {}, _defineProperty(_limitsWithOverscanSi, propName.top, limits[propName.top] - overscanSize), _defineProperty(_limitsWithOverscanSi, propName.bottom, limits[propName.bottom] + overscanSize), _limitsWithOverscanSi);\n      if (marginTopRef.current < 0 && topSpacerRect[propName.top] - marginTopRef.current >= limitsWithOverscanSize[propName.top] || marginTopRef.current > 0 && topSpacerRect[propName.top] >= limitsWithOverscanSize[propName.top] || marginTopRef.current && scrollToIndexOptionsRef.current) {\n        topSpacer.style[propName.marginTop] = '0px';\n        viewport.style[propName.overflowY] = 'hidden';\n        viewport[propName.scrollTop] += -marginTopRef.current;\n        viewport.style[propName.overflowY] = '';\n        marginTopRef.current = 0;\n        return;\n      }\n      if (estimatedItemHeight === 0 || estimatedItemMargin === -1) {\n        var itemsHeightSum = 0;\n        findElement({\n          fromElement: topElement,\n          toElement: bottomSpacer,\n          fromIndex: startIndex,\n          compare: function compare(element) {\n            itemsHeightSum += getItemBoundingClientRect(element)[propName.height];\n            return false;\n          }\n        });\n        if (!itemsHeightSum) {\n          return;\n        }\n        var renderedItemsCount = endIndex - startIndex + 1;\n        var nextItemHeight = estimatedItemHeight === 0 ? Math.ceil(itemsHeightSum / renderedItemsCount) : estimatedItemHeight;\n        var nextItemMargin = estimatedItemMargin === -1 ? Math.ceil((bottomSpacerRect[propName.top] - topSpacerRect[propName.bottom] - itemsHeightSum) / renderedItemsCount) : estimatedItemMargin;\n        setItemDimensions([nextItemHeight, nextItemMargin]);\n        return;\n      }\n      if (scrollToIndexTimeoutIdRef.current) {\n        return;\n      }\n      if (scrollToIndexOptionsRef.current) {\n        var targetIndex = normalizeValue(0, scrollToIndexOptionsRef.current.index, maxIndex);\n        if (targetIndex < startIndex || targetIndex > endIndex) {\n          setIndexes([targetIndex - scrollToIndexOptionsRef.current.prerender, targetIndex + scrollToIndexOptionsRef.current.prerender]);\n          return;\n        }\n        var _findElement = findElement({\n            fromElement: topElement,\n            toElement: bottomSpacer,\n            fromIndex: startIndex,\n            compare: function compare(_, index) {\n              return index === targetIndex;\n            }\n          }),\n          _findElement2 = _slicedToArray(_findElement, 1),\n          targetElement = _findElement2[0];\n        if (!targetElement) {\n          return;\n        }\n        var _scrollToIndexOptions = scrollToIndexOptionsRef.current,\n          alignToTop = _scrollToIndexOptions.alignToTop,\n          offset = _scrollToIndexOptions.offset,\n          delay = _scrollToIndexOptions.delay;\n        scrollToIndexOptionsRef.current = null;\n        var scrollToElement = function scrollToElement() {\n          var elementRect = getItemBoundingClientRect(targetElement);\n          var shift = alignToTop ? elementRect[propName.top] - limits[propName.top] + offset : elementRect[propName.bottom] - limits[propName.top] - viewport[propName.clientHeight] + offset;\n          viewport[propName.scrollTop] += shift;\n          scrollToIndexTimeoutIdRef.current = null;\n        };\n        var scrollToElementDelay = delay < 0 && SHOULD_DELAY_SCROLL ? 30 : delay;\n        if (scrollToElementDelay > 0) {\n          scrollToIndexTimeoutIdRef.current = setTimeout(scrollToElement, scrollToElementDelay);\n          return;\n        }\n        scrollToElement();\n        return;\n      }\n      if (scrollTopRef.current === null) {\n        scrollTopRef.current = viewport.scrollTop;\n      } else if (scrollTopRef.current !== viewport.scrollTop) {\n        var diff = Math.abs(viewport.scrollTop - scrollTopRef.current);\n        scrollTopRef.current = viewport.scrollTop;\n        if (scrollThreshold > 0 && diff > scrollThreshold) {\n          return;\n        }\n      }\n      var topSecondElement = topElement === bottomSpacer ? bottomSpacer : topElement.nextSibling;\n      var bottomSecondElement = bottomElement === topSpacer ? topSpacer : bottomElement.previousSibling;\n      var averageSize = Math.ceil((bottomSpacerRect[propName.top] - topSpacerRect[propName.bottom]) / (endIndex + 1 - startIndex));\n      var isAllAboveTop = topSpacerRect[propName.bottom] > limitsWithOverscanSize[propName.bottom];\n      var isAllBelowBottom = bottomSpacerRect[propName.top] < limitsWithOverscanSize[propName.top];\n      var isTopBelowTop = !isAllAboveTop && !isAllBelowBottom && topSpacerRect[propName.bottom] > limitsWithOverscanSize[propName.top];\n      var isBottomAboveBottom = !isAllAboveTop && !isAllBelowBottom && bottomSpacerRect[propName.top] < limitsWithOverscanSize[propName.bottom];\n      var isBottomSecondAboveTop = !isAllAboveTop && !isAllBelowBottom && (bottomSecondElement === topSpacer ? topSpacerRect : getItemBoundingClientRect(bottomSecondElement))[propName.bottom] > limitsWithOverscanSize[propName.bottom];\n      var isTopSecondAboveTop = !isAllAboveTop && !isAllBelowBottom && (topSecondElement === bottomSpacer ? bottomSpacerRect : getItemBoundingClientRect(topSecondElement))[propName.top] < limitsWithOverscanSize[propName.top];\n      var nextStartIndex = startIndex;\n      var nextEndIndex = endIndex;\n      if (isAllAboveTop) {\n        nextStartIndex -= getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n        nextEndIndex -= getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n      }\n      if (isAllBelowBottom) {\n        nextEndIndex += getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n        nextStartIndex += getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n      }\n      if (isTopBelowTop) {\n        nextStartIndex -= getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n      }\n      if (isBottomAboveBottom) {\n        nextEndIndex += getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n      }\n      if (isBottomSecondAboveTop) {\n        var _findElement3 = findElement({\n            fromElement: bottomElement,\n            toElement: topSpacer,\n            fromIndex: endIndex,\n            asc: false,\n            compare: function compare(element) {\n              return getItemBoundingClientRect(element)[propName.bottom] <= limitsWithOverscanSize[propName.bottom];\n            }\n          }),\n          _findElement4 = _slicedToArray(_findElement3, 2),\n          index = _findElement4[1];\n        if (index !== -1) {\n          nextEndIndex = index + 1;\n        }\n      }\n      if (isTopSecondAboveTop) {\n        var _findElement5 = findElement({\n            fromElement: topElement,\n            toElement: bottomSpacer,\n            fromIndex: startIndex,\n            compare: function compare(element) {\n              return getItemBoundingClientRect(element)[propName.top] >= limitsWithOverscanSize[propName.top];\n            }\n          }),\n          _findElement6 = _slicedToArray(_findElement5, 2),\n          _index = _findElement6[1];\n        if (_index !== -1) {\n          nextStartIndex = _index - 1;\n        }\n      }\n      if (onViewportIndexesChange) {\n        var _findElement7 = findElement({\n            fromElement: topElement,\n            toElement: bottomSpacer,\n            fromIndex: startIndex,\n            compare: function compare(element) {\n              return getItemBoundingClientRect(element)[propName.bottom] > limits[propName.top];\n            }\n          }),\n          _findElement8 = _slicedToArray(_findElement7, 2),\n          startViewportIndex = _findElement8[1];\n        if (startViewportIndex === -1) {\n          startViewportIndex = startIndex;\n        }\n        var _findElement9 = findElement({\n            fromElement: bottomElement,\n            toElement: topSpacer,\n            fromIndex: endIndex,\n            asc: false,\n            compare: function compare(element) {\n              return getItemBoundingClientRect(element)[propName.top] < limits[propName.bottom];\n            }\n          }),\n          _findElement10 = _slicedToArray(_findElement9, 2),\n          endViewportIndex = _findElement10[1];\n        if (endViewportIndex === -1) {\n          endViewportIndex = endIndex;\n        }\n        if (startViewportIndex !== viewportIndexesRef.current[0] || endViewportIndex !== viewportIndexesRef.current[1]) {\n          viewportIndexesRef.current = [startViewportIndex, endViewportIndex];\n          onViewportIndexesChange(viewportIndexesRef.current);\n        }\n      }\n      nextStartIndex = normalizeValue(0, nextStartIndex, maxIndex);\n      nextEndIndex = normalizeValue(nextStartIndex, nextEndIndex, maxIndex);\n      if (nextStartIndex === startIndex && nextEndIndex === endIndex) {\n        return;\n      }\n      if (nextStartIndex !== startIndex) {\n        if (startIndex >= nextStartIndex) {\n          anchorElementRef.current = topElement;\n          anchorIndexRef.current = startIndex;\n        } else {\n          var _findElement11 = findElement({\n              fromElement: topElement,\n              toElement: bottomSpacer,\n              fromIndex: startIndex,\n              compare: function compare(element, index) {\n                if (index === nextStartIndex) {\n                  return true;\n                }\n                var elementRect = getItemBoundingClientRect(element);\n                if (elementRect[propName.height] !== estimatedItemHeight) {\n                  cacheRef.current[index] = elementRect[propName.height];\n                }\n                return false;\n              }\n            }),\n            _findElement12 = _slicedToArray(_findElement11, 2),\n            anchorElement = _findElement12[0],\n            anchorElementIndex = _findElement12[1];\n          if (anchorElement) {\n            anchorElementRef.current = anchorElement;\n            anchorIndexRef.current = anchorElementIndex;\n          } else {\n            anchorElementRef.current = bottomElement;\n            anchorIndexRef.current = endIndex;\n          }\n        }\n      }\n      setIndexes([nextStartIndex, nextEndIndex]);\n    };\n    getScrollPositionRef.current = function () {\n      var _limits2;\n      var viewport = getViewport();\n      var topSpacer = topSpacerRef.current;\n      var bottomSpacer = bottomSpacerRef.current;\n      var scrollIndex = -1;\n      var scrollOffset = 0;\n      if (!viewport || !topSpacer || !bottomSpacer) {\n        return {\n          index: scrollIndex,\n          offset: scrollOffset\n        };\n      }\n      var topElement = topSpacer.nextSibling;\n      var viewportRect = viewport.getBoundingClientRect();\n      var limits = (_limits2 = {}, _defineProperty(_limits2, propName.top, viewport === document.documentElement ? 0 : viewportRect[propName.top]), _defineProperty(_limits2, propName.bottom, viewport === document.documentElement ? document.documentElement[propName.clientHeight] : viewportRect[propName.bottom]), _limits2);\n      findElement({\n        fromElement: topElement,\n        toElement: bottomSpacer,\n        fromIndex: startIndex,\n        compare: function compare(element, index) {\n          var rect = getItemBoundingClientRect(element);\n          scrollIndex = index;\n          scrollOffset = limits[propName.top] - rect[propName.top];\n          return rect[propName.bottom] > limits[propName.top];\n        }\n      });\n      return {\n        index: scrollIndex,\n        offset: scrollOffset\n      };\n    };\n  });\n  var anchorHeightOnRender;\n  if (anchorElementRef.current && getViewport() && topSpacerRef.current) {\n    anchorHeightOnRender = getItemBoundingClientRect(anchorElementRef.current)[propName.top] - (getViewport() === document.documentElement ? 0 : getViewport().getBoundingClientRect()[propName.top]);\n  }\n  useIsomorphicLayoutEffect(function () {\n    anchorElementRef.current = null;\n    var anchorIndex = anchorIndexRef.current;\n    var ignoreOverflowAnchor = ignoreOverflowAnchorRef.current;\n    anchorIndexRef.current = -1;\n    ignoreOverflowAnchorRef.current = false;\n    var viewport = getViewport();\n    var topSpacer = topSpacerRef.current;\n    var bottomSpacer = bottomSpacerRef.current;\n    if (anchorIndex === -1 || !viewport || !topSpacer || !bottomSpacer || anchorHeightOnRender === undefined || IS_OVERFLOW_ANCHOR_SUPPORTED && overflowAnchor !== 'none' && !ignoreOverflowAnchor) {\n      return;\n    }\n    var top = null;\n    if (anchorIndex >= startIndex && anchorIndex <= endIndex) {\n      var _findElement13 = findElement({\n          fromElement: topSpacer.nextSibling,\n          toElement: bottomSpacer,\n          fromIndex: startIndex,\n          compare: function compare(_, index) {\n            return index === anchorIndex;\n          }\n        }),\n        _findElement14 = _slicedToArray(_findElement13, 1),\n        anchorElement = _findElement14[0];\n      if (anchorElement) {\n        top = getItemBoundingClientRect(anchorElement)[propName.top];\n      }\n    } else {\n      if (anchorIndex < startIndex) {\n        top = topSpacer.getBoundingClientRect()[propName.top] + (withCache ? cacheRef.current : []).slice(0, anchorIndex).reduce(function (sum, next) {\n          return sum + (next - estimatedItemHeight);\n        }, anchorIndex * itemHeightWithMargin);\n      } else if (anchorIndex <= maxIndex) {\n        top = bottomSpacer.getBoundingClientRect()[propName.top] + (withCache ? cacheRef.current : []).slice(endIndex + 1, anchorIndex).reduce(function (sum, next) {\n          return sum + (next - estimatedItemHeight);\n        }, itemHeightWithMargin * (anchorIndex - 1 - endIndex));\n      }\n    }\n    if (top === null) {\n      return;\n    }\n    var offset = top - (viewport === document.documentElement ? 0 : viewport.getBoundingClientRect()[propName.top]) - anchorHeightOnRender;\n    if (!offset) {\n      return;\n    }\n    if (IS_TOUCH_DEVICE) {\n      marginTopRef.current -= offset;\n      topSpacer.style[propName.marginTop] = \"\".concat(marginTopRef.current, \"px\");\n      return;\n    }\n    viewport[propName.scrollTop] += offset;\n  }, [startIndex]);\n  useIsomorphicLayoutEffect(function () {\n    var frameId;\n    var frame = function frame() {\n      frameId = requestAnimationFrame(frame);\n      mainFrameRef.current();\n    };\n    frame();\n    return function () {\n      cancelAnimationFrame(frameId);\n      if (scrollToIndexTimeoutIdRef.current) {\n        clearTimeout(scrollToIndexTimeoutIdRef.current);\n      }\n    };\n  }, []);\n  (0, react_1.useImperativeHandle)(ref, function () {\n    return {\n      scrollToIndex: function scrollToIndex(_ref11) {\n        var _ref11$index = _ref11.index,\n          index = _ref11$index === void 0 ? -1 : _ref11$index,\n          _ref11$alignToTop = _ref11.alignToTop,\n          alignToTop = _ref11$alignToTop === void 0 ? true : _ref11$alignToTop,\n          _ref11$offset = _ref11.offset,\n          offset = _ref11$offset === void 0 ? 0 : _ref11$offset,\n          _ref11$delay = _ref11.delay,\n          delay = _ref11$delay === void 0 ? -1 : _ref11$delay,\n          _ref11$prerender = _ref11.prerender,\n          prerender = _ref11$prerender === void 0 ? 0 : _ref11$prerender;\n        scrollToIndexOptionsRef.current = {\n          index: index,\n          alignToTop: alignToTop,\n          offset: offset,\n          delay: delay,\n          prerender: prerender\n        };\n        mainFrameRef.current();\n      },\n      getScrollPosition: function getScrollPosition() {\n        return getScrollPositionRef.current();\n      }\n    };\n  }, []);\n  return (0, jsx_runtime_1.jsxs)(react_1.Fragment, {\n    children: [renderSpacer({\n      ref: topSpacerRef,\n      style: topSpacerStyle,\n      type: 'top'\n    }), (!!count || !!items.length) && generateArray(startIndex, endIndex + 1, withCount ? children : function (index) {\n      return children(items[index], index, items);\n    }), renderSpacer({\n      ref: bottomSpacerRef,\n      style: bottomSpacerStyle,\n      type: 'bottom'\n    })]\n  }, void 0);\n};\nexports.ViewportList = (0, react_1.forwardRef)(ViewportListInner);","map":{"version":3,"names":["_slicedToArray","require","default","_defineProperty","Object","defineProperty","exports","value","ViewportList","jsx_runtime_1","react_1","IS_SSR","window","IS_TOUCH_DEVICE","navigator","maxTouchPoints","_a","IS_OVERFLOW_ANCHOR_SUPPORTED","CSS","supports","SHOULD_DELAY_SCROLL","PROP_NAME_FOR_Y_AXIS","top","bottom","clientHeight","scrollHeight","scrollTop","overflowY","height","minHeight","maxHeight","marginTop","PROP_NAME_FOR_X_AXIS","normalizeValue","min","max","arguments","length","undefined","Infinity","Math","getDiff","value1","value2","step","ceil","abs","useIsomorphicLayoutEffect","useEffect","useLayoutEffect","generateArray","from","to","generate","array","index","push","findElement","_ref","fromElement","toElement","fromIndex","_ref$asc","asc","compare","element","nextSibling","previousSibling","SCROLLABLE_REGEXP","findNearestScrollableElement","propName","node","document","body","documentElement","style","getComputedStyle","test","overflow","parentNode","getStyle","size","_ref2","padding","margin","border","visibility","overflowAnchor","ViewportListInner","_ref3","ref","_ref3$items","items","count","children","viewportRef","_ref3$itemSize","itemSize","_ref3$itemMargin","itemMargin","_ref3$overscan","overscan","_ref3$axis","axis","_ref3$initialIndex","initialIndex","_ref3$initialAlignToT","initialAlignToTop","_ref3$initialOffset","initialOffset","_ref3$initialDelay","initialDelay","_ref3$initialPrerende","initialPrerender","onViewportIndexesChange","_ref3$overflowAnchor","_ref3$withCache","withCache","_ref3$scrollThreshold","scrollThreshold","_ref3$renderSpacer","renderSpacer","_ref4","jsx","_ref3$indexesShift","indexesShift","_ref3$getItemBounding","getItemBoundingClientRect","getBoundingClientRect","withCount","maxIndex","_ref5","useState","_ref6","_ref6$","estimatedItemHeight","estimatedItemMargin","setItemDimensions","itemHeightWithMargin","overscanSize","_ref7","_ref8","indexes","setIndexes","anchorElementRef","useRef","anchorIndexRef","topSpacerRef","bottomSpacerRef","ignoreOverflowAnchorRef","lastIndexesShiftRef","cacheRef","scrollToIndexOptionsRef","alignToTop","offset","delay","prerender","scrollToIndexTimeoutIdRef","marginTopRef","viewportIndexesRef","scrollTopRef","_ref9","useMemo","shift","current","topSpacer","_ref10","startIndex","endIndex","topSpacerStyle","slice","reduce","sum","next","bottomSpacerStyle","getViewport","autoViewport","isConnected","mainFrameRef","getScrollPositionRef","_limits","_limitsWithOverscanSi","viewport","bottomSpacer","topElement","bottomElement","viewportRect","topSpacerRect","bottomSpacerRect","limits","limitsWithOverscanSize","itemsHeightSum","renderedItemsCount","nextItemHeight","nextItemMargin","targetIndex","_findElement","_","_findElement2","targetElement","_scrollToIndexOptions","scrollToElement","elementRect","scrollToElementDelay","setTimeout","diff","topSecondElement","bottomSecondElement","averageSize","isAllAboveTop","isAllBelowBottom","isTopBelowTop","isBottomAboveBottom","isBottomSecondAboveTop","isTopSecondAboveTop","nextStartIndex","nextEndIndex","_findElement3","_findElement4","_findElement5","_findElement6","_findElement7","_findElement8","startViewportIndex","_findElement9","_findElement10","endViewportIndex","_findElement11","_findElement12","anchorElement","anchorElementIndex","_limits2","scrollIndex","scrollOffset","rect","anchorHeightOnRender","anchorIndex","ignoreOverflowAnchor","_findElement13","_findElement14","concat","frameId","frame","requestAnimationFrame","cancelAnimationFrame","clearTimeout","useImperativeHandle","scrollToIndex","_ref11","_ref11$index","_ref11$alignToTop","_ref11$offset","_ref11$delay","_ref11$prerender","getScrollPosition","jsxs","Fragment","type","forwardRef"],"sources":["/Users/apple/Documents/treasure/node_modules/react-viewport-list/lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ViewportList = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = require(\"react\");\nconst IS_SSR = typeof window === 'undefined';\nconst IS_TOUCH_DEVICE = !IS_SSR &&\n    (() => {\n        try {\n            return 'ontouchstart' in window || navigator.maxTouchPoints;\n        }\n        catch (_a) {\n            return false;\n        }\n    })();\nconst IS_OVERFLOW_ANCHOR_SUPPORTED = !IS_SSR &&\n    (() => {\n        try {\n            return window.CSS.supports('overflow-anchor: auto');\n        }\n        catch (_a) {\n            return false;\n        }\n    })();\nconst SHOULD_DELAY_SCROLL = IS_TOUCH_DEVICE && !IS_OVERFLOW_ANCHOR_SUPPORTED;\nconst PROP_NAME_FOR_Y_AXIS = {\n    top: 'top',\n    bottom: 'bottom',\n    clientHeight: 'clientHeight',\n    scrollHeight: 'scrollHeight',\n    scrollTop: 'scrollTop',\n    overflowY: 'overflowY',\n    height: 'height',\n    minHeight: 'minHeight',\n    maxHeight: 'maxHeight',\n    marginTop: 'marginTop',\n};\nconst PROP_NAME_FOR_X_AXIS = {\n    top: 'left',\n    bottom: 'right',\n    scrollHeight: 'scrollWidth',\n    clientHeight: 'clientWidth',\n    scrollTop: 'scrollLeft',\n    overflowY: 'overflowX',\n    minHeight: 'minWidth',\n    height: 'width',\n    maxHeight: 'maxWidth',\n    marginTop: 'marginLeft',\n};\nconst normalizeValue = (min, value, max = Infinity) => Math.max(Math.min(value, max), min);\nconst getDiff = (value1, value2, step) => Math.ceil(Math.abs(value1 - value2) / step);\nconst useIsomorphicLayoutEffect = IS_SSR ? react_1.useEffect : react_1.useLayoutEffect;\nconst generateArray = (from, to, generate) => {\n    const array = [];\n    for (let index = from; index < to; index++) {\n        array.push(generate(index));\n    }\n    return array;\n};\nconst findElement = ({ fromElement, toElement, fromIndex, asc = true, compare, }) => {\n    let index = fromIndex;\n    let element = fromElement;\n    while (element && element !== toElement) {\n        if (compare(element, index)) {\n            return [element, index];\n        }\n        if (asc) {\n            index++;\n            element = element.nextSibling;\n        }\n        else {\n            index--;\n            element = element.previousSibling;\n        }\n    }\n    return [null, -1];\n};\nconst SCROLLABLE_REGEXP = /auto|scroll/gi;\nconst findNearestScrollableElement = (propName, node) => {\n    if (!node || node === document.body || node === document.documentElement) {\n        return document.documentElement;\n    }\n    const style = window.getComputedStyle(node);\n    if (SCROLLABLE_REGEXP.test(style[propName.overflowY]) || SCROLLABLE_REGEXP.test(style.overflow)) {\n        return node;\n    }\n    return findNearestScrollableElement(propName, node.parentNode);\n};\nconst getStyle = (propName, size, marginTop = 0) => ({\n    padding: 0,\n    margin: 0,\n    border: 'none',\n    visibility: 'hidden',\n    overflowAnchor: 'none',\n    [propName.minHeight]: size,\n    [propName.height]: size,\n    [propName.maxHeight]: size,\n    [propName.marginTop]: marginTop,\n});\nconst ViewportListInner = ({ items = [], count, children, viewportRef, itemSize = 0, itemMargin = -1, overscan = 1, axis = 'y', initialIndex = -1, initialAlignToTop = true, initialOffset = 0, initialDelay = -1, initialPrerender = 0, onViewportIndexesChange, overflowAnchor = 'auto', withCache = true, scrollThreshold = 0, renderSpacer = ({ ref, style }) => (0, jsx_runtime_1.jsx)(\"div\", { ref: ref, style: style }, void 0), indexesShift = 0, getItemBoundingClientRect = (element) => element.getBoundingClientRect(), }, ref) => {\n    const propName = axis === 'y' ? PROP_NAME_FOR_Y_AXIS : PROP_NAME_FOR_X_AXIS;\n    const withCount = typeof count === 'number';\n    const maxIndex = (withCount ? count : items.length) - 1;\n    const [[estimatedItemHeight, estimatedItemMargin], setItemDimensions] = (0, react_1.useState)(() => [\n        normalizeValue(0, itemSize),\n        normalizeValue(-1, itemMargin),\n    ]);\n    const itemHeightWithMargin = normalizeValue(0, estimatedItemHeight + estimatedItemMargin);\n    const overscanSize = normalizeValue(0, Math.ceil(overscan * itemHeightWithMargin));\n    const [indexes, setIndexes] = (0, react_1.useState)([initialIndex - initialPrerender, initialIndex + initialPrerender]);\n    const anchorElementRef = (0, react_1.useRef)(null);\n    const anchorIndexRef = (0, react_1.useRef)(-1);\n    const topSpacerRef = (0, react_1.useRef)(null);\n    const bottomSpacerRef = (0, react_1.useRef)(null);\n    const ignoreOverflowAnchorRef = (0, react_1.useRef)(false);\n    const lastIndexesShiftRef = (0, react_1.useRef)(indexesShift);\n    const cacheRef = (0, react_1.useRef)([]);\n    const scrollToIndexOptionsRef = (0, react_1.useRef)(initialIndex >= 0\n        ? {\n            index: initialIndex,\n            alignToTop: initialAlignToTop,\n            offset: initialOffset,\n            delay: initialDelay,\n            prerender: initialPrerender,\n        }\n        : null);\n    const scrollToIndexTimeoutIdRef = (0, react_1.useRef)(null);\n    const marginTopRef = (0, react_1.useRef)(0);\n    const viewportIndexesRef = (0, react_1.useRef)([-1, -1]);\n    const scrollTopRef = (0, react_1.useRef)(null);\n    const [startIndex, endIndex] = (0, react_1.useMemo)(() => {\n        indexes[0] = normalizeValue(0, indexes[0], maxIndex);\n        indexes[1] = normalizeValue(indexes[0], indexes[1], maxIndex);\n        const shift = indexesShift - lastIndexesShiftRef.current;\n        lastIndexesShiftRef.current = indexesShift;\n        const topSpacer = topSpacerRef.current;\n        if (topSpacer && shift) {\n            indexes[0] = normalizeValue(0, indexes[0] + shift, maxIndex);\n            indexes[1] = normalizeValue(indexes[0], indexes[1] + shift, maxIndex);\n            anchorElementRef.current = topSpacer.nextSibling;\n            anchorIndexRef.current = indexes[0];\n            ignoreOverflowAnchorRef.current = true;\n        }\n        return indexes;\n    }, [indexesShift, indexes, maxIndex]);\n    const topSpacerStyle = (0, react_1.useMemo)(() => getStyle(propName, (withCache ? cacheRef.current : [])\n        .slice(0, startIndex)\n        .reduce((sum, next) => sum + (next - estimatedItemHeight), startIndex * itemHeightWithMargin), marginTopRef.current), [propName, withCache, startIndex, itemHeightWithMargin, estimatedItemHeight]);\n    const bottomSpacerStyle = (0, react_1.useMemo)(() => getStyle(propName, (withCache ? cacheRef.current : [])\n        .slice(endIndex + 1, maxIndex + 1)\n        .reduce((sum, next) => sum + (next - estimatedItemHeight), itemHeightWithMargin * (maxIndex - endIndex))), [propName, withCache, endIndex, maxIndex, itemHeightWithMargin, estimatedItemHeight]);\n    const getViewport = (0, react_1.useMemo)(() => {\n        let autoViewport = null;\n        return () => {\n            if (viewportRef) {\n                if (viewportRef.current === document.body) {\n                    return document.documentElement;\n                }\n                return viewportRef.current;\n            }\n            if (autoViewport && autoViewport.isConnected) {\n                return autoViewport;\n            }\n            const topSpacer = topSpacerRef.current;\n            if (!topSpacer) {\n                return null;\n            }\n            autoViewport = findNearestScrollableElement(propName, topSpacer.parentNode);\n            return autoViewport;\n        };\n    }, [propName, viewportRef]);\n    const mainFrameRef = (0, react_1.useRef)(() => { });\n    const getScrollPositionRef = (0, react_1.useRef)(() => ({ index: -1, offset: 0 }));\n    useIsomorphicLayoutEffect(() => {\n        mainFrameRef.current = () => {\n            const viewport = getViewport();\n            const topSpacer = topSpacerRef.current;\n            const bottomSpacer = bottomSpacerRef.current;\n            if (!viewport || !topSpacer || !bottomSpacer) {\n                return;\n            }\n            const topElement = topSpacer.nextSibling;\n            const bottomElement = bottomSpacer.previousSibling;\n            const viewportRect = viewport.getBoundingClientRect();\n            const topSpacerRect = topSpacer.getBoundingClientRect();\n            const bottomSpacerRect = bottomSpacer.getBoundingClientRect();\n            const limits = {\n                [propName.top]: viewport === document.documentElement ? 0 : viewportRect[propName.top],\n                [propName.bottom]: viewport === document.documentElement\n                    ? document.documentElement[propName.clientHeight]\n                    : viewportRect[propName.bottom],\n            };\n            const limitsWithOverscanSize = {\n                [propName.top]: limits[propName.top] - overscanSize,\n                [propName.bottom]: limits[propName.bottom] + overscanSize,\n            };\n            if ((marginTopRef.current < 0 &&\n                topSpacerRect[propName.top] - marginTopRef.current >= limitsWithOverscanSize[propName.top]) ||\n                (marginTopRef.current > 0 && topSpacerRect[propName.top] >= limitsWithOverscanSize[propName.top]) ||\n                (marginTopRef.current && scrollToIndexOptionsRef.current)) {\n                topSpacer.style[propName.marginTop] = '0px';\n                viewport.style[propName.overflowY] = 'hidden';\n                viewport[propName.scrollTop] += -marginTopRef.current;\n                viewport.style[propName.overflowY] = '';\n                marginTopRef.current = 0;\n                return;\n            }\n            if (estimatedItemHeight === 0 || estimatedItemMargin === -1) {\n                let itemsHeightSum = 0;\n                findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (element) => {\n                        itemsHeightSum += getItemBoundingClientRect(element)[propName.height];\n                        return false;\n                    },\n                });\n                if (!itemsHeightSum) {\n                    return;\n                }\n                const renderedItemsCount = endIndex - startIndex + 1;\n                const nextItemHeight = estimatedItemHeight === 0 ? Math.ceil(itemsHeightSum / renderedItemsCount) : estimatedItemHeight;\n                const nextItemMargin = estimatedItemMargin === -1\n                    ? Math.ceil((bottomSpacerRect[propName.top] - topSpacerRect[propName.bottom] - itemsHeightSum) /\n                        renderedItemsCount)\n                    : estimatedItemMargin;\n                setItemDimensions([nextItemHeight, nextItemMargin]);\n                return;\n            }\n            if (scrollToIndexTimeoutIdRef.current) {\n                return;\n            }\n            if (scrollToIndexOptionsRef.current) {\n                const targetIndex = normalizeValue(0, scrollToIndexOptionsRef.current.index, maxIndex);\n                if (targetIndex < startIndex || targetIndex > endIndex) {\n                    setIndexes([\n                        targetIndex - scrollToIndexOptionsRef.current.prerender,\n                        targetIndex + scrollToIndexOptionsRef.current.prerender,\n                    ]);\n                    return;\n                }\n                const [targetElement] = findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (_, index) => index === targetIndex,\n                });\n                if (!targetElement) {\n                    return;\n                }\n                const { alignToTop, offset, delay } = scrollToIndexOptionsRef.current;\n                scrollToIndexOptionsRef.current = null;\n                const scrollToElement = () => {\n                    const elementRect = getItemBoundingClientRect(targetElement);\n                    const shift = alignToTop\n                        ? elementRect[propName.top] - limits[propName.top] + offset\n                        : elementRect[propName.bottom] -\n                            limits[propName.top] -\n                            viewport[propName.clientHeight] +\n                            offset;\n                    viewport[propName.scrollTop] += shift;\n                    scrollToIndexTimeoutIdRef.current = null;\n                };\n                const scrollToElementDelay = delay < 0 && SHOULD_DELAY_SCROLL ? 30 : delay;\n                if (scrollToElementDelay > 0) {\n                    scrollToIndexTimeoutIdRef.current = setTimeout(scrollToElement, scrollToElementDelay);\n                    return;\n                }\n                scrollToElement();\n                return;\n            }\n            if (scrollTopRef.current === null) {\n                scrollTopRef.current = viewport.scrollTop;\n            }\n            else if (scrollTopRef.current !== viewport.scrollTop) {\n                const diff = Math.abs(viewport.scrollTop - scrollTopRef.current);\n                scrollTopRef.current = viewport.scrollTop;\n                if (scrollThreshold > 0 && diff > scrollThreshold) {\n                    return;\n                }\n            }\n            const topSecondElement = topElement === bottomSpacer ? bottomSpacer : topElement.nextSibling;\n            const bottomSecondElement = bottomElement === topSpacer ? topSpacer : bottomElement.previousSibling;\n            const averageSize = Math.ceil((bottomSpacerRect[propName.top] - topSpacerRect[propName.bottom]) / (endIndex + 1 - startIndex));\n            const isAllAboveTop = topSpacerRect[propName.bottom] > limitsWithOverscanSize[propName.bottom];\n            const isAllBelowBottom = bottomSpacerRect[propName.top] < limitsWithOverscanSize[propName.top];\n            const isTopBelowTop = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                topSpacerRect[propName.bottom] > limitsWithOverscanSize[propName.top];\n            const isBottomAboveBottom = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                bottomSpacerRect[propName.top] < limitsWithOverscanSize[propName.bottom];\n            const isBottomSecondAboveTop = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                (bottomSecondElement === topSpacer ? topSpacerRect : getItemBoundingClientRect(bottomSecondElement))[propName.bottom] > limitsWithOverscanSize[propName.bottom];\n            const isTopSecondAboveTop = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                (topSecondElement === bottomSpacer ? bottomSpacerRect : getItemBoundingClientRect(topSecondElement))[propName.top] < limitsWithOverscanSize[propName.top];\n            let nextStartIndex = startIndex;\n            let nextEndIndex = endIndex;\n            if (isAllAboveTop) {\n                nextStartIndex -= getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n                nextEndIndex -= getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n            }\n            if (isAllBelowBottom) {\n                nextEndIndex += getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n                nextStartIndex += getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n            }\n            if (isTopBelowTop) {\n                nextStartIndex -= getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n            }\n            if (isBottomAboveBottom) {\n                nextEndIndex += getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n            }\n            if (isBottomSecondAboveTop) {\n                const [, index] = findElement({\n                    fromElement: bottomElement,\n                    toElement: topSpacer,\n                    fromIndex: endIndex,\n                    asc: false,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.bottom] <= limitsWithOverscanSize[propName.bottom],\n                });\n                if (index !== -1) {\n                    nextEndIndex = index + 1;\n                }\n            }\n            if (isTopSecondAboveTop) {\n                const [, index] = findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.top] >= limitsWithOverscanSize[propName.top],\n                });\n                if (index !== -1) {\n                    nextStartIndex = index - 1;\n                }\n            }\n            if (onViewportIndexesChange) {\n                let [, startViewportIndex] = findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.bottom] > limits[propName.top],\n                });\n                if (startViewportIndex === -1) {\n                    startViewportIndex = startIndex;\n                }\n                let [, endViewportIndex] = findElement({\n                    fromElement: bottomElement,\n                    toElement: topSpacer,\n                    fromIndex: endIndex,\n                    asc: false,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.top] < limits[propName.bottom],\n                });\n                if (endViewportIndex === -1) {\n                    endViewportIndex = endIndex;\n                }\n                if (startViewportIndex !== viewportIndexesRef.current[0] ||\n                    endViewportIndex !== viewportIndexesRef.current[1]) {\n                    viewportIndexesRef.current = [startViewportIndex, endViewportIndex];\n                    onViewportIndexesChange(viewportIndexesRef.current);\n                }\n            }\n            nextStartIndex = normalizeValue(0, nextStartIndex, maxIndex);\n            nextEndIndex = normalizeValue(nextStartIndex, nextEndIndex, maxIndex);\n            if (nextStartIndex === startIndex && nextEndIndex === endIndex) {\n                return;\n            }\n            if (nextStartIndex !== startIndex) {\n                if (startIndex >= nextStartIndex) {\n                    anchorElementRef.current = topElement;\n                    anchorIndexRef.current = startIndex;\n                }\n                else {\n                    const [anchorElement, anchorElementIndex] = findElement({\n                        fromElement: topElement,\n                        toElement: bottomSpacer,\n                        fromIndex: startIndex,\n                        compare: (element, index) => {\n                            if (index === nextStartIndex) {\n                                return true;\n                            }\n                            const elementRect = getItemBoundingClientRect(element);\n                            if (elementRect[propName.height] !== estimatedItemHeight) {\n                                cacheRef.current[index] = elementRect[propName.height];\n                            }\n                            return false;\n                        },\n                    });\n                    if (anchorElement) {\n                        anchorElementRef.current = anchorElement;\n                        anchorIndexRef.current = anchorElementIndex;\n                    }\n                    else {\n                        anchorElementRef.current = bottomElement;\n                        anchorIndexRef.current = endIndex;\n                    }\n                }\n            }\n            setIndexes([nextStartIndex, nextEndIndex]);\n        };\n        getScrollPositionRef.current = () => {\n            const viewport = getViewport();\n            const topSpacer = topSpacerRef.current;\n            const bottomSpacer = bottomSpacerRef.current;\n            let scrollIndex = -1;\n            let scrollOffset = 0;\n            if (!viewport || !topSpacer || !bottomSpacer) {\n                return { index: scrollIndex, offset: scrollOffset };\n            }\n            const topElement = topSpacer.nextSibling;\n            const viewportRect = viewport.getBoundingClientRect();\n            const limits = {\n                [propName.top]: viewport === document.documentElement ? 0 : viewportRect[propName.top],\n                [propName.bottom]: viewport === document.documentElement\n                    ? document.documentElement[propName.clientHeight]\n                    : viewportRect[propName.bottom],\n            };\n            findElement({\n                fromElement: topElement,\n                toElement: bottomSpacer,\n                fromIndex: startIndex,\n                compare: (element, index) => {\n                    const rect = getItemBoundingClientRect(element);\n                    scrollIndex = index;\n                    scrollOffset = limits[propName.top] - rect[propName.top];\n                    return rect[propName.bottom] > limits[propName.top];\n                },\n            });\n            return { index: scrollIndex, offset: scrollOffset };\n        };\n    });\n    let anchorHeightOnRender;\n    if (anchorElementRef.current && getViewport() && topSpacerRef.current) {\n        anchorHeightOnRender =\n            getItemBoundingClientRect(anchorElementRef.current)[propName.top] -\n                (getViewport() === document.documentElement ? 0 : getViewport().getBoundingClientRect()[propName.top]);\n    }\n    useIsomorphicLayoutEffect(() => {\n        anchorElementRef.current = null;\n        const anchorIndex = anchorIndexRef.current;\n        const ignoreOverflowAnchor = ignoreOverflowAnchorRef.current;\n        anchorIndexRef.current = -1;\n        ignoreOverflowAnchorRef.current = false;\n        const viewport = getViewport();\n        const topSpacer = topSpacerRef.current;\n        const bottomSpacer = bottomSpacerRef.current;\n        if (anchorIndex === -1 ||\n            !viewport ||\n            !topSpacer ||\n            !bottomSpacer ||\n            anchorHeightOnRender === undefined ||\n            (IS_OVERFLOW_ANCHOR_SUPPORTED && overflowAnchor !== 'none' && !ignoreOverflowAnchor)) {\n            return;\n        }\n        let top = null;\n        if (anchorIndex >= startIndex && anchorIndex <= endIndex) {\n            const [anchorElement] = findElement({\n                fromElement: topSpacer.nextSibling,\n                toElement: bottomSpacer,\n                fromIndex: startIndex,\n                compare: (_, index) => index === anchorIndex,\n            });\n            if (anchorElement) {\n                top = getItemBoundingClientRect(anchorElement)[propName.top];\n            }\n        }\n        else {\n            if (anchorIndex < startIndex) {\n                top =\n                    topSpacer.getBoundingClientRect()[propName.top] +\n                        (withCache ? cacheRef.current : [])\n                            .slice(0, anchorIndex)\n                            .reduce((sum, next) => sum + (next - estimatedItemHeight), anchorIndex * itemHeightWithMargin);\n            }\n            else if (anchorIndex <= maxIndex) {\n                top =\n                    bottomSpacer.getBoundingClientRect()[propName.top] +\n                        (withCache ? cacheRef.current : [])\n                            .slice(endIndex + 1, anchorIndex)\n                            .reduce((sum, next) => sum + (next - estimatedItemHeight), itemHeightWithMargin * (anchorIndex - 1 - endIndex));\n            }\n        }\n        if (top === null) {\n            return;\n        }\n        const offset = top -\n            (viewport === document.documentElement ? 0 : viewport.getBoundingClientRect()[propName.top]) -\n            anchorHeightOnRender;\n        if (!offset) {\n            return;\n        }\n        if (IS_TOUCH_DEVICE) {\n            marginTopRef.current -= offset;\n            topSpacer.style[propName.marginTop] = `${marginTopRef.current}px`;\n            return;\n        }\n        viewport[propName.scrollTop] += offset;\n    }, [startIndex]);\n    useIsomorphicLayoutEffect(() => {\n        let frameId;\n        const frame = () => {\n            frameId = requestAnimationFrame(frame);\n            mainFrameRef.current();\n        };\n        frame();\n        return () => {\n            cancelAnimationFrame(frameId);\n            if (scrollToIndexTimeoutIdRef.current) {\n                clearTimeout(scrollToIndexTimeoutIdRef.current);\n            }\n        };\n    }, []);\n    (0, react_1.useImperativeHandle)(ref, () => ({\n        scrollToIndex: ({ index = -1, alignToTop = true, offset = 0, delay = -1, prerender = 0 }) => {\n            scrollToIndexOptionsRef.current = { index, alignToTop, offset, delay, prerender };\n            mainFrameRef.current();\n        },\n        getScrollPosition: () => getScrollPositionRef.current(),\n    }), []);\n    return ((0, jsx_runtime_1.jsxs)(react_1.Fragment, { children: [renderSpacer({ ref: topSpacerRef, style: topSpacerStyle, type: 'top' }), (!!count || !!items.length) &&\n                generateArray(startIndex, endIndex + 1, withCount ? children : (index) => children(items[index], index, items)), renderSpacer({ ref: bottomSpacerRef, style: bottomSpacerStyle, type: 'bottom' })] }, void 0));\n};\nexports.ViewportList = (0, react_1.forwardRef)(ViewportListInner);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}