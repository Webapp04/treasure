{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { Uint8ArrayList } from 'uint8arraylist';\n/**\n * Returns an `AsyncGenerator` that allows reading a set number of bytes from the passed source.\n *\n * @example\n *\n * ```javascript\n * import { reader } from 'it-reader'\n *\n * const stream = reader(source)\n *\n * // read 10 bytes from the stream\n * const { done, value } = await stream.next(10)\n *\n * if (done === true) {\n *   // stream finished\n * }\n *\n * if (value != null) {\n *   // do something with value\n * }\n * ```\n */\nexport function reader(source) {\n  var reader = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var bytes, bl, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, data;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return;\n        case 2:\n          bytes = _context.sent;\n          // Allows us to receive 8 when reader.next(8) is called\n          bl = new Uint8ArrayList();\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 6;\n          _iterator = _asyncIterator(source);\n        case 8:\n          _context.next = 10;\n          return _awaitAsyncGenerator(_iterator.next());\n        case 10:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 38;\n            break;\n          }\n          chunk = _step.value;\n          if (!(bytes == null)) {\n            _context.next = 19;\n            break;\n          }\n          bl.append(chunk);\n          _context.next = 16;\n          return bl;\n        case 16:\n          bytes = _context.sent;\n          bl = new Uint8ArrayList();\n          return _context.abrupt(\"continue\", 35);\n        case 19:\n          bl.append(chunk);\n        case 20:\n          if (!(bl.length >= bytes)) {\n            _context.next = 35;\n            break;\n          }\n          data = bl.sublist(0, bytes);\n          bl.consume(bytes);\n          _context.next = 25;\n          return data;\n        case 25:\n          bytes = _context.sent;\n          if (!(bytes == null)) {\n            _context.next = 33;\n            break;\n          }\n          if (!(bl.length > 0)) {\n            _context.next = 32;\n            break;\n          }\n          _context.next = 30;\n          return bl;\n        case 30:\n          bytes = _context.sent;\n          bl = new Uint8ArrayList();\n        case 32:\n          return _context.abrupt(\"break\", 35);\n        case 33:\n          _context.next = 20;\n          break;\n        case 35:\n          _iteratorAbruptCompletion = false;\n          _context.next = 8;\n          break;\n        case 38:\n          _context.next = 44;\n          break;\n        case 40:\n          _context.prev = 40;\n          _context.t0 = _context[\"catch\"](6);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n        case 44:\n          _context.prev = 44;\n          _context.prev = 45;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context.next = 49;\n            break;\n          }\n          _context.next = 49;\n          return _awaitAsyncGenerator(_iterator.return());\n        case 49:\n          _context.prev = 49;\n          if (!_didIteratorError) {\n            _context.next = 52;\n            break;\n          }\n          throw _iteratorError;\n        case 52:\n          return _context.finish(49);\n        case 53:\n          return _context.finish(44);\n        case 54:\n          if (!(bytes != null)) {\n            _context.next = 56;\n            break;\n          }\n          throw Object.assign(new Error(\"stream ended before \".concat(bytes, \" bytes became available\")), {\n            code: 'ERR_UNDER_READ',\n            buffer: bl\n          });\n        case 56:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[6, 40, 44, 54], [45,, 49, 53]]);\n  }))();\n  void reader.next();\n  return reader;\n}","map":{"version":3,"names":["Uint8ArrayList","reader","source","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","bytes","bl","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","data","wrap","_callee$","_context","prev","next","sent","_asyncIterator","_awaitAsyncGenerator","done","value","append","abrupt","length","sublist","consume","t0","return","finish","Object","assign","Error","concat","code","buffer","stop"],"sources":["/Users/apple/Documents/treasure/node_modules/it-reader/src/index.ts"],"sourcesContent":["import { Uint8ArrayList } from 'uint8arraylist'\nimport type { Source } from 'it-stream-types'\n\n/**\n * A specialized `AsyncGenerator` that lets you pass a number to the `.next` method which\n * will attempt to return only that many bytes.\n */\nexport interface Reader extends AsyncGenerator<Uint8ArrayList, void, any> {\n  next: (...args: [] | [number | undefined]) => Promise<IteratorResult<Uint8ArrayList, void>>\n}\n\n/**\n * Returns an `AsyncGenerator` that allows reading a set number of bytes from the passed source.\n *\n * @example\n *\n * ```javascript\n * import { reader } from 'it-reader'\n *\n * const stream = reader(source)\n *\n * // read 10 bytes from the stream\n * const { done, value } = await stream.next(10)\n *\n * if (done === true) {\n *   // stream finished\n * }\n *\n * if (value != null) {\n *   // do something with value\n * }\n * ```\n */\nexport function reader (source: Source<Uint8Array | Uint8ArrayList>) {\n  const reader: Reader = (async function * (): AsyncGenerator<Uint8ArrayList, void, any> {\n    // @ts-expect-error first yield in stream is ignored\n    let bytes: number | undefined = yield // Allows us to receive 8 when reader.next(8) is called\n    let bl = new Uint8ArrayList()\n\n    for await (const chunk of source) {\n      if (bytes == null) {\n        bl.append(chunk)\n        bytes = yield bl\n        bl = new Uint8ArrayList()\n        continue\n      }\n\n      bl.append(chunk)\n\n      while (bl.length >= bytes) {\n        const data = bl.sublist(0, bytes)\n        bl.consume(bytes)\n        bytes = yield data\n\n        // If we no longer want a specific byte length, we yield the rest now\n        if (bytes == null) {\n          if (bl.length > 0) {\n            bytes = yield bl\n            bl = new Uint8ArrayList()\n          }\n          break // bytes is null and/or no more buffer to yield\n        }\n      }\n    }\n\n    // Consumer wants more bytes but the source has ended and our buffer\n    // is not big enough to satisfy.\n    if (bytes != null) {\n      throw Object.assign(\n        new Error(`stream ended before ${bytes} bytes became available`),\n        { code: 'ERR_UNDER_READ', buffer: bl }\n      )\n    }\n  })()\n\n  void reader.next()\n  return reader\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}