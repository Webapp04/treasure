{"ast":null,"code":"/**\n * @param {Uint8Array} block\n * @param {number} blockStart\n * @param {number} requestedStart\n * @param {number} requestedEnd\n */\nfunction extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {\n  var blockLength = block.length;\n  var blockEnd = blockStart + blockLength;\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0);\n  }\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, requestedEnd - blockStart);\n  }\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(requestedStart - blockStart);\n  }\n  return block;\n}\nexport default extractDataFromBlock;","map":{"version":3,"names":["extractDataFromBlock","block","blockStart","requestedStart","requestedEnd","blockLength","length","blockEnd","Uint8Array","subarray"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js"],"sourcesContent":["/**\n * @param {Uint8Array} block\n * @param {number} blockStart\n * @param {number} requestedStart\n * @param {number} requestedEnd\n */\nfunction extractDataFromBlock (block, blockStart, requestedStart, requestedEnd) {\n  const blockLength = block.length\n  const blockEnd = blockStart + blockLength\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, requestedEnd - blockStart)\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(requestedStart - blockStart)\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,oBAAoBA,CAAEC,KAAK,EAAEC,UAAU,EAAEC,cAAc,EAAEC,YAAY,EAAE;EAC9E,IAAMC,WAAW,GAAGJ,KAAK,CAACK,MAAM;EAChC,IAAMC,QAAQ,GAAGL,UAAU,GAAGG,WAAW;EAEzC,IAAIF,cAAc,IAAII,QAAQ,IAAIH,YAAY,GAAGF,UAAU,EAAE;IAC3D;IACA;IACA,OAAO,IAAIM,UAAU,CAAC,CAAC,CAAC;EAC1B;EAEA,IAAIJ,YAAY,IAAIF,UAAU,IAAIE,YAAY,GAAGG,QAAQ,EAAE;IACzD;IACAN,KAAK,GAAGA,KAAK,CAACQ,QAAQ,CAAC,CAAC,EAAEL,YAAY,GAAGF,UAAU,CAAC;EACtD;EAEA,IAAIC,cAAc,IAAID,UAAU,IAAIC,cAAc,GAAGI,QAAQ,EAAE;IAC7D;IACAN,KAAK,GAAGA,KAAK,CAACQ,QAAQ,CAACN,cAAc,GAAGD,UAAU,CAAC;EACrD;EAEA,OAAOD,KAAK;AACd;AAEA,eAAeD,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}