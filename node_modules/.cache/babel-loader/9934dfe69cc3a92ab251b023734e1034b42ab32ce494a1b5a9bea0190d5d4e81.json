{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:webrtc-star:socket');\n/**\n * Convert a socket into a MultiaddrConnection\n * https://github.com/libp2p/js-libp2p-interfaces/tree/master/src/transport#multiaddrconnection\n */\nexport function toMultiaddrConnection(socket, options) {\n  var _sink = socket.sink,\n    source = socket.source;\n  var maConn = {\n    remoteAddr: options.remoteAddr,\n    sink: function sink(source) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (options.signal != null) {\n                source = abortableSource(source, options.signal);\n              }\n              _context.prev = 1;\n              _context.next = 4;\n              return _sink(source);\n            case 4:\n              _context.next = 9;\n              break;\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](1);\n              // If aborted we can safely ignore\n              if (_context.t0.type !== 'aborted') {\n                // If the source errored the socket will already have been destroyed by\n                // toIterable.duplex(). If the socket errored it will already be\n                // destroyed. There's nothing to do here except log the error & return.\n                log.error(_context.t0);\n              }\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[1, 6]]);\n      }))();\n    },\n    source: options.signal != null ? abortableSource(source, options.signal) : source,\n    timeline: {\n      open: Date.now()\n    },\n    close: function close() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var start, timeout;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!socket.closed) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              start = Date.now(); // Attempt to end the socket. If it takes longer to close than the\n              // timeout, destroy it manually.\n              timeout = setTimeout(function () {\n                if (maConn.remoteAddr != null) {\n                  var _maConn$remoteAddr$to = maConn.remoteAddr.toOptions(),\n                    host = _maConn$remoteAddr$to.host,\n                    port = _maConn$remoteAddr$to.port;\n                  log('timeout closing socket to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n                }\n                if (!socket.closed) {\n                  socket.close().catch(function (err) {\n                    log.error('could not close socket', err);\n                  });\n                }\n              }, CLOSE_TIMEOUT);\n              _context2.prev = 4;\n              _context2.next = 7;\n              return socket.close();\n            case 7:\n              _context2.prev = 7;\n              clearTimeout(timeout);\n              return _context2.finish(7);\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[4,, 7, 10]]);\n      }))();\n    }\n  };\n  socket.addEventListener('close', function () {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now();\n    }\n  }, {\n    once: true\n  });\n  return maConn;\n}","map":{"version":3,"names":["abortableSource","CLOSE_TIMEOUT","logger","log","toMultiaddrConnection","socket","options","sink","source","maConn","remoteAddr","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","signal","t0","type","error","stop","timeline","open","Date","now","close","_callee2","start","timeout","_callee2$","_context2","closed","abrupt","setTimeout","_maConn$remoteAddr$to","toOptions","host","port","catch","err","clearTimeout","finish","addEventListener","once"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/webrtc-star/src/socket-to-conn.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { CLOSE_TIMEOUT } from './constants.js'\nimport { logger } from '@libp2p/logger'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { WebRTCPeer } from '@libp2p/webrtc-peer'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:webrtc-star:socket')\n\nexport interface ToMultiaddrConnectionOptions extends AbortOptions {\n  remoteAddr: Multiaddr\n}\n\n/**\n * Convert a socket into a MultiaddrConnection\n * https://github.com/libp2p/js-libp2p-interfaces/tree/master/src/transport#multiaddrconnection\n */\nexport function toMultiaddrConnection (socket: WebRTCPeer, options: ToMultiaddrConnectionOptions): MultiaddrConnection {\n  const { sink, source } = socket\n\n  const maConn: MultiaddrConnection = {\n    remoteAddr: options.remoteAddr,\n\n    async sink (source) {\n      if (options.signal != null) {\n        source = abortableSource(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n      } catch (err: any) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log.error(err)\n        }\n      }\n    },\n\n    source: (options.signal != null) ? abortableSource(source, options.signal) : source,\n\n    timeline: { open: Date.now() },\n\n    async close () {\n      if (socket.closed) {\n        return\n      }\n\n      const start = Date.now()\n\n      // Attempt to end the socket. If it takes longer to close than the\n      // timeout, destroy it manually.\n      const timeout = setTimeout(() => {\n        if (maConn.remoteAddr != null) {\n          const { host, port } = maConn.remoteAddr.toOptions()\n          log('timeout closing socket to %s:%s after %dms, destroying it manually',\n            host, port, Date.now() - start)\n        }\n\n        if (!socket.closed) {\n          socket.close().catch(err => {\n            log.error('could not close socket', err)\n          })\n        }\n      }, CLOSE_TIMEOUT)\n\n      try {\n        await socket.close()\n      } finally {\n        clearTimeout(timeout)\n      }\n    }\n  }\n\n  socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }, {\n    once: true\n  })\n\n  return maConn\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}