{"ast":null,"code":"import _defineProperty from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js';\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nvar Encoder = /*#__PURE__*/function () {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  function Encoder(name, prefix, baseEncode) {\n    _classCallCheck(this, Encoder);\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  _createClass(Encoder, [{\n    key: \"encode\",\n    value: function encode(bytes) {\n      if (bytes instanceof Uint8Array) {\n        return \"\".concat(this.prefix).concat(this.baseEncode(bytes));\n      } else {\n        throw Error('Unknown type, must be binary type');\n      }\n    }\n  }]);\n  return Encoder;\n}();\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nvar Decoder = /*#__PURE__*/function () {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  function Decoder(name, prefix, baseDecode) {\n    _classCallCheck(this, Decoder);\n    this.name = name;\n    this.prefix = prefix;\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n\n  /**\n   * @param {string} text\n   */\n  _createClass(Decoder, [{\n    key: \"decode\",\n    value: function decode(text) {\n      if (typeof text === 'string') {\n        if (text.codePointAt(0) !== this.prefixCodePoint) {\n          throw Error(\"Unable to decode multibase string \".concat(JSON.stringify(text), \", \").concat(this.name, \" decoder only supports inputs prefixed with \").concat(this.prefix));\n        }\n        return this.baseDecode(text.slice(this.prefix.length));\n      } else {\n        throw Error('Can only multibase decode strings');\n      }\n    }\n\n    /**\n     * @template {string} OtherPrefix\n     * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n     * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n     */\n  }, {\n    key: \"or\",\n    value: function or(decoder) {\n      return _or(this, decoder);\n    }\n  }]);\n  return Decoder;\n}();\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nvar ComposedDecoder = /*#__PURE__*/function () {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  function ComposedDecoder(decoders) {\n    _classCallCheck(this, ComposedDecoder);\n    this.decoders = decoders;\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  _createClass(ComposedDecoder, [{\n    key: \"or\",\n    value: function or(decoder) {\n      return _or(this, decoder);\n    }\n\n    /**\n     * @param {string} input\n     * @returns {Uint8Array}\n     */\n  }, {\n    key: \"decode\",\n    value: function decode(input) {\n      var prefix = /** @type {Prefix} */input[0];\n      var decoder = this.decoders[prefix];\n      if (decoder) {\n        return decoder.decode(input);\n      } else {\n        throw RangeError(\"Unable to decode multibase string \".concat(JSON.stringify(input), \", only inputs prefixed with \").concat(Object.keys(this.decoders), \" are supported\"));\n      }\n    }\n  }]);\n  return ComposedDecoder;\n}();\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nvar _or = function _or(left, right) {\n  return new ComposedDecoder( /** @type {Decoders<L|R>} */_objectSpread(_objectSpread({}, left.decoders || _defineProperty({}, /** @type API.UnibaseDecoder<L> */left.prefix, left)), right.decoders || _defineProperty({}, /** @type API.UnibaseDecoder<R> */right.prefix, right)));\n};\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport { _or as or };\nexport var Codec = /*#__PURE__*/function () {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  function Codec(name, prefix, baseEncode, baseDecode) {\n    _classCallCheck(this, Codec);\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  _createClass(Codec, [{\n    key: \"encode\",\n    value: function encode(input) {\n      return this.encoder.encode(input);\n    }\n\n    /**\n     * @param {string} input\n     */\n  }, {\n    key: \"decode\",\n    value: function decode(input) {\n      return this.decoder.decode(input);\n    }\n  }]);\n  return Codec;\n}();\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport var from = function from(_ref3) {\n  var name = _ref3.name,\n    prefix = _ref3.prefix,\n    encode = _ref3.encode,\n    decode = _ref3.decode;\n  return new Codec(name, prefix, encode, decode);\n};\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport var baseX = function baseX(_ref4) {\n  var prefix = _ref4.prefix,\n    name = _ref4.name,\n    alphabet = _ref4.alphabet;\n  var _basex = basex(alphabet, name),\n    encode = _basex.encode,\n    _decode = _basex.decode;\n  return from({\n    prefix: prefix,\n    name: name,\n    encode: encode,\n    /**\n     * @param {string} text\n     */\n    decode: function decode(text) {\n      return coerce(_decode(text));\n    }\n  });\n};\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nvar _decode2 = function decode(string, alphabet, bitsPerChar, name) {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  var codes = {};\n  for (var i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  // Count the padding bytes:\n  var end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  // Allocate the output:\n  var out = new Uint8Array(end * bitsPerChar / 8 | 0);\n\n  // Parse the data:\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  var written = 0; // Next byte to write\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = codes[string[_i]];\n    if (value === undefined) {\n      throw new SyntaxError(\"Non-\".concat(name, \" character\"));\n    }\n\n    // Append the bits to the buffer:\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nvar _encode = function encode(data, alphabet, bitsPerChar) {\n  var pad = alphabet[alphabet.length - 1] === '=';\n  var mask = (1 << bitsPerChar) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport var rfc4648 = function rfc4648(_ref5) {\n  var name = _ref5.name,\n    prefix = _ref5.prefix,\n    bitsPerChar = _ref5.bitsPerChar,\n    alphabet = _ref5.alphabet;\n  return from({\n    prefix: prefix,\n    name: name,\n    encode: function encode(input) {\n      return _encode(input, alphabet, bitsPerChar);\n    },\n    decode: function decode(input) {\n      return _decode2(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","map":{"version":3,"names":["basex","coerce","API","Encoder","name","prefix","baseEncode","_classCallCheck","_createClass","key","value","encode","bytes","Uint8Array","concat","Error","Decoder","baseDecode","codePointAt","undefined","prefixCodePoint","decode","text","JSON","stringify","slice","length","or","decoder","ComposedDecoder","decoders","input","RangeError","Object","keys","left","right","_objectSpread","_defineProperty","_or","Codec","encoder","from","_ref3","baseX","_ref4","alphabet","_basex","string","bitsPerChar","codes","i","end","out","bits","buffer","written","SyntaxError","data","pad","mask","rfc4648","_ref5"],"sources":["/Users/apple/Documents/treasure/node_modules/hamt-sharding/node_modules/multiformats/src/bases/base.js"],"sourcesContent":["import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}