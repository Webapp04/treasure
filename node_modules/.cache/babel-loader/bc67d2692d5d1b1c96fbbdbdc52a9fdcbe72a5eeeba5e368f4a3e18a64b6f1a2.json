{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { Key } from 'interface-datastore/key';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport isPrivateIp from 'private-ip';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { RECORD_KEY_PREFIX } from './constants.js';\n// const IPNS_PREFIX = uint8ArrayFromString('/ipns/')\nvar PK_PREFIX = uint8ArrayFromString('/pk/');\nexport function removePrivateAddresses(peer) {\n  return _objectSpread(_objectSpread({}, peer), {}, {\n    multiaddrs: peer.multiaddrs.filter(function (multiaddr) {\n      var _multiaddr$stringTupl = multiaddr.stringTuples(),\n        _multiaddr$stringTupl2 = _slicedToArray(_multiaddr$stringTupl, 1),\n        _multiaddr$stringTupl3 = _slicedToArray(_multiaddr$stringTupl2[0], 2),\n        type = _multiaddr$stringTupl3[0],\n        addr = _multiaddr$stringTupl3[1];\n      if (type !== 4 && type !== 6) {\n        return false;\n      }\n      if (addr == null) {\n        return false;\n      }\n      return !isPrivateIp(addr);\n    })\n  });\n}\nexport function removePublicAddresses(peer) {\n  return _objectSpread(_objectSpread({}, peer), {}, {\n    multiaddrs: peer.multiaddrs.filter(function (multiaddr) {\n      var _multiaddr$stringTupl4 = multiaddr.stringTuples(),\n        _multiaddr$stringTupl5 = _slicedToArray(_multiaddr$stringTupl4, 1),\n        _multiaddr$stringTupl6 = _slicedToArray(_multiaddr$stringTupl5[0], 2),\n        type = _multiaddr$stringTupl6[0],\n        addr = _multiaddr$stringTupl6[1];\n      if (type !== 4 && type !== 6) {\n        return false;\n      }\n      if (addr == null) {\n        return false;\n      }\n      return isPrivateIp(addr);\n    })\n  });\n}\n/**\n * Creates a DHT ID by hashing a given Uint8Array\n */\nexport function convertBuffer(_x) {\n  return _convertBuffer.apply(this, arguments);\n}\n/**\n * Creates a DHT ID by hashing a Peer ID\n */\nfunction _convertBuffer() {\n  _convertBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(buf) {\n    var multihash;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return sha256.digest(buf);\n        case 2:\n          multihash = _context.sent;\n          return _context.abrupt(\"return\", multihash.digest);\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _convertBuffer.apply(this, arguments);\n}\nexport function convertPeerId(_x2) {\n  return _convertPeerId.apply(this, arguments);\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nfunction _convertPeerId() {\n  _convertPeerId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return convertBuffer(peerId.toBytes());\n        case 2:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 3:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _convertPeerId.apply(this, arguments);\n}\nexport function bufferToKey(buf) {\n  return new Key('/' + uint8ArrayToString(buf, 'base32'), false);\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToRecordKey(buf) {\n  return new Key(\"\".concat(RECORD_KEY_PREFIX, \"/\").concat(uint8ArrayToString(buf, 'base32')), false);\n}\n/**\n * Generate the key for a public key.\n */\nexport function keyForPublicKey(peer) {\n  return uint8ArrayConcat([PK_PREFIX, peer.toBytes()]);\n}\nexport function isPublicKeyKey(key) {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/pk/';\n}\nexport function isIPNSKey(key) {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/ipns/';\n}\nexport function fromPublicKeyKey(key) {\n  return peerIdFromBytes(key.subarray(4));\n}\n/**\n * Create a new put record, encodes and signs it if enabled\n */\nexport function createPutRecord(key, value) {\n  var timeReceived = new Date();\n  var rec = new Libp2pRecord(key, value, timeReceived);\n  return rec.serialize();\n}\nexport function debounce(callback) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n  var timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return callback();\n    }, wait);\n  };\n}","map":{"version":3,"names":["sha256","Key","Libp2pRecord","fromString","uint8ArrayFromString","toString","uint8ArrayToString","concat","uint8ArrayConcat","isPrivateIp","peerIdFromBytes","RECORD_KEY_PREFIX","PK_PREFIX","removePrivateAddresses","peer","_objectSpread","multiaddrs","filter","multiaddr","_multiaddr$stringTupl","stringTuples","_multiaddr$stringTupl2","_slicedToArray","_multiaddr$stringTupl3","type","addr","removePublicAddresses","_multiaddr$stringTupl4","_multiaddr$stringTupl5","_multiaddr$stringTupl6","convertBuffer","_x","_convertBuffer","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","buf","multihash","wrap","_callee$","_context","prev","next","digest","sent","abrupt","stop","convertPeerId","_x2","_convertPeerId","_callee2","peerId","_callee2$","_context2","toBytes","bufferToKey","bufferToRecordKey","keyForPublicKey","isPublicKeyKey","key","subarray","isIPNSKey","fromPublicKeyKey","createPutRecord","value","timeReceived","Date","rec","serialize","debounce","callback","wait","length","undefined","timeout","clearTimeout","setTimeout"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/kad-dht/src/utils.ts"],"sourcesContent":["import { sha256 } from 'multiformats/hashes/sha2'\nimport { Key } from 'interface-datastore/key'\nimport { Libp2pRecord } from '@libp2p/record'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport isPrivateIp from 'private-ip'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { RECORD_KEY_PREFIX } from './constants.js'\n\n// const IPNS_PREFIX = uint8ArrayFromString('/ipns/')\nconst PK_PREFIX = uint8ArrayFromString('/pk/')\n\nexport function removePrivateAddresses (peer: PeerInfo): PeerInfo {\n  return {\n    ...peer,\n    multiaddrs: peer.multiaddrs.filter(multiaddr => {\n      const [[type, addr]] = multiaddr.stringTuples()\n\n      if (type !== 4 && type !== 6) {\n        return false\n      }\n\n      if (addr == null) {\n        return false\n      }\n\n      return !isPrivateIp(addr)\n    })\n  }\n}\n\nexport function removePublicAddresses (peer: PeerInfo): PeerInfo {\n  return {\n    ...peer,\n    multiaddrs: peer.multiaddrs.filter(multiaddr => {\n      const [[type, addr]] = multiaddr.stringTuples()\n\n      if (type !== 4 && type !== 6) {\n        return false\n      }\n\n      if (addr == null) {\n        return false\n      }\n\n      return isPrivateIp(addr)\n    })\n  }\n}\n\n/**\n * Creates a DHT ID by hashing a given Uint8Array\n */\nexport async function convertBuffer (buf: Uint8Array) {\n  const multihash = await sha256.digest(buf)\n\n  return multihash.digest\n}\n\n/**\n * Creates a DHT ID by hashing a Peer ID\n */\nexport async function convertPeerId (peerId: PeerId) {\n  return await convertBuffer(peerId.toBytes())\n}\n\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToKey (buf: Uint8Array) {\n  return new Key('/' + uint8ArrayToString(buf, 'base32'), false)\n}\n\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToRecordKey (buf: Uint8Array) {\n  return new Key(`${RECORD_KEY_PREFIX}/${uint8ArrayToString(buf, 'base32')}`, false)\n}\n\n/**\n * Generate the key for a public key.\n */\nexport function keyForPublicKey (peer: PeerId) {\n  return uint8ArrayConcat([\n    PK_PREFIX,\n    peer.toBytes()\n  ])\n}\n\nexport function isPublicKeyKey (key: Uint8Array) {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/pk/'\n}\n\nexport function isIPNSKey (key: Uint8Array) {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/ipns/'\n}\n\nexport function fromPublicKeyKey (key: Uint8Array) {\n  return peerIdFromBytes(key.subarray(4))\n}\n\n/**\n * Create a new put record, encodes and signs it if enabled\n */\nexport function createPutRecord (key: Uint8Array, value: Uint8Array) {\n  const timeReceived = new Date()\n  const rec = new Libp2pRecord(key, value, timeReceived)\n\n  return rec.serialize()\n}\n\nexport function debounce (callback: () => void, wait: number = 100) {\n  let timeout: ReturnType<typeof setTimeout>\n\n  return () => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => callback(), wait)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}