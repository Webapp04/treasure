{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport errCode from 'err-code';\nimport * as ERRORS from './errors.js';\nimport { unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id';\nimport { logger } from '@libp2p/logger';\nimport { IpnsEntry } from './pb/ipns.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport * as cborg from 'cborg';\nvar log = logger('ipns:utils');\nvar IPNS_PREFIX = uint8ArrayFromString('/ipns/');\n/**\n * Convert a JavaScript date into an `RFC3339Nano` formatted\n * string\n */\nexport function toRFC3339(time) {\n  var year = time.getUTCFullYear();\n  var month = String(time.getUTCMonth() + 1).padStart(2, '0');\n  var day = String(time.getUTCDate()).padStart(2, '0');\n  var hour = String(time.getUTCHours()).padStart(2, '0');\n  var minute = String(time.getUTCMinutes()).padStart(2, '0');\n  var seconds = String(time.getUTCSeconds()).padStart(2, '0');\n  var milliseconds = time.getUTCMilliseconds();\n  var nanoseconds = milliseconds * 1000 * 1000;\n  return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(seconds, \".\").concat(nanoseconds, \"Z\");\n}\n/**\n * Parses a date string formatted as `RFC3339Nano` into a\n * JavaScript Date object\n */\nexport function parseRFC3339(time) {\n  var rfc3339Matcher = new RegExp(\n  // 2006-01-02T\n  '(\\\\d{4})-(\\\\d{2})-(\\\\d{2})T' +\n  // 15:04:05\n  '(\\\\d{2}):(\\\\d{2}):(\\\\d{2})' +\n  // .999999999Z\n  '\\\\.(\\\\d+)Z');\n  var m = String(time).trim().match(rfc3339Matcher);\n  if (m == null) {\n    throw new Error('Invalid format');\n  }\n  var year = parseInt(m[1], 10);\n  var month = parseInt(m[2], 10) - 1;\n  var date = parseInt(m[3], 10);\n  var hour = parseInt(m[4], 10);\n  var minute = parseInt(m[5], 10);\n  var second = parseInt(m[6], 10);\n  var millisecond = parseInt(m[7].slice(0, -6), 10);\n  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));\n}\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record\n */\nexport var extractPublicKey = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, entry) {\n    var error, pubKey, otherId;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!(entry == null || peerId == null)) {\n            _context.next = 4;\n            break;\n          }\n          error = new Error('one or more of the provided parameters are not defined');\n          log.error(error);\n          throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n        case 4:\n          if (!(entry.pubKey != null)) {\n            _context.next = 20;\n            break;\n          }\n          _context.prev = 5;\n          pubKey = unmarshalPublicKey(entry.pubKey);\n          _context.next = 13;\n          break;\n        case 9:\n          _context.prev = 9;\n          _context.t0 = _context[\"catch\"](5);\n          log.error(_context.t0);\n          throw _context.t0;\n        case 13:\n          _context.next = 15;\n          return peerIdFromKeys(entry.pubKey);\n        case 15:\n          otherId = _context.sent;\n          if (otherId.equals(peerId)) {\n            _context.next = 18;\n            break;\n          }\n          throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY);\n        case 18:\n          _context.next = 21;\n          break;\n        case 20:\n          if (peerId.publicKey != null) {\n            pubKey = unmarshalPublicKey(peerId.publicKey);\n          }\n        case 21:\n          if (!(pubKey != null)) {\n            _context.next = 23;\n            break;\n          }\n          return _context.abrupt(\"return\", pubKey);\n        case 23:\n          throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER);\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[5, 9]]);\n  }));\n  return function extractPublicKey(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Utility for creating the record data for being signed\n */\nexport var ipnsEntryDataForV1Sig = function ipnsEntryDataForV1Sig(value, validityType, validity) {\n  var validityTypeBuffer = uint8ArrayFromString(validityType);\n  return uint8ArrayConcat([value, validity, validityTypeBuffer]);\n};\n/**\n * Utility for creating the record data for being signed\n */\nexport var ipnsEntryDataForV2Sig = function ipnsEntryDataForV2Sig(data) {\n  var entryData = uint8ArrayFromString('ipns-signature:');\n  return uint8ArrayConcat([entryData, data]);\n};\nexport var marshal = function marshal(obj) {\n  return IpnsEntry.encode(obj);\n};\nexport var unmarshal = function unmarshal(buf) {\n  var _message$value, _message$signature, _message$validityType, _message$validity, _message$sequence, _message$ttl;\n  var message = IpnsEntry.decode(buf);\n  // protobufjs returns bigints as numbers\n  if (message.sequence != null) {\n    message.sequence = BigInt(message.sequence);\n  }\n  // protobufjs returns bigints as numbers\n  if (message.ttl != null) {\n    message.ttl = BigInt(message.ttl);\n  }\n  return {\n    value: (_message$value = message.value) !== null && _message$value !== void 0 ? _message$value : new Uint8Array(0),\n    signature: (_message$signature = message.signature) !== null && _message$signature !== void 0 ? _message$signature : new Uint8Array(0),\n    validityType: (_message$validityType = message.validityType) !== null && _message$validityType !== void 0 ? _message$validityType : IpnsEntry.ValidityType.EOL,\n    validity: (_message$validity = message.validity) !== null && _message$validity !== void 0 ? _message$validity : new Uint8Array(0),\n    sequence: (_message$sequence = message.sequence) !== null && _message$sequence !== void 0 ? _message$sequence : 0n,\n    pubKey: message.pubKey,\n    ttl: (_message$ttl = message.ttl) !== null && _message$ttl !== void 0 ? _message$ttl : undefined,\n    signatureV2: message.signatureV2,\n    data: message.data\n  };\n};\nexport var peerIdToRoutingKey = function peerIdToRoutingKey(peerId) {\n  return uint8ArrayConcat([IPNS_PREFIX, peerId.toBytes()]);\n};\nexport var peerIdFromRoutingKey = function peerIdFromRoutingKey(key) {\n  return peerIdFromBytes(key.slice(IPNS_PREFIX.length));\n};\nexport var createCborData = function createCborData(value, validity, validityType, sequence, ttl) {\n  var ValidityType;\n  if (validityType === IpnsEntry.ValidityType.EOL) {\n    ValidityType = 0;\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n  var data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: ValidityType,\n    Sequence: sequence,\n    TTL: ttl\n  };\n  return cborg.encode(data);\n};\nexport var parseCborData = function parseCborData(buf) {\n  var data = cborg.decode(buf);\n  if (data.ValidityType === 0) {\n    data.ValidityType = IpnsEntry.ValidityType.EOL;\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence);\n  }\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL);\n  }\n  return data;\n};","map":{"version":3,"names":["errCode","ERRORS","unmarshalPublicKey","peerIdFromBytes","peerIdFromKeys","logger","IpnsEntry","fromString","uint8ArrayFromString","concat","uint8ArrayConcat","cborg","log","IPNS_PREFIX","toRFC3339","time","year","getUTCFullYear","month","String","getUTCMonth","padStart","day","getUTCDate","hour","getUTCHours","minute","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","nanoseconds","parseRFC3339","rfc3339Matcher","RegExp","m","trim","match","Error","parseInt","date","second","millisecond","slice","Date","UTC","extractPublicKey","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","peerId","entry","error","pubKey","otherId","wrap","_callee$","_context","prev","next","ERR_UNDEFINED_PARAMETER","t0","sent","equals","ERR_INVALID_EMBEDDED_KEY","publicKey","abrupt","stop","_x","_x2","apply","arguments","ipnsEntryDataForV1Sig","value","validityType","validity","validityTypeBuffer","ipnsEntryDataForV2Sig","data","entryData","marshal","obj","encode","unmarshal","buf","_message$value","_message$signature","_message$validityType","_message$validity","_message$sequence","_message$ttl","message","decode","sequence","BigInt","ttl","Uint8Array","signature","ValidityType","EOL","undefined","signatureV2","peerIdToRoutingKey","toBytes","peerIdFromRoutingKey","key","length","createCborData","ERR_UNRECOGNIZED_VALIDITY","Value","Validity","Sequence","TTL","parseCborData","Number","isInteger"],"sources":["/Users/apple/Documents/treasure/node_modules/ipns/src/utils.ts"],"sourcesContent":["import errCode from 'err-code'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { IPNSEntry, IPNSEntryData } from './index.js'\nimport * as ERRORS from './errors.js'\nimport { unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id'\nimport { logger } from '@libp2p/logger'\nimport { IpnsEntry } from './pb/ipns.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport * as cborg from 'cborg'\n\nconst log = logger('ipns:utils')\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/')\n\n/**\n * Convert a JavaScript date into an `RFC3339Nano` formatted\n * string\n */\nexport function toRFC3339 (time: Date) {\n  const year = time.getUTCFullYear()\n  const month = String(time.getUTCMonth() + 1).padStart(2, '0')\n  const day = String(time.getUTCDate()).padStart(2, '0')\n  const hour = String(time.getUTCHours()).padStart(2, '0')\n  const minute = String(time.getUTCMinutes()).padStart(2, '0')\n  const seconds = String(time.getUTCSeconds()).padStart(2, '0')\n  const milliseconds = time.getUTCMilliseconds()\n  const nanoseconds = milliseconds * 1000 * 1000\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`\n}\n\n/**\n * Parses a date string formatted as `RFC3339Nano` into a\n * JavaScript Date object\n */\nexport function parseRFC3339 (time: string) {\n  const rfc3339Matcher = new RegExp(\n    // 2006-01-02T\n    '(\\\\d{4})-(\\\\d{2})-(\\\\d{2})T' +\n    // 15:04:05\n    '(\\\\d{2}):(\\\\d{2}):(\\\\d{2})' +\n    // .999999999Z\n    '\\\\.(\\\\d+)Z'\n  )\n  const m = String(time).trim().match(rfc3339Matcher)\n\n  if (m == null) {\n    throw new Error('Invalid format')\n  }\n\n  const year = parseInt(m[1], 10)\n  const month = parseInt(m[2], 10) - 1\n  const date = parseInt(m[3], 10)\n  const hour = parseInt(m[4], 10)\n  const minute = parseInt(m[5], 10)\n  const second = parseInt(m[6], 10)\n  const millisecond = parseInt(m[7].slice(0, -6), 10)\n\n  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond))\n}\n\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record\n */\nexport const extractPublicKey = async (peerId: PeerId, entry: IpnsEntry) => {\n  if (entry == null || peerId == null) {\n    const error = new Error('one or more of the provided parameters are not defined')\n\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  let pubKey\n\n  if (entry.pubKey != null) {\n    try {\n      pubKey = unmarshalPublicKey(entry.pubKey)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    const otherId = await peerIdFromKeys(entry.pubKey)\n\n    if (!otherId.equals(peerId)) {\n      throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY)\n    }\n  } else if (peerId.publicKey != null) {\n    pubKey = unmarshalPublicKey(peerId.publicKey)\n  }\n\n  if (pubKey != null) {\n    return pubKey\n  }\n\n  throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER)\n}\n\n/**\n * Utility for creating the record data for being signed\n */\nexport const ipnsEntryDataForV1Sig = (value: Uint8Array, validityType: IpnsEntry.ValidityType, validity: Uint8Array): Uint8Array => {\n  const validityTypeBuffer = uint8ArrayFromString(validityType)\n\n  return uint8ArrayConcat([value, validity, validityTypeBuffer])\n}\n\n/**\n * Utility for creating the record data for being signed\n */\nexport const ipnsEntryDataForV2Sig = (data: Uint8Array): Uint8Array => {\n  const entryData = uint8ArrayFromString('ipns-signature:')\n\n  return uint8ArrayConcat([entryData, data])\n}\n\nexport const marshal = (obj: IPNSEntry): Uint8Array => {\n  return IpnsEntry.encode(obj)\n}\n\nexport const unmarshal = (buf: Uint8Array): IPNSEntry => {\n  const message = IpnsEntry.decode(buf)\n\n  // protobufjs returns bigints as numbers\n  if (message.sequence != null) {\n    message.sequence = BigInt(message.sequence)\n  }\n\n  // protobufjs returns bigints as numbers\n  if (message.ttl != null) {\n    message.ttl = BigInt(message.ttl)\n  }\n\n  return {\n    value: message.value ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    validityType: message.validityType ?? IpnsEntry.ValidityType.EOL,\n    validity: message.validity ?? new Uint8Array(0),\n    sequence: message.sequence ?? 0n,\n    pubKey: message.pubKey,\n    ttl: message.ttl ?? undefined,\n    signatureV2: message.signatureV2,\n    data: message.data\n  }\n}\n\nexport const peerIdToRoutingKey = (peerId: PeerId): Uint8Array => {\n  return uint8ArrayConcat([\n    IPNS_PREFIX,\n    peerId.toBytes()\n  ])\n}\n\nexport const peerIdFromRoutingKey = (key: Uint8Array): PeerId => {\n  return peerIdFromBytes(key.slice(IPNS_PREFIX.length))\n}\n\nexport const createCborData = (value: Uint8Array, validity: Uint8Array, validityType: string, sequence: bigint, ttl: bigint): Uint8Array => {\n  let ValidityType\n\n  if (validityType === IpnsEntry.ValidityType.EOL) {\n    ValidityType = 0\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType,\n    Sequence: sequence,\n    TTL: ttl\n  }\n\n  return cborg.encode(data)\n}\n\nexport const parseCborData = (buf: Uint8Array): IPNSEntryData => {\n  const data = cborg.decode(buf)\n\n  if (data.ValidityType === 0) {\n    data.ValidityType = IpnsEntry.ValidityType.EOL\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence)\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL)\n  }\n\n  return data\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}