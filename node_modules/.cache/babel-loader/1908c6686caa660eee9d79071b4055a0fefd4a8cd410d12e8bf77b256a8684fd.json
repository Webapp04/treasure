{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Service } from '../utils/service.js';\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('../types').Print} config.print\n * @param {import('../types').Preload} config.preload\n * @param {import('../types').MfsPreload} config.mfsPreload\n * @param {import('./ipns').IPNSAPI} config.ipns\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n * @param {import('ipfs-core-utils/multihashes').Multihashes} config.hashers\n * @param {import('../types').Options} config.options\n */\nexport function createStart(_ref) {\n  var network = _ref.network,\n    preload = _ref.preload,\n    peerId = _ref.peerId,\n    keychain = _ref.keychain,\n    repo = _ref.repo,\n    ipns = _ref.ipns,\n    mfsPreload = _ref.mfsPreload,\n    print = _ref.print,\n    hashers = _ref.hashers,\n    options = _ref.options;\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"start\"]}\n   */\n  var start = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var _yield$Service$start, libp2p;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Service.start(network, {\n              peerId: peerId,\n              repo: repo,\n              print: print,\n              hashers: hashers,\n              options: options\n            });\n          case 2:\n            _yield$Service$start = _context.sent;\n            libp2p = _yield$Service$start.libp2p;\n            _context.next = 6;\n            return Promise.all([ipns.startOnline({\n              keychain: keychain,\n              libp2p: libp2p,\n              peerId: peerId,\n              repo: repo\n            }), preload.start(), mfsPreload.start()]);\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function start() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  return start;\n}","map":{"version":3,"names":["Service","createStart","_ref","network","preload","peerId","keychain","repo","ipns","mfsPreload","print","hashers","options","start","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_yield$Service$start","libp2p","wrap","_callee$","_context","prev","next","sent","Promise","all","startOnline","stop","apply","arguments"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/start.js"],"sourcesContent":["import { Service } from '../utils/service.js'\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('../types').Print} config.print\n * @param {import('../types').Preload} config.preload\n * @param {import('../types').MfsPreload} config.mfsPreload\n * @param {import('./ipns').IPNSAPI} config.ipns\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n * @param {import('ipfs-core-utils/multihashes').Multihashes} config.hashers\n * @param {import('../types').Options} config.options\n */\nexport function createStart ({ network, preload, peerId, keychain, repo, ipns, mfsPreload, print, hashers, options }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"start\"]}\n   */\n  const start = async () => {\n    const { libp2p } = await Service.start(network, {\n      peerId,\n      repo,\n      print,\n      hashers,\n      options\n    })\n\n    await Promise.all([\n      ipns.startOnline({ keychain, libp2p, peerId, repo }),\n      preload.start(),\n      mfsPreload.start()\n    ])\n  }\n\n  return start\n}\n"],"mappings":";;AAAA,SAASA,OAAO,QAAQ,qBAAqB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAAAC,IAAA,EAA2F;EAAA,IAAvFC,OAAO,GAAAD,IAAA,CAAPC,OAAO;IAAEC,OAAO,GAAAF,IAAA,CAAPE,OAAO;IAAEC,MAAM,GAAAH,IAAA,CAANG,MAAM;IAAEC,QAAQ,GAAAJ,IAAA,CAARI,QAAQ;IAAEC,IAAI,GAAAL,IAAA,CAAJK,IAAI;IAAEC,IAAI,GAAAN,IAAA,CAAJM,IAAI;IAAEC,UAAU,GAAAP,IAAA,CAAVO,UAAU;IAAEC,KAAK,GAAAR,IAAA,CAALQ,KAAK;IAAEC,OAAO,GAAAT,IAAA,CAAPS,OAAO;IAAEC,OAAO,GAAAV,IAAA,CAAPU,OAAO;EAChH;AACF;AACA;EACE,IAAMC,KAAK;IAAA,IAAAC,KAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,QAAA;MAAA,IAAAC,oBAAA,EAAAC,MAAA;MAAA,OAAAJ,mBAAA,GAAAK,IAAA,UAAAC,SAAAC,QAAA;QAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;UAAA;YAAAF,QAAA,CAAAE,IAAA;YAAA,OACazB,OAAO,CAACa,KAAK,CAACV,OAAO,EAAE;cAC9CE,MAAM,EAANA,MAAM;cACNE,IAAI,EAAJA,IAAI;cACJG,KAAK,EAALA,KAAK;cACLC,OAAO,EAAPA,OAAO;cACPC,OAAO,EAAPA;YACF,CAAC,CAAC;UAAA;YAAAO,oBAAA,GAAAI,QAAA,CAAAG,IAAA;YANMN,MAAM,GAAAD,oBAAA,CAANC,MAAM;YAAAG,QAAA,CAAAE,IAAA;YAAA,OAQRE,OAAO,CAACC,GAAG,CAAC,CAChBpB,IAAI,CAACqB,WAAW,CAAC;cAAEvB,QAAQ,EAARA,QAAQ;cAAEc,MAAM,EAANA,MAAM;cAAEf,MAAM,EAANA,MAAM;cAAEE,IAAI,EAAJA;YAAK,CAAC,CAAC,EACpDH,OAAO,CAACS,KAAK,CAAC,CAAC,EACfJ,UAAU,CAACI,KAAK,CAAC,CAAC,CACnB,CAAC;UAAA;UAAA;YAAA,OAAAU,QAAA,CAAAO,IAAA;QAAA;MAAA,GAAAZ,OAAA;IAAA,CACH;IAAA,gBAdKL,KAAKA,CAAA;MAAA,OAAAC,KAAA,CAAAiB,KAAA,OAAAC,SAAA;IAAA;EAAA,GAcV;EAED,OAAOnB,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}