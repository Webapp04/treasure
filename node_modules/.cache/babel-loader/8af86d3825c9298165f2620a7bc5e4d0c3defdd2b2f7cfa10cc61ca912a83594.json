{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { connect } from 'it-ws/client';\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri';\nimport { AbortError } from '@libp2p/interfaces/errors';\nimport pDefer from 'p-defer';\nimport { logger } from '@libp2p/logger';\nimport { isBrowser, isWebWorker } from 'wherearewe';\nimport { createListener as _createListener } from './listener.js';\nimport { socketToMaConn } from './socket-to-conn.js';\nimport * as filters from './filters.js';\nimport { symbol } from '@libp2p/interface-transport';\nvar log = logger('libp2p:websockets');\nexport var WebSockets = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function WebSockets(init) {\n    _classCallCheck(this, WebSockets);\n    this.init = init;\n  }\n  _createClass(WebSockets, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return '@libp2p/websockets';\n    }\n  }, {\n    key: symbol,\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"dial\",\n    value: function () {\n      var _dial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ma, options) {\n        var _options;\n        var socket, maConn, conn;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              log('dialing %s', ma);\n              options = (_options = options) !== null && _options !== void 0 ? _options : {};\n              _context.next = 4;\n              return this._connect(ma, options);\n            case 4:\n              socket = _context.sent;\n              maConn = socketToMaConn(socket, ma);\n              log('new outbound connection %s', maConn.remoteAddr);\n              _context.next = 9;\n              return options.upgrader.upgradeOutbound(maConn);\n            case 9:\n              conn = _context.sent;\n              log('outbound connection %s upgraded', maConn.remoteAddr);\n              return _context.abrupt(\"return\", conn);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function dial(_x, _x2) {\n        return _dial.apply(this, arguments);\n      }\n      return dial;\n    }()\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ma, options) {\n        var _options$signal;\n        var cOpts, errorPromise, errfn, rawSocket, onAbort, abort, _options$signal4;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!((options === null || options === void 0 || (_options$signal = options.signal) === null || _options$signal === void 0 ? void 0 : _options$signal.aborted) === true)) {\n                _context2.next = 2;\n                break;\n              }\n              throw new AbortError();\n            case 2:\n              cOpts = ma.toOptions();\n              log('dialing %s:%s', cOpts.host, cOpts.port);\n              errorPromise = pDefer();\n              errfn = function errfn(err) {\n                log.error('connection error:', err);\n                errorPromise.reject(err);\n              };\n              rawSocket = connect(toUri(ma), this.init);\n              if (rawSocket.socket.on != null) {\n                rawSocket.socket.on('error', errfn);\n              } else {\n                rawSocket.socket.onerror = errfn;\n              }\n              if (!(options.signal == null)) {\n                _context2.next = 13;\n                break;\n              }\n              _context2.next = 11;\n              return Promise.race([rawSocket.connected(), errorPromise.promise]);\n            case 11:\n              log('connected %s', ma);\n              return _context2.abrupt(\"return\", rawSocket);\n            case 13:\n              abort = new Promise(function (resolve, reject) {\n                var _options$signal2, _options$signal3;\n                onAbort = function onAbort() {\n                  reject(new AbortError());\n                  rawSocket.close().catch(function (err) {\n                    log.error('error closing raw socket', err);\n                  });\n                };\n                // Already aborted?\n                if ((options === null || options === void 0 || (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.aborted) === true) {\n                  return onAbort();\n                }\n                options === null || options === void 0 || (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.addEventListener('abort', onAbort);\n              });\n              _context2.prev = 14;\n              _context2.next = 17;\n              return Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n            case 17:\n              _context2.prev = 17;\n              if (onAbort != null) {\n                options === null || options === void 0 || (_options$signal4 = options.signal) === null || _options$signal4 === void 0 ? void 0 : _options$signal4.removeEventListener('abort', onAbort);\n              }\n              return _context2.finish(17);\n            case 20:\n              log('connected %s', ma);\n              return _context2.abrupt(\"return\", rawSocket);\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[14,, 17, 20]]);\n      }));\n      function _connect(_x3, _x4) {\n        return _connect2.apply(this, arguments);\n      }\n      return _connect;\n    }()\n    /**\n     * Creates a Websockets listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`\n     */\n  }, {\n    key: \"createListener\",\n    value: function createListener(options) {\n      return _createListener(_objectSpread(_objectSpread({}, this.init), options));\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n     * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n     * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      var _this$init;\n      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n      if (((_this$init = this.init) === null || _this$init === void 0 ? void 0 : _this$init.filter) != null) {\n        var _this$init2;\n        return (_this$init2 = this.init) === null || _this$init2 === void 0 ? void 0 : _this$init2.filter(multiaddrs);\n      }\n      // Browser\n      if (isBrowser || isWebWorker) {\n        return filters.dnsWss(multiaddrs);\n      }\n      return filters.all(multiaddrs);\n    }\n  }]);\n  return WebSockets;\n}(Symbol.toStringTag);","map":{"version":3,"names":["connect","multiaddrToUri","toUri","AbortError","pDefer","logger","isBrowser","isWebWorker","createListener","socketToMaConn","filters","symbol","log","WebSockets","_Symbol$toStringTag","init","_classCallCheck","_createClass","key","get","value","_dial","_asyncToGenerator","_regeneratorRuntime","mark","_callee","ma","options","_options","socket","maConn","conn","wrap","_callee$","_context","prev","next","_connect","sent","remoteAddr","upgrader","upgradeOutbound","abrupt","stop","dial","_x","_x2","apply","arguments","_connect2","_callee2","_options$signal","cOpts","errorPromise","errfn","rawSocket","onAbort","abort","_options$signal4","_callee2$","_context2","signal","aborted","toOptions","host","port","err","error","reject","on","onerror","Promise","race","connected","promise","resolve","_options$signal2","_options$signal3","close","catch","addEventListener","removeEventListener","finish","_x3","_x4","_objectSpread","filter","multiaddrs","_this$init","Array","isArray","_this$init2","dnsWss","all","Symbol","toStringTag"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/websockets/src/index.ts"],"sourcesContent":["import { connect, WebSocketOptions } from 'it-ws/client'\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri'\nimport { AbortError } from '@libp2p/interfaces/errors'\nimport pDefer from 'p-defer'\nimport { logger } from '@libp2p/logger'\nimport { isBrowser, isWebWorker } from 'wherearewe'\nimport { createListener } from './listener.js'\nimport { socketToMaConn } from './socket-to-conn.js'\nimport * as filters from './filters.js'\nimport { Transport, MultiaddrFilter, symbol, CreateListenerOptions, DialOptions } from '@libp2p/interface-transport'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\nimport type { ClientOptions } from 'ws'\nimport type { Server } from 'http'\n\nconst log = logger('libp2p:websockets')\n\nexport interface WebSocketsInit extends AbortOptions, WebSocketOptions {\n  filter?: MultiaddrFilter\n  websocket?: ClientOptions\n  server?: Server\n}\n\nexport class WebSockets implements Transport {\n  private readonly init?: WebSocketsInit\n\n  constructor (init?: WebSocketsInit) {\n    this.init = init\n  }\n\n  get [Symbol.toStringTag] () {\n    return '@libp2p/websockets'\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  async dial (ma: Multiaddr, options: DialOptions): Promise<Connection> {\n    log('dialing %s', ma)\n    options = options ?? {}\n\n    const socket = await this._connect(ma, options)\n    const maConn = socketToMaConn(socket, ma)\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await options.upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: AbortOptions): Promise<DuplexWebSocket> {\n    if (options?.signal?.aborted === true) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const errorPromise = pDefer()\n    const errfn = (err: any) => {\n      log.error('connection error:', err)\n\n      errorPromise.reject(err)\n    }\n\n    const rawSocket = connect(toUri(ma), this.init)\n\n    if (rawSocket.socket.on != null) {\n      rawSocket.socket.on('error', errfn)\n    } else {\n      rawSocket.socket.onerror = errfn\n    }\n\n    if (options.signal == null) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise])\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        rawSocket.close().catch(err => {\n          log.error('error closing raw socket', err)\n        })\n      }\n\n      // Already aborted?\n      if (options?.signal?.aborted === true) {\n        return onAbort()\n      }\n\n      options?.signal?.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])\n    } finally {\n      if (onAbort != null) {\n        options?.signal?.removeEventListener('abort', onAbort)\n      }\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n  createListener (options: CreateListenerOptions) {\n    return createListener({ ...this.init, ...options })\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   */\n  filter (multiaddrs: Multiaddr[]) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    if (this.init?.filter != null) {\n      return this.init?.filter(multiaddrs)\n    }\n\n    // Browser\n    if (isBrowser || isWebWorker) {\n      return filters.dnsWss(multiaddrs)\n    }\n\n    return filters.all(multiaddrs)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}