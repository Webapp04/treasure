{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { CID } from 'multiformats/cid';\nimport { Key } from 'interface-datastore/key';\nimport debug from 'debug';\nimport length from 'it-length';\nimport { base32 } from 'multiformats/bases/base32';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as mhd from 'multiformats/hashes/digest';\nvar log = debug('ipfs:repo:migrator:migration-8');\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\nfunction unwrap(blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child);\n  }\n  return blockstore;\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToMultihash(key) {\n  try {\n    var buf = base32.decode(\"b\".concat(key.toString().toLowerCase().slice(1)));\n\n    // Extract multihash from CID\n    var multihash = CID.decode(buf).multihash.bytes;\n\n    // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n    var multihashStr = base32.encode(multihash).slice(1).toUpperCase();\n    return new Key(\"/\".concat(multihashStr), false);\n  } catch ( /** @type {any} */err) {\n    return key;\n  }\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToCid(key) {\n  try {\n    var buf = base32.decode(\"b\".concat(key.toString().toLowerCase().slice(1)));\n    var digest = mhd.decode(buf);\n\n    // CID to Key\n    var multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1);\n    return new Key(\"/\".concat(multihash.toUpperCase()), false);\n  } catch (_unused) {\n    return key;\n  }\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\nfunction process(_x, _x2, _x3) {\n  return _process.apply(this, arguments);\n}\n/** @type {Migration} */\nfunction _process() {\n  _process = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backends, onProgress, keyFunction) {\n    var blockstore, unwrapped, blockCount, counter, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, block, newKey;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          blockstore = backends.blocks;\n          _context.next = 3;\n          return blockstore.open();\n        case 3:\n          unwrapped = unwrap(blockstore);\n          _context.next = 6;\n          return length(unwrapped.queryKeys({\n            filters: [function (key) {\n              var newKey = keyFunction(key);\n              return newKey.toString() !== key.toString();\n            }]\n          }));\n        case 6:\n          blockCount = _context.sent;\n          _context.prev = 7;\n          counter = 0;\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 11;\n          _iterator = _asyncIterator(unwrapped.query({}));\n        case 13:\n          _context.next = 15;\n          return _iterator.next();\n        case 15:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 34;\n            break;\n          }\n          block = _step.value;\n          newKey = keyFunction(block.key); // If the Key is base32 CIDv0 then there's nothing to do\n          if (!(newKey.toString() !== block.key.toString())) {\n            _context.next = 31;\n            break;\n          }\n          counter += 1;\n          _context.t0 = log;\n          _context.t1 = \"Migrating Block from \".concat(block.key, \" to \").concat(newKey);\n          _context.next = 24;\n          return unwrapped.has(block.key);\n        case 24:\n          _context.t2 = _context.sent;\n          (0, _context.t0)(_context.t1, _context.t2);\n          _context.next = 28;\n          return unwrapped.delete(block.key);\n        case 28:\n          _context.next = 30;\n          return unwrapped.put(newKey, block.value);\n        case 30:\n          onProgress(counter / blockCount * 100, \"Migrated Block from \".concat(block.key, \" to \").concat(newKey));\n        case 31:\n          _iteratorAbruptCompletion = false;\n          _context.next = 13;\n          break;\n        case 34:\n          _context.next = 40;\n          break;\n        case 36:\n          _context.prev = 36;\n          _context.t3 = _context[\"catch\"](11);\n          _didIteratorError = true;\n          _iteratorError = _context.t3;\n        case 40:\n          _context.prev = 40;\n          _context.prev = 41;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context.next = 45;\n            break;\n          }\n          _context.next = 45;\n          return _iterator.return();\n        case 45:\n          _context.prev = 45;\n          if (!_didIteratorError) {\n            _context.next = 48;\n            break;\n          }\n          throw _iteratorError;\n        case 48:\n          return _context.finish(45);\n        case 49:\n          return _context.finish(40);\n        case 50:\n          _context.prev = 50;\n          _context.next = 53;\n          return blockstore.close();\n        case 53:\n          return _context.finish(50);\n        case 54:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[7,, 50, 54], [11, 36, 40, 50], [41,, 45, 49]]);\n  }));\n  return _process.apply(this, arguments);\n}\nexport var migration = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: function migrate(backends) {\n    var onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    return process(backends, onProgress, keyToMultihash);\n  },\n  revert: function revert(backends) {\n    var onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    return process(backends, onProgress, keyToCid);\n  }\n};","map":{"version":3,"names":["CID","Key","debug","length","base32","raw","mhd","log","unwrap","blockstore","child","keyToMultihash","key","buf","decode","concat","toString","toLowerCase","slice","multihash","bytes","multihashStr","encode","toUpperCase","err","keyToCid","digest","createV1","code","_unused","process","_x","_x2","_x3","_process","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","backends","onProgress","keyFunction","unwrapped","blockCount","counter","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","block","newKey","wrap","_callee$","_context","prev","next","blocks","open","queryKeys","filters","sent","_asyncIterator","query","done","value","t0","t1","has","t2","delete","put","t3","return","finish","close","stop","migration","version","description","migrate","undefined","revert"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-repo-migrations/migrations/migration-8/index.js"],"sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport { Key } from 'interface-datastore/key'\nimport debug from 'debug'\nimport length from 'it-length'\nimport { base32 } from 'multiformats/bases/base32'\nimport * as raw from 'multiformats/codecs/raw'\nimport * as mhd from 'multiformats/hashes/digest'\n\nconst log = debug('ipfs:repo:migrator:migration-8')\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\nfunction unwrap (blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child)\n  }\n\n  return blockstore\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToMultihash (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n\n    // Extract multihash from CID\n    const multihash = CID.decode(buf).multihash.bytes\n\n    // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase()\n\n    return new Key(`/${multihashStr}`, false)\n  } catch (/** @type {any} */ err) {\n    return key\n  }\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToCid (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n    const digest = mhd.decode(buf)\n\n    // CID to Key\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1)\n\n    return new Key(`/${multihash.toUpperCase()}`, false)\n  } catch {\n    return key\n  }\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\nasync function process (backends, onProgress, keyFunction) {\n  const blockstore = backends.blocks\n  await blockstore.open()\n\n  const unwrapped = unwrap(blockstore)\n\n  const blockCount = await length(unwrapped.queryKeys({\n    filters: [(key) => {\n      const newKey = keyFunction(key)\n\n      return newKey.toString() !== key.toString()\n    }]\n  }))\n\n  try {\n    let counter = 0\n\n    for await (const block of unwrapped.query({})) {\n      const newKey = keyFunction(block.key)\n\n      // If the Key is base32 CIDv0 then there's nothing to do\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1\n        log(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key))\n\n        await unwrapped.delete(block.key)\n        await unwrapped.put(newKey, block.value)\n\n        onProgress((counter / blockCount) * 100, `Migrated Block from ${block.key} to ${newKey}`)\n      }\n    }\n  } finally {\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nexport const migration = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToMultihash)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToCid)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}