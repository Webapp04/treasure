{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { logger } from '@libp2p/logger';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { generatePath, updateHamtDirectory } from './hamt-utils.js';\nimport errCode from 'err-code';\nvar log = logger('ipfs:mfs:core:utils:remove-link');\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nexport function removeLink(_x, _x2) {\n  return _removeLink.apply(this, arguments);\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nfunction _removeLink() {\n  _removeLink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(context, options) {\n    var parent, parentCid, block, meta;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          parent = options.parent;\n          if (!options.parentCid) {\n            _context4.next = 10;\n            break;\n          }\n          parentCid = CID.asCID(options.parentCid);\n          if (!(parentCid === null)) {\n            _context4.next = 5;\n            break;\n          }\n          throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n        case 5:\n          log(\"Loading parent node \".concat(parentCid));\n          _context4.next = 8;\n          return context.repo.blocks.get(parentCid);\n        case 8:\n          block = _context4.sent;\n          parent = dagPB.decode(block);\n        case 10:\n          if (parent) {\n            _context4.next = 12;\n            break;\n          }\n          throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n        case 12:\n          if (options.name) {\n            _context4.next = 14;\n            break;\n          }\n          throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n        case 14:\n          if (parent.Data) {\n            _context4.next = 16;\n            break;\n          }\n          throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n        case 16:\n          meta = UnixFS.unmarshal(parent.Data);\n          if (!(meta.type === 'hamt-sharded-directory')) {\n            _context4.next = 20;\n            break;\n          }\n          log(\"Removing \".concat(options.name, \" from sharded directory\"));\n          return _context4.abrupt(\"return\", removeFromShardedDirectory(context, _objectSpread(_objectSpread({}, options), {}, {\n            parent: parent\n          })));\n        case 20:\n          log(\"Removing link \".concat(options.name, \" regular directory\"));\n          return _context4.abrupt(\"return\", removeFromDirectory(context, _objectSpread(_objectSpread({}, options), {}, {\n            parent: parent\n          })));\n        case 22:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _removeLink.apply(this, arguments);\n}\nvar removeFromDirectory = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, options) {\n    var parentBlock, hasher, hash, parentCid;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          // Remove existing link if it exists\n          options.parent.Links = options.parent.Links.filter(function (link) {\n            return link.Name !== options.name;\n          });\n          _context.next = 3;\n          return dagPB.encode(options.parent);\n        case 3:\n          parentBlock = _context.sent;\n          _context.next = 6;\n          return context.hashers.getHasher(options.hashAlg);\n        case 6:\n          hasher = _context.sent;\n          _context.next = 9;\n          return hasher.digest(parentBlock);\n        case 9:\n          hash = _context.sent;\n          parentCid = CID.create(options.cidVersion, dagPB.code, hash);\n          _context.next = 13;\n          return context.repo.blocks.put(parentCid, parentBlock);\n        case 13:\n          log(\"Updated regular directory \".concat(parentCid));\n          return _context.abrupt(\"return\", {\n            node: options.parent,\n            cid: parentCid\n          });\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nvar removeFromShardedDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, options) {\n    var _yield$generatePath, rootBucket, path, _yield$updateShard, node;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return generatePath(context, options.name, options.parent);\n        case 2:\n          _yield$generatePath = _context2.sent;\n          rootBucket = _yield$generatePath.rootBucket;\n          path = _yield$generatePath.path;\n          _context2.next = 7;\n          return rootBucket.del(options.name);\n        case 7:\n          _context2.next = 9;\n          return updateShard(context, path, options.name, options);\n        case 9:\n          _yield$updateShard = _context2.sent;\n          node = _yield$updateShard.node;\n          return _context2.abrupt(\"return\", updateHamtDirectory(context, node.Links, rootBucket, options));\n        case 12:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nvar updateShard = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(context, positions, name, options) {\n    var last, bucket, prefix, node, link, links, result, cid, size, newName, _link;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          last = positions.pop();\n          if (last) {\n            _context3.next = 3;\n            break;\n          }\n          throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n        case 3:\n          bucket = last.bucket, prefix = last.prefix, node = last.node;\n          if (node) {\n            _context3.next = 6;\n            break;\n          }\n          throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n        case 6:\n          link = node.Links.find(function (link) {\n            return (link.Name || '').substring(0, 2) === prefix;\n          });\n          if (link) {\n            _context3.next = 9;\n            break;\n          }\n          throw errCode(new Error(\"No link found with prefix \".concat(prefix, \" for file \").concat(name)), 'ERR_NOT_FOUND');\n        case 9:\n          if (!(link.Name === \"\".concat(prefix).concat(name))) {\n            _context3.next = 15;\n            break;\n          }\n          log(\"Removing existing link \".concat(link.Name));\n          links = node.Links.filter(function (nodeLink) {\n            return nodeLink.Name !== link.Name;\n          });\n          _context3.next = 14;\n          return bucket.del(name);\n        case 14:\n          return _context3.abrupt(\"return\", updateHamtDirectory(context, links, bucket, options));\n        case 15:\n          log(\"Descending into sub-shard \".concat(link.Name, \" for \").concat(prefix).concat(name));\n          _context3.next = 18;\n          return updateShard(context, positions, name, options);\n        case 18:\n          result = _context3.sent;\n          cid = result.cid;\n          size = result.size;\n          newName = prefix;\n          if (result.node.Links.length === 1) {\n            log(\"Removing subshard for \".concat(prefix));\n\n            // convert shard back to normal dir\n            _link = result.node.Links[0];\n            newName = \"\".concat(prefix).concat((_link.Name || '').substring(2));\n            cid = _link.Hash;\n            size = _link.Tsize || 0;\n          }\n          log(\"Updating shard \".concat(prefix, \" with name \").concat(newName));\n          return _context3.abrupt(\"return\", updateShardParent(context, bucket, node, prefix, newName, size, cid, options));\n        case 25:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nvar updateShardParent = function updateShardParent(context, bucket, parent, oldName, newName, size, cid, options) {\n  // Remove existing link if it exists\n  var parentLinks = parent.Links.filter(function (link) {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return updateHamtDirectory(context, parentLinks, bucket, options);\n};","map":{"version":3,"names":["dagPB","CID","logger","UnixFS","generatePath","updateHamtDirectory","errCode","log","removeLink","_x","_x2","_removeLink","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee4","context","options","parent","parentCid","block","meta","wrap","_callee4$","_context4","prev","next","asCID","Error","concat","repo","blocks","get","sent","decode","name","Data","unmarshal","type","abrupt","removeFromShardedDirectory","_objectSpread","removeFromDirectory","stop","_ref","_callee","parentBlock","hasher","hash","_callee$","_context","Links","filter","link","Name","encode","hashers","getHasher","hashAlg","digest","create","cidVersion","code","put","node","cid","_x3","_x4","_ref2","_callee2","_yield$generatePath","rootBucket","path","_yield$updateShard","_callee2$","_context2","del","updateShard","_x5","_x6","_ref3","_callee3","positions","last","bucket","prefix","links","result","size","newName","_link","_callee3$","_context3","pop","find","substring","nodeLink","length","Hash","Tsize","updateShardParent","_x7","_x8","_x9","_x10","oldName","parentLinks","push"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/utils/remove-link.js"],"sourcesContent":["\nimport * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport {\n  generatePath,\n  updateHamtDirectory\n} from './hamt-utils.js'\nimport errCode from 'err-code'\n\nconst log = logger('ipfs:mfs:core:utils:remove-link')\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nexport async function removeLink (context, options) {\n  let parent = options.parent\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid)\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n    }\n\n    log(`Loading parent node ${parentCid}`)\n    const block = await context.repo.blocks.get(parentCid)\n    parent = dagPB.decode(block)\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE')\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    })\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  })\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter((link) => {\n    return link.Name !== options.name\n  })\n\n  const parentBlock = await dagPB.encode(options.parent)\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const hash = await hasher.digest(parentBlock)\n  const parentCid = CID.create(options.cidVersion, dagPB.code, hash)\n\n  await context.repo.blocks.put(parentCid, parentBlock)\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: options.parent,\n    cid: parentCid\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, options.name, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop()\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const link = node.Links\n    .find(link => (link.Name || '').substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    const links = node.Links.filter((nodeLink) => {\n      return nodeLink.Name !== link.Name\n    })\n\n    await bucket.del(name)\n\n    return updateHamtDirectory(context, links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`)\n\n  const result = await updateShard(context, positions, name, options)\n\n  let cid = result.cid\n  let size = result.size\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    const link = result.node.Links[0]\n\n    newName = `${prefix}${(link.Name || '').substring(2)}`\n    cid = link.Hash\n    size = link.Tsize || 0\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter((link) => {\n    return link.Name !== oldName\n  })\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  })\n\n  return updateHamtDirectory(context, parentLinks, bucket, options)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}