{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _construct from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport * as multistream from './multistream.js';\nimport { handshake } from 'it-handshake';\nimport { PROTOCOL_ID } from './constants.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { Uint8ArrayList } from 'uint8arraylist';\nvar log = logger('libp2p:mss:handle');\nexport function handle(_x, _x2, _x3) {\n  return _handle.apply(this, arguments);\n}\nfunction _handle() {\n  _handle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(stream, protocols, options) {\n    var _handshake, writer, reader, rest, shakeStream, protocol;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          protocols = Array.isArray(protocols) ? protocols : [protocols];\n          _handshake = handshake(stream), writer = _handshake.writer, reader = _handshake.reader, rest = _handshake.rest, shakeStream = _handshake.stream;\n        case 2:\n          if (!true) {\n            _context.next = 24;\n            break;\n          }\n          _context.next = 5;\n          return multistream.readString(reader, options);\n        case 5:\n          protocol = _context.sent;\n          log('read \"%s\"', protocol);\n          if (!(protocol === PROTOCOL_ID)) {\n            _context.next = 11;\n            break;\n          }\n          log('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol);\n          multistream.write(writer, uint8ArrayFromString(PROTOCOL_ID), options);\n          return _context.abrupt(\"continue\", 2);\n        case 11:\n          if (!protocols.includes(protocol)) {\n            _context.next = 16;\n            break;\n          }\n          multistream.write(writer, uint8ArrayFromString(protocol), options);\n          log('respond with \"%s\" for \"%s\"', protocol, protocol);\n          rest();\n          return _context.abrupt(\"return\", {\n            stream: shakeStream,\n            protocol: protocol\n          });\n        case 16:\n          if (!(protocol === 'ls')) {\n            _context.next = 20;\n            break;\n          }\n          // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n          multistream.write(writer, _construct(Uint8ArrayList, _toConsumableArray(protocols.map(function (p) {\n            return multistream.encode(uint8ArrayFromString(p));\n          }))), options);\n          // multistream.writeAll(writer, protocols.map(p => uint8ArrayFromString(p)))\n          log('respond with \"%s\" for %s', protocols, protocol);\n          return _context.abrupt(\"continue\", 2);\n        case 20:\n          multistream.write(writer, uint8ArrayFromString('na'), options);\n          log('respond with \"na\" for \"%s\"', protocol);\n          _context.next = 2;\n          break;\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _handle.apply(this, arguments);\n}","map":{"version":3,"names":["logger","multistream","handshake","PROTOCOL_ID","fromString","uint8ArrayFromString","Uint8ArrayList","log","handle","_x","_x2","_x3","_handle","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","stream","protocols","options","_handshake","writer","reader","rest","shakeStream","protocol","wrap","_callee$","_context","prev","next","Array","isArray","readString","sent","write","abrupt","includes","_construct","_toConsumableArray","map","p","encode","stop"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/multistream-select/src/handle.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport * as multistream from './multistream.js'\nimport { handshake } from 'it-handshake'\nimport { PROTOCOL_ID } from './constants.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport type { Duplex } from 'it-stream-types'\nimport type { ByteArrayInit, ByteListInit, MultistreamSelectInit, ProtocolStream } from './index.js'\n\nconst log = logger('libp2p:mss:handle')\n\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```js\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle (stream: Duplex<Uint8Array>, protocols: string | string[], options: ByteArrayInit): Promise<ProtocolStream<Uint8Array>>\nexport async function handle (stream: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>, protocols: string | string[], options?: ByteListInit): Promise<ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>>\nexport async function handle (stream: Duplex<any>, protocols: string | string[], options?: MultistreamSelectInit): Promise<ProtocolStream<any>> {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n  const { writer, reader, rest, stream: shakeStream } = handshake(stream)\n\n  while (true) {\n    const protocol = await multistream.readString(reader, options)\n    log('read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      log('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      multistream.write(writer, uint8ArrayFromString(PROTOCOL_ID), options)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      multistream.write(writer, uint8ArrayFromString(protocol), options)\n      log('respond with \"%s\" for \"%s\"', protocol, protocol)\n      rest()\n      return { stream: shakeStream, protocol }\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      multistream.write(writer, new Uint8ArrayList(...protocols.map(p => multistream.encode(uint8ArrayFromString(p)))), options)\n      // multistream.writeAll(writer, protocols.map(p => uint8ArrayFromString(p)))\n      log('respond with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    multistream.write(writer, uint8ArrayFromString('na'), options)\n    log('respond with \"na\" for \"%s\"', protocol)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}