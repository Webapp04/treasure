{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Tags;\n(function (Tags) {\n  var _codec;\n  Tags.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.tags != null) {\n          var _iterator = _createForOfIteratorHelper(obj.tags),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var value = _step.value;\n              writer.uint32(10);\n              Tag.codec().encode(value, writer);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"tags\" was not found in object');\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var obj = {\n          tags: []\n        };\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              obj.tags.push(Tag.codec().decode(reader, reader.uint32()));\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Tags.encode = function (obj) {\n    return encodeMessage(obj, Tags.codec());\n  };\n  Tags.decode = function (buf) {\n    return decodeMessage(buf, Tags.codec());\n  };\n})(Tags || (Tags = {}));\nexport var Tag;\n(function (Tag) {\n  var _codec;\n  Tag.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.name != null) {\n          writer.uint32(10);\n          writer.string(obj.name);\n        } else {\n          throw new Error('Protocol error: required field \"name\" was not found in object');\n        }\n        if (obj.value != null) {\n          writer.uint32(16);\n          writer.uint32(obj.value);\n        }\n        if (obj.expiry != null) {\n          writer.uint32(24);\n          writer.uint64(obj.expiry);\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var obj = {\n          name: ''\n        };\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              obj.name = reader.string();\n              break;\n            case 2:\n              obj.value = reader.uint32();\n              break;\n            case 3:\n              obj.expiry = reader.uint64();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        if (obj.name == null) {\n          throw new Error('Protocol error: value for required field \"name\" was not found in protobuf');\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Tag.encode = function (obj) {\n    return encodeMessage(obj, Tag.codec());\n  };\n  Tag.decode = function (buf) {\n    return decodeMessage(buf, Tag.codec());\n  };\n})(Tag || (Tag = {}));","map":{"version":3,"names":["encodeMessage","decodeMessage","message","Tags","_codec","codec","obj","writer","opts","arguments","length","undefined","lengthDelimited","fork","tags","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","uint32","Tag","encode","err","e","f","Error","ldelim","reader","end","len","pos","tag","push","decode","skipType","buf","name","string","expiry","uint64"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/peer-store/src/pb/tags.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface Tags {\n  tags: Tag[]\n}\n\nexport namespace Tags {\n  let _codec: Codec<Tags>\n\n  export const codec = (): Codec<Tags> => {\n    if (_codec == null) {\n      _codec = message<Tags>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.tags != null) {\n          for (const value of obj.tags) {\n            writer.uint32(10)\n            Tag.codec().encode(value, writer)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"tags\" was not found in object')\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          tags: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.tags.push(Tag.codec().decode(reader, reader.uint32()))\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Tags): Uint8Array => {\n    return encodeMessage(obj, Tags.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Tags => {\n    return decodeMessage(buf, Tags.codec())\n  }\n}\n\nexport interface Tag {\n  name: string\n  value?: number\n  expiry?: bigint\n}\n\nexport namespace Tag {\n  let _codec: Codec<Tag>\n\n  export const codec = (): Codec<Tag> => {\n    if (_codec == null) {\n      _codec = message<Tag>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.name != null) {\n          writer.uint32(10)\n          writer.string(obj.name)\n        } else {\n          throw new Error('Protocol error: required field \"name\" was not found in object')\n        }\n\n        if (obj.value != null) {\n          writer.uint32(16)\n          writer.uint32(obj.value)\n        }\n\n        if (obj.expiry != null) {\n          writer.uint32(24)\n          writer.uint64(obj.expiry)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          name: ''\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.name = reader.string()\n              break\n            case 2:\n              obj.value = reader.uint32()\n              break\n            case 3:\n              obj.expiry = reader.uint64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        if (obj.name == null) {\n          throw new Error('Protocol error: value for required field \"name\" was not found in protobuf')\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Tag): Uint8Array => {\n    return encodeMessage(obj, Tag.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Tag => {\n    return decodeMessage(buf, Tag.codec())\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}