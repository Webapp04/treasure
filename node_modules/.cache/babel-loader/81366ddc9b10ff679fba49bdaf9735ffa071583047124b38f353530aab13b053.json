{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport errCode from 'err-code';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\n/**\n * Checks a record and ensures it is still valid.\n * It runs the needed validators.\n * If verification fails the returned Promise will reject with the error.\n */\nexport function verifyRecord(validators, record) {\n  var key = record.key;\n  var keyString = uint8ArrayToString(key);\n  var parts = keyString.split('/');\n  if (parts.length < 3) {\n    // No validator available\n    return;\n  }\n  var validator = validators[parts[1].toString()];\n  if (validator == null) {\n    var errMsg = 'Invalid record keytype';\n    throw errCode(new Error(errMsg), 'ERR_INVALID_RECORD_KEY_TYPE');\n  }\n  return validator(key, record.value);\n}\n/**\n * Validator for public key records.\n * Verifies that the passed in record value is the PublicKey\n * that matches the passed in key.\n * If validation fails the returned Promise will reject with the error.\n *\n * @param {Uint8Array} key - A valid key is of the form `'/pk/<keymultihash>'`\n * @param {Uint8Array} publicKey - The public key to validate against (protobuf encoded).\n */\nvar validatePublicKeyRecord = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, publicKey) {\n    var prefix, keyhash, publicKeyHash;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (key instanceof Uint8Array) {\n            _context.next = 2;\n            break;\n          }\n          throw errCode(new Error('\"key\" must be a Uint8Array'), 'ERR_INVALID_RECORD_KEY_NOT_BUFFER');\n        case 2:\n          if (!(key.byteLength < 5)) {\n            _context.next = 4;\n            break;\n          }\n          throw errCode(new Error('invalid public key record'), 'ERR_INVALID_RECORD_KEY_TOO_SHORT');\n        case 4:\n          prefix = uint8ArrayToString(key.subarray(0, 4));\n          if (!(prefix !== '/pk/')) {\n            _context.next = 7;\n            break;\n          }\n          throw errCode(new Error('key was not prefixed with /pk/'), 'ERR_INVALID_RECORD_KEY_BAD_PREFIX');\n        case 7:\n          keyhash = key.slice(4);\n          _context.next = 10;\n          return sha256.digest(publicKey);\n        case 10:\n          publicKeyHash = _context.sent;\n          if (uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {\n            _context.next = 13;\n            break;\n          }\n          throw errCode(new Error('public key does not match passed in key'), 'ERR_INVALID_RECORD_HASH_MISMATCH');\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function validatePublicKeyRecord(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var validators = {\n  pk: validatePublicKeyRecord\n};","map":{"version":3,"names":["errCode","toString","uint8ArrayToString","sha256","equals","uint8ArrayEquals","verifyRecord","validators","record","key","keyString","parts","split","length","validator","errMsg","Error","value","validatePublicKeyRecord","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","publicKey","prefix","keyhash","publicKeyHash","wrap","_callee$","_context","prev","next","Uint8Array","byteLength","subarray","slice","digest","sent","bytes","stop","_x","_x2","apply","arguments","pk"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/record/src/validators.ts"],"sourcesContent":["import errCode from 'err-code'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Libp2pRecord } from './index.js'\nimport type { Validators } from '@libp2p/interface-dht'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\n\n/**\n * Checks a record and ensures it is still valid.\n * It runs the needed validators.\n * If verification fails the returned Promise will reject with the error.\n */\nexport function verifyRecord (validators: Validators, record: Libp2pRecord) {\n  const key = record.key\n  const keyString = uint8ArrayToString(key)\n  const parts = keyString.split('/')\n\n  if (parts.length < 3) {\n    // No validator available\n    return\n  }\n\n  const validator = validators[parts[1].toString()]\n\n  if (validator == null) {\n    const errMsg = 'Invalid record keytype'\n\n    throw errCode(new Error(errMsg), 'ERR_INVALID_RECORD_KEY_TYPE')\n  }\n\n  return validator(key, record.value)\n}\n\n/**\n * Validator for public key records.\n * Verifies that the passed in record value is the PublicKey\n * that matches the passed in key.\n * If validation fails the returned Promise will reject with the error.\n *\n * @param {Uint8Array} key - A valid key is of the form `'/pk/<keymultihash>'`\n * @param {Uint8Array} publicKey - The public key to validate against (protobuf encoded).\n */\nconst validatePublicKeyRecord = async (key: Uint8Array, publicKey: Uint8Array) => {\n  if (!(key instanceof Uint8Array)) {\n    throw errCode(new Error('\"key\" must be a Uint8Array'), 'ERR_INVALID_RECORD_KEY_NOT_BUFFER')\n  }\n\n  if (key.byteLength < 5) {\n    throw errCode(new Error('invalid public key record'), 'ERR_INVALID_RECORD_KEY_TOO_SHORT')\n  }\n\n  const prefix = uint8ArrayToString(key.subarray(0, 4))\n\n  if (prefix !== '/pk/') {\n    throw errCode(new Error('key was not prefixed with /pk/'), 'ERR_INVALID_RECORD_KEY_BAD_PREFIX')\n  }\n\n  const keyhash = key.slice(4)\n\n  const publicKeyHash = await sha256.digest(publicKey)\n\n  if (!uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {\n    throw errCode(new Error('public key does not match passed in key'), 'ERR_INVALID_RECORD_HASH_MISMATCH')\n  }\n}\n\nexport const validators: Validators = {\n  pk: validatePublicKeyRecord\n}\n"],"mappings":";;AAAA,OAAOA,OAAO,MAAM,UAAU;AAC9B,SAASC,QAAQ,IAAIC,kBAAkB,QAAQ,uBAAuB;AAGtE,SAASC,MAAM,QAAQ,0BAA0B;AACjD,SAASC,MAAM,IAAIC,gBAAgB,QAAQ,oBAAoB;AAE/D;;;;;AAKA,OAAM,SAAUC,YAAYA,CAAEC,UAAsB,EAAEC,MAAoB;EACxE,IAAMC,GAAG,GAAGD,MAAM,CAACC,GAAG;EACtB,IAAMC,SAAS,GAAGR,kBAAkB,CAACO,GAAG,CAAC;EACzC,IAAME,KAAK,GAAGD,SAAS,CAACE,KAAK,CAAC,GAAG,CAAC;EAElC,IAAID,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;IACpB;IACA;;EAGF,IAAMC,SAAS,GAAGP,UAAU,CAACI,KAAK,CAAC,CAAC,CAAC,CAACV,QAAQ,EAAE,CAAC;EAEjD,IAAIa,SAAS,IAAI,IAAI,EAAE;IACrB,IAAMC,MAAM,GAAG,wBAAwB;IAEvC,MAAMf,OAAO,CAAC,IAAIgB,KAAK,CAACD,MAAM,CAAC,EAAE,6BAA6B,CAAC;;EAGjE,OAAOD,SAAS,CAACL,GAAG,EAAED,MAAM,CAACS,KAAK,CAAC;AACrC;AAEA;;;;;;;;;AASA,IAAMC,uBAAuB;EAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,QAAOd,GAAe,EAAEe,SAAqB;IAAA,IAAAC,MAAA,EAAAC,OAAA,EAAAC,aAAA;IAAA,OAAAN,mBAAA,GAAAO,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,IACrEvB,GAAG,YAAYwB,UAAU;YAAAH,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACvBhC,OAAO,CAAC,IAAIgB,KAAK,CAAC,4BAA4B,CAAC,EAAE,mCAAmC,CAAC;QAAA;UAAA,MAGzFP,GAAG,CAACyB,UAAU,GAAG,CAAC;YAAAJ,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACdhC,OAAO,CAAC,IAAIgB,KAAK,CAAC,2BAA2B,CAAC,EAAE,kCAAkC,CAAC;QAAA;UAGrFS,MAAM,GAAGvB,kBAAkB,CAACO,GAAG,CAAC0B,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UAAA,MAEjDV,MAAM,KAAK,MAAM;YAAAK,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACbhC,OAAO,CAAC,IAAIgB,KAAK,CAAC,gCAAgC,CAAC,EAAE,mCAAmC,CAAC;QAAA;UAG3FU,OAAO,GAAGjB,GAAG,CAAC2B,KAAK,CAAC,CAAC,CAAC;UAAAN,QAAA,CAAAE,IAAA;UAAA,OAEA7B,MAAM,CAACkC,MAAM,CAACb,SAAS,CAAC;QAAA;UAA9CG,aAAa,GAAAG,QAAA,CAAAQ,IAAA;UAAA,IAEdjC,gBAAgB,CAACqB,OAAO,EAAEC,aAAa,CAACY,KAAK,CAAC;YAAAT,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MAC3ChC,OAAO,CAAC,IAAIgB,KAAK,CAAC,yCAAyC,CAAC,EAAE,kCAAkC,CAAC;QAAA;QAAA;UAAA,OAAAc,QAAA,CAAAU,IAAA;MAAA;IAAA,GAAAjB,OAAA;EAAA,CAE1G;EAAA,gBAtBKL,uBAAuBA,CAAAuB,EAAA,EAAAC,GAAA;IAAA,OAAAvB,IAAA,CAAAwB,KAAA,OAAAC,SAAA;EAAA;AAAA,GAsB5B;AAED,OAAO,IAAMrC,UAAU,GAAe;EACpCsC,EAAE,EAAE3B;CACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}