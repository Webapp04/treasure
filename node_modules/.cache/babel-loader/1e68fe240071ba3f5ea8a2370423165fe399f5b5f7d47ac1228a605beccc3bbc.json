{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Peer;\n(function (Peer) {\n  var _codec;\n  Peer.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.addresses != null) {\n          var _iterator = _createForOfIteratorHelper(obj.addresses),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var value = _step.value;\n              writer.uint32(10);\n              Address.codec().encode(value, writer);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"addresses\" was not found in object');\n        }\n        if (obj.protocols != null) {\n          var _iterator2 = _createForOfIteratorHelper(obj.protocols),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _value = _step2.value;\n              writer.uint32(18);\n              writer.string(_value);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"protocols\" was not found in object');\n        }\n        if (obj.metadata != null) {\n          var _iterator3 = _createForOfIteratorHelper(obj.metadata),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _value2 = _step3.value;\n              writer.uint32(26);\n              Metadata.codec().encode(_value2, writer);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"metadata\" was not found in object');\n        }\n        if (obj.pubKey != null) {\n          writer.uint32(34);\n          writer.bytes(obj.pubKey);\n        }\n        if (obj.peerRecordEnvelope != null) {\n          writer.uint32(42);\n          writer.bytes(obj.peerRecordEnvelope);\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var obj = {\n          addresses: [],\n          protocols: [],\n          metadata: []\n        };\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32()));\n              break;\n            case 2:\n              obj.protocols.push(reader.string());\n              break;\n            case 3:\n              obj.metadata.push(Metadata.codec().decode(reader, reader.uint32()));\n              break;\n            case 4:\n              obj.pubKey = reader.bytes();\n              break;\n            case 5:\n              obj.peerRecordEnvelope = reader.bytes();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Peer.encode = function (obj) {\n    return encodeMessage(obj, Peer.codec());\n  };\n  Peer.decode = function (buf) {\n    return decodeMessage(buf, Peer.codec());\n  };\n})(Peer || (Peer = {}));\nexport var Address;\n(function (Address) {\n  var _codec;\n  Address.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.multiaddr != null) {\n          writer.uint32(10);\n          writer.bytes(obj.multiaddr);\n        } else {\n          throw new Error('Protocol error: required field \"multiaddr\" was not found in object');\n        }\n        if (obj.isCertified != null) {\n          writer.uint32(16);\n          writer.bool(obj.isCertified);\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var obj = {\n          multiaddr: new Uint8Array(0)\n        };\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              obj.multiaddr = reader.bytes();\n              break;\n            case 2:\n              obj.isCertified = reader.bool();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        if (obj.multiaddr == null) {\n          throw new Error('Protocol error: value for required field \"multiaddr\" was not found in protobuf');\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Address.encode = function (obj) {\n    return encodeMessage(obj, Address.codec());\n  };\n  Address.decode = function (buf) {\n    return decodeMessage(buf, Address.codec());\n  };\n})(Address || (Address = {}));\nexport var Metadata;\n(function (Metadata) {\n  var _codec;\n  Metadata.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.key != null) {\n          writer.uint32(10);\n          writer.string(obj.key);\n        } else {\n          throw new Error('Protocol error: required field \"key\" was not found in object');\n        }\n        if (obj.value != null) {\n          writer.uint32(18);\n          writer.bytes(obj.value);\n        } else {\n          throw new Error('Protocol error: required field \"value\" was not found in object');\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var obj = {\n          key: '',\n          value: new Uint8Array(0)\n        };\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.string();\n              break;\n            case 2:\n              obj.value = reader.bytes();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        if (obj.key == null) {\n          throw new Error('Protocol error: value for required field \"key\" was not found in protobuf');\n        }\n        if (obj.value == null) {\n          throw new Error('Protocol error: value for required field \"value\" was not found in protobuf');\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Metadata.encode = function (obj) {\n    return encodeMessage(obj, Metadata.codec());\n  };\n  Metadata.decode = function (buf) {\n    return decodeMessage(buf, Metadata.codec());\n  };\n})(Metadata || (Metadata = {}));","map":{"version":3,"names":["encodeMessage","decodeMessage","message","Peer","_codec","codec","obj","writer","opts","arguments","length","undefined","lengthDelimited","fork","addresses","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","uint32","Address","encode","err","e","f","Error","protocols","_iterator2","_step2","string","metadata","_iterator3","_step3","Metadata","pubKey","bytes","peerRecordEnvelope","ldelim","reader","end","len","pos","tag","push","decode","skipType","buf","multiaddr","isCertified","bool","Uint8Array","key"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/peer-store/src/pb/peer.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface Peer {\n  addresses: Address[]\n  protocols: string[]\n  metadata: Metadata[]\n  pubKey?: Uint8Array\n  peerRecordEnvelope?: Uint8Array\n}\n\nexport namespace Peer {\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            writer.uint32(10)\n            Address.codec().encode(value, writer)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"addresses\" was not found in object')\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            writer.uint32(18)\n            writer.string(value)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"protocols\" was not found in object')\n        }\n\n        if (obj.metadata != null) {\n          for (const value of obj.metadata) {\n            writer.uint32(26)\n            Metadata.codec().encode(value, writer)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"metadata\" was not found in object')\n        }\n\n        if (obj.pubKey != null) {\n          writer.uint32(34)\n          writer.bytes(obj.pubKey)\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          writer.uint32(42)\n          writer.bytes(obj.peerRecordEnvelope)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          addresses: [],\n          protocols: [],\n          metadata: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32()))\n              break\n            case 2:\n              obj.protocols.push(reader.string())\n              break\n            case 3:\n              obj.metadata.push(Metadata.codec().decode(reader, reader.uint32()))\n              break\n            case 4:\n              obj.pubKey = reader.bytes()\n              break\n            case 5:\n              obj.peerRecordEnvelope = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Peer): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n    return decodeMessage(buf, Peer.codec())\n  }\n}\n\nexport interface Address {\n  multiaddr: Uint8Array\n  isCertified?: boolean\n}\n\nexport namespace Address {\n  let _codec: Codec<Address>\n\n  export const codec = (): Codec<Address> => {\n    if (_codec == null) {\n      _codec = message<Address>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.multiaddr != null) {\n          writer.uint32(10)\n          writer.bytes(obj.multiaddr)\n        } else {\n          throw new Error('Protocol error: required field \"multiaddr\" was not found in object')\n        }\n\n        if (obj.isCertified != null) {\n          writer.uint32(16)\n          writer.bool(obj.isCertified)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          multiaddr: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.multiaddr = reader.bytes()\n              break\n            case 2:\n              obj.isCertified = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        if (obj.multiaddr == null) {\n          throw new Error('Protocol error: value for required field \"multiaddr\" was not found in protobuf')\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Address): Uint8Array => {\n    return encodeMessage(obj, Address.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Address => {\n    return decodeMessage(buf, Address.codec())\n  }\n}\n\nexport interface Metadata {\n  key: string\n  value: Uint8Array\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.key != null) {\n          writer.uint32(10)\n          writer.string(obj.key)\n        } else {\n          throw new Error('Protocol error: required field \"key\" was not found in object')\n        }\n\n        if (obj.value != null) {\n          writer.uint32(18)\n          writer.bytes(obj.value)\n        } else {\n          throw new Error('Protocol error: required field \"value\" was not found in object')\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          key: '',\n          value: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.string()\n              break\n            case 2:\n              obj.value = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        if (obj.key == null) {\n          throw new Error('Protocol error: value for required field \"key\" was not found in protobuf')\n        }\n\n        if (obj.value == null) {\n          throw new Error('Protocol error: value for required field \"value\" was not found in protobuf')\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Metadata): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}