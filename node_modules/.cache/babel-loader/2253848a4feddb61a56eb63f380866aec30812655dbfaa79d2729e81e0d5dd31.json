{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport { createTopology } from '@libp2p/topology';\nimport { BitswapMessage as Message } from './message/index.js';\nimport * as CONSTANTS from './constants.js';\nimport { logger } from './utils/index.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableSource } from 'abortable-iterator';\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n * @typedef {import('@libp2p/interface-connection').Connection} Connection\n * @typedef {import('@libp2p/interface-connection').Stream} Stream\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n *\n * @typedef {object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {import('it-stream-types').Duplex<Uint8Array>} Duplex\n */\n\nvar BITSWAP100 = '/ipfs/bitswap/1.0.0';\nvar BITSWAP110 = '/ipfs/bitswap/1.1.0';\nvar BITSWAP120 = '/ipfs/bitswap/1.2.0';\nvar DEFAULT_MAX_INBOUND_STREAMS = 32;\nvar DEFAULT_MAX_OUTBOUND_STREAMS = 128;\nvar DEFAULT_INCOMING_STREAM_TIMEOUT = 30000;\nexport var Network = /*#__PURE__*/function () {\n  /**\n   * @param {import('libp2p').Libp2p} libp2p\n   * @param {import('./bitswap').Bitswap} bitswap\n   * @param {import('./stats').Stats} stats\n   * @param {object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   */\n  function Network(libp2p, bitswap, stats) {\n    var _options$maxInboundSt, _options$maxOutboundS, _options$incomingStre;\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, Network);\n    this._log = logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110);\n      this._protocols.unshift(BITSWAP120);\n    }\n    this._stats = stats;\n    this._running = false;\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashLoader = options.hashLoader;\n    this._maxInboundStreams = (_options$maxInboundSt = options.maxInboundStreams) !== null && _options$maxInboundSt !== void 0 ? _options$maxInboundSt : DEFAULT_MAX_INBOUND_STREAMS;\n    this._maxOutboundStreams = (_options$maxOutboundS = options.maxOutboundStreams) !== null && _options$maxOutboundS !== void 0 ? _options$maxOutboundS : DEFAULT_MAX_OUTBOUND_STREAMS;\n    this._incomingStreamTimeout = (_options$incomingStre = options.incomingStreamTimeout) !== null && _options$incomingStre !== void 0 ? _options$incomingStre : DEFAULT_INCOMING_STREAM_TIMEOUT;\n  }\n  _createClass(Network, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this = this;\n        var topology, _iterator3, _step3, protocol;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this._running = true;\n              _context.next = 3;\n              return this._libp2p.handle(this._protocols, this._onConnection, {\n                maxInboundStreams: this._maxInboundStreams,\n                maxOutboundStreams: this._maxOutboundStreams\n              });\n            case 3:\n              // register protocol with topology\n              topology = createTopology({\n                onConnect: this._onPeerConnect,\n                onDisconnect: this._onPeerDisconnect\n              });\n              /** @type {string[]} */\n              this._registrarIds = [];\n              _iterator3 = _createForOfIteratorHelper(this._protocols);\n              _context.prev = 6;\n              _iterator3.s();\n            case 8:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 17;\n                break;\n              }\n              protocol = _step3.value;\n              _context.t0 = this._registrarIds;\n              _context.next = 13;\n              return this._libp2p.registrar.register(protocol, topology);\n            case 13:\n              _context.t1 = _context.sent;\n              _context.t0.push.call(_context.t0, _context.t1);\n            case 15:\n              _context.next = 8;\n              break;\n            case 17:\n              _context.next = 22;\n              break;\n            case 19:\n              _context.prev = 19;\n              _context.t2 = _context[\"catch\"](6);\n              _iterator3.e(_context.t2);\n            case 22:\n              _context.prev = 22;\n              _iterator3.f();\n              return _context.finish(22);\n            case 25:\n              // All existing connections are like new ones for us\n              this._libp2p.getConnections().forEach(function (conn) {\n                _this._onPeerConnect(conn.remotePeer);\n              });\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[6, 19, 22, 25]]);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _iterator4, _step4, id;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this._running = false;\n\n              // Unhandle both, libp2p doesn't care if it's not already handled\n              _context2.next = 3;\n              return this._libp2p.unhandle(this._protocols);\n            case 3:\n              // unregister protocol and handlers\n              if (this._registrarIds != null) {\n                _iterator4 = _createForOfIteratorHelper(this._registrarIds);\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    id = _step4.value;\n                    this._libp2p.registrar.unregister(id);\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n                this._registrarIds = [];\n              }\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Handles both types of incoming bitswap messages\n     *\n     * @private\n     * @param {object} connection\n     * @param {Stream} connection.stream - A duplex iterable stream\n     * @param {Connection} connection.connection - A libp2p Connection\n     */\n  }, {\n    key: \"_onConnection\",\n    value: function _onConnection(_ref) {\n      var _this2 = this;\n      var stream = _ref.stream,\n        connection = _ref.connection;\n      if (!this._running) {\n        return;\n      }\n      var controller = new TimeoutController(this._incomingStreamTimeout);\n      Promise.resolve().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _this2._log('incoming new bitswap %s connection from %p', stream.stat.protocol, connection.remotePeer);\n              _context4.next = 3;\n              return pipe(abortableSource(stream.source, controller.signal), lp.decode(), /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, data, message;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _iteratorAbruptCompletion = false;\n                        _didIteratorError = false;\n                        _context3.prev = 2;\n                        _iterator = _asyncIterator(source);\n                      case 4:\n                        _context3.next = 6;\n                        return _iterator.next();\n                      case 6:\n                        if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {\n                          _context3.next = 24;\n                          break;\n                        }\n                        data = _step.value;\n                        _context3.prev = 8;\n                        _context3.next = 11;\n                        return Message.deserialize(data.subarray(), _this2._hashLoader);\n                      case 11:\n                        message = _context3.sent;\n                        _context3.next = 14;\n                        return _this2._bitswap._receiveMessage(connection.remotePeer, message);\n                      case 14:\n                        _context3.next = 20;\n                        break;\n                      case 16:\n                        _context3.prev = 16;\n                        _context3.t0 = _context3[\"catch\"](8);\n                        _this2._bitswap._receiveError(_context3.t0);\n                        return _context3.abrupt(\"break\", 24);\n                      case 20:\n                        // we have received some data so reset the timeout controller\n                        controller.reset();\n                      case 21:\n                        _iteratorAbruptCompletion = false;\n                        _context3.next = 4;\n                        break;\n                      case 24:\n                        _context3.next = 30;\n                        break;\n                      case 26:\n                        _context3.prev = 26;\n                        _context3.t1 = _context3[\"catch\"](2);\n                        _didIteratorError = true;\n                        _iteratorError = _context3.t1;\n                      case 30:\n                        _context3.prev = 30;\n                        _context3.prev = 31;\n                        if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                          _context3.next = 35;\n                          break;\n                        }\n                        _context3.next = 35;\n                        return _iterator.return();\n                      case 35:\n                        _context3.prev = 35;\n                        if (!_didIteratorError) {\n                          _context3.next = 38;\n                          break;\n                        }\n                        throw _iteratorError;\n                      case 38:\n                        return _context3.finish(35);\n                      case 39:\n                        return _context3.finish(30);\n                      case 40:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3, null, [[2, 26, 30, 40], [8, 16], [31,, 35, 39]]);\n                }));\n                return function (_x) {\n                  return _ref3.apply(this, arguments);\n                };\n              }());\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }))).catch(function (err) {\n        _this2._log(err);\n        stream.abort(err);\n      }).finally(function () {\n        controller.clear();\n        stream.close();\n      });\n    }\n\n    /**\n     * @private\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerId) {\n      this._bitswap._onPeerConnected(peerId);\n    }\n\n    /**\n     * @private\n     * @param {PeerId} peerId\n     */\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerId) {\n      this._bitswap._onPeerDisconnected(peerId);\n    }\n\n    /**\n     * Find providers given a `cid`.\n     *\n     * @param {CID} cid\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @returns {AsyncIterable<Provider>}\n     */\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(cid) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this._libp2p.contentRouting.findProviders(cid, options);\n    }\n\n    /**\n     * Find the providers of a given `cid` and connect to them.\n     *\n     * @param {CID} cid\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n  }, {\n    key: \"findAndConnect\",\n    value: function () {\n      var _findAndConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cid, options) {\n        var _this3 = this;\n        var connectAttempts, found, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, provider;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              connectAttempts = [];\n              found = 0;\n              _iteratorAbruptCompletion2 = false;\n              _didIteratorError2 = false;\n              _context5.prev = 4;\n              _iterator2 = _asyncIterator(this.findProviders(cid, options));\n            case 6:\n              _context5.next = 8;\n              return _iterator2.next();\n            case 8:\n              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context5.sent).done)) {\n                _context5.next = 18;\n                break;\n              }\n              provider = _step2.value;\n              this._log(\"connecting to provider \".concat(provider.id));\n              connectAttempts.push(this.connectTo(provider.id, options).catch(function (err) {\n                // Prevent unhandled promise rejection\n                _this3._log.error(err);\n              }));\n              found++;\n              if (!(found === CONSTANTS.maxProvidersPerRequest)) {\n                _context5.next = 15;\n                break;\n              }\n              return _context5.abrupt(\"break\", 18);\n            case 15:\n              _iteratorAbruptCompletion2 = false;\n              _context5.next = 6;\n              break;\n            case 18:\n              _context5.next = 24;\n              break;\n            case 20:\n              _context5.prev = 20;\n              _context5.t0 = _context5[\"catch\"](4);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context5.t0;\n            case 24:\n              _context5.prev = 24;\n              _context5.prev = 25;\n              if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                _context5.next = 29;\n                break;\n              }\n              _context5.next = 29;\n              return _iterator2.return();\n            case 29:\n              _context5.prev = 29;\n              if (!_didIteratorError2) {\n                _context5.next = 32;\n                break;\n              }\n              throw _iteratorError2;\n            case 32:\n              return _context5.finish(29);\n            case 33:\n              return _context5.finish(24);\n            case 34:\n              _context5.next = 36;\n              return Promise.all(connectAttempts);\n            case 36:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[4, 20, 24, 34], [25,, 29, 33]]);\n      }));\n      function findAndConnect(_x2, _x3) {\n        return _findAndConnect.apply(this, arguments);\n      }\n      return findAndConnect;\n    }()\n    /**\n     * Tell the network we can provide content for the passed CID\n     *\n     * @param {CID} cid\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n  }, {\n    key: \"provide\",\n    value: function () {\n      var _provide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(cid, options) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this._libp2p.contentRouting.provide(cid, options);\n            case 2:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function provide(_x4, _x5) {\n        return _provide.apply(this, arguments);\n      }\n      return provide;\n    }()\n    /**\n     * Connect to the given peer\n     * Send the given msg (instance of Message) to the given peer\n     *\n     * @param {PeerId} peer\n     * @param {Message} msg\n     */\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(peer, msg) {\n        var stringId, connection, stream;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (this._running) {\n                _context7.next = 2;\n                break;\n              }\n              throw new Error('network isn\\'t running');\n            case 2:\n              stringId = peer.toString();\n              this._log('sendMessage to %s', stringId, msg);\n              _context7.next = 6;\n              return this._libp2p.dial(peer);\n            case 6:\n              connection = _context7.sent;\n              _context7.next = 9;\n              return connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n            case 9:\n              stream = _context7.sent;\n              _context7.next = 12;\n              return writeMessage(stream, msg, this._log);\n            case 12:\n              this._updateSentStats(peer, msg.blocks);\n            case 13:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function sendMessage(_x6, _x7) {\n        return _sendMessage.apply(this, arguments);\n      }\n      return sendMessage;\n    }()\n    /**\n     * Connects to another peer\n     *\n     * @param {PeerId|Multiaddr} peer\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<Connection>}\n     */\n  }, {\n    key: \"connectTo\",\n    value: function () {\n      var _connectTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(peer, options) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (this._running) {\n                _context8.next = 2;\n                break;\n              }\n              throw new Error('network isn\\'t running');\n            case 2:\n              return _context8.abrupt(\"return\", this._libp2p.dial(peer, options));\n            case 3:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function connectTo(_x8, _x9) {\n        return _connectTo.apply(this, arguments);\n      }\n      return connectTo;\n    }()\n    /**\n     * @private\n     * @param {PeerId} peer\n     * @param {Map<string, Uint8Array>} blocks\n     */\n  }, {\n    key: \"_updateSentStats\",\n    value: function _updateSentStats(peer, blocks) {\n      var peerId = peer.toString();\n      if (this._stats) {\n        var _iterator5 = _createForOfIteratorHelper(blocks.values()),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var block = _step5.value;\n            this._stats.push(peerId, 'dataSent', block.length);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        this._stats.push(peerId, 'blocksSent', blocks.size);\n      }\n    }\n  }]);\n  return Network;\n}();\n\n/**\n *\n * @param {Stream} stream\n * @param {Message} msg\n * @param {*} log\n */\nfunction writeMessage(_x10, _x11, _x12) {\n  return _writeMessage.apply(this, arguments);\n}\nfunction _writeMessage() {\n  _writeMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(stream, msg, log) {\n    var serialized;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          _context9.prev = 0;\n          _context9.t0 = stream.stat.protocol;\n          _context9.next = _context9.t0 === BITSWAP100 ? 4 : _context9.t0 === BITSWAP110 ? 6 : _context9.t0 === BITSWAP120 ? 6 : 8;\n          break;\n        case 4:\n          serialized = msg.serializeToBitswap100();\n          return _context9.abrupt(\"break\", 9);\n        case 6:\n          serialized = msg.serializeToBitswap110();\n          return _context9.abrupt(\"break\", 9);\n        case 8:\n          throw new Error('Unknown protocol: ' + stream.stat.protocol);\n        case 9:\n          _context9.next = 11;\n          return pipe([serialized], lp.encode(), stream);\n        case 11:\n          _context9.next = 16;\n          break;\n        case 13:\n          _context9.prev = 13;\n          _context9.t1 = _context9[\"catch\"](0);\n          log(_context9.t1);\n        case 16:\n          _context9.prev = 16;\n          stream.close();\n          return _context9.finish(16);\n        case 19:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9, null, [[0, 13, 16, 19]]);\n  }));\n  return _writeMessage.apply(this, arguments);\n}","map":{"version":3,"names":["lp","pipe","createTopology","BitswapMessage","Message","CONSTANTS","logger","TimeoutController","abortableSource","BITSWAP100","BITSWAP110","BITSWAP120","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","DEFAULT_INCOMING_STREAM_TIMEOUT","Network","libp2p","bitswap","stats","_options$maxInboundSt","_options$maxOutboundS","_options$incomingStre","options","arguments","length","undefined","_classCallCheck","_log","peerId","_libp2p","_bitswap","_protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","_hashLoader","hashLoader","_maxInboundStreams","maxInboundStreams","_maxOutboundStreams","maxOutboundStreams","_incomingStreamTimeout","incomingStreamTimeout","_createClass","key","value","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this","topology","_iterator3","_step3","protocol","wrap","_callee$","_context","prev","next","handle","onConnect","onDisconnect","_registrarIds","_createForOfIteratorHelper","s","n","done","t0","registrar","register","t1","sent","push","call","t2","e","f","finish","getConnections","forEach","conn","remotePeer","stop","start","apply","_stop","_callee2","_iterator4","_step4","id","_callee2$","_context2","unhandle","unregister","err","_ref","_this2","stream","connection","controller","Promise","resolve","then","_callee4","_callee4$","_context4","stat","source","signal","decode","_ref3","_callee3","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","data","message","_callee3$","_context3","_asyncIterator","deserialize","subarray","_receiveMessage","_receiveError","abrupt","reset","return","_x","catch","abort","finally","clear","close","_onPeerConnected","_onPeerDisconnected","findProviders","cid","contentRouting","_findAndConnect","_callee5","_this3","connectAttempts","found","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","provider","_callee5$","_context5","concat","connectTo","error","maxProvidersPerRequest","all","findAndConnect","_x2","_x3","_provide","_callee6","_callee6$","_context6","provide","_x4","_x5","_sendMessage","_callee7","peer","msg","stringId","_callee7$","_context7","Error","toString","dial","newStream","writeMessage","_updateSentStats","blocks","sendMessage","_x6","_x7","_connectTo","_callee8","_callee8$","_context8","_x8","_x9","_iterator5","values","_step5","block","size","_x10","_x11","_x12","_writeMessage","_callee9","log","serialized","_callee9$","_context9","serializeToBitswap100","serializeToBitswap110","encode"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-bitswap/src/network.js"],"sourcesContent":["import * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { createTopology } from '@libp2p/topology'\nimport { BitswapMessage as Message } from './message/index.js'\nimport * as CONSTANTS from './constants.js'\nimport { logger } from './utils/index.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { abortableSource } from 'abortable-iterator'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n * @typedef {import('@libp2p/interface-connection').Connection} Connection\n * @typedef {import('@libp2p/interface-connection').Stream} Stream\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n *\n * @typedef {object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {import('it-stream-types').Duplex<Uint8Array>} Duplex\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nconst DEFAULT_MAX_INBOUND_STREAMS = 32\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 128\nconst DEFAULT_INCOMING_STREAM_TIMEOUT = 30000\n\nexport class Network {\n  /**\n   * @param {import('libp2p').Libp2p} libp2p\n   * @param {import('./bitswap').Bitswap} bitswap\n   * @param {import('./stats').Stats} stats\n   * @param {object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   */\n  constructor (libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network')\n    this._libp2p = libp2p\n    this._bitswap = bitswap\n    this._protocols = [BITSWAP100]\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110)\n      this._protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n    this._hashLoader = options.hashLoader\n    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS\n    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT\n  }\n\n  async start () {\n    this._running = true\n    await this._libp2p.handle(this._protocols, this._onConnection, {\n      maxInboundStreams: this._maxInboundStreams,\n      maxOutboundStreams: this._maxOutboundStreams\n    })\n\n    // register protocol with topology\n    const topology = createTopology({\n      onConnect: this._onPeerConnect,\n      onDisconnect: this._onPeerDisconnect\n    })\n\n    /** @type {string[]} */\n    this._registrarIds = []\n\n    for (const protocol of this._protocols) {\n      this._registrarIds.push(await this._libp2p.registrar.register(protocol, topology))\n    }\n\n    // All existing connections are like new ones for us\n    this._libp2p.getConnections().forEach(conn => {\n      this._onPeerConnect(conn.remotePeer)\n    })\n  }\n\n  async stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    await this._libp2p.unhandle(this._protocols)\n\n    // unregister protocol and handlers\n    if (this._registrarIds != null) {\n      for (const id of this._registrarIds) {\n        this._libp2p.registrar.unregister(id)\n      }\n\n      this._registrarIds = []\n    }\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {Stream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n  _onConnection ({ stream, connection }) {\n    if (!this._running) {\n      return\n    }\n\n    const controller = new TimeoutController(this._incomingStreamTimeout)\n\n    Promise.resolve().then(async () => {\n      this._log('incoming new bitswap %s connection from %p', stream.stat.protocol, connection.remotePeer)\n\n      await pipe(\n        abortableSource(stream.source, controller.signal),\n        lp.decode(),\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.subarray(), this._hashLoader)\n              await this._bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (/** @type {any} */ err) {\n              this._bitswap._receiveError(err)\n              break\n            }\n\n            // we have received some data so reset the timeout controller\n            controller.reset()\n          }\n        }\n      )\n    })\n      .catch(err => {\n        this._log(err)\n        stream.abort(err)\n      })\n      .finally(() => {\n        controller.clear()\n        stream.close()\n      })\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerConnect (peerId) {\n    this._bitswap._onPeerConnected(peerId)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnect (peerId) {\n    this._bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n  findProviders (cid, options = {}) {\n    return this._libp2p.contentRouting.findProviders(cid, options)\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    let found = 0\n\n    for await (const provider of this.findProviders(cid, options)) {\n      this._log(`connecting to provider ${provider.id}`)\n      connectAttempts.push(\n        this.connectTo(provider.id, options)\n          .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err)\n          })\n      )\n\n      found++\n\n      if (found === CONSTANTS.maxProvidersPerRequest) {\n        break\n      }\n    }\n\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async provide (cid, options) {\n    await this._libp2p.contentRouting.provide(cid, options)\n  }\n\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toString()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const connection = await this._libp2p.dial(peer)\n    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100])\n\n    await writeMessage(stream, msg, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this._libp2p.dial(peer, options)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toString()\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length)\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\n/**\n *\n * @param {Stream} stream\n * @param {Message} msg\n * @param {*} log\n */\nasync function writeMessage (stream, msg, log) {\n  try {\n    /** @type {Uint8Array} */\n    let serialized\n    switch (stream.stat.protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + stream.stat.protocol)\n    }\n\n    await pipe(\n      [serialized],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  } finally {\n    stream.close()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}