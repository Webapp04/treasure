{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar ModuleError = require('module-error');\nvar encodings = require('./lib/encodings');\nvar _require = require('./lib/encoding'),\n  Encoding = _require.Encoding;\nvar _require2 = require('./lib/formats'),\n  BufferFormat = _require2.BufferFormat,\n  ViewFormat = _require2.ViewFormat,\n  UTF8Format = _require2.UTF8Format;\nvar kFormats = Symbol('formats');\nvar kEncodings = Symbol('encodings');\nvar validFormats = new Set(['buffer', 'view', 'utf8']);\n\n/** @template T */\nvar Transcoder = /*#__PURE__*/function () {\n  /**\n   * @param {Array<'buffer'|'view'|'utf8'>} formats\n   */\n  function Transcoder(formats) {\n    _classCallCheck(this, Transcoder);\n    if (!Array.isArray(formats)) {\n      throw new TypeError(\"The first argument 'formats' must be an array\");\n    } else if (!formats.every(function (f) {\n      return validFormats.has(f);\n    })) {\n      // Note: we only only support aliases in key- and valueEncoding options (where we already did)\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\");\n    }\n\n    /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */\n    this[kEncodings] = new Map();\n    this[kFormats] = new Set(formats);\n\n    // Register encodings (done early in order to populate encodings())\n    for (var k in encodings) {\n      try {\n        this.encoding(k);\n      } catch (err) {\n        /* istanbul ignore if: assertion */\n        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err;\n      }\n    }\n  }\n\n  /**\n   * @returns {Array<Encoding<any,T,any>>}\n   */\n  _createClass(Transcoder, [{\n    key: \"encodings\",\n    value: function encodings() {\n      return Array.from(new Set(this[kEncodings].values()));\n    }\n\n    /**\n     * @param {string|MixedEncoding<any, any, any>} encoding\n     * @returns {Encoding<any, T, any>}\n     */\n  }, {\n    key: \"encoding\",\n    value: function encoding(_encoding) {\n      var resolved = this[kEncodings].get(_encoding);\n      if (resolved === undefined) {\n        if (typeof _encoding === 'string' && _encoding !== '') {\n          resolved = lookup[_encoding];\n          if (!resolved) {\n            throw new ModuleError(\"Encoding '\".concat(_encoding, \"' is not found\"), {\n              code: 'LEVEL_ENCODING_NOT_FOUND'\n            });\n          }\n        } else if (typeof _encoding !== 'object' || _encoding === null) {\n          throw new TypeError(\"First argument 'encoding' must be a string or object\");\n        } else {\n          resolved = from(_encoding);\n        }\n        var _resolved = resolved,\n          name = _resolved.name,\n          format = _resolved.format;\n        if (!this[kFormats].has(format)) {\n          if (this[kFormats].has('view')) {\n            resolved = resolved.createViewTranscoder();\n          } else if (this[kFormats].has('buffer')) {\n            resolved = resolved.createBufferTranscoder();\n          } else if (this[kFormats].has('utf8')) {\n            resolved = resolved.createUTF8Transcoder();\n          } else {\n            throw new ModuleError(\"Encoding '\".concat(name, \"' cannot be transcoded\"), {\n              code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n            });\n          }\n        }\n        for (var _i = 0, _arr = [_encoding, name, resolved.name, resolved.commonName]; _i < _arr.length; _i++) {\n          var k = _arr[_i];\n          this[kEncodings].set(k, resolved);\n        }\n      }\n      return resolved;\n    }\n  }]);\n  return Transcoder;\n}();\nexports.Transcoder = Transcoder;\n\n/**\n * @param {MixedEncoding<any, any, any>} options\n * @returns {Encoding<any, any, any>}\n */\nfunction from(options) {\n  if (options instanceof Encoding) {\n    return options;\n  }\n\n  // Loosely typed for ecosystem compatibility\n  var maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined;\n  var name = options.name || maybeType || \"anonymous-\".concat(anonymousCount++);\n  switch (detectFormat(options)) {\n    case 'view':\n      return new ViewFormat(_objectSpread(_objectSpread({}, options), {}, {\n        name: name\n      }));\n    case 'utf8':\n      return new UTF8Format(_objectSpread(_objectSpread({}, options), {}, {\n        name: name\n      }));\n    case 'buffer':\n      return new BufferFormat(_objectSpread(_objectSpread({}, options), {}, {\n        name: name\n      }));\n    default:\n      {\n        throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\");\n      }\n  }\n}\n\n/**\n * If format is not provided, fallback to detecting `level-codec`\n * or `multiformats` encodings, else assume a format of buffer.\n * @param {MixedEncoding<any, any, any>} options\n * @returns {string}\n */\nfunction detectFormat(options) {\n  if ('format' in options && options.format !== undefined) {\n    return options.format;\n  } else if ('buffer' in options && typeof options.buffer === 'boolean') {\n    return options.buffer ? 'buffer' : 'utf8'; // level-codec\n  } else if ('code' in options && Number.isInteger(options.code)) {\n    return 'view'; // multiformats\n  } else {\n    return 'buffer';\n  }\n}\n\n/**\n * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nvar aliases = {\n  binary: encodings.buffer,\n  'utf-8': encodings.utf8\n};\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nvar lookup = _objectSpread(_objectSpread({}, encodings), aliases);\nvar anonymousCount = 0;","map":{"version":3,"names":["_objectSpread","require","default","_classCallCheck","_createClass","ModuleError","encodings","_require","Encoding","_require2","BufferFormat","ViewFormat","UTF8Format","kFormats","Symbol","kEncodings","validFormats","Set","Transcoder","formats","Array","isArray","TypeError","every","f","has","Map","k","encoding","err","code","key","value","from","values","resolved","get","undefined","lookup","concat","_resolved","name","format","createViewTranscoder","createBufferTranscoder","createUTF8Transcoder","_i","_arr","commonName","length","set","exports","options","maybeType","type","anonymousCount","detectFormat","buffer","Number","isInteger","aliases","binary","utf8"],"sources":["/Users/apple/Documents/treasure/node_modules/level-transcoder/index.js"],"sourcesContent":["'use strict'\n\nconst ModuleError = require('module-error')\nconst encodings = require('./lib/encodings')\nconst { Encoding } = require('./lib/encoding')\nconst { BufferFormat, ViewFormat, UTF8Format } = require('./lib/formats')\n\nconst kFormats = Symbol('formats')\nconst kEncodings = Symbol('encodings')\nconst validFormats = new Set(['buffer', 'view', 'utf8'])\n\n/** @template T */\nclass Transcoder {\n  /**\n   * @param {Array<'buffer'|'view'|'utf8'>} formats\n   */\n  constructor (formats) {\n    if (!Array.isArray(formats)) {\n      throw new TypeError(\"The first argument 'formats' must be an array\")\n    } else if (!formats.every(f => validFormats.has(f))) {\n      // Note: we only only support aliases in key- and valueEncoding options (where we already did)\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n\n    /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */\n    this[kEncodings] = new Map()\n    this[kFormats] = new Set(formats)\n\n    // Register encodings (done early in order to populate encodings())\n    for (const k in encodings) {\n      try {\n        this.encoding(k)\n      } catch (err) {\n        /* istanbul ignore if: assertion */\n        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err\n      }\n    }\n  }\n\n  /**\n   * @returns {Array<Encoding<any,T,any>>}\n   */\n  encodings () {\n    return Array.from(new Set(this[kEncodings].values()))\n  }\n\n  /**\n   * @param {string|MixedEncoding<any, any, any>} encoding\n   * @returns {Encoding<any, T, any>}\n   */\n  encoding (encoding) {\n    let resolved = this[kEncodings].get(encoding)\n\n    if (resolved === undefined) {\n      if (typeof encoding === 'string' && encoding !== '') {\n        resolved = lookup[encoding]\n\n        if (!resolved) {\n          throw new ModuleError(`Encoding '${encoding}' is not found`, {\n            code: 'LEVEL_ENCODING_NOT_FOUND'\n          })\n        }\n      } else if (typeof encoding !== 'object' || encoding === null) {\n        throw new TypeError(\"First argument 'encoding' must be a string or object\")\n      } else {\n        resolved = from(encoding)\n      }\n\n      const { name, format } = resolved\n\n      if (!this[kFormats].has(format)) {\n        if (this[kFormats].has('view')) {\n          resolved = resolved.createViewTranscoder()\n        } else if (this[kFormats].has('buffer')) {\n          resolved = resolved.createBufferTranscoder()\n        } else if (this[kFormats].has('utf8')) {\n          resolved = resolved.createUTF8Transcoder()\n        } else {\n          throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {\n            code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n          })\n        }\n      }\n\n      for (const k of [encoding, name, resolved.name, resolved.commonName]) {\n        this[kEncodings].set(k, resolved)\n      }\n    }\n\n    return resolved\n  }\n}\n\nexports.Transcoder = Transcoder\n\n/**\n * @param {MixedEncoding<any, any, any>} options\n * @returns {Encoding<any, any, any>}\n */\nfunction from (options) {\n  if (options instanceof Encoding) {\n    return options\n  }\n\n  // Loosely typed for ecosystem compatibility\n  const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined\n  const name = options.name || maybeType || `anonymous-${anonymousCount++}`\n\n  switch (detectFormat(options)) {\n    case 'view': return new ViewFormat({ ...options, name })\n    case 'utf8': return new UTF8Format({ ...options, name })\n    case 'buffer': return new BufferFormat({ ...options, name })\n    default: {\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n  }\n}\n\n/**\n * If format is not provided, fallback to detecting `level-codec`\n * or `multiformats` encodings, else assume a format of buffer.\n * @param {MixedEncoding<any, any, any>} options\n * @returns {string}\n */\nfunction detectFormat (options) {\n  if ('format' in options && options.format !== undefined) {\n    return options.format\n  } else if ('buffer' in options && typeof options.buffer === 'boolean') {\n    return options.buffer ? 'buffer' : 'utf8' // level-codec\n  } else if ('code' in options && Number.isInteger(options.code)) {\n    return 'view' // multiformats\n  } else {\n    return 'buffer'\n  }\n}\n\n/**\n * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst aliases = {\n  binary: encodings.buffer,\n  'utf-8': encodings.utf8\n}\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst lookup = {\n  ...encodings,\n  ...aliases\n}\n\nlet anonymousCount = 0\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}