{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { IPNS } from '../ipns/index.js';\nimport { createRouting } from '../ipns/routing/config.js';\nimport { OfflineDatastore } from '../ipns/routing/offline-datastore.js';\nimport { NotInitializedError, AlreadyInitializedError } from '../errors.js';\nimport { logger } from '@libp2p/logger';\nvar log = logger('ipfs:components:ipns');\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n *\n * @typedef {object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nexport var IPNSAPI = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  function IPNSAPI() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      pass: ''\n    };\n    _classCallCheck(this, IPNSAPI);\n    this.options = options;\n\n    /** @type {IPNS | null} */\n    this.offline = null;\n\n    /** @type {IPNS | null} */\n    this.online = null;\n  }\n  _createClass(IPNSAPI, [{\n    key: \"getIPNS\",\n    value: function getIPNS() {\n      var ipns = this.online || this.offline;\n      if (ipns) {\n        return ipns;\n      } else {\n        throw new NotInitializedError();\n      }\n    }\n  }, {\n    key: \"routing\",\n    get: function get() {\n      return this.getIPNS().routing;\n    }\n\n    /**\n     * Activates IPNS subsystem in an ofline mode. If it was started once already\n     * it will throw an exception.\n     *\n     * This is primarily used for offline ipns modifications, such as the\n     * initializeKeyspace feature.\n     *\n     * @param {object} config\n     * @param {import('ipfs-repo').IPFSRepo} config.repo\n     * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n     * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n     */\n  }, {\n    key: \"startOffline\",\n    value: function startOffline(_ref) {\n      var repo = _ref.repo,\n        peerId = _ref.peerId,\n        keychain = _ref.keychain;\n      if (this.offline != null) {\n        throw new AlreadyInitializedError();\n      }\n      log('initializing IPNS keyspace (offline)');\n      var routing = new OfflineDatastore(repo.datastore);\n      var ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n      this.offline = ipns;\n    }\n\n    /**\n     * @param {object} config\n     * @param {import('libp2p').Libp2p} config.libp2p\n     * @param {import('ipfs-repo').IPFSRepo} config.repo\n     * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n     * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n     */\n  }, {\n    key: \"startOnline\",\n    value: function () {\n      var _startOnline = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {\n        var libp2p, repo, peerId, keychain, routing, ipns;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              libp2p = _ref2.libp2p, repo = _ref2.repo, peerId = _ref2.peerId, keychain = _ref2.keychain;\n              if (!(this.online != null)) {\n                _context.next = 3;\n                break;\n              }\n              throw new AlreadyInitializedError();\n            case 3:\n              routing = createRouting({\n                libp2p: libp2p,\n                repo: repo,\n                peerId: peerId,\n                options: this.options\n              }); // @ts-expect-error routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n              ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n              _context.next = 7;\n              return ipns.republisher.start();\n            case 7:\n              this.online = ipns;\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function startOnline(_x) {\n        return _startOnline.apply(this, arguments);\n      }\n      return startOnline;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var ipns;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              ipns = this.online;\n              if (!ipns) {\n                _context2.next = 5;\n                break;\n              }\n              _context2.next = 4;\n              return ipns.republisher.stop();\n            case 4:\n              this.online = null;\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * @param {PeerId} peerId\n     * @param {Uint8Array} value\n     * @param {number} lifetime\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"publish\",\n    value: function publish(peerId, value, lifetime, options) {\n      return this.getIPNS().publish(peerId, value, lifetime, options);\n    }\n\n    /**\n     *\n     * @param {string} name\n     * @param {object} [options]\n     * @param {boolean} [options.nocache]\n     * @param {boolean} [options.recursive]\n     * @param {AbortSignal} [options.signal]\n     */\n  }, {\n    key: \"resolve\",\n    value: function resolve(name, options) {\n      return this.getIPNS().resolve(name, options);\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @param {Uint8Array} value\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"initializeKeyspace\",\n    value: function initializeKeyspace(peerId, value, options) {\n      return this.getIPNS().initializeKeyspace(peerId, value, options);\n    }\n  }]);\n  return IPNSAPI;\n}();","map":{"version":3,"names":["IPNS","createRouting","OfflineDatastore","NotInitializedError","AlreadyInitializedError","logger","log","IPNSAPI","options","arguments","length","undefined","pass","_classCallCheck","offline","online","_createClass","key","value","getIPNS","ipns","get","routing","startOffline","_ref","repo","peerId","keychain","datastore","_startOnline","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_ref2","libp2p","wrap","_callee$","_context","prev","next","republisher","start","stop","startOnline","_x","apply","_stop","_callee2","_callee2$","_context2","publish","lifetime","resolve","name","initializeKeyspace"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/ipns.js"],"sourcesContent":["import { IPNS } from '../ipns/index.js'\nimport { createRouting } from '../ipns/routing/config.js'\nimport { OfflineDatastore } from '../ipns/routing/offline-datastore.js'\nimport { NotInitializedError, AlreadyInitializedError } from '../errors.js'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipfs:components:ipns')\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n *\n * @typedef {object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nexport class IPNSAPI {\n  /**\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor (options = { pass: '' }) {\n    this.options = options\n\n    /** @type {IPNS | null} */\n    this.offline = null\n\n    /** @type {IPNS | null} */\n    this.online = null\n  }\n\n  getIPNS () {\n    const ipns = this.online || this.offline\n    if (ipns) {\n      return ipns\n    } else {\n      throw new NotInitializedError()\n    }\n  }\n\n  get routing () {\n    return this.getIPNS().routing\n  }\n\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  startOffline ({ repo, peerId, keychain }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError()\n    }\n\n    log('initializing IPNS keyspace (offline)')\n\n    const routing = new OfflineDatastore(repo.datastore)\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n\n    this.offline = ipns\n  }\n\n  /**\n   * @param {object} config\n   * @param {import('libp2p').Libp2p} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  async startOnline ({ libp2p, repo, peerId, keychain }) {\n    if (this.online != null) {\n      throw new AlreadyInitializedError()\n    }\n    const routing = createRouting({ libp2p, repo, peerId, options: this.options })\n\n    // @ts-expect-error routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n    await ipns.republisher.start()\n    this.online = ipns\n  }\n\n  async stop () {\n    const ipns = this.online\n    if (ipns) {\n      await ipns.republisher.stop()\n      this.online = null\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  publish (peerId, value, lifetime, options) {\n    return this.getIPNS().publish(peerId, value, lifetime, options)\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  resolve (name, options) {\n    return this.getIPNS().resolve(name, options)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  initializeKeyspace (peerId, value, options) {\n    return this.getIPNS().initializeKeyspace(peerId, value, options)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}