{"ast":null,"code":"import _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nexport var MIN_NONCE = 0;\n// For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\nexport var MAX_NONCE = 0xffffffff;\nvar ERR_MAX_NONCE = 'Cipherstate has reached maximum n, a new handshake must be performed';\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\nexport var Nonce = /*#__PURE__*/function () {\n  function Nonce() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MIN_NONCE;\n    _classCallCheck(this, Nonce);\n    this.n = n;\n    this.bytes = new Uint8Array(12);\n    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);\n    this.view.setUint32(4, n, true);\n  }\n  _createClass(Nonce, [{\n    key: \"increment\",\n    value: function increment() {\n      this.n++;\n      // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n      this.view.setUint32(4, this.n, true);\n    }\n  }, {\n    key: \"getBytes\",\n    value: function getBytes() {\n      return this.bytes;\n    }\n  }, {\n    key: \"getUint64\",\n    value: function getUint64() {\n      return this.n;\n    }\n  }, {\n    key: \"assertValue\",\n    value: function assertValue() {\n      if (this.n > MAX_NONCE) {\n        throw new Error(ERR_MAX_NONCE);\n      }\n    }\n  }]);\n  return Nonce;\n}();","map":{"version":3,"names":["MIN_NONCE","MAX_NONCE","ERR_MAX_NONCE","Nonce","n","arguments","length","undefined","_classCallCheck","bytes","Uint8Array","view","DataView","buffer","byteOffset","byteLength","setUint32","_createClass","key","value","increment","getBytes","getUint64","assertValue","Error"],"sources":["/Users/apple/Documents/treasure/node_modules/@chainsafe/libp2p-noise/src/nonce.ts"],"sourcesContent":["import type { bytes, uint64 } from './@types/basic'\n\nexport const MIN_NONCE = 0\n// For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\nexport const MAX_NONCE = 0xffffffff\n\nconst ERR_MAX_NONCE = 'Cipherstate has reached maximum n, a new handshake must be performed'\n\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\nexport class Nonce {\n  private n: uint64\n  private readonly bytes: bytes\n  private readonly view: DataView\n\n  constructor (n = MIN_NONCE) {\n    this.n = n\n    this.bytes = new Uint8Array(12)\n    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength)\n    this.view.setUint32(4, n, true)\n  }\n\n  increment (): void {\n    this.n++\n    // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n    this.view.setUint32(4, this.n, true)\n  }\n\n  getBytes (): bytes {\n    return this.bytes\n  }\n\n  getUint64 (): uint64 {\n    return this.n\n  }\n\n  assertValue (): void {\n    if (this.n > MAX_NONCE) {\n      throw new Error(ERR_MAX_NONCE)\n    }\n  }\n}\n"],"mappings":";;AAEA,OAAO,IAAMA,SAAS,GAAG,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMC,SAAS,GAAG,UAAU;AAEnC,IAAMC,aAAa,GAAG,sEAAsE;AAE5F;;;;AAIA,WAAaC,KAAK;EAKhB,SAAAA,MAAA,EAA0B;IAAA,IAAbC,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGL,SAAS;IAAAQ,eAAA,OAAAL,KAAA;IACxB,IAAI,CAACC,CAAC,GAAGA,CAAC;IACV,IAAI,CAACK,KAAK,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;IAC/B,IAAI,CAACC,IAAI,GAAG,IAAIC,QAAQ,CAAC,IAAI,CAACH,KAAK,CAACI,MAAM,EAAE,IAAI,CAACJ,KAAK,CAACK,UAAU,EAAE,IAAI,CAACL,KAAK,CAACM,UAAU,CAAC;IACzF,IAAI,CAACJ,IAAI,CAACK,SAAS,CAAC,CAAC,EAAEZ,CAAC,EAAE,IAAI,CAAC;EACjC;EAACa,YAAA,CAAAd,KAAA;IAAAe,GAAA;IAAAC,KAAA,EAED,SAAAC,UAAA,EAAS;MACP,IAAI,CAAChB,CAAC,EAAE;MACR;MACA,IAAI,CAACO,IAAI,CAACK,SAAS,CAAC,CAAC,EAAE,IAAI,CAACZ,CAAC,EAAE,IAAI,CAAC;IACtC;EAAC;IAAAc,GAAA;IAAAC,KAAA,EAED,SAAAE,SAAA,EAAQ;MACN,OAAO,IAAI,CAACZ,KAAK;IACnB;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAED,SAAAG,UAAA,EAAS;MACP,OAAO,IAAI,CAAClB,CAAC;IACf;EAAC;IAAAc,GAAA;IAAAC,KAAA,EAED,SAAAI,YAAA,EAAW;MACT,IAAI,IAAI,CAACnB,CAAC,GAAGH,SAAS,EAAE;QACtB,MAAM,IAAIuB,KAAK,CAACtB,aAAa,CAAC;;IAElC;EAAC;EAAA,OAAAC,KAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}