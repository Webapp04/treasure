{"ast":null,"code":"import _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { codes } from './errors.js';\nimport { isTopology } from '@libp2p/interface-registrar';\nimport merge from 'merge-options';\nvar log = logger('libp2p:registrar');\nexport var DEFAULT_MAX_INBOUND_STREAMS = 32;\nexport var DEFAULT_MAX_OUTBOUND_STREAMS = 64;\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport var DefaultRegistrar = /*#__PURE__*/function () {\n  function DefaultRegistrar(components) {\n    _classCallCheck(this, DefaultRegistrar);\n    this.topologies = new Map();\n    this.handlers = new Map();\n    this.components = components;\n    this._onDisconnect = this._onDisconnect.bind(this);\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this.components.getConnectionManager().addEventListener('peer:disconnect', this._onDisconnect);\n    // happens after identify\n    this.components.getPeerStore().addEventListener('change:protocols', this._onProtocolChange);\n  }\n  _createClass(DefaultRegistrar, [{\n    key: \"getProtocols\",\n    value: function getProtocols() {\n      return Array.from(new Set([].concat(_toConsumableArray(this.topologies.keys()), _toConsumableArray(this.handlers.keys())))).sort();\n    }\n  }, {\n    key: \"getHandler\",\n    value: function getHandler(protocol) {\n      var handler = this.handlers.get(protocol);\n      if (handler == null) {\n        throw errCode(new Error(\"No handler registered for protocol \".concat(protocol)), codes.ERR_NO_HANDLER_FOR_PROTOCOL);\n      }\n      return handler;\n    }\n  }, {\n    key: \"getTopologies\",\n    value: function getTopologies(protocol) {\n      var topologies = this.topologies.get(protocol);\n      if (topologies == null) {\n        return [];\n      }\n      return _toConsumableArray(topologies.values());\n    }\n    /**\n     * Registers the `handler` for each protocol\n     */\n  }, {\n    key: \"handle\",\n    value: function () {\n      var _handle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(protocol, handler, opts) {\n        var options;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.handlers.has(protocol)) {\n                _context.next = 2;\n                break;\n              }\n              throw errCode(new Error(\"Handler already registered for protocol \".concat(protocol)), codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);\n            case 2:\n              options = merge.bind({\n                ignoreUndefined: true\n              })({\n                maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n                maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n              }, opts);\n              this.handlers.set(protocol, {\n                handler: handler,\n                options: options\n              });\n              // Add new protocols to self protocols in the Protobook\n              _context.next = 6;\n              return this.components.getPeerStore().protoBook.add(this.components.getPeerId(), [protocol]);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function handle(_x, _x2, _x3) {\n        return _handle.apply(this, arguments);\n      }\n      return handle;\n    }()\n    /**\n     * Removes the handler for each protocol. The protocol\n     * will no longer be supported on streams.\n     */\n  }, {\n    key: \"unhandle\",\n    value: function () {\n      var _unhandle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(protocols) {\n        var _this = this;\n        var protocolList;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              protocolList = Array.isArray(protocols) ? protocols : [protocols];\n              protocolList.forEach(function (protocol) {\n                _this.handlers.delete(protocol);\n              });\n              // Remove protocols from self protocols in the Protobook\n              _context2.next = 4;\n              return this.components.getPeerStore().protoBook.remove(this.components.getPeerId(), protocolList);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function unhandle(_x4) {\n        return _unhandle.apply(this, arguments);\n      }\n      return unhandle;\n    }()\n    /**\n     * Register handlers for a set of multicodecs given\n     */\n  }, {\n    key: \"register\",\n    value: function () {\n      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(protocol, topology) {\n        var id, topologies;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (isTopology(topology)) {\n                _context3.next = 3;\n                break;\n              }\n              log.error('topology must be an instance of interfaces/topology');\n              throw errCode(new Error('topology must be an instance of interfaces/topology'), codes.ERR_INVALID_PARAMETERS);\n            case 3:\n              // Create topology\n              id = \"\".concat((Math.random() * 1e9).toString(36)).concat(Date.now());\n              topologies = this.topologies.get(protocol);\n              if (topologies == null) {\n                topologies = new Map();\n                this.topologies.set(protocol, topologies);\n              }\n              topologies.set(id, topology);\n              // Set registrar\n              _context3.next = 9;\n              return topology.setRegistrar(this);\n            case 9:\n              return _context3.abrupt(\"return\", id);\n            case 10:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function register(_x5, _x6) {\n        return _register.apply(this, arguments);\n      }\n      return register;\n    }()\n    /**\n     * Unregister topology\n     */\n  }, {\n    key: \"unregister\",\n    value: function unregister(id) {\n      var _iterator = _createForOfIteratorHelper(this.topologies.entries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            protocol = _step$value[0],\n            topologies = _step$value[1];\n          if (topologies.has(id)) {\n            topologies.delete(id);\n            if (topologies.size === 0) {\n              this.topologies.delete(protocol);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Remove a disconnected peer from the record\n     */\n  }, {\n    key: \"_onDisconnect\",\n    value: function _onDisconnect(evt) {\n      var _this2 = this;\n      var connection = evt.detail;\n      void this.components.getPeerStore().protoBook.get(connection.remotePeer).then(function (peerProtocols) {\n        var _iterator2 = _createForOfIteratorHelper(peerProtocols),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var protocol = _step2.value;\n            var topologies = _this2.topologies.get(protocol);\n            if (topologies == null) {\n              // no topologies are interested in this protocol\n              continue;\n            }\n            var _iterator3 = _createForOfIteratorHelper(topologies.values()),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var topology = _step3.value;\n                topology.onDisconnect(connection.remotePeer);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }).catch(function (err) {\n        log.error(err);\n      });\n    }\n    /**\n     * Check if a new peer support the multicodecs for this topology\n     */\n  }, {\n    key: \"_onProtocolChange\",\n    value: function _onProtocolChange(evt) {\n      var _evt$detail = evt.detail,\n        peerId = _evt$detail.peerId,\n        protocols = _evt$detail.protocols,\n        oldProtocols = _evt$detail.oldProtocols;\n      var removed = oldProtocols.filter(function (protocol) {\n        return !protocols.includes(protocol);\n      });\n      var added = protocols.filter(function (protocol) {\n        return !oldProtocols.includes(protocol);\n      });\n      var _iterator4 = _createForOfIteratorHelper(removed),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var protocol = _step4.value;\n          var topologies = this.topologies.get(protocol);\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue;\n          }\n          var _iterator6 = _createForOfIteratorHelper(topologies.values()),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var topology = _step6.value;\n              topology.onDisconnect(peerId);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var _iterator5 = _createForOfIteratorHelper(added),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _protocol = _step5.value;\n          var _topologies = this.topologies.get(_protocol);\n          if (_topologies == null) {\n            // no topologies are interested in this protocol\n            continue;\n          }\n          var _iterator7 = _createForOfIteratorHelper(_topologies.values()),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _topology = _step7.value;\n              var connection = this.components.getConnectionManager().getConnections(peerId)[0];\n              if (connection == null) {\n                continue;\n              }\n              _topology.onConnect(peerId, connection);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }]);\n  return DefaultRegistrar;\n}();","map":{"version":3,"names":["logger","errCode","codes","isTopology","merge","log","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","DefaultRegistrar","components","_classCallCheck","topologies","Map","handlers","_onDisconnect","bind","_onProtocolChange","getConnectionManager","addEventListener","getPeerStore","_createClass","key","value","getProtocols","Array","from","Set","concat","_toConsumableArray","keys","sort","getHandler","protocol","handler","get","Error","ERR_NO_HANDLER_FOR_PROTOCOL","getTopologies","values","_handle","_asyncToGenerator","_regeneratorRuntime","mark","_callee","opts","options","wrap","_callee$","_context","prev","next","has","ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED","ignoreUndefined","maxInboundStreams","maxOutboundStreams","set","protoBook","add","getPeerId","stop","handle","_x","_x2","_x3","apply","arguments","_unhandle","_callee2","protocols","_this","protocolList","_callee2$","_context2","isArray","forEach","delete","remove","unhandle","_x4","_register","_callee3","topology","id","_callee3$","_context3","error","ERR_INVALID_PARAMETERS","Math","random","toString","Date","now","setRegistrar","abrupt","register","_x5","_x6","unregister","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","size","err","e","f","evt","_this2","connection","detail","remotePeer","then","peerProtocols","_iterator2","_step2","_iterator3","_step3","onDisconnect","catch","_evt$detail","peerId","oldProtocols","removed","filter","includes","added","_iterator4","_step4","_iterator6","_step6","_iterator5","_step5","_iterator7","_step7","getConnections","onConnect"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/registrar.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { codes } from './errors.js'\nimport { isTopology, StreamHandlerOptions, StreamHandlerRecord } from '@libp2p/interface-registrar'\nimport merge from 'merge-options'\nimport type { Registrar, StreamHandler, Topology } from '@libp2p/interface-registrar'\nimport type { PeerProtocolsChangeData } from '@libp2p/interface-peer-store'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { Components } from '@libp2p/components'\n\nconst log = logger('libp2p:registrar')\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class DefaultRegistrar implements Registrar {\n  private readonly topologies: Map<string, Map<string, Topology>>\n  private readonly handlers: Map<string, StreamHandlerRecord>\n  private readonly components: Components\n\n  constructor (components: Components) {\n    this.topologies = new Map()\n    this.handlers = new Map()\n    this.components = components\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n\n    this.components.getConnectionManager().addEventListener('peer:disconnect', this._onDisconnect)\n\n    // happens after identify\n    this.components.getPeerStore().addEventListener('change:protocols', this._onProtocolChange)\n  }\n\n  getProtocols () {\n    return Array.from(new Set<string>([\n      ...this.topologies.keys(),\n      ...this.handlers.keys()\n    ])).sort()\n  }\n\n  getHandler (protocol: string) {\n    const handler = this.handlers.get(protocol)\n\n    if (handler == null) {\n      throw errCode(new Error(`No handler registered for protocol ${protocol}`), codes.ERR_NO_HANDLER_FOR_PROTOCOL)\n    }\n\n    return handler\n  }\n\n  getTopologies (protocol: string) {\n    const topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      return []\n    }\n\n    return [\n      ...topologies.values()\n    ]\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  async handle (protocol: string, handler: StreamHandler, opts?: StreamHandlerOptions): Promise<void> {\n    if (this.handlers.has(protocol)) {\n      throw errCode(new Error(`Handler already registered for protocol ${protocol}`), codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED)\n    }\n\n    const options = merge.bind({ ignoreUndefined: true })({\n      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n    }, opts)\n\n    this.handlers.set(protocol, {\n      handler,\n      options\n    })\n\n    // Add new protocols to self protocols in the Protobook\n    await this.components.getPeerStore().protoBook.add(this.components.getPeerId(), [protocol])\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  async unhandle (protocols: string | string[]) {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols]\n\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol)\n    })\n\n    // Remove protocols from self protocols in the Protobook\n    await this.components.getPeerStore().protoBook.remove(this.components.getPeerId(), protocolList)\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n  async register (protocol: string, topology: Topology): Promise<string> {\n    if (!isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology')\n      throw errCode(new Error('topology must be an instance of interfaces/topology'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    // Create topology\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n\n    let topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      topologies = new Map<string, Topology>()\n      this.topologies.set(protocol, topologies)\n    }\n\n    topologies.set(id, topology)\n\n    // Set registrar\n    await topology.setRegistrar(this)\n\n    return id\n  }\n\n  /**\n   * Unregister topology\n   */\n  unregister (id: string) {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id)\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol)\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   */\n  _onDisconnect (evt: CustomEvent<Connection>) {\n    const connection = evt.detail\n\n    void this.components.getPeerStore().protoBook.get(connection.remotePeer)\n      .then(peerProtocols => {\n        for (const protocol of peerProtocols) {\n          const topologies = this.topologies.get(protocol)\n\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue\n          }\n\n          for (const topology of topologies.values()) {\n            topology.onDisconnect(connection.remotePeer)\n          }\n        }\n      })\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  /**\n   * Check if a new peer support the multicodecs for this topology\n   */\n  _onProtocolChange (evt: CustomEvent<PeerProtocolsChangeData>) {\n    const { peerId, protocols, oldProtocols } = evt.detail\n\n    const removed = oldProtocols.filter(protocol => !protocols.includes(protocol))\n    const added = protocols.filter(protocol => !oldProtocols.includes(protocol))\n\n    for (const protocol of removed) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        topology.onDisconnect(peerId)\n      }\n    }\n\n    for (const protocol of added) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        const connection = this.components.getConnectionManager().getConnections(peerId)[0]\n\n        if (connection == null) {\n          continue\n        }\n\n        topology.onConnect(peerId, connection)\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;AAAA,SAASA,MAAM,QAAQ,gBAAgB;AACvC,OAAOC,OAAO,MAAM,UAAU;AAC9B,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,UAAU,QAAmD,6BAA6B;AACnG,OAAOC,KAAK,MAAM,eAAe;AAMjC,IAAMC,GAAG,GAAGL,MAAM,CAAC,kBAAkB,CAAC;AAEtC,OAAO,IAAMM,2BAA2B,GAAG,EAAE;AAC7C,OAAO,IAAMC,4BAA4B,GAAG,EAAE;AAE9C;;;AAGA,WAAaC,gBAAgB;EAK3B,SAAAA,iBAAaC,UAAsB;IAAAC,eAAA,OAAAF,gBAAA;IACjC,IAAI,CAACG,UAAU,GAAG,IAAIC,GAAG,EAAE;IAC3B,IAAI,CAACC,QAAQ,GAAG,IAAID,GAAG,EAAE;IACzB,IAAI,CAACH,UAAU,GAAGA,UAAU;IAE5B,IAAI,CAACK,aAAa,GAAG,IAAI,CAACA,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC;IAClD,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACD,IAAI,CAAC,IAAI,CAAC;IAE1D,IAAI,CAACN,UAAU,CAACQ,oBAAoB,EAAE,CAACC,gBAAgB,CAAC,iBAAiB,EAAE,IAAI,CAACJ,aAAa,CAAC;IAE9F;IACA,IAAI,CAACL,UAAU,CAACU,YAAY,EAAE,CAACD,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAACF,iBAAiB,CAAC;EAC7F;EAACI,YAAA,CAAAZ,gBAAA;IAAAa,GAAA;IAAAC,KAAA,EAED,SAAAC,aAAA,EAAY;MACV,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAIC,GAAG,IAAAC,MAAA,CAAAC,kBAAA,CACpB,IAAI,CAACjB,UAAU,CAACkB,IAAI,EAAE,GAAAD,kBAAA,CACtB,IAAI,CAACf,QAAQ,CAACgB,IAAI,EAAE,EACxB,CAAC,CAAC,CAACC,IAAI,EAAE;IACZ;EAAC;IAAAT,GAAA;IAAAC,KAAA,EAED,SAAAS,WAAYC,QAAgB;MAC1B,IAAMC,OAAO,GAAG,IAAI,CAACpB,QAAQ,CAACqB,GAAG,CAACF,QAAQ,CAAC;MAE3C,IAAIC,OAAO,IAAI,IAAI,EAAE;QACnB,MAAMhC,OAAO,CAAC,IAAIkC,KAAK,uCAAAR,MAAA,CAAuCK,QAAQ,CAAE,CAAC,EAAE9B,KAAK,CAACkC,2BAA2B,CAAC;;MAG/G,OAAOH,OAAO;IAChB;EAAC;IAAAZ,GAAA;IAAAC,KAAA,EAED,SAAAe,cAAeL,QAAgB;MAC7B,IAAMrB,UAAU,GAAG,IAAI,CAACA,UAAU,CAACuB,GAAG,CAACF,QAAQ,CAAC;MAEhD,IAAIrB,UAAU,IAAI,IAAI,EAAE;QACtB,OAAO,EAAE;;MAGX,OAAAiB,kBAAA,CACKjB,UAAU,CAAC2B,MAAM,EAAE;IAE1B;IAEA;;;EAAA;IAAAjB,GAAA;IAAAC,KAAA;MAAA,IAAAiB,OAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGA,SAAAC,QAAcX,QAAgB,EAAEC,OAAsB,EAAEW,IAA2B;QAAA,IAAAC,OAAA;QAAA,OAAAJ,mBAAA,GAAAK,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAA,KAC7E,IAAI,CAACrC,QAAQ,CAACsC,GAAG,CAACnB,QAAQ,CAAC;gBAAAgB,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAAA,MACvBjD,OAAO,CAAC,IAAIkC,KAAK,4CAAAR,MAAA,CAA4CK,QAAQ,CAAE,CAAC,EAAE9B,KAAK,CAACkD,uCAAuC,CAAC;YAAA;cAG1HP,OAAO,GAAGzC,KAAK,CAACW,IAAI,CAAC;gBAAEsC,eAAe,EAAE;cAAI,CAAE,CAAC,CAAC;gBACpDC,iBAAiB,EAAEhD,2BAA2B;gBAC9CiD,kBAAkB,EAAEhD;eACrB,EAAEqC,IAAI,CAAC;cAER,IAAI,CAAC/B,QAAQ,CAAC2C,GAAG,CAACxB,QAAQ,EAAE;gBAC1BC,OAAO,EAAPA,OAAO;gBACPY,OAAO,EAAPA;eACD,CAAC;cAEF;cAAAG,QAAA,CAAAE,IAAA;cAAA,OACM,IAAI,CAACzC,UAAU,CAACU,YAAY,EAAE,CAACsC,SAAS,CAACC,GAAG,CAAC,IAAI,CAACjD,UAAU,CAACkD,SAAS,EAAE,EAAE,CAAC3B,QAAQ,CAAC,CAAC;YAAA;YAAA;cAAA,OAAAgB,QAAA,CAAAY,IAAA;UAAA;QAAA,GAAAjB,OAAA;MAAA,CAC5F;MAAA,SAAAkB,OAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;QAAA,OAAAzB,OAAA,CAAA0B,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAL,MAAA;IAAA;IAED;;;;EAAA;IAAAxC,GAAA;IAAAC,KAAA;MAAA,IAAA6C,SAAA,GAAA3B,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAIA,SAAA0B,SAAgBC,SAA4B;QAAA,IAAAC,KAAA;QAAA,IAAAC,YAAA;QAAA,OAAA9B,mBAAA,GAAAK,IAAA,UAAA0B,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAxB,IAAA,GAAAwB,SAAA,CAAAvB,IAAA;YAAA;cACpCqB,YAAY,GAAG/C,KAAK,CAACkD,OAAO,CAACL,SAAS,CAAC,GAAGA,SAAS,GAAG,CAACA,SAAS,CAAC;cAEvEE,YAAY,CAACI,OAAO,CAAC,UAAA3C,QAAQ,EAAG;gBAC9BsC,KAAI,CAACzD,QAAQ,CAAC+D,MAAM,CAAC5C,QAAQ,CAAC;cAChC,CAAC,CAAC;cAEF;cAAAyC,SAAA,CAAAvB,IAAA;cAAA,OACM,IAAI,CAACzC,UAAU,CAACU,YAAY,EAAE,CAACsC,SAAS,CAACoB,MAAM,CAAC,IAAI,CAACpE,UAAU,CAACkD,SAAS,EAAE,EAAEY,YAAY,CAAC;YAAA;YAAA;cAAA,OAAAE,SAAA,CAAAb,IAAA;UAAA;QAAA,GAAAQ,QAAA;MAAA,CACjG;MAAA,SAAAU,SAAAC,GAAA;QAAA,OAAAZ,SAAA,CAAAF,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAY,QAAA;IAAA;IAED;;;EAAA;IAAAzD,GAAA;IAAAC,KAAA;MAAA,IAAA0D,SAAA,GAAAxC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGA,SAAAuC,SAAgBjD,QAAgB,EAAEkD,QAAkB;QAAA,IAAAC,EAAA,EAAAxE,UAAA;QAAA,OAAA8B,mBAAA,GAAAK,IAAA,UAAAsC,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAApC,IAAA,GAAAoC,SAAA,CAAAnC,IAAA;YAAA;cAAA,IAC7C/C,UAAU,CAAC+E,QAAQ,CAAC;gBAAAG,SAAA,CAAAnC,IAAA;gBAAA;cAAA;cACvB7C,GAAG,CAACiF,KAAK,CAAC,qDAAqD,CAAC;cAAA,MAC1DrF,OAAO,CAAC,IAAIkC,KAAK,CAAC,qDAAqD,CAAC,EAAEjC,KAAK,CAACqF,sBAAsB,CAAC;YAAA;cAG/G;cACMJ,EAAE,MAAAxD,MAAA,CAAM,CAAC6D,IAAI,CAACC,MAAM,EAAE,GAAG,GAAG,EAAEC,QAAQ,CAAC,EAAE,CAAC,EAAA/D,MAAA,CAAGgE,IAAI,CAACC,GAAG,EAAE;cAEzDjF,UAAU,GAAG,IAAI,CAACA,UAAU,CAACuB,GAAG,CAACF,QAAQ,CAAC;cAE9C,IAAIrB,UAAU,IAAI,IAAI,EAAE;gBACtBA,UAAU,GAAG,IAAIC,GAAG,EAAoB;gBACxC,IAAI,CAACD,UAAU,CAAC6C,GAAG,CAACxB,QAAQ,EAAErB,UAAU,CAAC;;cAG3CA,UAAU,CAAC6C,GAAG,CAAC2B,EAAE,EAAED,QAAQ,CAAC;cAE5B;cAAAG,SAAA,CAAAnC,IAAA;cAAA,OACMgC,QAAQ,CAACW,YAAY,CAAC,IAAI,CAAC;YAAA;cAAA,OAAAR,SAAA,CAAAS,MAAA,WAE1BX,EAAE;YAAA;YAAA;cAAA,OAAAE,SAAA,CAAAzB,IAAA;UAAA;QAAA,GAAAqB,QAAA;MAAA,CACV;MAAA,SAAAc,SAAAC,GAAA,EAAAC,GAAA;QAAA,OAAAjB,SAAA,CAAAf,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAA6B,QAAA;IAAA;IAED;;;EAAA;IAAA1E,GAAA;IAAAC,KAAA,EAGA,SAAA4E,WAAYf,EAAU;MAAA,IAAAgB,SAAA,GAAAC,0BAAA,CACiB,IAAI,CAACzF,UAAU,CAAC0F,OAAO,EAAE;QAAAC,KAAA;MAAA;QAA9D,KAAAH,SAAA,CAAAI,CAAA,MAAAD,KAAA,GAAAH,SAAA,CAAAK,CAAA,IAAAC,IAAA,GAAgE;UAAA,IAAAC,WAAA,GAAAC,cAAA,CAAAL,KAAA,CAAAhF,KAAA;YAApDU,QAAQ,GAAA0E,WAAA;YAAE/F,UAAU,GAAA+F,WAAA;UAC9B,IAAI/F,UAAU,CAACwC,GAAG,CAACgC,EAAE,CAAC,EAAE;YACtBxE,UAAU,CAACiE,MAAM,CAACO,EAAE,CAAC;YAErB,IAAIxE,UAAU,CAACiG,IAAI,KAAK,CAAC,EAAE;cACzB,IAAI,CAACjG,UAAU,CAACiE,MAAM,CAAC5C,QAAQ,CAAC;;;;MAGrC,SAAA6E,GAAA;QAAAV,SAAA,CAAAW,CAAA,CAAAD,GAAA;MAAA;QAAAV,SAAA,CAAAY,CAAA;MAAA;IACH;IAEA;;;EAAA;IAAA1F,GAAA;IAAAC,KAAA,EAGA,SAAAR,cAAekG,GAA4B;MAAA,IAAAC,MAAA;MACzC,IAAMC,UAAU,GAAGF,GAAG,CAACG,MAAM;MAE7B,KAAK,IAAI,CAAC1G,UAAU,CAACU,YAAY,EAAE,CAACsC,SAAS,CAACvB,GAAG,CAACgF,UAAU,CAACE,UAAU,CAAC,CACrEC,IAAI,CAAC,UAAAC,aAAa,EAAG;QAAA,IAAAC,UAAA,GAAAnB,0BAAA,CACGkB,aAAa;UAAAE,MAAA;QAAA;UAApC,KAAAD,UAAA,CAAAhB,CAAA,MAAAiB,MAAA,GAAAD,UAAA,CAAAf,CAAA,IAAAC,IAAA,GAAsC;YAAA,IAA3BzE,QAAQ,GAAAwF,MAAA,CAAAlG,KAAA;YACjB,IAAMX,UAAU,GAAGsG,MAAI,CAACtG,UAAU,CAACuB,GAAG,CAACF,QAAQ,CAAC;YAEhD,IAAIrB,UAAU,IAAI,IAAI,EAAE;cACtB;cACA;;YACD,IAAA8G,UAAA,GAAArB,0BAAA,CAEsBzF,UAAU,CAAC2B,MAAM,EAAE;cAAAoF,MAAA;YAAA;cAA1C,KAAAD,UAAA,CAAAlB,CAAA,MAAAmB,MAAA,GAAAD,UAAA,CAAAjB,CAAA,IAAAC,IAAA,GAA4C;gBAAA,IAAjCvB,QAAQ,GAAAwC,MAAA,CAAApG,KAAA;gBACjB4D,QAAQ,CAACyC,YAAY,CAACT,UAAU,CAACE,UAAU,CAAC;;YAC7C,SAAAP,GAAA;cAAAY,UAAA,CAAAX,CAAA,CAAAD,GAAA;YAAA;cAAAY,UAAA,CAAAV,CAAA;YAAA;;QACF,SAAAF,GAAA;UAAAU,UAAA,CAAAT,CAAA,CAAAD,GAAA;QAAA;UAAAU,UAAA,CAAAR,CAAA;QAAA;MACH,CAAC,CAAC,CACDa,KAAK,CAAC,UAAAf,GAAG,EAAG;QACXxG,GAAG,CAACiF,KAAK,CAACuB,GAAG,CAAC;MAChB,CAAC,CAAC;IACN;IAEA;;;EAAA;IAAAxF,GAAA;IAAAC,KAAA,EAGA,SAAAN,kBAAmBgG,GAAyC;MAC1D,IAAAa,WAAA,GAA4Cb,GAAG,CAACG,MAAM;QAA9CW,MAAM,GAAAD,WAAA,CAANC,MAAM;QAAEzD,SAAS,GAAAwD,WAAA,CAATxD,SAAS;QAAE0D,YAAY,GAAAF,WAAA,CAAZE,YAAY;MAEvC,IAAMC,OAAO,GAAGD,YAAY,CAACE,MAAM,CAAC,UAAAjG,QAAQ;QAAA,OAAI,CAACqC,SAAS,CAAC6D,QAAQ,CAAClG,QAAQ,CAAC;MAAA,EAAC;MAC9E,IAAMmG,KAAK,GAAG9D,SAAS,CAAC4D,MAAM,CAAC,UAAAjG,QAAQ;QAAA,OAAI,CAAC+F,YAAY,CAACG,QAAQ,CAAClG,QAAQ,CAAC;MAAA,EAAC;MAAA,IAAAoG,UAAA,GAAAhC,0BAAA,CAErD4B,OAAO;QAAAK,MAAA;MAAA;QAA9B,KAAAD,UAAA,CAAA7B,CAAA,MAAA8B,MAAA,GAAAD,UAAA,CAAA5B,CAAA,IAAAC,IAAA,GAAgC;UAAA,IAArBzE,QAAQ,GAAAqG,MAAA,CAAA/G,KAAA;UACjB,IAAMX,UAAU,GAAG,IAAI,CAACA,UAAU,CAACuB,GAAG,CAACF,QAAQ,CAAC;UAEhD,IAAIrB,UAAU,IAAI,IAAI,EAAE;YACtB;YACA;;UACD,IAAA2H,UAAA,GAAAlC,0BAAA,CAEsBzF,UAAU,CAAC2B,MAAM,EAAE;YAAAiG,MAAA;UAAA;YAA1C,KAAAD,UAAA,CAAA/B,CAAA,MAAAgC,MAAA,GAAAD,UAAA,CAAA9B,CAAA,IAAAC,IAAA,GAA4C;cAAA,IAAjCvB,QAAQ,GAAAqD,MAAA,CAAAjH,KAAA;cACjB4D,QAAQ,CAACyC,YAAY,CAACG,MAAM,CAAC;;UAC9B,SAAAjB,GAAA;YAAAyB,UAAA,CAAAxB,CAAA,CAAAD,GAAA;UAAA;YAAAyB,UAAA,CAAAvB,CAAA;UAAA;;MACF,SAAAF,GAAA;QAAAuB,UAAA,CAAAtB,CAAA,CAAAD,GAAA;MAAA;QAAAuB,UAAA,CAAArB,CAAA;MAAA;MAAA,IAAAyB,UAAA,GAAApC,0BAAA,CAEsB+B,KAAK;QAAAM,MAAA;MAAA;QAA5B,KAAAD,UAAA,CAAAjC,CAAA,MAAAkC,MAAA,GAAAD,UAAA,CAAAhC,CAAA,IAAAC,IAAA,GAA8B;UAAA,IAAnBzE,SAAQ,GAAAyG,MAAA,CAAAnH,KAAA;UACjB,IAAMX,WAAU,GAAG,IAAI,CAACA,UAAU,CAACuB,GAAG,CAACF,SAAQ,CAAC;UAEhD,IAAIrB,WAAU,IAAI,IAAI,EAAE;YACtB;YACA;;UACD,IAAA+H,UAAA,GAAAtC,0BAAA,CAEsBzF,WAAU,CAAC2B,MAAM,EAAE;YAAAqG,MAAA;UAAA;YAA1C,KAAAD,UAAA,CAAAnC,CAAA,MAAAoC,MAAA,GAAAD,UAAA,CAAAlC,CAAA,IAAAC,IAAA,GAA4C;cAAA,IAAjCvB,SAAQ,GAAAyD,MAAA,CAAArH,KAAA;cACjB,IAAM4F,UAAU,GAAG,IAAI,CAACzG,UAAU,CAACQ,oBAAoB,EAAE,CAAC2H,cAAc,CAACd,MAAM,CAAC,CAAC,CAAC,CAAC;cAEnF,IAAIZ,UAAU,IAAI,IAAI,EAAE;gBACtB;;cAGFhC,SAAQ,CAAC2D,SAAS,CAACf,MAAM,EAAEZ,UAAU,CAAC;;UACvC,SAAAL,GAAA;YAAA6B,UAAA,CAAA5B,CAAA,CAAAD,GAAA;UAAA;YAAA6B,UAAA,CAAA3B,CAAA;UAAA;;MACF,SAAAF,GAAA;QAAA2B,UAAA,CAAA1B,CAAA,CAAAD,GAAA;MAAA;QAAA2B,UAAA,CAAAzB,CAAA;MAAA;IACH;EAAC;EAAA,OAAAvG,gBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}