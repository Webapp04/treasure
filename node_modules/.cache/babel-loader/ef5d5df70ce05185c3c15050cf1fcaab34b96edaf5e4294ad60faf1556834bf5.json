{"ast":null,"code":"import _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { Message as PBMessage } from './dht.js';\nexport var MESSAGE_TYPE = PBMessage.MessageType;\nexport var CONNECTION_TYPE = PBMessage.ConnectionType;\nexport var MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);\n/**\n * Represents a single DHT control message.\n */\nexport var Message = /*#__PURE__*/function () {\n  function Message(type, key, level) {\n    _classCallCheck(this, Message);\n    if (!(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array');\n    }\n    this.type = type;\n    this.key = key;\n    this.clusterLevelRaw = level;\n    this.closerPeers = [];\n    this.providerPeers = [];\n    this.record = undefined;\n  }\n  /**\n   * @type {number}\n   */\n  _createClass(Message, [{\n    key: \"clusterLevel\",\n    get: function get() {\n      var level = this.clusterLevelRaw - 1;\n      if (level < 0) {\n        return 0;\n      }\n      return level;\n    },\n    set: function set(level) {\n      this.clusterLevelRaw = level;\n    }\n    /**\n     * Encode into protobuf\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return PBMessage.encode({\n        key: this.key,\n        type: this.type,\n        clusterLevelRaw: this.clusterLevelRaw,\n        closerPeers: this.closerPeers.map(toPbPeer),\n        providerPeers: this.providerPeers.map(toPbPeer),\n        record: this.record == null ? undefined : this.record.serialize().subarray()\n      });\n    }\n    /**\n     * Decode from protobuf\n     */\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(raw) {\n      var _dec$type, _dec$key, _dec$clusterLevelRaw, _dec$record;\n      var dec = PBMessage.decode(raw);\n      var msg = new Message((_dec$type = dec.type) !== null && _dec$type !== void 0 ? _dec$type : PBMessage.MessageType.PUT_VALUE, (_dec$key = dec.key) !== null && _dec$key !== void 0 ? _dec$key : Uint8Array.from([]), (_dec$clusterLevelRaw = dec.clusterLevelRaw) !== null && _dec$clusterLevelRaw !== void 0 ? _dec$clusterLevelRaw : 0);\n      msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n      msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n      if (((_dec$record = dec.record) === null || _dec$record === void 0 ? void 0 : _dec$record.length) != null) {\n        msg.record = Libp2pRecord.deserialize(dec.record);\n      }\n      return msg;\n    }\n  }]);\n  return Message;\n}();\nfunction toPbPeer(peer) {\n  var _peer$multiaddrs;\n  var output = {\n    id: peer.id.toBytes(),\n    addrs: ((_peer$multiaddrs = peer.multiaddrs) !== null && _peer$multiaddrs !== void 0 ? _peer$multiaddrs : []).map(function (m) {\n      return m.bytes;\n    }),\n    connection: CONNECTION_TYPE.CONNECTED\n  };\n  return output;\n}\nfunction fromPbPeer(peer) {\n  var _peer$addrs;\n  if (peer.id == null) {\n    throw new Error('Invalid peer in message');\n  }\n  return {\n    id: peerIdFromBytes(peer.id),\n    multiaddrs: ((_peer$addrs = peer.addrs) !== null && _peer$addrs !== void 0 ? _peer$addrs : []).map(function (a) {\n      return multiaddr(a);\n    }),\n    protocols: []\n  };\n}","map":{"version":3,"names":["peerIdFromBytes","multiaddr","Libp2pRecord","Message","PBMessage","MESSAGE_TYPE","MessageType","CONNECTION_TYPE","ConnectionType","MESSAGE_TYPE_LOOKUP","Object","keys","type","key","level","_classCallCheck","Uint8Array","Error","clusterLevelRaw","closerPeers","providerPeers","record","undefined","_createClass","get","set","value","serialize","encode","map","toPbPeer","subarray","deserialize","raw","_dec$type","_dec$key","_dec$clusterLevelRaw","_dec$record","dec","decode","msg","PUT_VALUE","from","fromPbPeer","length","peer","_peer$multiaddrs","output","id","toBytes","addrs","multiaddrs","m","bytes","connection","CONNECTED","_peer$addrs","a","protocols"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/kad-dht/src/message/index.ts"],"sourcesContent":["import { peerIdFromBytes } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Libp2pRecord } from '@libp2p/record'\nimport { Message as PBMessage } from './dht.js'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport const MESSAGE_TYPE = PBMessage.MessageType\nexport const CONNECTION_TYPE = PBMessage.ConnectionType\nexport const MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE)\n\ninterface PBPeer {\n  id: Uint8Array\n  addrs: Uint8Array[]\n  connection: PBMessage.ConnectionType\n}\n\n/**\n * Represents a single DHT control message.\n */\nexport class Message {\n  public type: PBMessage.MessageType\n  public key: Uint8Array\n  private clusterLevelRaw: number\n  public closerPeers: PeerInfo[]\n  public providerPeers: PeerInfo[]\n  public record?: Libp2pRecord\n\n  constructor (type: PBMessage.MessageType, key: Uint8Array, level: number) {\n    if (!(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array')\n    }\n\n    this.type = type\n    this.key = key\n    this.clusterLevelRaw = level\n    this.closerPeers = []\n    this.providerPeers = []\n    this.record = undefined\n  }\n\n  /**\n   * @type {number}\n   */\n  get clusterLevel () {\n    const level = this.clusterLevelRaw - 1\n    if (level < 0) {\n      return 0\n    }\n\n    return level\n  }\n\n  set clusterLevel (level) {\n    this.clusterLevelRaw = level\n  }\n\n  /**\n   * Encode into protobuf\n   */\n  serialize () {\n    return PBMessage.encode({\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this.clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer),\n      record: this.record == null ? undefined : this.record.serialize().subarray()\n    })\n  }\n\n  /**\n   * Decode from protobuf\n   */\n  static deserialize (raw: Uint8ArrayList | Uint8Array) {\n    const dec = PBMessage.decode(raw)\n\n    const msg = new Message(dec.type ?? PBMessage.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0)\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer)\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer)\n\n    if (dec.record?.length != null) {\n      msg.record = Libp2pRecord.deserialize(dec.record)\n    }\n\n    return msg\n  }\n}\n\nfunction toPbPeer (peer: PeerInfo) {\n  const output: PBPeer = {\n    id: peer.id.toBytes(),\n    addrs: (peer.multiaddrs ?? []).map((m) => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  }\n\n  return output\n}\n\nfunction fromPbPeer (peer: PBMessage.Peer) {\n  if (peer.id == null) {\n    throw new Error('Invalid peer in message')\n  }\n\n  return {\n    id: peerIdFromBytes(peer.id),\n    multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),\n    protocols: []\n  }\n}\n"],"mappings":";;AAAA,SAASA,eAAe,QAAQ,iBAAiB;AACjD,SAASC,SAAS,QAAQ,yBAAyB;AACnD,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,OAAO,IAAIC,SAAS,QAAQ,UAAU;AAI/C,OAAO,IAAMC,YAAY,GAAGD,SAAS,CAACE,WAAW;AACjD,OAAO,IAAMC,eAAe,GAAGH,SAAS,CAACI,cAAc;AACvD,OAAO,IAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAI,CAACN,YAAY,CAAC;AAQ5D;;;AAGA,WAAaF,OAAO;EAQlB,SAAAA,QAAaS,IAA2B,EAAEC,GAAe,EAAEC,KAAa;IAAAC,eAAA,OAAAZ,OAAA;IACtE,IAAI,EAAEU,GAAG,YAAYG,UAAU,CAAC,EAAE;MAChC,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;;IAG7C,IAAI,CAACL,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACK,eAAe,GAAGJ,KAAK;IAC5B,IAAI,CAACK,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,MAAM,GAAGC,SAAS;EACzB;EAEA;;;EAAAC,YAAA,CAAApB,OAAA;IAAAU,GAAA;IAAAW,GAAA,EAGA,SAAAA,IAAA,EAAgB;MACd,IAAMV,KAAK,GAAG,IAAI,CAACI,eAAe,GAAG,CAAC;MACtC,IAAIJ,KAAK,GAAG,CAAC,EAAE;QACb,OAAO,CAAC;;MAGV,OAAOA,KAAK;IACd,CAAC;IAAAW,GAAA,EAED,SAAAA,IAAkBX,KAAK;MACrB,IAAI,CAACI,eAAe,GAAGJ,KAAK;IAC9B;IAEA;;;EAAA;IAAAD,GAAA;IAAAa,KAAA,EAGA,SAAAC,UAAA,EAAS;MACP,OAAOvB,SAAS,CAACwB,MAAM,CAAC;QACtBf,GAAG,EAAE,IAAI,CAACA,GAAG;QACbD,IAAI,EAAE,IAAI,CAACA,IAAI;QACfM,eAAe,EAAE,IAAI,CAACA,eAAe;QACrCC,WAAW,EAAE,IAAI,CAACA,WAAW,CAACU,GAAG,CAACC,QAAQ,CAAC;QAC3CV,aAAa,EAAE,IAAI,CAACA,aAAa,CAACS,GAAG,CAACC,QAAQ,CAAC;QAC/CT,MAAM,EAAE,IAAI,CAACA,MAAM,IAAI,IAAI,GAAGC,SAAS,GAAG,IAAI,CAACD,MAAM,CAACM,SAAS,EAAE,CAACI,QAAQ;OAC3E,CAAC;IACJ;IAEA;;;EAAA;IAAAlB,GAAA;IAAAa,KAAA,EAGA,SAAAM,YAAoBC,GAAgC;MAAA,IAAAC,SAAA,EAAAC,QAAA,EAAAC,oBAAA,EAAAC,WAAA;MAClD,IAAMC,GAAG,GAAGlC,SAAS,CAACmC,MAAM,CAACN,GAAG,CAAC;MAEjC,IAAMO,GAAG,GAAG,IAAIrC,OAAO,EAAA+B,SAAA,GAACI,GAAG,CAAC1B,IAAI,cAAAsB,SAAA,cAAAA,SAAA,GAAI9B,SAAS,CAACE,WAAW,CAACmC,SAAS,GAAAN,QAAA,GAAEG,GAAG,CAACzB,GAAG,cAAAsB,QAAA,cAAAA,QAAA,GAAInB,UAAU,CAAC0B,IAAI,CAAC,EAAE,CAAC,GAAAN,oBAAA,GAAEE,GAAG,CAACpB,eAAe,cAAAkB,oBAAA,cAAAA,oBAAA,GAAI,CAAC,CAAC;MAC9HI,GAAG,CAACrB,WAAW,GAAGmB,GAAG,CAACnB,WAAW,CAACU,GAAG,CAACc,UAAU,CAAC;MACjDH,GAAG,CAACpB,aAAa,GAAGkB,GAAG,CAAClB,aAAa,CAACS,GAAG,CAACc,UAAU,CAAC;MAErD,IAAI,EAAAN,WAAA,GAAAC,GAAG,CAACjB,MAAM,cAAAgB,WAAA,uBAAVA,WAAA,CAAYO,MAAM,KAAI,IAAI,EAAE;QAC9BJ,GAAG,CAACnB,MAAM,GAAGnB,YAAY,CAAC8B,WAAW,CAACM,GAAG,CAACjB,MAAM,CAAC;;MAGnD,OAAOmB,GAAG;IACZ;EAAC;EAAA,OAAArC,OAAA;AAAA;AAGH,SAAS2B,QAAQA,CAAEe,IAAc;EAAA,IAAAC,gBAAA;EAC/B,IAAMC,MAAM,GAAW;IACrBC,EAAE,EAAEH,IAAI,CAACG,EAAE,CAACC,OAAO,EAAE;IACrBC,KAAK,EAAE,EAAAJ,gBAAA,GAACD,IAAI,CAACM,UAAU,cAAAL,gBAAA,cAAAA,gBAAA,GAAI,EAAE,EAAEjB,GAAG,CAAC,UAACuB,CAAC;MAAA,OAAKA,CAAC,CAACC,KAAK;IAAA,EAAC;IAClDC,UAAU,EAAE/C,eAAe,CAACgD;GAC7B;EAED,OAAOR,MAAM;AACf;AAEA,SAASJ,UAAUA,CAAEE,IAAoB;EAAA,IAAAW,WAAA;EACvC,IAAIX,IAAI,CAACG,EAAE,IAAI,IAAI,EAAE;IACnB,MAAM,IAAI/B,KAAK,CAAC,yBAAyB,CAAC;;EAG5C,OAAO;IACL+B,EAAE,EAAEhD,eAAe,CAAC6C,IAAI,CAACG,EAAE,CAAC;IAC5BG,UAAU,EAAE,EAAAK,WAAA,GAACX,IAAI,CAACK,KAAK,cAAAM,WAAA,cAAAA,WAAA,GAAI,EAAE,EAAE3B,GAAG,CAAC,UAAC4B,CAAC;MAAA,OAAKxD,SAAS,CAACwD,CAAC,CAAC;IAAA,EAAC;IACvDC,SAAS,EAAE;GACZ;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}