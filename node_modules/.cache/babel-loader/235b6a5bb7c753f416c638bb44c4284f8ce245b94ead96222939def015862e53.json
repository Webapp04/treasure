{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport mergeOpts from 'merge-options';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { toTrail } from './utils/to-trail.js';\nimport { addLink } from './utils/add-link.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { pipe } from 'it-pipe';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { recursive } from 'ipfs-unixfs-exporter';\nimport last from 'it-last';\nimport { createCp } from './cp.js';\nimport { createRm } from './rm.js';\nimport { persist } from './utils/persist.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nvar mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nvar log = logger('ipfs:mfs:touch');\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nvar defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification(mode, originalMode, isDirectory) {\n  var modification = 0;\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 1 || originalMode & 8 || originalMode & 64)) {\n    modification += 1;\n  }\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n  return modification;\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO(references, modification) {\n  var ugo = 0;\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n  return ugo;\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n  return modification;\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n  var match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n  if (!match) {\n    throw new Error(\"Invalid file mode: \".concat(input));\n  }\n  var _match = _slicedToArray(match, 4),\n    references = _match[1],\n    operator = _match[2],\n    mode = _match[3];\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n  var modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8);\n\n      // or them together\n      originalMode = originalMode | modification;\n    }\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8);\n\n      // or them together\n      originalMode = originalMode | modification;\n    }\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8);\n\n      // or them together\n      originalMode = originalMode | modification;\n    }\n    return originalMode;\n  }\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n  return originalMode;\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    var strMode = \"\".concat(mode);\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      mode = 0 + strMode.split(',').reduce(function (curr, acc) {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n  return mode;\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createChmod(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"chmod\"]}\n   */\n  function mfsChmod(_x4, _x5) {\n    return _mfsChmod.apply(this, arguments);\n  }\n  function _mfsChmod() {\n    _mfsChmod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(path, mode) {\n      var options,\n        opts,\n        _yield$toMfsPath,\n        cid,\n        mfsDirectory,\n        name,\n        root,\n        block,\n        node,\n        metadata,\n        updatedBlock,\n        hashAlg,\n        hasher,\n        hash,\n        updatedCid,\n        trail,\n        parent,\n        parentCid,\n        parentBlock,\n        parentNode,\n        result,\n        newRootCid,\n        _args5 = arguments;\n      return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};\n            /** @type {DefaultOptions} */\n            opts = mergeOptions(defaultOptions, options);\n            log(\"Fetching stats for \".concat(path));\n            _context5.next = 5;\n            return toMfsPath(context, path, opts);\n          case 5:\n            _yield$toMfsPath = _context5.sent;\n            cid = _yield$toMfsPath.cid;\n            mfsDirectory = _yield$toMfsPath.mfsDirectory;\n            name = _yield$toMfsPath.name;\n            if (!(cid.code !== dagPB.code)) {\n              _context5.next = 11;\n              break;\n            }\n            throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n          case 11:\n            if (!opts.recursive) {\n              _context5.next = 22;\n              break;\n            }\n            _context5.next = 14;\n            return pipe( /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, _node;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _iteratorAbruptCompletion = false;\n                    _didIteratorError = false;\n                    _context.prev = 2;\n                    _iterator = _asyncIterator(recursive(cid, context.repo.blocks));\n                  case 4:\n                    _context.next = 6;\n                    return _awaitAsyncGenerator(_iterator.next());\n                  case 6:\n                    if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                      _context.next = 17;\n                      break;\n                    }\n                    entry = _step.value;\n                    if (!(entry.type !== 'file' && entry.type !== 'directory')) {\n                      _context.next = 10;\n                      break;\n                    }\n                    throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n                  case 10:\n                    entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n                    _node = dagPB.prepare({\n                      Data: entry.unixfs.marshal(),\n                      Links: entry.node.Links\n                    });\n                    _context.next = 14;\n                    return {\n                      path: entry.path,\n                      content: _node\n                    };\n                  case 14:\n                    _iteratorAbruptCompletion = false;\n                    _context.next = 4;\n                    break;\n                  case 17:\n                    _context.next = 23;\n                    break;\n                  case 19:\n                    _context.prev = 19;\n                    _context.t0 = _context[\"catch\"](2);\n                    _didIteratorError = true;\n                    _iteratorError = _context.t0;\n                  case 23:\n                    _context.prev = 23;\n                    _context.prev = 24;\n                    if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                      _context.next = 28;\n                      break;\n                    }\n                    _context.next = 28;\n                    return _awaitAsyncGenerator(_iterator.return());\n                  case 28:\n                    _context.prev = 28;\n                    if (!_didIteratorError) {\n                      _context.next = 31;\n                      break;\n                    }\n                    throw _iteratorError;\n                  case 31:\n                    return _context.finish(28);\n                  case 32:\n                    return _context.finish(23);\n                  case 33:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, null, [[2, 19, 23, 33], [24,, 28, 32]]);\n            })),\n            // @ts-expect-error we account for the incompatible source type with our custom dag builder below\n            function (source) {\n              return importer(source, context.repo.blocks, _objectSpread(_objectSpread({}, opts), {}, {\n                pin: false,\n                dagBuilder: function () {\n                  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source, block, opts) {\n                    var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _loop, _iterator2, _step2;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n                      while (1) switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _iteratorAbruptCompletion2 = false;\n                          _didIteratorError2 = false;\n                          _context4.prev = 2;\n                          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                            var entry;\n                            return _regeneratorRuntime().wrap(function _loop$(_context3) {\n                              while (1) switch (_context3.prev = _context3.next) {\n                                case 0:\n                                  entry = _step2.value;\n                                  _context3.next = 3;\n                                  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                                    var node, buf, cid, unixfs;\n                                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                                      while (1) switch (_context2.prev = _context2.next) {\n                                        case 0:\n                                          /** @type {PBNode} */\n                                          // @ts-expect-error - cannot derive type\n                                          node = entry.content;\n                                          buf = dagPB.encode(node);\n                                          _context2.next = 4;\n                                          return persist(buf, block, opts);\n                                        case 4:\n                                          cid = _context2.sent;\n                                          if (node.Data) {\n                                            _context2.next = 7;\n                                            break;\n                                          }\n                                          throw errCode(new Error(\"\".concat(cid, \" had no data\")), 'ERR_INVALID_NODE');\n                                        case 7:\n                                          unixfs = UnixFS.unmarshal(node.Data);\n                                          return _context2.abrupt(\"return\", {\n                                            cid: cid,\n                                            size: buf.length,\n                                            path: entry.path,\n                                            unixfs: unixfs\n                                          });\n                                        case 9:\n                                        case \"end\":\n                                          return _context2.stop();\n                                      }\n                                    }, _callee2);\n                                  }));\n                                case 3:\n                                case \"end\":\n                                  return _context3.stop();\n                              }\n                            }, _loop);\n                          });\n                          _iterator2 = _asyncIterator(source);\n                        case 5:\n                          _context4.next = 7;\n                          return _awaitAsyncGenerator(_iterator2.next());\n                        case 7:\n                          if (!(_iteratorAbruptCompletion2 = !(_step2 = _context4.sent).done)) {\n                            _context4.next = 12;\n                            break;\n                          }\n                          return _context4.delegateYield(_loop(), \"t0\", 9);\n                        case 9:\n                          _iteratorAbruptCompletion2 = false;\n                          _context4.next = 5;\n                          break;\n                        case 12:\n                          _context4.next = 18;\n                          break;\n                        case 14:\n                          _context4.prev = 14;\n                          _context4.t1 = _context4[\"catch\"](2);\n                          _didIteratorError2 = true;\n                          _iteratorError2 = _context4.t1;\n                        case 18:\n                          _context4.prev = 18;\n                          _context4.prev = 19;\n                          if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                            _context4.next = 23;\n                            break;\n                          }\n                          _context4.next = 23;\n                          return _awaitAsyncGenerator(_iterator2.return());\n                        case 23:\n                          _context4.prev = 23;\n                          if (!_didIteratorError2) {\n                            _context4.next = 26;\n                            break;\n                          }\n                          throw _iteratorError2;\n                        case 26:\n                          return _context4.finish(23);\n                        case 27:\n                          return _context4.finish(18);\n                        case 28:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }, _callee3, null, [[2, 14, 18, 28], [19,, 23, 27]]);\n                  }));\n                  return function dagBuilder(_x, _x2, _x3) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()\n              }));\n            }, function (nodes) {\n              return last(nodes);\n            });\n          case 14:\n            root = _context5.sent;\n            if (root) {\n              _context5.next = 17;\n              break;\n            }\n            throw errCode(new Error(\"Could not chmod \".concat(path)), 'ERR_COULD_NOT_CHMOD');\n          case 17:\n            _context5.next = 19;\n            return createRm(context)(path, opts);\n          case 19:\n            _context5.next = 21;\n            return createCp(context)(\"/ipfs/\".concat(root.cid), path, opts);\n          case 21:\n            return _context5.abrupt(\"return\");\n          case 22:\n            _context5.next = 24;\n            return context.repo.blocks.get(cid);\n          case 24:\n            block = _context5.sent;\n            node = dagPB.decode(block);\n            if (node.Data) {\n              _context5.next = 28;\n              break;\n            }\n            throw errCode(new Error(\"\".concat(cid, \" had no data\")), 'ERR_INVALID_NODE');\n          case 28:\n            metadata = UnixFS.unmarshal(node.Data);\n            metadata.mode = calculateMode(mode, metadata);\n            updatedBlock = dagPB.encode({\n              Data: metadata.marshal(),\n              Links: node.Links\n            });\n            hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n            _context5.next = 34;\n            return context.hashers.getHasher(hashAlg);\n          case 34:\n            hasher = _context5.sent;\n            _context5.next = 37;\n            return hasher.digest(updatedBlock);\n          case 37:\n            hash = _context5.sent;\n            updatedCid = CID.create(opts.cidVersion, dagPB.code, hash);\n            if (!opts.flush) {\n              _context5.next = 42;\n              break;\n            }\n            _context5.next = 42;\n            return context.repo.blocks.put(updatedCid, updatedBlock);\n          case 42:\n            _context5.next = 44;\n            return toTrail(context, mfsDirectory);\n          case 44:\n            trail = _context5.sent;\n            parent = trail[trail.length - 1];\n            parentCid = CID.decode(parent.cid.bytes);\n            _context5.next = 49;\n            return context.repo.blocks.get(parentCid);\n          case 49:\n            parentBlock = _context5.sent;\n            parentNode = dagPB.decode(parentBlock);\n            _context5.next = 53;\n            return addLink(context, {\n              parent: parentNode,\n              name: name,\n              cid: updatedCid,\n              size: updatedBlock.length,\n              flush: opts.flush,\n              // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n              hashAlg: hashAlg,\n              cidVersion: cid.version,\n              shardSplitThreshold: Infinity\n            });\n          case 53:\n            result = _context5.sent;\n            parent.cid = result.cid;\n\n            // update the tree with the new child\n            _context5.next = 57;\n            return updateTree(context, trail, opts);\n          case 57:\n            newRootCid = _context5.sent;\n            _context5.next = 60;\n            return updateMfsRoot(context, newRootCid, opts);\n          case 60:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee4);\n    }));\n    return _mfsChmod.apply(this, arguments);\n  }\n  return withTimeoutOption(mfsChmod);\n}","map":{"version":3,"names":["mergeOpts","toMfsPath","logger","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPB","CID","pipe","importer","recursive","last","createCp","createRm","persist","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","concat","_match","_slicedToArray","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","createChmod","context","mfsChmod","_x4","_x5","_mfsChmod","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee4","path","options","opts","_yield$toMfsPath","cid","mfsDirectory","name","root","block","node","updatedBlock","hasher","hash","updatedCid","trail","parent","parentCid","parentBlock","parentNode","result","newRootCid","_args5","wrap","_callee4$","_context5","prev","next","length","undefined","sent","code","_wrapAsyncGenerator","_callee","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","entry","_node","_callee$","_context","_asyncIterator","repo","blocks","_awaitAsyncGenerator","done","value","type","unixfs","prepare","Data","marshal","Links","content","t0","return","finish","stop","source","_objectSpread","pin","dagBuilder","_ref2","_callee3","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_loop","_iterator2","_step2","_callee3$","_context4","_loop$","_context3","_callee2","buf","_callee2$","_context2","encode","unmarshal","abrupt","size","delegateYield","t1","_x","_x2","_x3","nodes","get","decode","hashers","getHasher","digest","create","put","bytes","version","Infinity"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/chmod.js"],"sourcesContent":["import mergeOpts from 'merge-options'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { toTrail } from './utils/to-trail.js'\nimport { addLink } from './utils/add-link.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { pipe } from 'it-pipe'\nimport { importer } from 'ipfs-unixfs-importer'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport last from 'it-last'\nimport { createCp } from './cp.js'\nimport { createRm } from './rm.js'\nimport { persist } from './utils/persist.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:touch')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n}\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    ,\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n\n  return originalMode\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode (mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8)\n    } else {\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode || 0)\n    }\n  }\n\n  return mode\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createChmod (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"chmod\"]}\n   */\n  async function mfsChmod (path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts)\n\n    if (cid.code !== dagPB.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of recursive(cid, context.repo.blocks)) {\n            if (entry.type !== 'file' && entry.type !== 'directory') {\n              throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n            }\n\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n\n            const node = dagPB.prepare({\n              Data: entry.unixfs.marshal(),\n              Links: entry.node.Links\n            })\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        // @ts-expect-error we account for the incompatible source type with our custom dag builder below\n        (source) => importer(source, context.repo.blocks, {\n          ...opts,\n          pin: false,\n          dagBuilder: async function * (source, block, opts) {\n            for await (const entry of source) {\n              yield async function () {\n                /** @type {PBNode} */\n                // @ts-expect-error - cannot derive type\n                const node = entry.content\n\n                const buf = dagPB.encode(node)\n                const cid = await persist(buf, block, opts)\n\n                if (!node.Data) {\n                  throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n                }\n\n                const unixfs = UnixFS.unmarshal(node.Data)\n\n                return {\n                  cid,\n                  size: buf.length,\n                  path: entry.path,\n                  unixfs\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD')\n      }\n\n      // remove old path from mfs\n      await createRm(context)(path, opts)\n\n      // add newly created tree to mfs at path\n      await createCp(context)(`/ipfs/${root.cid}`, path, opts)\n\n      return\n    }\n\n    const block = await context.repo.blocks.get(cid)\n    const node = dagPB.decode(block)\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    const updatedBlock = dagPB.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    })\n\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n    const hash = await hasher.digest(updatedBlock)\n    const updatedCid = CID.create(opts.cidVersion, dagPB.code, hash)\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock)\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = CID.decode(parent.cid.bytes)\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPB.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsChmod)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}