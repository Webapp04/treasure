{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { logger } from '@libp2p/logger';\nimport mergeOptions from 'merge-options';\n// @ts-expect-error retimer does not have types\nimport retimer from 'retimer';\nimport all from 'it-all';\nimport { pipe } from 'it-pipe';\nimport filter from 'it-filter';\nimport sort from 'it-sort';\nvar log = logger('libp2p:connection-manager:auto-dialler');\nvar defaultOptions = {\n  enabled: true,\n  minConnections: 0,\n  autoDialInterval: 10000\n};\nexport var AutoDialler = /*#__PURE__*/function () {\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   */\n  function AutoDialler(components, init) {\n    _classCallCheck(this, AutoDialler);\n    this.components = components;\n    this.options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, init);\n    this.running = false;\n    this._autoDial = this._autoDial.bind(this);\n    log('options: %j', this.options);\n  }\n  _createClass(AutoDialler, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.running;\n    }\n    /**\n     * Starts the auto dialer\n     */\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.options.enabled) {\n                _context.next = 3;\n                break;\n              }\n              log('not enabled');\n              return _context.abrupt(\"return\");\n            case 3:\n              this.running = true;\n              void this._autoDial().catch(function (err) {\n                log.error('could start autodial', err);\n              });\n              log('started');\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n    /**\n     * Stops the auto dialler\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.options.enabled) {\n                _context2.next = 3;\n                break;\n              }\n              log('not enabled');\n              return _context2.abrupt(\"return\");\n            case 3:\n              this.running = false;\n              if (this.autoDialTimeout != null) {\n                this.autoDialTimeout.clear();\n              }\n              log('stopped');\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n  }, {\n    key: \"_autoDial\",\n    value: function () {\n      var _autoDial2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this = this;\n        var minConnections, allPeers, peers, i, peer;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.autoDialTimeout != null) {\n                this.autoDialTimeout.clear();\n              }\n              minConnections = this.options.minConnections; // Already has enough connections\n              if (!(this.components.getConnectionManager().getConnections().length >= minConnections)) {\n                _context4.next = 5;\n                break;\n              }\n              this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval);\n              return _context4.abrupt(\"return\");\n            case 5:\n              _context4.next = 7;\n              return this.components.getPeerStore().all();\n            case 7:\n              allPeers = _context4.sent;\n              _context4.next = 10;\n              return pipe(\n              // shuffle the peers\n              allPeers.sort(function () {\n                return Math.random() > 0.5 ? 1 : -1;\n              }), function (source) {\n                return filter(source, function (peer) {\n                  return !peer.id.equals(_this.components.getPeerId());\n                });\n              }, function (source) {\n                return sort(source, function (a, b) {\n                  if (b.protocols.length > a.protocols.length) {\n                    return 1;\n                  } else if (b.id.publicKey != null && a.id.publicKey == null) {\n                    return 1;\n                  }\n                  return -1;\n                });\n              }, /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return all(source);\n                      case 2:\n                        return _context3.abrupt(\"return\", _context3.sent);\n                      case 3:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function (_x) {\n                  return _ref.apply(this, arguments);\n                };\n              }());\n            case 10:\n              peers = _context4.sent;\n              i = 0;\n            case 12:\n              if (!(this.running && i < peers.length && this.components.getConnectionManager().getConnections().length < minConnections)) {\n                _context4.next = 29;\n                break;\n              }\n              if (this.running) {\n                _context4.next = 15;\n                break;\n              }\n              return _context4.abrupt(\"return\");\n            case 15:\n              peer = peers[i];\n              if (!(this.components.getConnectionManager().getConnections(peer.id).length === 0)) {\n                _context4.next = 26;\n                break;\n              }\n              log('connecting to a peerStore stored peer %p', peer.id);\n              _context4.prev = 18;\n              _context4.next = 21;\n              return this.components.getConnectionManager().openConnection(peer.id);\n            case 21:\n              _context4.next = 26;\n              break;\n            case 23:\n              _context4.prev = 23;\n              _context4.t0 = _context4[\"catch\"](18);\n              log.error('could not connect to peerStore stored peer', _context4.t0);\n            case 26:\n              i++;\n              _context4.next = 12;\n              break;\n            case 29:\n              if (this.running) {\n                _context4.next = 31;\n                break;\n              }\n              return _context4.abrupt(\"return\");\n            case 31:\n              this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval);\n            case 32:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[18, 23]]);\n      }));\n      function _autoDial() {\n        return _autoDial2.apply(this, arguments);\n      }\n      return _autoDial;\n    }()\n  }]);\n  return AutoDialler;\n}();","map":{"version":3,"names":["logger","mergeOptions","retimer","all","pipe","filter","sort","log","defaultOptions","enabled","minConnections","autoDialInterval","AutoDialler","components","init","_classCallCheck","options","call","ignoreUndefined","running","_autoDial","bind","_createClass","key","value","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","catch","err","error","stop","start","apply","arguments","_stop","_callee2","_callee2$","_context2","autoDialTimeout","clear","_autoDial2","_callee4","_this","allPeers","peers","i","peer","_callee4$","_context4","getConnectionManager","getConnections","length","getPeerStore","sent","Math","random","source","id","equals","getPeerId","a","b","protocols","publicKey","_ref","_callee3","_callee3$","_context3","_x","openConnection","t0"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/connection-manager/auto-dialler.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport mergeOptions from 'merge-options'\n// @ts-expect-error retimer does not have types\nimport retimer from 'retimer'\nimport all from 'it-all'\nimport { pipe } from 'it-pipe'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { Components } from '@libp2p/components'\n\nconst log = logger('libp2p:connection-manager:auto-dialler')\n\nexport interface AutoDiallerInit {\n  /**\n   * Should preemptively guarantee connections are above the low watermark\n   */\n  enabled?: boolean\n\n  /**\n   * The minimum number of connections to avoid pruning\n   */\n  minConnections?: number\n\n  /**\n   * How often, in milliseconds, it should preemptively guarantee connections are above the low watermark\n   */\n  autoDialInterval?: number\n}\n\nconst defaultOptions: Partial<AutoDiallerInit> = {\n  enabled: true,\n  minConnections: 0,\n  autoDialInterval: 10000\n}\n\nexport class AutoDialler implements Startable {\n  private readonly components: Components\n  private readonly options: Required<AutoDiallerInit>\n  private running: boolean\n  private autoDialTimeout?: ReturnType<retimer>\n\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   */\n  constructor (components: Components, init: AutoDiallerInit) {\n    this.components = components\n    this.options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, init)\n    this.running = false\n    this._autoDial = this._autoDial.bind(this)\n\n    log('options: %j', this.options)\n  }\n\n  isStarted () {\n    return this.running\n  }\n\n  /**\n   * Starts the auto dialer\n   */\n  async start () {\n    if (!this.options.enabled) {\n      log('not enabled')\n      return\n    }\n\n    this.running = true\n\n    void this._autoDial().catch(err => {\n      log.error('could start autodial', err)\n    })\n\n    log('started')\n  }\n\n  /**\n   * Stops the auto dialler\n   */\n  async stop () {\n    if (!this.options.enabled) {\n      log('not enabled')\n      return\n    }\n\n    this.running = false\n\n    if (this.autoDialTimeout != null) {\n      this.autoDialTimeout.clear()\n    }\n\n    log('stopped')\n  }\n\n  async _autoDial () {\n    if (this.autoDialTimeout != null) {\n      this.autoDialTimeout.clear()\n    }\n\n    const minConnections = this.options.minConnections\n\n    // Already has enough connections\n    if (this.components.getConnectionManager().getConnections().length >= minConnections) {\n      this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval)\n\n      return\n    }\n\n    // Sort peers on whether we know protocols or public keys for them\n    const allPeers = await this.components.getPeerStore().all()\n\n    const peers = await pipe(\n      // shuffle the peers\n      allPeers.sort(() => Math.random() > 0.5 ? 1 : -1),\n      (source) => filter(source, (peer) => !peer.id.equals(this.components.getPeerId())),\n      (source) => sort(source, (a, b) => {\n        if (b.protocols.length > a.protocols.length) {\n          return 1\n        } else if (b.id.publicKey != null && a.id.publicKey == null) {\n          return 1\n        }\n        return -1\n      }),\n      async (source) => await all(source)\n    )\n\n    for (let i = 0; this.running && i < peers.length && this.components.getConnectionManager().getConnections().length < minConnections; i++) {\n      // Connection Manager was stopped during async dial\n      if (!this.running) {\n        return\n      }\n\n      const peer = peers[i]\n\n      if (this.components.getConnectionManager().getConnections(peer.id).length === 0) {\n        log('connecting to a peerStore stored peer %p', peer.id)\n        try {\n          await this.components.getConnectionManager().openConnection(peer.id)\n        } catch (err: any) {\n          log.error('could not connect to peerStore stored peer', err)\n        }\n      }\n    }\n\n    // Connection Manager was stopped\n    if (!this.running) {\n      return\n    }\n\n    this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}