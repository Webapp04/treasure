{"ast":null,"code":"var _classCallCheck = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar RateLimiterAbstract = require('./RateLimiterAbstract');\nvar BlockedKeys = require('./component/BlockedKeys');\nvar RateLimiterRes = require('./RateLimiterRes');\nmodule.exports = /*#__PURE__*/function (_RateLimiterAbstract) {\n  \"use strict\";\n\n  _inherits(RateLimiterStoreAbstract, _RateLimiterAbstract);\n  var _super = _createSuper(RateLimiterStoreAbstract);\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  function RateLimiterStoreAbstract() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, RateLimiterStoreAbstract);\n    _this = _super.call(this, opts);\n    _this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;\n    _this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;\n    _this.insuranceLimiter = opts.insuranceLimiter;\n    _this._inMemoryBlockedKeys = new BlockedKeys();\n    return _this;\n  }\n  _createClass(RateLimiterStoreAbstract, [{\n    key: \"client\",\n    get: function get() {\n      return this._client;\n    },\n    set: function set(value) {\n      if (typeof value === 'undefined') {\n        throw new Error('storeClient is not set');\n      }\n      this._client = value;\n    }\n\n    /**\n     * Have to be launched after consume\n     * It blocks key and execute evenly depending on result from store\n     *\n     * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n     *\n     * @param resolve\n     * @param reject\n     * @param rlKey\n     * @param changedPoints\n     * @param storeResult\n     * @param {Object} options\n     * @private\n     */\n  }, {\n    key: \"_afterConsume\",\n    value: function _afterConsume(resolve, reject, rlKey, changedPoints, storeResult) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n      var res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n      if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n        if (res.consumedPoints > this.points) {\n          return reject(res);\n        } else {\n          return resolve(res);\n        }\n      } else if (res.consumedPoints > this.points) {\n        var blockPromise = Promise.resolve();\n        // Block only first time when consumed more than points\n        if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {\n          res.msBeforeNext = this.msBlockDuration;\n          blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n        }\n        if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n          // Block key for this.inMemoryBlockDuration seconds\n          this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n          res.msBeforeNext = this.msInMemoryBlockDuration;\n        }\n        blockPromise.then(function () {\n          reject(res);\n        }).catch(function (err) {\n          reject(err);\n        });\n      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n        var delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n        if (delay < this.execEvenlyMinDelayMs) {\n          delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n        }\n        setTimeout(resolve, delay, res);\n      } else {\n        resolve(res);\n      }\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(err, funcName, resolve, reject, key) {\n      var data = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n      if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n        reject(err);\n      } else {\n        this.insuranceLimiter[funcName](key, data, options).then(function (res) {\n          resolve(res);\n        }).catch(function (res) {\n          reject(res);\n        });\n      }\n    }\n\n    /**\n     * @deprecated Use camelCase version\n     * @returns {BlockedKeys}\n     * @private\n     */\n  }, {\n    key: \"_inmemoryBlockedKeys\",\n    get: function get() {\n      return this._inMemoryBlockedKeys;\n    }\n\n    /**\n     * @deprecated Use camelCase version\n     * @param rlKey\n     * @returns {number}\n     */\n  }, {\n    key: \"getInmemoryBlockMsBeforeExpire\",\n    value: function getInmemoryBlockMsBeforeExpire(rlKey) {\n      return this.getInMemoryBlockMsBeforeExpire(rlKey);\n    }\n\n    /**\n     * @deprecated Use camelCase version\n     * @returns {number|number}\n     */\n  }, {\n    key: \"inmemoryBlockOnConsumed\",\n    get: function get() {\n      return this.inMemoryBlockOnConsumed;\n    }\n\n    /**\n     * @deprecated Use camelCase version\n     * @param value\n     */,\n    set: function set(value) {\n      this.inMemoryBlockOnConsumed = value;\n    }\n\n    /**\n     * @deprecated Use camelCase version\n     * @returns {number|number}\n     */\n  }, {\n    key: \"inmemoryBlockDuration\",\n    get: function get() {\n      return this.inMemoryBlockDuration;\n    }\n\n    /**\n     * @deprecated Use camelCase version\n     * @param value\n     */,\n    set: function set(value) {\n      this.inMemoryBlockDuration = value;\n    }\n\n    /**\n     * @deprecated Use camelCase version\n     * @returns {number}\n     */\n  }, {\n    key: \"msInmemoryBlockDuration\",\n    get: function get() {\n      return this.inMemoryBlockDuration * 1000;\n    }\n  }, {\n    key: \"getInMemoryBlockMsBeforeExpire\",\n    value: function getInMemoryBlockMsBeforeExpire(rlKey) {\n      if (this.inMemoryBlockOnConsumed > 0) {\n        return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n      }\n      return 0;\n    }\n  }, {\n    key: \"inMemoryBlockOnConsumed\",\n    get: function get() {\n      return this._inMemoryBlockOnConsumed;\n    },\n    set: function set(value) {\n      this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n      if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n        throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n      }\n    }\n  }, {\n    key: \"inMemoryBlockDuration\",\n    get: function get() {\n      return this._inMemoryBlockDuration;\n    },\n    set: function set(value) {\n      this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n      if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n        throw new Error('inMemoryBlockOnConsumed option must be set up');\n      }\n    }\n  }, {\n    key: \"msInMemoryBlockDuration\",\n    get: function get() {\n      return this._inMemoryBlockDuration * 1000;\n    }\n  }, {\n    key: \"insuranceLimiter\",\n    get: function get() {\n      return this._insuranceLimiter;\n    },\n    set: function set(value) {\n      if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n        throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n      }\n      this._insuranceLimiter = value;\n      if (this._insuranceLimiter) {\n        this._insuranceLimiter.blockDuration = this.blockDuration;\n        this._insuranceLimiter.execEvenly = this.execEvenly;\n      }\n    }\n\n    /**\n     * Block any key for secDuration seconds\n     *\n     * @param key\n     * @param secDuration\n     * @param {Object} options\n     *\n     * @return Promise<RateLimiterRes>\n     */\n  }, {\n    key: \"block\",\n    value: function block(key, secDuration) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var msDuration = secDuration * 1000;\n      return this._block(this.getKey(key), this.points + 1, msDuration, options);\n    }\n\n    /**\n     * Set points by key for any duration\n     *\n     * @param key\n     * @param points\n     * @param secDuration\n     * @param {Object} options\n     *\n     * @return Promise<RateLimiterRes>\n     */\n  }, {\n    key: \"set\",\n    value: function set(key, points, secDuration) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n      return this._block(this.getKey(key), points, msDuration, options);\n    }\n\n    /**\n     *\n     * @param key\n     * @param pointsToConsume\n     * @param {Object} options\n     * @returns Promise<RateLimiterRes>\n     */\n  }, {\n    key: \"consume\",\n    value: function consume(key) {\n      var _this2 = this;\n      var pointsToConsume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return new Promise(function (resolve, reject) {\n        var rlKey = _this2.getKey(key);\n        var inMemoryBlockMsBeforeExpire = _this2.getInMemoryBlockMsBeforeExpire(rlKey);\n        if (inMemoryBlockMsBeforeExpire > 0) {\n          return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n        }\n        _this2._upsert(rlKey, pointsToConsume, _this2._getKeySecDuration(options) * 1000, false, options).then(function (res) {\n          _this2._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n        }).catch(function (err) {\n          _this2._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n        });\n      });\n    }\n\n    /**\n     *\n     * @param key\n     * @param points\n     * @param {Object} options\n     * @returns Promise<RateLimiterRes>\n     */\n  }, {\n    key: \"penalty\",\n    value: function penalty(key) {\n      var _this3 = this;\n      var points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var rlKey = this.getKey(key);\n      return new Promise(function (resolve, reject) {\n        _this3._upsert(rlKey, points, _this3._getKeySecDuration(options) * 1000, false, options).then(function (res) {\n          resolve(_this3._getRateLimiterRes(rlKey, points, res));\n        }).catch(function (err) {\n          _this3._handleError(err, 'penalty', resolve, reject, key, points, options);\n        });\n      });\n    }\n\n    /**\n     *\n     * @param key\n     * @param points\n     * @param {Object} options\n     * @returns Promise<RateLimiterRes>\n     */\n  }, {\n    key: \"reward\",\n    value: function reward(key) {\n      var _this4 = this;\n      var points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var rlKey = this.getKey(key);\n      return new Promise(function (resolve, reject) {\n        _this4._upsert(rlKey, -points, _this4._getKeySecDuration(options) * 1000, false, options).then(function (res) {\n          resolve(_this4._getRateLimiterRes(rlKey, -points, res));\n        }).catch(function (err) {\n          _this4._handleError(err, 'reward', resolve, reject, key, points, options);\n        });\n      });\n    }\n\n    /**\n     *\n     * @param key\n     * @param {Object} options\n     * @returns Promise<RateLimiterRes>|null\n     */\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var _this5 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rlKey = this.getKey(key);\n      return new Promise(function (resolve, reject) {\n        _this5._get(rlKey, options).then(function (res) {\n          if (res === null || typeof res === 'undefined') {\n            resolve(null);\n          } else {\n            resolve(_this5._getRateLimiterRes(rlKey, 0, res));\n          }\n        }).catch(function (err) {\n          _this5._handleError(err, 'get', resolve, reject, key, options);\n        });\n      });\n    }\n\n    /**\n     *\n     * @param key\n     * @param {Object} options\n     * @returns Promise<boolean>\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var _this6 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rlKey = this.getKey(key);\n      return new Promise(function (resolve, reject) {\n        _this6._delete(rlKey, options).then(function (res) {\n          _this6._inMemoryBlockedKeys.delete(rlKey);\n          resolve(res);\n        }).catch(function (err) {\n          _this6._handleError(err, 'delete', resolve, reject, key, options);\n        });\n      });\n    }\n\n    /**\n     * Cleanup keys no-matter expired or not.\n     */\n  }, {\n    key: \"deleteInMemoryBlockedAll\",\n    value: function deleteInMemoryBlockedAll() {\n      this._inMemoryBlockedKeys.delete();\n    }\n\n    /**\n     * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n     *\n     * @param rlKey\n     * @param changedPoints\n     * @param storeResult\n     * @private\n     */\n  }, {\n    key: \"_getRateLimiterRes\",\n    value: function _getRateLimiterRes(rlKey, changedPoints, storeResult) {\n      // eslint-disable-line no-unused-vars\n      throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n    }\n\n    /**\n     * Block key for this.msBlockDuration milliseconds\n     * Usually, it just prolongs lifetime of key\n     *\n     * @param rlKey\n     * @param initPoints\n     * @param msDuration\n     * @param {Object} options\n     *\n     * @return Promise<any>\n     */\n  }, {\n    key: \"_block\",\n    value: function _block(rlKey, initPoints, msDuration) {\n      var _this7 = this;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return new Promise(function (resolve, reject) {\n        _this7._upsert(rlKey, initPoints, msDuration, true, options).then(function () {\n          resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n        }).catch(function (err) {\n          _this7._handleError(err, 'block', resolve, reject, _this7.parseKey(rlKey), msDuration / 1000, options);\n        });\n      });\n    }\n\n    /**\n     * Have to be implemented in every limiter\n     * Resolve with raw result from Store OR null if rlKey is not set\n     * or Reject with error\n     *\n     * @param rlKey\n     * @param {Object} options\n     * @private\n     *\n     * @return Promise<any>\n     */\n  }, {\n    key: \"_get\",\n    value: function _get(rlKey) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // eslint-disable-line no-unused-vars\n      throw new Error(\"You have to implement the method '_get'!\");\n    }\n\n    /**\n     * Have to be implemented\n     * Resolve with true OR false if rlKey doesn't exist\n     * or Reject with error\n     *\n     * @param rlKey\n     * @param {Object} options\n     * @private\n     *\n     * @return Promise<any>\n     */\n  }, {\n    key: \"_delete\",\n    value: function _delete(rlKey) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // eslint-disable-line no-unused-vars\n      throw new Error(\"You have to implement the method '_delete'!\");\n    }\n\n    /**\n     * Have to be implemented\n     * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n     *\n     * @param {string} rlKey\n     * @param {number} points\n     * @param {number} msDuration\n     * @param {boolean} forceExpire\n     * @param {Object} options\n     * @abstract\n     *\n     * @return Promise<Object>\n     */\n  }, {\n    key: \"_upsert\",\n    value: function _upsert(rlKey, points, msDuration) {\n      var forceExpire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      throw new Error(\"You have to implement the method '_upsert'!\");\n    }\n  }]);\n  return RateLimiterStoreAbstract;\n}(RateLimiterAbstract);","map":{"version":3,"names":["RateLimiterAbstract","require","BlockedKeys","RateLimiterRes","module","exports","_RateLimiterAbstract","_inherits","RateLimiterStoreAbstract","_super","_createSuper","_this","opts","arguments","length","undefined","_classCallCheck","call","inMemoryBlockOnConsumed","inmemoryBlockOnConsumed","inMemoryBlockDuration","inmemoryBlockDuration","insuranceLimiter","_inMemoryBlockedKeys","_createClass","key","get","_client","set","value","Error","_afterConsume","resolve","reject","rlKey","changedPoints","storeResult","options","res","_getRateLimiterRes","consumedPoints","addMs","msBeforeNext","points","blockPromise","Promise","blockDuration","msBlockDuration","_block","add","msInMemoryBlockDuration","then","catch","err","execEvenly","isFirstInDuration","delay","Math","ceil","remainingPoints","execEvenlyMinDelayMs","setTimeout","_handleError","funcName","data","getInmemoryBlockMsBeforeExpire","getInMemoryBlockMsBeforeExpire","msBeforeExpire","_inMemoryBlockOnConsumed","parseInt","_inMemoryBlockDuration","_insuranceLimiter","block","secDuration","msDuration","getKey","duration","consume","_this2","pointsToConsume","inMemoryBlockMsBeforeExpire","_upsert","_getKeySecDuration","penalty","_this3","reward","_this4","_this5","_get","_delete","_this6","delete","deleteInMemoryBlockedAll","initPoints","_this7","parseKey","forceExpire"],"sources":["/Users/apple/Documents/treasure/node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"],"sourcesContent":["const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst BlockedKeys = require('./component/BlockedKeys');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  constructor(opts = {}) {\n    super(opts);\n\n    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;\n    this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;\n    this.insuranceLimiter = opts.insuranceLimiter;\n    this._inMemoryBlockedKeys = new BlockedKeys();\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('storeClient is not set');\n    }\n    this._client = value;\n  }\n\n  /**\n   * Have to be launched after consume\n   * It blocks key and execute evenly depending on result from store\n   *\n   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n   *\n   * @param resolve\n   * @param reject\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @param {Object} options\n   * @private\n   */\n  _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {\n    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n\n    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0)\n      && res.consumedPoints >= this.inMemoryBlockOnConsumed\n    ) {\n      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n      if (res.consumedPoints > this.points) {\n        return reject(res);\n      } else {\n        return resolve(res)\n      }\n    } else if (res.consumedPoints > this.points) {\n      let blockPromise = Promise.resolve();\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + changedPoints)) {\n        res.msBeforeNext = this.msBlockDuration;\n        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n      }\n\n      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        // Block key for this.inMemoryBlockDuration seconds\n        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n        res.msBeforeNext = this.msInMemoryBlockDuration;\n      }\n\n      blockPromise\n        .then(() => {\n          reject(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n      if (delay < this.execEvenlyMinDelayMs) {\n        delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n      }\n\n      setTimeout(resolve, delay, res);\n    } else {\n      resolve(res);\n    }\n  }\n\n  _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {\n    if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n      reject(err);\n    } else {\n      this.insuranceLimiter[funcName](key, data, options)\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((res) => {\n          reject(res);\n        });\n    }\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {BlockedKeys}\n   * @private\n   */\n  get _inmemoryBlockedKeys() {\n    return this._inMemoryBlockedKeys\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param rlKey\n   * @returns {number}\n   */\n  getInmemoryBlockMsBeforeExpire(rlKey) {\n    return this.getInMemoryBlockMsBeforeExpire(rlKey)\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockOnConsumed() {\n    return this.inMemoryBlockOnConsumed;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockOnConsumed(value) {\n    this.inMemoryBlockOnConsumed = value;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockDuration() {\n    return this.inMemoryBlockDuration;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockDuration(value) {\n    this.inMemoryBlockDuration = value\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number}\n   */\n  get msInmemoryBlockDuration() {\n    return this.inMemoryBlockDuration * 1000;\n  }\n\n  getInMemoryBlockMsBeforeExpire(rlKey) {\n    if (this.inMemoryBlockOnConsumed > 0) {\n      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n    }\n\n    return 0;\n  }\n\n  get inMemoryBlockOnConsumed() {\n    return this._inMemoryBlockOnConsumed;\n  }\n\n  set inMemoryBlockOnConsumed(value) {\n    this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n      throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n    }\n  }\n\n  get inMemoryBlockDuration() {\n    return this._inMemoryBlockDuration;\n  }\n\n  set inMemoryBlockDuration(value) {\n    this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n      throw new Error('inMemoryBlockOnConsumed option must be set up');\n    }\n  }\n\n  get msInMemoryBlockDuration() {\n    return this._inMemoryBlockDuration * 1000;\n  }\n\n  get insuranceLimiter() {\n    return this._insuranceLimiter;\n  }\n\n  set insuranceLimiter(value) {\n    if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n      throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n    }\n    this._insuranceLimiter = value;\n    if (this._insuranceLimiter) {\n      this._insuranceLimiter.blockDuration = this.blockDuration;\n      this._insuranceLimiter.execEvenly = this.execEvenly;\n    }\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  block(key, secDuration, options = {}) {\n    const msDuration = secDuration * 1000;\n    return this._block(this.getKey(key), this.points + 1, msDuration, options);\n  }\n\n  /**\n   * Set points by key for any duration\n   *\n   * @param key\n   * @param points\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  set(key, points, secDuration, options = {}) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    return this._block(this.getKey(key), points, msDuration, options);\n  }\n\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n\n      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);\n      if (inMemoryBlockMsBeforeExpire > 0) {\n        return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n      }\n\n      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'penalty', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, -points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'reward', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>|null\n   */\n  get(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._get(rlKey, options)\n        .then((res) => {\n          if (res === null || typeof res === 'undefined') {\n            resolve(null);\n          } else {\n            resolve(this._getRateLimiterRes(rlKey, 0, res));\n          }\n        })\n        .catch((err) => {\n          this._handleError(err, 'get', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<boolean>\n   */\n  delete(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._delete(rlKey, options)\n        .then((res) => {\n          this._inMemoryBlockedKeys.delete(rlKey);\n          resolve(res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'delete', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   * Cleanup keys no-matter expired or not.\n   */\n  deleteInMemoryBlockedAll() {\n    this._inMemoryBlockedKeys.delete();\n  }\n\n  /**\n   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n   *\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @private\n   */\n  _getRateLimiterRes(rlKey, changedPoints, storeResult) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n  }\n\n  /**\n   * Block key for this.msBlockDuration milliseconds\n   * Usually, it just prolongs lifetime of key\n   *\n   * @param rlKey\n   * @param initPoints\n   * @param msDuration\n   * @param {Object} options\n   *\n   * @return Promise<any>\n   */\n  _block(rlKey, initPoints, msDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, initPoints, msDuration, true, options)\n        .then(() => {\n          resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n        })\n        .catch((err) => {\n          this._handleError(err, 'block', resolve, reject, this.parseKey(rlKey), msDuration / 1000, options);\n        });\n    });\n  }\n\n  /**\n   * Have to be implemented in every limiter\n   * Resolve with raw result from Store OR null if rlKey is not set\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _get(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_get'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with true OR false if rlKey doesn't exist\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _delete(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_delete'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n   *\n   * @param {string} rlKey\n   * @param {number} points\n   * @param {number} msDuration\n   * @param {boolean} forceExpire\n   * @param {Object} options\n   * @abstract\n   *\n   * @return Promise<Object>\n   */\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    throw new Error(\"You have to implement the method '_upsert'!\");\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}