{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { loadMfsRoot } from './with-mfs-root.js';\nimport { toPathComponents } from './to-path-components.js';\nimport { exporter } from 'ipfs-unixfs-exporter';\nimport errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nvar IPFS_PREFIX = 'ipfs';\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nexport var toMfsPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, path, options) {\n    var root, output, ipfsPath, pathComponents, mfsDirectory, mfsPath, _mfsDirectory, cidPath, res;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return loadMfsRoot(context, options);\n        case 2:\n          root = _context.sent;\n          /** @type {MfsPath} */\n          // @ts-expect-error fields get set later\n          output = {\n            entryType: 'file'\n          };\n          ipfsPath = '';\n          if (CID.asCID(path)) {\n            ipfsPath = \"/ipfs/\".concat(path);\n          } else {\n            ipfsPath = path.toString();\n          }\n          ipfsPath = ipfsPath.trim();\n          ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/');\n          if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n            ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n          }\n          if (ipfsPath) {\n            _context.next = 11;\n            break;\n          }\n          throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n        case 11:\n          if (!(ipfsPath.substring(0, 1) !== '/')) {\n            _context.next = 13;\n            break;\n          }\n          throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n        case 13:\n          if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n            ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n          }\n          pathComponents = toPathComponents(ipfsPath);\n          if (pathComponents[0] === IPFS_PREFIX) {\n            // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n\n            if (pathComponents.length === 2) {\n              mfsDirectory = \"/\".concat(pathComponents.join('/'));\n            } else {\n              mfsDirectory = \"/\".concat(pathComponents.slice(0, pathComponents.length - 1).join('/'));\n            }\n\n            // @ts-expect-error fields being set\n            output = {\n              type: 'ipfs',\n              depth: pathComponents.length - 2,\n              entryType: 'file',\n              mfsPath: \"/\".concat(pathComponents.join('/')),\n              mfsDirectory: mfsDirectory,\n              parts: pathComponents,\n              path: \"/\".concat(pathComponents.join('/')),\n              name: pathComponents[pathComponents.length - 1]\n            };\n          } else {\n            mfsPath = \"/\".concat(IPFS_PREFIX, \"/\").concat(root).concat(pathComponents.length ? '/' + pathComponents.join('/') : '');\n            _mfsDirectory = \"/\".concat(IPFS_PREFIX, \"/\").concat(root, \"/\").concat(pathComponents.slice(0, pathComponents.length - 1).join('/')); // @ts-expect-error fields being set\n            output = {\n              type: 'mfs',\n              depth: pathComponents.length,\n              entryType: 'file',\n              mfsDirectory: _mfsDirectory,\n              mfsPath: mfsPath,\n              parts: pathComponents,\n              path: \"/\".concat(pathComponents.join('/')),\n              name: pathComponents[pathComponents.length - 1]\n            };\n          }\n          cidPath = output.type === 'mfs' ? output.mfsPath : output.path;\n          _context.prev = 17;\n          _context.next = 20;\n          return exporter(cidPath, context.repo.blocks, options);\n        case 20:\n          res = _context.sent;\n          output.cid = res.cid;\n          output.mfsPath = \"/ipfs/\".concat(res.path);\n          output.entryType = res.type;\n          output.content = res.content;\n          if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n            output.unixfs = res.unixfs;\n          }\n          _context.next = 32;\n          break;\n        case 28:\n          _context.prev = 28;\n          _context.t0 = _context[\"catch\"](17);\n          if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n            _context.next = 32;\n            break;\n          }\n          throw _context.t0;\n        case 32:\n          output.exists = Boolean(output.cid);\n          return _context.abrupt(\"return\", output);\n        case 34:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[17, 28]]);\n  }));\n  return function toMfsPath(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["loadMfsRoot","toPathComponents","exporter","errCode","CID","IPFS_PREFIX","toMfsPath","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","context","path","options","root","output","ipfsPath","pathComponents","mfsDirectory","mfsPath","_mfsDirectory","cidPath","res","wrap","_callee$","_context","prev","next","sent","entryType","asCID","concat","toString","trim","replace","endsWith","length","substring","Error","join","slice","type","depth","parts","name","repo","blocks","cid","content","unixfs","t0","code","exists","Boolean","abrupt","stop","_x","_x2","_x3","apply","arguments"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js"],"sourcesContent":["import { loadMfsRoot } from './with-mfs-root.js'\nimport { toPathComponents } from './to-path-components.js'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport errCode from 'err-code'\nimport { CID } from 'multiformats/cid'\n\nconst IPFS_PREFIX = 'ipfs'\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nexport const toMfsPath = async (context, path, options) => {\n  const root = await loadMfsRoot(context, options)\n\n  /** @type {MfsPath} */\n  // @ts-expect-error fields get set later\n  let output = {\n    entryType: 'file'\n  }\n\n  let ipfsPath = ''\n\n  if (CID.asCID(path)) {\n    ipfsPath = `/ipfs/${path}`\n  } else {\n    ipfsPath = path.toString()\n  }\n\n  ipfsPath = ipfsPath.trim()\n  ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/')\n\n  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  if (!ipfsPath) {\n    throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n  }\n\n  if (ipfsPath.substring(0, 1) !== '/') {\n    throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n  }\n\n  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  const pathComponents = toPathComponents(ipfsPath)\n\n  if (pathComponents[0] === IPFS_PREFIX) {\n    // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n    let mfsDirectory\n\n    if (pathComponents.length === 2) {\n      mfsDirectory = `/${pathComponents.join('/')}`\n    } else {\n      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n    }\n\n    // @ts-expect-error fields being set\n    output = {\n      type: 'ipfs',\n      depth: pathComponents.length - 2,\n      entryType: 'file',\n\n      mfsPath: `/${pathComponents.join('/')}`,\n      mfsDirectory,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  } else {\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n\n    // @ts-expect-error fields being set\n    output = {\n      type: 'mfs',\n      depth: pathComponents.length,\n      entryType: 'file',\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  }\n\n  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path\n\n  try {\n    const res = await exporter(cidPath, context.repo.blocks, options)\n\n    output.cid = res.cid\n    output.mfsPath = `/ipfs/${res.path}`\n    output.entryType = res.type\n    output.content = res.content\n\n    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n      output.unixfs = res.unixfs\n    }\n  } catch (/** @type {any} */ err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  output.exists = Boolean(output.cid)\n\n  return output\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}