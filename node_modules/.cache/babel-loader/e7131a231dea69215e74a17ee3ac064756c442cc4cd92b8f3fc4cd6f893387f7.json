{"ast":null,"code":"import _defineProperty from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { decode } from '@ipld/dag-pb';\nimport { createStat } from './stat.js';\nimport { createMkdir } from './mkdir.js';\nimport { addLink } from './utils/add-link.js';\nimport mergeOpts from 'merge-options';\nimport { createLock } from './utils/create-lock.js';\nimport { toAsyncIterator } from './utils/to-async-iterator.js';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { toPathComponents } from './utils/to-path-components.js';\nimport { toTrail } from './utils/to-trail.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport errCode from 'err-code';\nimport { MFS_MAX_CHUNK_SIZE } from '../../utils.js';\nimport last from 'it-last';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { parseMode, parseMtime } from 'ipfs-unixfs';\nvar mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nvar log = logger('ipfs:mfs:write');\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('./utils/to-mfs-path').FilePath} FilePath\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {object} DefaultOptions\n * @property {number} offset\n * @property {number} length\n * @property {boolean} create\n * @property {boolean} truncate\n * @property {boolean} rawLeaves\n * @property {boolean} reduceSingleLeafToSelf\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} parents\n * @property {import('ipfs-core-types/src/root').AddProgressFn} progress\n * @property {'trickle' | 'balanced'} strategy\n * @property {boolean} flush\n * @property {'raw' | 'file'} leafType\n * @property {number} shardSplitThreshold\n * @property {MtimeLike} [mtime]\n * @property {number} [mode]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nvar defaultOptions = {\n  offset: 0,\n  // the offset in the file to begin writing\n  length: Infinity,\n  // how many bytes from the incoming buffer to write\n  create: false,\n  // whether to create the file if it does not exist\n  truncate: false,\n  // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false,\n  // whether to create intermediate directories if they do not exist\n  progress: function progress(bytes, path) {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n};\n\n/**\n * @param {MfsContext} context\n */\nexport function createWrite(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"write\"]}\n   */\n  function mfsWrite(_x4, _x5) {\n    return _mfsWrite.apply(this, arguments);\n  }\n  function _mfsWrite() {\n    _mfsWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, content) {\n      var opts,\n        options,\n        source,\n        destination,\n        parent,\n        _args2 = arguments;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            opts = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n            /** @type {DefaultOptions} */\n            options = mergeOptions(defaultOptions, opts);\n            /** @type {AsyncIterable<Uint8Array>} */\n            /** @type {MfsPath} */\n            /** @type {MfsPath} */\n            log('Reading source, destination and parent');\n            _context2.next = 5;\n            return createLock().readLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return toAsyncIterator(content);\n                  case 2:\n                    source = _context.sent;\n                    _context.next = 5;\n                    return toMfsPath(context, path, options);\n                  case 5:\n                    destination = _context.sent;\n                    _context.next = 8;\n                    return toMfsPath(context, destination.mfsDirectory, options);\n                  case 8:\n                    parent = _context.sent;\n                  case 9:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            })))();\n          case 5:\n            log('Read source, destination and parent');\n            // @ts-expect-error - parent may be undefined\n            if (!(!options.parents && !parent.exists)) {\n              _context2.next = 8;\n              break;\n            }\n            throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n          case 8:\n            if (!(source == null)) {\n              _context2.next = 10;\n              break;\n            }\n            throw errCode(new Error('could not create source'), 'ERR_NO_SOURCE');\n          case 10:\n            if (!(destination == null)) {\n              _context2.next = 12;\n              break;\n            }\n            throw errCode(new Error('could not create destination'), 'ERR_NO_DESTINATION');\n          case 12:\n            if (!(!options.create && !destination.exists)) {\n              _context2.next = 14;\n              break;\n            }\n            throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST');\n          case 14:\n            if (!(destination.entryType !== 'file')) {\n              _context2.next = 16;\n              break;\n            }\n            throw errCode(new Error('not a file'), 'ERR_NOT_A_FILE');\n          case 16:\n            return _context2.abrupt(\"return\", updateOrImport(context, path, source, destination, options));\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return _mfsWrite.apply(this, arguments);\n  }\n  return withTimeoutOption(mfsWrite);\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\nvar updateOrImport = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(context, path, source, destination, options) {\n    var child;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return write(context, source, destination, options);\n        case 2:\n          child = _context4.sent;\n          _context4.next = 5;\n          return createLock().writeLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n            var pathComponents, fileName, parentExists, updatedPath, trail, parent, parentBlock, parentNode, result, newRootCid;\n            return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  pathComponents = toPathComponents(path);\n                  fileName = pathComponents.pop();\n                  if (!(fileName == null)) {\n                    _context3.next = 4;\n                    break;\n                  }\n                  throw errCode(new Error('source does not exist'), 'ERR_NO_EXIST');\n                case 4:\n                  parentExists = false;\n                  _context3.prev = 5;\n                  _context3.next = 8;\n                  return createStat(context)(\"/\".concat(pathComponents.join('/')), options);\n                case 8:\n                  parentExists = true;\n                  _context3.next = 15;\n                  break;\n                case 11:\n                  _context3.prev = 11;\n                  _context3.t0 = _context3[\"catch\"](5);\n                  if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                    _context3.next = 15;\n                    break;\n                  }\n                  throw _context3.t0;\n                case 15:\n                  if (parentExists) {\n                    _context3.next = 18;\n                    break;\n                  }\n                  _context3.next = 18;\n                  return createMkdir(context)(\"/\".concat(pathComponents.join('/')), options);\n                case 18:\n                  _context3.next = 20;\n                  return toMfsPath(context, path, options);\n                case 20:\n                  updatedPath = _context3.sent;\n                  _context3.next = 23;\n                  return toTrail(context, updatedPath.mfsDirectory);\n                case 23:\n                  trail = _context3.sent;\n                  parent = trail[trail.length - 1];\n                  if (parent) {\n                    _context3.next = 27;\n                    break;\n                  }\n                  throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n                case 27:\n                  if (!(!parent.type || !parent.type.includes('directory'))) {\n                    _context3.next = 29;\n                    break;\n                  }\n                  throw errCode(new Error(\"cannot write to \".concat(parent.name, \": Not a directory\")), 'ERR_NOT_A_DIRECTORY');\n                case 29:\n                  _context3.next = 31;\n                  return context.repo.blocks.get(parent.cid);\n                case 31:\n                  parentBlock = _context3.sent;\n                  parentNode = decode(parentBlock);\n                  _context3.next = 35;\n                  return addLink(context, {\n                    parent: parentNode,\n                    name: fileName,\n                    cid: child.cid,\n                    size: child.size,\n                    flush: options.flush,\n                    shardSplitThreshold: options.shardSplitThreshold,\n                    hashAlg: options.hashAlg,\n                    cidVersion: options.cidVersion\n                  });\n                case 35:\n                  result = _context3.sent;\n                  parent.cid = result.cid;\n\n                  // update the tree with the new child\n                  _context3.next = 39;\n                  return updateTree(context, trail, options);\n                case 39:\n                  newRootCid = _context3.sent;\n                  _context3.next = 42;\n                  return updateMfsRoot(context, newRootCid, options);\n                case 42:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, _callee3, null, [[5, 11]]);\n          })))();\n        case 5:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function updateOrImport(_x6, _x7, _x8, _x9, _x10) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\nvar write = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(context, source, destination, options) {\n    var sources, extra, content, mode, mtime, hasher, result;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          if (destination.exists) {\n            log(\"Overwriting file \".concat(destination.cid, \" offset \").concat(options.offset, \" length \").concat(options.length));\n          } else {\n            log(\"Writing file offset \".concat(options.offset, \" length \").concat(options.length));\n          }\n\n          /** @type {Array<() => AsyncIterable<Uint8Array>>} */\n          sources = []; // pad start of file if necessary\n          if (options.offset > 0) {\n            if (destination.unixfs) {\n              log(\"Writing first \".concat(options.offset, \" bytes of original file\"));\n              sources.push(function () {\n                return destination.content({\n                  offset: 0,\n                  length: options.offset\n                });\n              });\n              if (destination.unixfs.fileSize() < options.offset) {\n                extra = options.offset - destination.unixfs.fileSize();\n                log(\"Writing zeros for extra \".concat(extra, \" bytes\"));\n                sources.push(asyncZeroes(extra));\n              }\n            } else {\n              log(\"Writing zeros for first \".concat(options.offset, \" bytes\"));\n              sources.push(asyncZeroes(options.offset));\n            }\n          }\n          sources.push(limitAsyncStreamBytes(source, options.length));\n          content = countBytesStreamed(catAsyncIterators(sources), function (bytesWritten) {\n            if (destination.unixfs && !options.truncate) {\n              // if we've done reading from the new source and we are not going\n              // to truncate the file, add the end of the existing file to the output\n              var fileSize = destination.unixfs.fileSize();\n              if (fileSize > bytesWritten) {\n                log(\"Writing last \".concat(fileSize - bytesWritten, \" of \").concat(fileSize, \" bytes from original file starting at offset \").concat(bytesWritten));\n                return destination.content({\n                  offset: bytesWritten\n                });\n              } else {\n                log('Not writing last bytes from original file');\n              }\n            }\n            return _defineProperty({}, Symbol.asyncIterator, _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n              return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                while (1) switch (_context5.prev = _context5.next) {\n                  case 0:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }, _callee5);\n            })));\n          });\n          /** @type {number | undefined} */\n          if (options.mode !== undefined && options.mode !== null) {\n            mode = parseMode(options.mode);\n          } else if (destination && destination.unixfs) {\n            mode = destination.unixfs.mode;\n          }\n\n          /** @type {import('ipfs-unixfs').Mtime | undefined} */\n\n          if (options.mtime != null) {\n            mtime = parseMtime(options.mtime);\n          } else if (destination && destination.unixfs) {\n            mtime = destination.unixfs.mtime;\n          }\n          _context6.next = 9;\n          return context.hashers.getHasher(options.hashAlg);\n        case 9:\n          hasher = _context6.sent;\n          _context6.next = 12;\n          return last(importer([{\n            content: content,\n            // persist mode & mtime if set previously\n            mode: mode,\n            mtime: mtime\n          }], context.repo.blocks, {\n            progress: options.progress,\n            hasher: hasher,\n            cidVersion: options.cidVersion,\n            strategy: options.strategy,\n            rawLeaves: options.rawLeaves,\n            reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n            leafType: options.leafType\n          }));\n        case 12:\n          result = _context6.sent;\n          if (result) {\n            _context6.next = 15;\n            break;\n          }\n          throw errCode(new Error(\"cannot write to \".concat(parent.name)), 'ERR_COULD_NOT_WRITE');\n        case 15:\n          log(\"Wrote \".concat(result.cid));\n          return _context6.abrupt(\"return\", {\n            cid: result.cid,\n            size: result.size\n          });\n        case 17:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return function write(_x11, _x12, _x13, _x14) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {AsyncIterable<Uint8Array>} stream\n * @param {number} limit\n */\nvar limitAsyncStreamBytes = function limitAsyncStreamBytes(stream, limit) {\n  return /*#__PURE__*/function () {\n    var _limitAsyncStreamBytes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      var emitted, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, buf;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            emitted = 0;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context7.prev = 3;\n            _iterator = _asyncIterator(stream);\n          case 5:\n            _context7.next = 7;\n            return _awaitAsyncGenerator(_iterator.next());\n          case 7:\n            if (!(_iteratorAbruptCompletion = !(_step = _context7.sent).done)) {\n              _context7.next = 19;\n              break;\n            }\n            buf = _step.value;\n            emitted += buf.length;\n            if (!(emitted > limit)) {\n              _context7.next = 14;\n              break;\n            }\n            _context7.next = 13;\n            return buf.slice(0, limit - emitted);\n          case 13:\n            return _context7.abrupt(\"return\");\n          case 14:\n            _context7.next = 16;\n            return buf;\n          case 16:\n            _iteratorAbruptCompletion = false;\n            _context7.next = 5;\n            break;\n          case 19:\n            _context7.next = 25;\n            break;\n          case 21:\n            _context7.prev = 21;\n            _context7.t0 = _context7[\"catch\"](3);\n            _didIteratorError = true;\n            _iteratorError = _context7.t0;\n          case 25:\n            _context7.prev = 25;\n            _context7.prev = 26;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context7.next = 30;\n              break;\n            }\n            _context7.next = 30;\n            return _awaitAsyncGenerator(_iterator.return());\n          case 30:\n            _context7.prev = 30;\n            if (!_didIteratorError) {\n              _context7.next = 33;\n              break;\n            }\n            throw _iteratorError;\n          case 33:\n            return _context7.finish(30);\n          case 34:\n            return _context7.finish(25);\n          case 35:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7, null, [[3, 21, 25, 35], [26,, 30, 34]]);\n    }));\n    function _limitAsyncStreamBytes() {\n      return _limitAsyncStreamBytes2.apply(this, arguments);\n    }\n    return _limitAsyncStreamBytes;\n  }();\n};\n\n/**\n * @param {number} count\n * @param {number} chunkSize\n */\nvar asyncZeroes = function asyncZeroes(count) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MFS_MAX_CHUNK_SIZE;\n  var buf = new Uint8Array(chunkSize);\n  function _asyncZeroes() {\n    return _asyncZeroes2.apply(this, arguments);\n  }\n  function _asyncZeroes2() {\n    _asyncZeroes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!true) {\n              _context8.next = 5;\n              break;\n            }\n            _context8.next = 3;\n            return buf.slice();\n          case 3:\n            _context8.next = 0;\n            break;\n          case 5:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8);\n    }));\n    return _asyncZeroes2.apply(this, arguments);\n  }\n  return limitAsyncStreamBytes(_asyncZeroes(), count);\n};\n\n/**\n * @param {Array<() => AsyncIterable<Uint8Array>>} sources\n */\nvar catAsyncIterators = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(sources) {\n    var i;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          i = 0;\n        case 1:\n          if (!(i < sources.length)) {\n            _context9.next = 6;\n            break;\n          }\n          return _context9.delegateYield(_asyncGeneratorDelegate(_asyncIterator(sources[i]()), _awaitAsyncGenerator), \"t0\", 3);\n        case 3:\n          i++;\n          _context9.next = 1;\n          break;\n        case 6:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9);\n  }));\n  return function catAsyncIterators(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {AsyncIterable<Uint8Array>} source\n * @param {(count: number) => AsyncIterable<Uint8Array>} notify\n */\nvar countBytesStreamed = /*#__PURE__*/function () {\n  var _ref3 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(source, notify) {\n    var wrote, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, buf, _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _buf;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          wrote = 0;\n          _iteratorAbruptCompletion2 = false;\n          _didIteratorError2 = false;\n          _context10.prev = 3;\n          _iterator2 = _asyncIterator(source);\n        case 5:\n          _context10.next = 7;\n          return _awaitAsyncGenerator(_iterator2.next());\n        case 7:\n          if (!(_iteratorAbruptCompletion2 = !(_step2 = _context10.sent).done)) {\n            _context10.next = 15;\n            break;\n          }\n          buf = _step2.value;\n          wrote += buf.length;\n          _context10.next = 12;\n          return buf;\n        case 12:\n          _iteratorAbruptCompletion2 = false;\n          _context10.next = 5;\n          break;\n        case 15:\n          _context10.next = 21;\n          break;\n        case 17:\n          _context10.prev = 17;\n          _context10.t0 = _context10[\"catch\"](3);\n          _didIteratorError2 = true;\n          _iteratorError2 = _context10.t0;\n        case 21:\n          _context10.prev = 21;\n          _context10.prev = 22;\n          if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n            _context10.next = 26;\n            break;\n          }\n          _context10.next = 26;\n          return _awaitAsyncGenerator(_iterator2.return());\n        case 26:\n          _context10.prev = 26;\n          if (!_didIteratorError2) {\n            _context10.next = 29;\n            break;\n          }\n          throw _iteratorError2;\n        case 29:\n          return _context10.finish(26);\n        case 30:\n          return _context10.finish(21);\n        case 31:\n          _iteratorAbruptCompletion3 = false;\n          _didIteratorError3 = false;\n          _context10.prev = 33;\n          _iterator3 = _asyncIterator(notify(wrote));\n        case 35:\n          _context10.next = 37;\n          return _awaitAsyncGenerator(_iterator3.next());\n        case 37:\n          if (!(_iteratorAbruptCompletion3 = !(_step3 = _context10.sent).done)) {\n            _context10.next = 45;\n            break;\n          }\n          _buf = _step3.value;\n          wrote += _buf.length;\n          _context10.next = 42;\n          return _buf;\n        case 42:\n          _iteratorAbruptCompletion3 = false;\n          _context10.next = 35;\n          break;\n        case 45:\n          _context10.next = 51;\n          break;\n        case 47:\n          _context10.prev = 47;\n          _context10.t1 = _context10[\"catch\"](33);\n          _didIteratorError3 = true;\n          _iteratorError3 = _context10.t1;\n        case 51:\n          _context10.prev = 51;\n          _context10.prev = 52;\n          if (!(_iteratorAbruptCompletion3 && _iterator3.return != null)) {\n            _context10.next = 56;\n            break;\n          }\n          _context10.next = 56;\n          return _awaitAsyncGenerator(_iterator3.return());\n        case 56:\n          _context10.prev = 56;\n          if (!_didIteratorError3) {\n            _context10.next = 59;\n            break;\n          }\n          throw _iteratorError3;\n        case 59:\n          return _context10.finish(56);\n        case 60:\n          return _context10.finish(51);\n        case 61:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee10, null, [[3, 17, 21, 31], [22,, 26, 30], [33, 47, 51, 61], [52,, 56, 60]]);\n  }));\n  return function countBytesStreamed(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["logger","importer","decode","createStat","createMkdir","addLink","mergeOpts","createLock","toAsyncIterator","toMfsPath","toPathComponents","toTrail","updateTree","updateMfsRoot","errCode","MFS_MAX_CHUNK_SIZE","last","withTimeoutOption","parseMode","parseMtime","mergeOptions","bind","ignoreUndefined","log","defaultOptions","offset","length","Infinity","create","truncate","rawLeaves","reduceSingleLeafToSelf","cidVersion","hashAlg","parents","progress","bytes","path","strategy","flush","leafType","shardSplitThreshold","createWrite","context","mfsWrite","_x4","_x5","_mfsWrite","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","content","opts","options","source","destination","parent","_args2","wrap","_callee2$","_context2","prev","next","undefined","readLock","_callee","_callee$","_context","sent","mfsDirectory","stop","exists","Error","entryType","abrupt","updateOrImport","_ref5","_callee4","child","_callee4$","_context4","write","writeLock","_callee3","pathComponents","fileName","parentExists","updatedPath","trail","parentBlock","parentNode","result","newRootCid","_callee3$","_context3","pop","concat","join","t0","code","type","includes","name","repo","blocks","get","cid","size","_x6","_x7","_x8","_x9","_x10","_ref7","_callee6","sources","extra","mode","mtime","hasher","_callee6$","_context6","unixfs","push","fileSize","asyncZeroes","limitAsyncStreamBytes","countBytesStreamed","catAsyncIterators","bytesWritten","_defineProperty","Symbol","asyncIterator","_wrapAsyncGenerator","_callee5","_callee5$","_context5","hashers","getHasher","_x11","_x12","_x13","_x14","stream","limit","_limitAsyncStreamBytes2","_callee7","emitted","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","buf","_callee7$","_context7","_asyncIterator","_awaitAsyncGenerator","done","value","slice","return","finish","_limitAsyncStreamBytes","count","chunkSize","Uint8Array","_asyncZeroes","_asyncZeroes2","_callee8","_callee8$","_context8","_ref2","_callee9","i","_callee9$","_context9","delegateYield","_asyncGeneratorDelegate","_x","_ref3","_callee10","notify","wrote","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_iteratorAbruptCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_buf","_callee10$","_context10","t1","_x2","_x3"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/write.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { importer } from 'ipfs-unixfs-importer'\nimport {\n  decode\n} from '@ipld/dag-pb'\nimport { createStat } from './stat.js'\nimport { createMkdir } from './mkdir.js'\nimport { addLink } from './utils/add-link.js'\nimport mergeOpts from 'merge-options'\nimport { createLock } from './utils/create-lock.js'\nimport { toAsyncIterator } from './utils/to-async-iterator.js'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { toPathComponents } from './utils/to-path-components.js'\nimport { toTrail } from './utils/to-trail.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport errCode from 'err-code'\nimport {\n  MFS_MAX_CHUNK_SIZE\n} from '../../utils.js'\nimport last from 'it-last'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport {\n  parseMode,\n  parseMtime\n} from 'ipfs-unixfs'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:write')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('./utils/to-mfs-path').FilePath} FilePath\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {object} DefaultOptions\n * @property {number} offset\n * @property {number} length\n * @property {boolean} create\n * @property {boolean} truncate\n * @property {boolean} rawLeaves\n * @property {boolean} reduceSingleLeafToSelf\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} parents\n * @property {import('ipfs-core-types/src/root').AddProgressFn} progress\n * @property {'trickle' | 'balanced'} strategy\n * @property {boolean} flush\n * @property {'raw' | 'file'} leafType\n * @property {number} shardSplitThreshold\n * @property {MtimeLike} [mtime]\n * @property {number} [mode]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  offset: 0, // the offset in the file to begin writing\n  length: Infinity, // how many bytes from the incoming buffer to write\n  create: false, // whether to create the file if it does not exist\n  truncate: false, // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false, // whether to create intermediate directories if they do not exist\n  progress: (bytes, path) => {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createWrite (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"write\"]}\n   */\n  async function mfsWrite (path, content, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    /** @type {AsyncIterable<Uint8Array>} */\n    let source\n    /** @type {MfsPath} */\n    let destination\n    /** @type {MfsPath} */\n    let parent\n    log('Reading source, destination and parent')\n    await createLock().readLock(async () => {\n      source = await toAsyncIterator(content)\n      destination = await toMfsPath(context, path, options)\n      parent = await toMfsPath(context, destination.mfsDirectory, options)\n    })()\n    log('Read source, destination and parent')\n    // @ts-expect-error - parent may be undefined\n    if (!options.parents && !parent.exists) {\n      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST')\n    }\n\n    // @ts-expect-error\n    if (source == null) {\n      throw errCode(new Error('could not create source'), 'ERR_NO_SOURCE')\n    }\n\n    // @ts-expect-error\n    if (destination == null) {\n      throw errCode(new Error('could not create destination'), 'ERR_NO_DESTINATION')\n    }\n\n    if (!options.create && !destination.exists) {\n      throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST')\n    }\n\n    if (destination.entryType !== 'file') {\n      throw errCode(new Error('not a file'), 'ERR_NOT_A_FILE')\n    }\n\n    return updateOrImport(context, path, source, destination, options)\n  }\n\n  return withTimeoutOption(mfsWrite)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\nconst updateOrImport = async (context, path, source, destination, options) => {\n  const child = await write(context, source, destination, options)\n\n  // The slow bit is done, now add or replace the DAGLink in the containing directory\n  // re-reading the path to the containing folder in case it has changed in the interim\n  await createLock().writeLock(async () => {\n    const pathComponents = toPathComponents(path)\n    const fileName = pathComponents.pop()\n\n    if (fileName == null) {\n      throw errCode(new Error('source does not exist'), 'ERR_NO_EXIST')\n    }\n\n    let parentExists = false\n\n    try {\n      await createStat(context)(`/${pathComponents.join('/')}`, options)\n      parentExists = true\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    if (!parentExists) {\n      await createMkdir(context)(`/${pathComponents.join('/')}`, options)\n    }\n\n    // get an updated mfs path in case the root changed while we were writing\n    const updatedPath = await toMfsPath(context, path, options)\n    const trail = await toTrail(context, updatedPath.mfsDirectory)\n    const parent = trail[trail.length - 1]\n\n    if (!parent) {\n      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST')\n    }\n\n    if (!parent.type || !parent.type.includes('directory')) {\n      throw errCode(new Error(`cannot write to ${parent.name}: Not a directory`), 'ERR_NOT_A_DIRECTORY')\n    }\n\n    const parentBlock = await context.repo.blocks.get(parent.cid)\n    const parentNode = decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: fileName,\n      cid: child.cid,\n      size: child.size,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, options)\n  })()\n}\n\n/**\n * @param {MfsContext} context\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\nconst write = async (context, source, destination, options) => {\n  if (destination.exists) {\n    log(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`)\n  } else {\n    log(`Writing file offset ${options.offset} length ${options.length}`)\n  }\n\n  /** @type {Array<() => AsyncIterable<Uint8Array>>} */\n  const sources = []\n\n  // pad start of file if necessary\n  if (options.offset > 0) {\n    if (destination.unixfs) {\n      log(`Writing first ${options.offset} bytes of original file`)\n\n      sources.push(\n        () => {\n          return destination.content({\n            offset: 0,\n            length: options.offset\n          })\n        }\n      )\n\n      if (destination.unixfs.fileSize() < options.offset) {\n        const extra = options.offset - destination.unixfs.fileSize()\n\n        log(`Writing zeros for extra ${extra} bytes`)\n        sources.push(\n          asyncZeroes(extra)\n        )\n      }\n    } else {\n      log(`Writing zeros for first ${options.offset} bytes`)\n      sources.push(\n        asyncZeroes(options.offset)\n      )\n    }\n  }\n\n  sources.push(\n    limitAsyncStreamBytes(source, options.length)\n  )\n\n  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {\n    if (destination.unixfs && !options.truncate) {\n      // if we've done reading from the new source and we are not going\n      // to truncate the file, add the end of the existing file to the output\n      const fileSize = destination.unixfs.fileSize()\n\n      if (fileSize > bytesWritten) {\n        log(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`)\n\n        return destination.content({\n          offset: bytesWritten\n        })\n      } else {\n        log('Not writing last bytes from original file')\n      }\n    }\n\n    return {\n      [Symbol.asyncIterator]: async function * () {}\n    }\n  })\n\n  /** @type {number | undefined} */\n  let mode\n\n  if (options.mode !== undefined && options.mode !== null) {\n    mode = parseMode(options.mode)\n  } else if (destination && destination.unixfs) {\n    mode = destination.unixfs.mode\n  }\n\n  /** @type {import('ipfs-unixfs').Mtime | undefined} */\n  let mtime\n\n  if (options.mtime != null) {\n    mtime = parseMtime(options.mtime)\n  } else if (destination && destination.unixfs) {\n    mtime = destination.unixfs.mtime\n  }\n\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n\n  const result = await last(importer([{\n    content: content,\n\n    // persist mode & mtime if set previously\n    mode,\n    mtime\n  }], context.repo.blocks, {\n    progress: options.progress,\n    hasher,\n    cidVersion: options.cidVersion,\n    strategy: options.strategy,\n    rawLeaves: options.rawLeaves,\n    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n    leafType: options.leafType\n  }))\n\n  if (!result) {\n    throw errCode(new Error(`cannot write to ${parent.name}`), 'ERR_COULD_NOT_WRITE')\n  }\n\n  log(`Wrote ${result.cid}`)\n\n  return {\n    cid: result.cid,\n    size: result.size\n  }\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} stream\n * @param {number} limit\n */\nconst limitAsyncStreamBytes = (stream, limit) => {\n  return async function * _limitAsyncStreamBytes () {\n    let emitted = 0\n\n    for await (const buf of stream) {\n      emitted += buf.length\n\n      if (emitted > limit) {\n        yield buf.slice(0, limit - emitted)\n\n        return\n      }\n\n      yield buf\n    }\n  }\n}\n\n/**\n * @param {number} count\n * @param {number} chunkSize\n */\nconst asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {\n  const buf = new Uint8Array(chunkSize)\n\n  async function * _asyncZeroes () {\n    while (true) {\n      yield buf.slice()\n    }\n  }\n\n  return limitAsyncStreamBytes(_asyncZeroes(), count)\n}\n\n/**\n * @param {Array<() => AsyncIterable<Uint8Array>>} sources\n */\nconst catAsyncIterators = async function * (sources) { // eslint-disable-line require-await\n  for (let i = 0; i < sources.length; i++) {\n    yield * sources[i]()\n  }\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} source\n * @param {(count: number) => AsyncIterable<Uint8Array>} notify\n */\nconst countBytesStreamed = async function * (source, notify) {\n  let wrote = 0\n\n  for await (const buf of source) {\n    wrote += buf.length\n\n    yield buf\n  }\n\n  for await (const buf of notify(wrote)) {\n    wrote += buf.length\n\n    yield buf\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}