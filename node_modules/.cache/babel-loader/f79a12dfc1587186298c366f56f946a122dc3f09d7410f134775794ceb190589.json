{"ast":null,"code":"import _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)\n */\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { VisibilityChangeEmitter } from './visibility-change-emitter.js';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:connection-manager:latency-monitor');\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * @extends {EventEmitter}\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nexport var LatencyMonitor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(LatencyMonitor, _EventEmitter);\n  var _super = _createSuper(LatencyMonitor);\n  function LatencyMonitor() {\n    var _globalThis$process, _window$performance;\n    var _this;\n    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, LatencyMonitor);\n    _this = _super.call(this);\n    var latencyCheckIntervalMs = init.latencyCheckIntervalMs,\n      dataEmitIntervalMs = init.dataEmitIntervalMs,\n      asyncTestFn = init.asyncTestFn,\n      latencyRandomPercentage = init.latencyRandomPercentage;\n    // 0 isn't valid here, so its ok to use ||\n    _this.latencyCheckIntervalMs = latencyCheckIntervalMs !== null && latencyCheckIntervalMs !== void 0 ? latencyCheckIntervalMs : 500; // 0.5s\n    _this.latencyRandomPercentage = latencyRandomPercentage !== null && latencyRandomPercentage !== void 0 ? latencyRandomPercentage : 10;\n    _this.latencyCheckMultiply = 2 * (_this.latencyRandomPercentage / 100.0) * _this.latencyCheckIntervalMs;\n    _this.latencyCheckSubtract = _this.latencyCheckMultiply / 2;\n    _this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs !== null && dataEmitIntervalMs !== void 0 ? dataEmitIntervalMs : 5 * 1000; // 5s\n    log('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', _this.latencyCheckIntervalMs, _this.dataEmitIntervalMs);\n    if (_this.dataEmitIntervalMs != null) {\n      log('Expecting ~%s events per summary', _this.latencyCheckIntervalMs / _this.dataEmitIntervalMs);\n    } else {\n      log('Not emitting summaries');\n    }\n    _this.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n    // If process: use high resolution timer\n    if (((_globalThis$process = globalThis.process) === null || _globalThis$process === void 0 ? void 0 : _globalThis$process.hrtime) != null) {\n      log('Using process.hrtime for timing');\n      _this.now = globalThis.process.hrtime; // eslint-disable-line no-undef\n      _this.getDeltaMS = function (startTime) {\n        var hrtime = _this.now(startTime);\n        return hrtime[0] * 1000 + hrtime[1] / 1000000;\n      };\n      // Let's try for a timer that only monotonically increases\n    } else if (typeof window !== 'undefined' && ((_window$performance = window.performance) === null || _window$performance === void 0 ? void 0 : _window$performance.now) != null) {\n      log('Using performance.now for timing');\n      _this.now = window.performance.now.bind(window.performance);\n      _this.getDeltaMS = function (startTime) {\n        return Math.round(_this.now() - startTime);\n      };\n    } else {\n      log('Using Date.now for timing');\n      _this.now = Date.now;\n      _this.getDeltaMS = function (startTime) {\n        return _this.now() - startTime;\n      };\n    }\n    _this.latencyData = _this.initLatencyData();\n    return _this;\n  }\n  _createClass(LatencyMonitor, [{\n    key: \"start\",\n    value: function start() {\n      var _this2 = this,\n        _this$visibilityChang;\n      // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n      // so we fall back to another library\n      // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n      if (isBrowser()) {\n        this.visibilityChangeEmitter = new VisibilityChangeEmitter();\n        this.visibilityChangeEmitter.addEventListener('visibilityChange', function (evt) {\n          var pageInFocus = evt.detail;\n          if (pageInFocus) {\n            _this2._startTimers();\n          } else {\n            _this2._emitSummary();\n            _this2._stopTimers();\n          }\n        });\n      }\n      if (((_this$visibilityChang = this.visibilityChangeEmitter) === null || _this$visibilityChang === void 0 ? void 0 : _this$visibilityChang.isVisible()) === true) {\n        this._startTimers();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stopTimers();\n    }\n    /**\n     * Start internal timers\n     *\n     * @private\n     */\n  }, {\n    key: \"_startTimers\",\n    value: function _startTimers() {\n      var _this3 = this;\n      // Timer already started, ignore this\n      if (this.checkLatencyID != null) {\n        return;\n      }\n      this.checkLatency();\n      if (this.dataEmitIntervalMs != null) {\n        this.emitIntervalID = setInterval(function () {\n          return _this3._emitSummary();\n        }, this.dataEmitIntervalMs);\n        if (typeof this.emitIntervalID.unref === 'function') {\n          this.emitIntervalID.unref(); // Doesn't block exit\n        }\n      }\n    }\n    /**\n     * Stop internal timers\n     *\n     * @private\n     */\n  }, {\n    key: \"_stopTimers\",\n    value: function _stopTimers() {\n      if (this.checkLatencyID != null) {\n        clearTimeout(this.checkLatencyID);\n        this.checkLatencyID = undefined;\n      }\n      if (this.emitIntervalID != null) {\n        clearInterval(this.emitIntervalID);\n        this.emitIntervalID = undefined;\n      }\n    }\n    /**\n     * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n     *\n     * @private\n     */\n  }, {\n    key: \"_emitSummary\",\n    value: function _emitSummary() {\n      var summary = this.getSummary();\n      if (summary.events > 0) {\n        this.dispatchEvent(new CustomEvent('data', {\n          detail: summary\n        }));\n      }\n    }\n    /**\n     * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n     * it will not count for this time period\n     */\n  }, {\n    key: \"getSummary\",\n    value: function getSummary() {\n      // We might want to adjust for the number of expected events\n      // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n      // Then this fires - looks like no latency!!\n      var latency = {\n        events: this.latencyData.events,\n        minMs: this.latencyData.minMs,\n        maxMs: this.latencyData.maxMs,\n        avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,\n        lengthMs: this.getDeltaMS(this.latencyData.startTime)\n      };\n      this.latencyData = this.initLatencyData(); // Clear\n      log.trace('Summary: %O', latency);\n      return latency;\n    }\n    /**\n     * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n     * it will simply report on event loop latency.\n     */\n  }, {\n    key: \"checkLatency\",\n    value: function checkLatency() {\n      var _this4 = this;\n      // Randomness is needed to avoid alignment by accident to regular things in the event loop\n      var randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract;\n      // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n      var localData = {\n        deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),\n        startTime: this.now()\n      };\n      var cb = function cb() {\n        // We are already stopped, ignore this datapoint\n        if (_this4.checkLatencyID == null) {\n          return;\n        }\n        var deltaMS = _this4.getDeltaMS(localData.startTime) - localData.deltaOffset;\n        _this4.checkLatency(); // Start again ASAP\n        // Add the data point. If this gets complex, refactor it\n        _this4.latencyData.events++;\n        _this4.latencyData.minMs = Math.min(_this4.latencyData.minMs, deltaMS);\n        _this4.latencyData.maxMs = Math.max(_this4.latencyData.maxMs, deltaMS);\n        _this4.latencyData.totalMs += deltaMS;\n        log.trace('MS: %s Data: %O', deltaMS, _this4.latencyData);\n      };\n      log.trace('localData: %O', localData);\n      this.checkLatencyID = setTimeout(function () {\n        // This gets rid of including event loop\n        if (_this4.asyncTestFn != null) {\n          // Clear timing related things\n          localData.deltaOffset = 0;\n          localData.startTime = _this4.now();\n          _this4.asyncTestFn(cb);\n        } else {\n          // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n          // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n          localData.deltaOffset -= 1;\n          // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n          // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n          cb();\n        }\n      }, localData.deltaOffset);\n      if (typeof this.checkLatencyID.unref === 'function') {\n        this.checkLatencyID.unref(); // Doesn't block exit\n      }\n    }\n  }, {\n    key: \"initLatencyData\",\n    value: function initLatencyData() {\n      return {\n        startTime: this.now(),\n        minMs: Number.POSITIVE_INFINITY,\n        maxMs: Number.NEGATIVE_INFINITY,\n        events: 0,\n        totalMs: 0\n      };\n    }\n  }]);\n  return LatencyMonitor;\n}(EventEmitter);\nfunction isBrowser() {\n  return typeof globalThis.window !== 'undefined';\n}","map":{"version":3,"names":["CustomEvent","EventEmitter","VisibilityChangeEmitter","logger","log","LatencyMonitor","_EventEmitter","_inherits","_super","_createSuper","_globalThis$process","_window$performance","_this","init","arguments","length","undefined","_classCallCheck","call","latencyCheckIntervalMs","dataEmitIntervalMs","asyncTestFn","latencyRandomPercentage","latencyCheckMultiply","latencyCheckSubtract","globalThis","process","hrtime","now","getDeltaMS","startTime","window","performance","bind","Math","round","Date","latencyData","initLatencyData","_createClass","key","value","start","_this2","_this$visibilityChang","isBrowser","visibilityChangeEmitter","addEventListener","evt","pageInFocus","detail","_startTimers","_emitSummary","_stopTimers","isVisible","stop","_this3","checkLatencyID","checkLatency","emitIntervalID","setInterval","unref","clearTimeout","clearInterval","summary","getSummary","events","dispatchEvent","latency","minMs","maxMs","avgMs","totalMs","Number","POSITIVE_INFINITY","lengthMs","trace","_this4","randomness","random","localData","deltaOffset","ceil","cb","deltaMS","min","max","setTimeout","NEGATIVE_INFINITY"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/connection-manager/latency-monitor.ts"],"sourcesContent":["/**\n * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)\n */\n\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport { VisibilityChangeEmitter } from './visibility-change-emitter.js'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('libp2p:connection-manager:latency-monitor')\n\nexport interface LatencyMonitorEvents {\n  'data': CustomEvent<SummaryObject>\n}\n\nexport interface LatencyMonitorInit {\n  /**\n   * How often to add a latency check event (ms)\n   */\n  latencyCheckIntervalMs?: number\n\n  /**\n   * How often to summarize latency check events. null or 0 disables event firing\n   */\n  dataEmitIntervalMs?: number\n\n  /**\n   * What cb-style async function to use\n   */\n  asyncTestFn?: (cb: () => void) => void\n\n  /**\n   * What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n   */\n  latencyRandomPercentage?: number\n}\n\nexport interface SummaryObject {\n  /**\n   * How many events were called\n   */\n  events: number\n\n  /**\n   * What was the min time for a cb to be called\n   */\n  minMs: number\n\n  /**\n   * What was the max time for a cb to be called\n   */\n  maxMs: number\n\n  /**\n   * What was the average time for a cb to be called\n   */\n  avgMs: number\n\n  /**\n   * How long this interval was in ms\n   */\n  lengthMs: number\n}\n\ninterface LatencyData {\n  startTime: number\n  events: number\n  minMs: number\n  maxMs: number\n  totalMs: number\n}\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * @extends {EventEmitter}\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nexport class LatencyMonitor extends EventEmitter<LatencyMonitorEvents> {\n  private readonly latencyCheckIntervalMs: number\n  private readonly latencyRandomPercentage: number\n  private readonly latencyCheckMultiply: number\n  private readonly latencyCheckSubtract: number\n  private readonly dataEmitIntervalMs?: number\n  private readonly asyncTestFn?: (cb: () => void) => void\n\n  private readonly now: (num?: any) => any\n  private readonly getDeltaMS: (num: number) => number\n  private visibilityChangeEmitter?: VisibilityChangeEmitter\n  private latencyData: LatencyData\n  private checkLatencyID?: NodeJS.Timeout\n  private emitIntervalID?: NodeJS.Timeout\n\n  constructor (init: LatencyMonitorInit = {}) {\n    super()\n\n    const { latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = init\n\n    // 0 isn't valid here, so its ok to use ||\n    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500 // 0.5s\n    this.latencyRandomPercentage = latencyRandomPercentage ?? 10\n    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100.0) * this.latencyCheckIntervalMs\n    this.latencyCheckSubtract = this.latencyCheckMultiply / 2\n\n    this.dataEmitIntervalMs = (dataEmitIntervalMs === null || dataEmitIntervalMs === 0)\n      ? undefined\n      : dataEmitIntervalMs ?? 5 * 1000 // 5s\n    log('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s',\n      this.latencyCheckIntervalMs, this.dataEmitIntervalMs)\n    if (this.dataEmitIntervalMs != null) {\n      log('Expecting ~%s events per summary', this.latencyCheckIntervalMs / this.dataEmitIntervalMs)\n    } else {\n      log('Not emitting summaries')\n    }\n\n    this.asyncTestFn = asyncTestFn // If there is no asyncFn, we measure latency\n\n    // If process: use high resolution timer\n    if (globalThis.process?.hrtime != null) {\n      log('Using process.hrtime for timing')\n      this.now = globalThis.process.hrtime // eslint-disable-line no-undef\n      this.getDeltaMS = (startTime) => {\n        const hrtime = this.now(startTime)\n        return (hrtime[0] * 1000) + (hrtime[1] / 1000000)\n      }\n      // Let's try for a timer that only monotonically increases\n    } else if (typeof window !== 'undefined' && window.performance?.now != null) {\n      log('Using performance.now for timing')\n      this.now = window.performance.now.bind(window.performance)\n      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime)\n    } else {\n      log('Using Date.now for timing')\n      this.now = Date.now\n      this.getDeltaMS = (startTime) => this.now() - startTime\n    }\n\n    this.latencyData = this.initLatencyData()\n  }\n\n  start () {\n    // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n    // so we fall back to another library\n    // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n    if (isBrowser()) {\n      this.visibilityChangeEmitter = new VisibilityChangeEmitter()\n\n      this.visibilityChangeEmitter.addEventListener('visibilityChange', (evt) => {\n        const { detail: pageInFocus } = evt\n\n        if (pageInFocus) {\n          this._startTimers()\n        } else {\n          this._emitSummary()\n          this._stopTimers()\n        }\n      })\n    }\n\n    if (this.visibilityChangeEmitter?.isVisible() === true) {\n      this._startTimers()\n    }\n  }\n\n  stop () {\n    this._stopTimers()\n  }\n\n  /**\n   * Start internal timers\n   *\n   * @private\n   */\n  _startTimers () {\n    // Timer already started, ignore this\n    if (this.checkLatencyID != null) {\n      return\n    }\n\n    this.checkLatency()\n\n    if (this.dataEmitIntervalMs != null) {\n      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs)\n      if (typeof this.emitIntervalID.unref === 'function') {\n        this.emitIntervalID.unref() // Doesn't block exit\n      }\n    }\n  }\n\n  /**\n   * Stop internal timers\n   *\n   * @private\n   */\n  _stopTimers () {\n    if (this.checkLatencyID != null) {\n      clearTimeout(this.checkLatencyID)\n      this.checkLatencyID = undefined\n    }\n    if (this.emitIntervalID != null) {\n      clearInterval(this.emitIntervalID)\n      this.emitIntervalID = undefined\n    }\n  }\n\n  /**\n   * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n   *\n   * @private\n   */\n  _emitSummary () {\n    const summary = this.getSummary()\n    if (summary.events > 0) {\n      this.dispatchEvent(new CustomEvent<SummaryObject>('data', {\n        detail: summary\n      }))\n    }\n  }\n\n  /**\n   * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n   * it will not count for this time period\n   */\n  getSummary (): SummaryObject {\n    // We might want to adjust for the number of expected events\n    // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n    // Then this fires - looks like no latency!!\n    const latency = {\n      events: this.latencyData.events,\n      minMs: this.latencyData.minMs,\n      maxMs: this.latencyData.maxMs,\n      avgMs: this.latencyData.events > 0\n        ? this.latencyData.totalMs / this.latencyData.events\n        : Number.POSITIVE_INFINITY,\n      lengthMs: this.getDeltaMS(this.latencyData.startTime)\n    }\n    this.latencyData = this.initLatencyData() // Clear\n\n    log.trace('Summary: %O', latency)\n    return latency\n  }\n\n  /**\n   * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n   * it will simply report on event loop latency.\n   */\n  checkLatency () {\n    // Randomness is needed to avoid alignment by accident to regular things in the event loop\n    const randomness = (Math.random() * this.latencyCheckMultiply) - this.latencyCheckSubtract\n\n    // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n    const localData = {\n      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),\n      startTime: this.now()\n    }\n\n    const cb = () => {\n      // We are already stopped, ignore this datapoint\n      if (this.checkLatencyID == null) {\n        return\n      }\n      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset\n      this.checkLatency() // Start again ASAP\n\n      // Add the data point. If this gets complex, refactor it\n      this.latencyData.events++\n      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS)\n      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS)\n      this.latencyData.totalMs += deltaMS\n      log.trace('MS: %s Data: %O', deltaMS, this.latencyData)\n    }\n    log.trace('localData: %O', localData)\n\n    this.checkLatencyID = setTimeout(() => {\n      // This gets rid of including event loop\n      if (this.asyncTestFn != null) {\n        // Clear timing related things\n        localData.deltaOffset = 0\n        localData.startTime = this.now()\n        this.asyncTestFn(cb)\n      } else {\n        // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n        // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n        localData.deltaOffset -= 1\n        // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n        // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n        cb()\n      }\n    }, localData.deltaOffset)\n\n    if (typeof this.checkLatencyID.unref === 'function') {\n      this.checkLatencyID.unref() // Doesn't block exit\n    }\n  }\n\n  initLatencyData (): LatencyData {\n    return {\n      startTime: this.now(),\n      minMs: Number.POSITIVE_INFINITY,\n      maxMs: Number.NEGATIVE_INFINITY,\n      events: 0,\n      totalMs: 0\n    }\n  }\n}\n\nfunction isBrowser () {\n  return typeof globalThis.window !== 'undefined'\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}