{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { encodeMessage, decodeMessage, message, enumeration } from 'protons-runtime';\nexport var Record;\n(function (Record) {\n  var _codec;\n  Record.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.key != null) {\n          writer.uint32(10);\n          writer.bytes(obj.key);\n        }\n        if (obj.value != null) {\n          writer.uint32(18);\n          writer.bytes(obj.value);\n        }\n        if (obj.author != null) {\n          writer.uint32(26);\n          writer.bytes(obj.author);\n        }\n        if (obj.signature != null) {\n          writer.uint32(34);\n          writer.bytes(obj.signature);\n        }\n        if (obj.timeReceived != null) {\n          writer.uint32(42);\n          writer.string(obj.timeReceived);\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var obj = {};\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.bytes();\n              break;\n            case 2:\n              obj.value = reader.bytes();\n              break;\n            case 3:\n              obj.author = reader.bytes();\n              break;\n            case 4:\n              obj.signature = reader.bytes();\n              break;\n            case 5:\n              obj.timeReceived = reader.string();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Record.encode = function (obj) {\n    return encodeMessage(obj, Record.codec());\n  };\n  Record.decode = function (buf) {\n    return decodeMessage(buf, Record.codec());\n  };\n})(Record || (Record = {}));\nexport var Message;\n(function (Message) {\n  var MessageType;\n  (function (MessageType) {\n    MessageType[\"PUT_VALUE\"] = \"PUT_VALUE\";\n    MessageType[\"GET_VALUE\"] = \"GET_VALUE\";\n    MessageType[\"ADD_PROVIDER\"] = \"ADD_PROVIDER\";\n    MessageType[\"GET_PROVIDERS\"] = \"GET_PROVIDERS\";\n    MessageType[\"FIND_NODE\"] = \"FIND_NODE\";\n    MessageType[\"PING\"] = \"PING\";\n  })(MessageType = Message.MessageType || (Message.MessageType = {}));\n  var __MessageTypeValues;\n  (function (__MessageTypeValues) {\n    __MessageTypeValues[__MessageTypeValues[\"PUT_VALUE\"] = 0] = \"PUT_VALUE\";\n    __MessageTypeValues[__MessageTypeValues[\"GET_VALUE\"] = 1] = \"GET_VALUE\";\n    __MessageTypeValues[__MessageTypeValues[\"ADD_PROVIDER\"] = 2] = \"ADD_PROVIDER\";\n    __MessageTypeValues[__MessageTypeValues[\"GET_PROVIDERS\"] = 3] = \"GET_PROVIDERS\";\n    __MessageTypeValues[__MessageTypeValues[\"FIND_NODE\"] = 4] = \"FIND_NODE\";\n    __MessageTypeValues[__MessageTypeValues[\"PING\"] = 5] = \"PING\";\n  })(__MessageTypeValues || (__MessageTypeValues = {}));\n  (function (MessageType) {\n    MessageType.codec = function () {\n      return enumeration(__MessageTypeValues);\n    };\n  })(MessageType = Message.MessageType || (Message.MessageType = {}));\n  var ConnectionType;\n  (function (ConnectionType) {\n    ConnectionType[\"NOT_CONNECTED\"] = \"NOT_CONNECTED\";\n    ConnectionType[\"CONNECTED\"] = \"CONNECTED\";\n    ConnectionType[\"CAN_CONNECT\"] = \"CAN_CONNECT\";\n    ConnectionType[\"CANNOT_CONNECT\"] = \"CANNOT_CONNECT\";\n  })(ConnectionType = Message.ConnectionType || (Message.ConnectionType = {}));\n  var __ConnectionTypeValues;\n  (function (__ConnectionTypeValues) {\n    __ConnectionTypeValues[__ConnectionTypeValues[\"NOT_CONNECTED\"] = 0] = \"NOT_CONNECTED\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CAN_CONNECT\"] = 2] = \"CAN_CONNECT\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CANNOT_CONNECT\"] = 3] = \"CANNOT_CONNECT\";\n  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));\n  (function (ConnectionType) {\n    ConnectionType.codec = function () {\n      return enumeration(__ConnectionTypeValues);\n    };\n  })(ConnectionType = Message.ConnectionType || (Message.ConnectionType = {}));\n  var Peer;\n  (function (Peer) {\n    var _codec;\n    Peer.codec = function () {\n      if (_codec == null) {\n        _codec = message(function (obj, writer) {\n          var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          if (opts.lengthDelimited !== false) {\n            writer.fork();\n          }\n          if (obj.id != null) {\n            writer.uint32(10);\n            writer.bytes(obj.id);\n          }\n          if (obj.addrs != null) {\n            var _iterator = _createForOfIteratorHelper(obj.addrs),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var value = _step.value;\n                writer.uint32(18);\n                writer.bytes(value);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } else {\n            throw new Error('Protocol error: required field \"addrs\" was not found in object');\n          }\n          if (obj.connection != null) {\n            writer.uint32(24);\n            Message.ConnectionType.codec().encode(obj.connection, writer);\n          }\n          if (opts.lengthDelimited !== false) {\n            writer.ldelim();\n          }\n        }, function (reader, length) {\n          var obj = {\n            addrs: []\n          };\n          var end = length == null ? reader.len : reader.pos + length;\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                obj.id = reader.bytes();\n                break;\n              case 2:\n                obj.addrs.push(reader.bytes());\n                break;\n              case 3:\n                obj.connection = Message.ConnectionType.codec().decode(reader);\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return obj;\n        });\n      }\n      return _codec;\n    };\n    Peer.encode = function (obj) {\n      return encodeMessage(obj, Peer.codec());\n    };\n    Peer.decode = function (buf) {\n      return decodeMessage(buf, Peer.codec());\n    };\n  })(Peer = Message.Peer || (Message.Peer = {}));\n  var _codec;\n  Message.codec = function () {\n    if (_codec == null) {\n      _codec = message(function (obj, writer) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (opts.lengthDelimited !== false) {\n          writer.fork();\n        }\n        if (obj.type != null) {\n          writer.uint32(8);\n          Message.MessageType.codec().encode(obj.type, writer);\n        }\n        if (obj.clusterLevelRaw != null) {\n          writer.uint32(80);\n          writer.int32(obj.clusterLevelRaw);\n        }\n        if (obj.key != null) {\n          writer.uint32(18);\n          writer.bytes(obj.key);\n        }\n        if (obj.record != null) {\n          writer.uint32(26);\n          writer.bytes(obj.record);\n        }\n        if (obj.closerPeers != null) {\n          var _iterator2 = _createForOfIteratorHelper(obj.closerPeers),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var value = _step2.value;\n              writer.uint32(66);\n              Message.Peer.codec().encode(value, writer);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"closerPeers\" was not found in object');\n        }\n        if (obj.providerPeers != null) {\n          var _iterator3 = _createForOfIteratorHelper(obj.providerPeers),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _value = _step3.value;\n              writer.uint32(74);\n              Message.Peer.codec().encode(_value, writer);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else {\n          throw new Error('Protocol error: required field \"providerPeers\" was not found in object');\n        }\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim();\n        }\n      }, function (reader, length) {\n        var obj = {\n          closerPeers: [],\n          providerPeers: []\n        };\n        var end = length == null ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = Message.MessageType.codec().decode(reader);\n              break;\n            case 10:\n              obj.clusterLevelRaw = reader.int32();\n              break;\n            case 2:\n              obj.key = reader.bytes();\n              break;\n            case 3:\n              obj.record = reader.bytes();\n              break;\n            case 8:\n              obj.closerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()));\n              break;\n            case 9:\n              obj.providerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()));\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return obj;\n      });\n    }\n    return _codec;\n  };\n  Message.encode = function (obj) {\n    return encodeMessage(obj, Message.codec());\n  };\n  Message.decode = function (buf) {\n    return decodeMessage(buf, Message.codec());\n  };\n})(Message || (Message = {}));","map":{"version":3,"names":["encodeMessage","decodeMessage","message","enumeration","Record","_codec","codec","obj","writer","opts","arguments","length","undefined","lengthDelimited","fork","key","uint32","bytes","value","author","signature","timeReceived","string","ldelim","reader","end","len","pos","tag","skipType","encode","decode","buf","Message","MessageType","__MessageTypeValues","ConnectionType","__ConnectionTypeValues","Peer","id","addrs","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","Error","connection","push","type","clusterLevelRaw","int32","record","closerPeers","_iterator2","_step2","providerPeers","_iterator3","_step3"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/kad-dht/src/message/dht.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-namespace */\n\nimport { encodeMessage, decodeMessage, message, enumeration } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface Record {\n  key?: Uint8Array\n  value?: Uint8Array\n  author?: Uint8Array\n  signature?: Uint8Array\n  timeReceived?: string\n}\n\nexport namespace Record {\n  let _codec: Codec<Record>\n\n  export const codec = (): Codec<Record> => {\n    if (_codec == null) {\n      _codec = message<Record>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.key != null) {\n          writer.uint32(10)\n          writer.bytes(obj.key)\n        }\n\n        if (obj.value != null) {\n          writer.uint32(18)\n          writer.bytes(obj.value)\n        }\n\n        if (obj.author != null) {\n          writer.uint32(26)\n          writer.bytes(obj.author)\n        }\n\n        if (obj.signature != null) {\n          writer.uint32(34)\n          writer.bytes(obj.signature)\n        }\n\n        if (obj.timeReceived != null) {\n          writer.uint32(42)\n          writer.string(obj.timeReceived)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.bytes()\n              break\n            case 2:\n              obj.value = reader.bytes()\n              break\n            case 3:\n              obj.author = reader.bytes()\n              break\n            case 4:\n              obj.signature = reader.bytes()\n              break\n            case 5:\n              obj.timeReceived = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Record): Uint8Array => {\n    return encodeMessage(obj, Record.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Record => {\n    return decodeMessage(buf, Record.codec())\n  }\n}\n\nexport interface Message {\n  type?: Message.MessageType\n  clusterLevelRaw?: number\n  key?: Uint8Array\n  record?: Uint8Array\n  closerPeers: Message.Peer[]\n  providerPeers: Message.Peer[]\n}\n\nexport namespace Message {\n  export enum MessageType {\n    PUT_VALUE = 'PUT_VALUE',\n    GET_VALUE = 'GET_VALUE',\n    ADD_PROVIDER = 'ADD_PROVIDER',\n    GET_PROVIDERS = 'GET_PROVIDERS',\n    FIND_NODE = 'FIND_NODE',\n    PING = 'PING'\n  }\n\n  enum __MessageTypeValues {\n    PUT_VALUE = 0,\n    GET_VALUE = 1,\n    ADD_PROVIDER = 2,\n    GET_PROVIDERS = 3,\n    FIND_NODE = 4,\n    PING = 5\n  }\n\n  export namespace MessageType {\n    export const codec = () => {\n      return enumeration<MessageType>(__MessageTypeValues)\n    }\n  }\n\n  export enum ConnectionType {\n    NOT_CONNECTED = 'NOT_CONNECTED',\n    CONNECTED = 'CONNECTED',\n    CAN_CONNECT = 'CAN_CONNECT',\n    CANNOT_CONNECT = 'CANNOT_CONNECT'\n  }\n\n  enum __ConnectionTypeValues {\n    NOT_CONNECTED = 0,\n    CONNECTED = 1,\n    CAN_CONNECT = 2,\n    CANNOT_CONNECT = 3\n  }\n\n  export namespace ConnectionType {\n    export const codec = () => {\n      return enumeration<ConnectionType>(__ConnectionTypeValues)\n    }\n  }\n\n  export interface Peer {\n    id?: Uint8Array\n    addrs: Uint8Array[]\n    connection?: Message.ConnectionType\n  }\n\n  export namespace Peer {\n    let _codec: Codec<Peer>\n\n    export const codec = (): Codec<Peer> => {\n      if (_codec == null) {\n        _codec = message<Peer>((obj, writer, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            writer.fork()\n          }\n\n          if (obj.id != null) {\n            writer.uint32(10)\n            writer.bytes(obj.id)\n          }\n\n          if (obj.addrs != null) {\n            for (const value of obj.addrs) {\n              writer.uint32(18)\n              writer.bytes(value)\n            }\n          } else {\n            throw new Error('Protocol error: required field \"addrs\" was not found in object')\n          }\n\n          if (obj.connection != null) {\n            writer.uint32(24)\n            Message.ConnectionType.codec().encode(obj.connection, writer)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            writer.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            addrs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.id = reader.bytes()\n                break\n              case 2:\n                obj.addrs.push(reader.bytes())\n                break\n              case 3:\n                obj.connection = Message.ConnectionType.codec().decode(reader)\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Peer): Uint8Array => {\n      return encodeMessage(obj, Peer.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n      return decodeMessage(buf, Peer.codec())\n    }\n  }\n\n  let _codec: Codec<Message>\n\n  export const codec = (): Codec<Message> => {\n    if (_codec == null) {\n      _codec = message<Message>((obj, writer, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          writer.fork()\n        }\n\n        if (obj.type != null) {\n          writer.uint32(8)\n          Message.MessageType.codec().encode(obj.type, writer)\n        }\n\n        if (obj.clusterLevelRaw != null) {\n          writer.uint32(80)\n          writer.int32(obj.clusterLevelRaw)\n        }\n\n        if (obj.key != null) {\n          writer.uint32(18)\n          writer.bytes(obj.key)\n        }\n\n        if (obj.record != null) {\n          writer.uint32(26)\n          writer.bytes(obj.record)\n        }\n\n        if (obj.closerPeers != null) {\n          for (const value of obj.closerPeers) {\n            writer.uint32(66)\n            Message.Peer.codec().encode(value, writer)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"closerPeers\" was not found in object')\n        }\n\n        if (obj.providerPeers != null) {\n          for (const value of obj.providerPeers) {\n            writer.uint32(74)\n            Message.Peer.codec().encode(value, writer)\n          }\n        } else {\n          throw new Error('Protocol error: required field \"providerPeers\" was not found in object')\n        }\n\n        if (opts.lengthDelimited !== false) {\n          writer.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          closerPeers: [],\n          providerPeers: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = Message.MessageType.codec().decode(reader)\n              break\n            case 10:\n              obj.clusterLevelRaw = reader.int32()\n              break\n            case 2:\n              obj.key = reader.bytes()\n              break\n            case 3:\n              obj.record = reader.bytes()\n              break\n            case 8:\n              obj.closerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()))\n              break\n            case 9:\n              obj.providerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()))\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Message): Uint8Array => {\n    return encodeMessage(obj, Message.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Message => {\n    return decodeMessage(buf, Message.codec())\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}