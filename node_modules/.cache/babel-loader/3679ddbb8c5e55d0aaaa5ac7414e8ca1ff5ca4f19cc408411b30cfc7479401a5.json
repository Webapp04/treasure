{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createMkdir } from './mkdir.js';\nimport { createStat } from './stat.js';\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport { addLink } from './utils/add-link.js';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport mergeOpts from 'merge-options';\nimport { toTrail } from './utils/to-trail.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nvar mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nvar log = logger('ipfs:mfs:cp');\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} DAGNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('./utils/to-trail').MfsTrail} MfsTrail\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nvar defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n};\n\n/**\n * @param {MfsContext} context\n */\nexport function createCp(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"cp\"]}\n   */\n  function mfsCp(_x, _x2) {\n    return _mfsCp.apply(this, arguments);\n  }\n  function _mfsCp() {\n    _mfsCp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(from, to) {\n      var opts,\n        options,\n        sources,\n        destination,\n        missing,\n        destinationIsDirectory,\n        parentFolder,\n        destinationPath,\n        trail,\n        source,\n        destinationName,\n        _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            /** @type {DefaultOptions} */\n            options = mergeOptions(defaultOptions, opts);\n            if (!Array.isArray(from)) {\n              from = [from];\n            }\n            _context.next = 5;\n            return Promise.all(from.map(function ( /** @type {CID | string} */path) {\n              return toMfsPath(context, path, options);\n            }));\n          case 5:\n            sources = _context.sent;\n            _context.next = 8;\n            return toMfsPath(context, to, options);\n          case 8:\n            destination = _context.sent;\n            if (!(!sources.length || !destination)) {\n              _context.next = 11;\n              break;\n            }\n            throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n          case 11:\n            // make sure all sources exist\n            missing = sources.find(function (source) {\n              return !source.exists;\n            });\n            if (!missing) {\n              _context.next = 14;\n              break;\n            }\n            throw errCode(new Error(\"\".concat(missing.path, \" does not exist\")), 'ERR_INVALID_PARAMS');\n          case 14:\n            destinationIsDirectory = isDirectory(destination);\n            if (!destination.exists) {\n              _context.next = 21;\n              break;\n            }\n            log('Destination exists');\n            if (!(sources.length === 1 && !destinationIsDirectory)) {\n              _context.next = 19;\n              break;\n            }\n            throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n          case 19:\n            _context.next = 50;\n            break;\n          case 21:\n            log('Destination does not exist');\n            if (!(sources.length > 1)) {\n              _context.next = 32;\n              break;\n            }\n            if (options.parents) {\n              _context.next = 25;\n              break;\n            }\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n          case 25:\n            _context.next = 27;\n            return createMkdir(context)(destination.path, options);\n          case 27:\n            _context.next = 29;\n            return toMfsPath(context, destination.path, options);\n          case 29:\n            destination = _context.sent;\n            _context.next = 50;\n            break;\n          case 32:\n            if (!(destination.parts.length > 1)) {\n              _context.next = 50;\n              break;\n            }\n            // copying to a folder, create it if necessary\n            parentFolder = \"/\".concat(destination.parts.slice(0, -1).join('/'));\n            _context.prev = 34;\n            _context.next = 37;\n            return createStat(context)(parentFolder, options);\n          case 37:\n            _context.next = 50;\n            break;\n          case 39:\n            _context.prev = 39;\n            _context.t0 = _context[\"catch\"](34);\n            if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n              _context.next = 43;\n              break;\n            }\n            throw _context.t0;\n          case 43:\n            if (options.parents) {\n              _context.next = 45;\n              break;\n            }\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n          case 45:\n            _context.next = 47;\n            return createMkdir(context)(parentFolder, options);\n          case 47:\n            _context.next = 49;\n            return toMfsPath(context, destination.path, options);\n          case 49:\n            destination = _context.sent;\n          case 50:\n            destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n            _context.next = 53;\n            return toTrail(context, destinationPath);\n          case 53:\n            trail = _context.sent;\n            if (!(sources.length === 1)) {\n              _context.next = 61;\n              break;\n            }\n            source = sources.pop();\n            if (source) {\n              _context.next = 58;\n              break;\n            }\n            throw errCode(new Error('could not find source'), 'ERR_INVALID_PARAMS');\n          case 58:\n            destinationName = destinationIsDirectory ? source.name : destination.name;\n            log(\"Only one source, copying to destination \".concat(destinationIsDirectory ? 'directory' : 'file', \" \").concat(destinationName));\n            return _context.abrupt(\"return\", copyToFile(context, source, destinationName, trail, options));\n          case 61:\n            log('Multiple sources, wrapping in a directory');\n            return _context.abrupt(\"return\", copyToDirectory(context, sources, destination, trail, options));\n          case 63:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[34, 39]]);\n    }));\n    return _mfsCp.apply(this, arguments);\n  }\n  return withTimeoutOption(mfsCp);\n}\n\n/**\n * @param {*} destination\n */\nvar isDirectory = function isDirectory(destination) {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\nvar copyToFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, source, destination, destinationTrail, options) {\n    var parent, newRootCid;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          parent = destinationTrail.pop();\n          if (parent) {\n            _context2.next = 3;\n            break;\n          }\n          throw errCode(new Error('destination had no parent'), 'ERR_INVALID_PARAMS');\n        case 3:\n          _context2.next = 5;\n          return addSourceToParent(context, source, destination, parent, options);\n        case 5:\n          parent = _context2.sent;\n          // update the tree with the new containing directory\n          destinationTrail.push(parent);\n          _context2.next = 9;\n          return updateTree(context, destinationTrail, options);\n        case 9:\n          newRootCid = _context2.sent;\n          _context2.next = 12;\n          return updateMfsRoot(context, newRootCid, options);\n        case 12:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function copyToFile(_x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath[]} sources\n * @param {*} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\nvar copyToDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(context, sources, destination, destinationTrail, options) {\n    var i, source, newRootCid;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          i = 0;\n        case 1:\n          if (!(i < sources.length)) {\n            _context3.next = 9;\n            break;\n          }\n          source = sources[i];\n          _context3.next = 5;\n          return addSourceToParent(context, source, source.name, destination, options);\n        case 5:\n          destination = _context3.sent;\n        case 6:\n          i++;\n          _context3.next = 1;\n          break;\n        case 9:\n          // update the tree with the new containing directory\n          destinationTrail[destinationTrail.length - 1] = destination;\n          _context3.next = 12;\n          return updateTree(context, destinationTrail, options);\n        case 12:\n          newRootCid = _context3.sent;\n          _context3.next = 15;\n          return updateMfsRoot(context, newRootCid, options);\n        case 15:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function copyToDirectory(_x8, _x9, _x10, _x11, _x12) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} childName\n * @param {*} parent\n * @param {DefaultOptions} options\n * @returns {Promise<MfsTrail>}\n */\nvar addSourceToParent = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(context, source, childName, parent, options) {\n    var sourceBlock, _yield$addLink, node, cid, size;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return context.repo.blocks.get(source.cid);\n        case 2:\n          sourceBlock = _context4.sent;\n          _context4.next = 5;\n          return addLink(context, {\n            parentCid: parent.cid,\n            size: sourceBlock.length,\n            cid: source.cid,\n            name: childName,\n            hashAlg: options.hashAlg,\n            cidVersion: options.cidVersion,\n            flush: options.flush,\n            shardSplitThreshold: options.shardSplitThreshold\n          });\n        case 5:\n          _yield$addLink = _context4.sent;\n          node = _yield$addLink.node;\n          cid = _yield$addLink.cid;\n          size = _yield$addLink.size;\n          parent.node = node;\n          parent.cid = cid;\n          parent.size = size;\n          return _context4.abrupt(\"return\", parent);\n        case 13:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function addSourceToParent(_x13, _x14, _x15, _x16, _x17) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["createMkdir","createStat","logger","errCode","updateTree","updateMfsRoot","addLink","toMfsPath","mergeOpts","toTrail","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","parents","flush","hashAlg","cidVersion","shardSplitThreshold","createCp","context","mfsCp","_x","_x2","_mfsCp","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","from","to","opts","options","sources","destination","missing","destinationIsDirectory","parentFolder","destinationPath","trail","source","destinationName","_args","wrap","_callee$","_context","prev","next","length","undefined","Array","isArray","Promise","all","map","path","sent","Error","find","exists","concat","isDirectory","parts","slice","join","t0","code","mfsPath","mfsDirectory","pop","name","abrupt","copyToFile","copyToDirectory","stop","unixfs","type","includes","_ref","_callee2","destinationTrail","parent","newRootCid","_callee2$","_context2","addSourceToParent","push","_x3","_x4","_x5","_x6","_x7","_ref2","_callee3","i","_callee3$","_context3","_x8","_x9","_x10","_x11","_x12","_ref3","_callee4","childName","sourceBlock","_yield$addLink","node","cid","size","_callee4$","_context4","repo","blocks","get","parentCid","_x13","_x14","_x15","_x16","_x17"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/files/cp.js"],"sourcesContent":["import { createMkdir } from './mkdir.js'\nimport { createStat } from './stat.js'\nimport { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport { addLink } from './utils/add-link.js'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport mergeOpts from 'merge-options'\nimport { toTrail } from './utils/to-trail.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:cp')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} DAGNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('./utils/to-trail').MfsTrail} MfsTrail\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createCp (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"cp\"]}\n   */\n  async function mfsCp (from, to, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    if (!Array.isArray(from)) {\n      from = [from]\n    }\n\n    const sources = await Promise.all(\n      from.map((/** @type {CID | string} */ path) => toMfsPath(context, path, options))\n    )\n    let destination = await toMfsPath(context, to, options)\n\n    if (!sources.length || !destination) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS')\n    }\n\n    // make sure all sources exist\n    const missing = sources.find(source => !source.exists)\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS')\n    }\n\n    const destinationIsDirectory = isDirectory(destination)\n\n    if (destination.exists) {\n      log('Destination exists')\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS')\n      }\n    } else {\n      log('Destination does not exist')\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n        }\n\n        await createMkdir(context)(destination.path, options)\n        destination = await toMfsPath(context, destination.path, options)\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`\n\n        try {\n          await createStat(context)(parentFolder, options)\n        } catch (/** @type {any} */ err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n          }\n\n          await createMkdir(context)(parentFolder, options)\n          destination = await toMfsPath(context, destination.path, options)\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory\n    const trail = await toTrail(context, destinationPath)\n\n    if (sources.length === 1) {\n      const source = sources.pop()\n\n      if (!source) {\n        throw errCode(new Error('could not find source'), 'ERR_INVALID_PARAMS')\n      }\n\n      const destinationName = destinationIsDirectory ? source.name : destination.name\n\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`)\n\n      return copyToFile(context, source, destinationName, trail, options)\n    }\n\n    log('Multiple sources, wrapping in a directory')\n    return copyToDirectory(context, sources, destination, trail, options)\n  }\n\n  return withTimeoutOption(mfsCp)\n}\n\n/**\n * @param {*} destination\n */\nconst isDirectory = (destination) => {\n  return destination.unixfs &&\n    destination.unixfs.type &&\n    destination.unixfs.type.includes('directory')\n}\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop()\n\n  if (!parent) {\n    throw errCode(new Error('destination had no parent'), 'ERR_INVALID_PARAMS')\n  }\n\n  parent = await addSourceToParent(context, source, destination, parent, options)\n\n  // update the tree with the new containing directory\n  destinationTrail.push(parent)\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath[]} sources\n * @param {*} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i]\n\n    destination = await addSourceToParent(context, source, source.name, destination, options)\n  }\n\n  // update the tree with the new containing directory\n  destinationTrail[destinationTrail.length - 1] = destination\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} childName\n * @param {*} parent\n * @param {DefaultOptions} options\n * @returns {Promise<MfsTrail>}\n */\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid)\n  const {\n    node,\n    cid,\n    size\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  parent.node = node\n  parent.cid = cid\n  parent.size = size\n\n  return parent\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}