{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { logger } from '@libp2p/logger';\nimport parseDuration from 'parse-duration';\nimport { importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport errcode from 'err-code';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { OFFLINE_ERROR, normalizePath } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { resolvePath } from './utils.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nvar log = logger('ipfs:name:publish');\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n */\nexport function createPublish(_ref) {\n  var ipns = _ref.ipns,\n    repo = _ref.repo,\n    codecs = _ref.codecs,\n    peerId = _ref.peerId,\n    isOnline = _ref.isOnline,\n    keychain = _ref.keychain;\n  /**\n   * @param {string} keyName\n   */\n  var lookupKey = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(keyName) {\n      var privateKey, pem;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(keyName === 'self' && peerId.privateKey != null)) {\n              _context.next = 6;\n              break;\n            }\n            _context.next = 3;\n            return unmarshalPrivateKey(peerId.privateKey);\n          case 3:\n            privateKey = _context.sent;\n            _context.next = 19;\n            break;\n          case 6:\n            _context.prev = 6;\n            _context.next = 9;\n            return keychain.exportKey(keyName, 'temp');\n          case 9:\n            pem = _context.sent;\n            _context.next = 12;\n            return importKey(pem, 'temp');\n          case 12:\n            privateKey = _context.sent;\n            _context.next = 19;\n            break;\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](6);\n            log.error(_context.t0);\n            throw errcode(_context.t0, 'ERR_CANNOT_GET_KEY');\n          case 19:\n            return _context.abrupt(\"return\", peerIdFromKeys(privateKey.public.bytes, privateKey.bytes));\n          case 20:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[6, 15]]);\n    }));\n    return function lookupKey(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"publish\"]}\n   */\n  function publish(_x2) {\n    return _publish.apply(this, arguments);\n  }\n  function _publish() {\n    _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(value) {\n      var options,\n        resolve,\n        lifetime,\n        key,\n        pubLifetime,\n        results,\n        bytes,\n        result,\n        _args2 = arguments;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            resolve = !(options.resolve === false);\n            lifetime = options.lifetime || '24h';\n            key = options.key || 'self';\n            if (isOnline()) {\n              _context2.next = 6;\n              break;\n            }\n            throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n          case 6:\n            _context2.prev = 6;\n            value = normalizePath(value);\n            _context2.next = 14;\n            break;\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](6);\n            log.error(_context2.t0);\n            throw _context2.t0;\n          case 14:\n            pubLifetime = 0;\n            _context2.prev = 15;\n            pubLifetime = parseDuration(lifetime) || 0;\n\n            // Calculate lifetime with nanoseconds precision\n            pubLifetime = parseFloat(pubLifetime.toFixed(6));\n            _context2.next = 24;\n            break;\n          case 20:\n            _context2.prev = 20;\n            _context2.t1 = _context2[\"catch\"](15);\n            log.error(_context2.t1);\n            throw _context2.t1;\n          case 24:\n            _context2.next = 26;\n            return Promise.all([\n            // verify if the path exists, if not, an error will stop the execution\n            lookupKey(key),\n            // if resolving, do a get so we make sure we have the blocks\n            resolve ? resolvePath({\n              ipns: ipns,\n              repo: repo,\n              codecs: codecs\n            }, value) : Promise.resolve()]);\n          case 26:\n            results = _context2.sent;\n            bytes = uint8ArrayFromString(value); // Start publishing process\n            _context2.next = 30;\n            return ipns.publish(results[0], bytes, pubLifetime, options);\n          case 30:\n            result = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              name: result.name,\n              value: uint8ArrayToString(result.value)\n            });\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[6, 10], [15, 20]]);\n    }));\n    return _publish.apply(this, arguments);\n  }\n  return withTimeoutOption(publish);\n}","map":{"version":3,"names":["logger","parseDuration","importKey","unmarshalPrivateKey","errcode","fromString","uint8ArrayFromString","toString","uint8ArrayToString","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","peerIdFromKeys","log","createPublish","_ref","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","keyName","privateKey","pem","wrap","_callee$","_context","prev","next","sent","exportKey","t0","error","abrupt","public","bytes","stop","_x","apply","arguments","publish","_x2","_publish","_callee2","value","options","resolve","lifetime","key","pubLifetime","results","result","_args2","_callee2$","_context2","length","undefined","Error","parseFloat","toFixed","t1","Promise","all","name"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/name/publish.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport parseDuration from 'parse-duration'\nimport { importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport errcode from 'err-code'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { OFFLINE_ERROR, normalizePath } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { resolvePath } from './utils.js'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\n\nconst log = logger('ipfs:name:publish')\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n */\nexport function createPublish ({ ipns, repo, codecs, peerId, isOnline, keychain }) {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    /** @type {import('@libp2p/interface-keys').PrivateKey} */\n    let privateKey\n\n    if (keyName === 'self' && peerId.privateKey != null) {\n      privateKey = await unmarshalPrivateKey(peerId.privateKey)\n    } else {\n      try {\n        // We're exporting and immediately importing the key, so we can just use a throw away password\n        const pem = await keychain.exportKey(keyName, 'temp')\n        privateKey = await importKey(pem, 'temp')\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n        throw errcode(err, 'ERR_CANNOT_GET_KEY')\n      }\n    }\n\n    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"publish\"]}\n   */\n  async function publish (value, options = {}) {\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime = 0\n    try {\n      pubLifetime = parseDuration(lifetime) || 0\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6))\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({ ipns, repo, codecs }, value) : Promise.resolve()\n    ])\n\n    const bytes = uint8ArrayFromString(value)\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime, options)\n\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    }\n  }\n\n  return withTimeoutOption(publish)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}