{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { logger } from '@libp2p/logger';\nimport { createRepo } from 'ipfs-core-config/repo';\nimport getDefaultConfig from 'ipfs-core-config/config';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport mergeOpts from 'merge-options';\nimport { profiles as configProfiles } from './config/profiles.js';\nimport { NotEnabledError, NotInitializedError } from '../errors.js';\nimport { createLibp2p } from './libp2p.js';\nimport { ERR_REPO_NOT_INITIALIZED } from 'ipfs-repo/errors';\nimport { createEd25519PeerId, createRSAPeerId } from '@libp2p/peer-id-factory';\nimport errCode from 'err-code';\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { Key } from 'interface-datastore/key';\nvar mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nvar log = logger('ipfs:components:peer:storage');\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@libp2p/crypto/keys').KeyTypes} KeyType\n * @typedef {import('@libp2p/interface-keychain').KeyChain} Keychain\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nexport var Storage = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  function Storage(peerId, keychain, repo, print, isNew) {\n    _classCallCheck(this, Storage);\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n   * @param {IPFSOptions} options\n   */\n  _createClass(Storage, null, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(print, codecs, options) {\n        var repoAutoMigrate, inputRepo, onMigrationProgress, repo, _yield$loadRepo, peerId, keychain, isNew;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              repoAutoMigrate = options.repoAutoMigrate, inputRepo = options.repo, onMigrationProgress = options.onMigrationProgress;\n              repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n                path: inputRepo,\n                autoMigrate: repoAutoMigrate,\n                onMigrationProgress: onMigrationProgress\n              }) : inputRepo;\n              _context.next = 4;\n              return loadRepo(print, repo, options);\n            case 4:\n              _yield$loadRepo = _context.sent;\n              peerId = _yield$loadRepo.peerId;\n              keychain = _yield$loadRepo.keychain;\n              isNew = _yield$loadRepo.isNew;\n              return _context.abrupt(\"return\", new Storage(peerId, keychain, repo, print, isNew));\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function start(_x, _x2, _x3) {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }]);\n  return Storage;\n}();\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nvar loadRepo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(print, repo, options) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (repo.closed) {\n            _context2.next = 11;\n            break;\n          }\n          _context2.t0 = _objectSpread;\n          _context2.t1 = _objectSpread;\n          _context2.t2 = {};\n          _context2.next = 6;\n          return configureRepo(repo, options);\n        case 6:\n          _context2.t3 = _context2.sent;\n          _context2.t4 = (0, _context2.t1)(_context2.t2, _context2.t3);\n          _context2.t5 = {};\n          _context2.t6 = {\n            isNew: false\n          };\n          return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t4, _context2.t5, _context2.t6));\n        case 11:\n          _context2.prev = 11;\n          _context2.next = 14;\n          return repo.open();\n        case 14:\n          _context2.t7 = _objectSpread;\n          _context2.t8 = _objectSpread;\n          _context2.t9 = {};\n          _context2.next = 19;\n          return configureRepo(repo, options);\n        case 19:\n          _context2.t10 = _context2.sent;\n          _context2.t11 = (0, _context2.t8)(_context2.t9, _context2.t10);\n          _context2.t12 = {};\n          _context2.t13 = {\n            isNew: false\n          };\n          return _context2.abrupt(\"return\", (0, _context2.t7)(_context2.t11, _context2.t12, _context2.t13));\n        case 26:\n          _context2.prev = 26;\n          _context2.t14 = _context2[\"catch\"](11);\n          if (!(_context2.t14.code !== ERR_REPO_NOT_INITIALIZED)) {\n            _context2.next = 30;\n            break;\n          }\n          throw _context2.t14;\n        case 30:\n          if (!(options.init && options.init.allowNew === false)) {\n            _context2.next = 32;\n            break;\n          }\n          throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n        case 32:\n          _context2.t15 = _objectSpread;\n          _context2.t16 = _objectSpread;\n          _context2.t17 = {};\n          _context2.next = 37;\n          return initRepo(print, repo, options);\n        case 37:\n          _context2.t18 = _context2.sent;\n          _context2.t19 = (0, _context2.t16)(_context2.t17, _context2.t18);\n          _context2.t20 = {};\n          _context2.t21 = {\n            isNew: true\n          };\n          return _context2.abrupt(\"return\", (0, _context2.t15)(_context2.t19, _context2.t20, _context2.t21));\n        case 42:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[11, 26]]);\n  }));\n  return function loadRepo(_x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nvar initRepo = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(print, repo, options) {\n    var initOptions, exists, peerId, identity, config, keychainConfig, libp2p;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          initOptions = options.init || {}; // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n          _context3.next = 3;\n          return repo.exists();\n        case 3:\n          exists = _context3.sent;\n          log('repo exists?', exists);\n          if (!(exists === true)) {\n            _context3.next = 7;\n            break;\n          }\n          throw new Error('repo already exists');\n        case 7:\n          if (!initOptions.privateKey) {\n            _context3.next = 13;\n            break;\n          }\n          _context3.next = 10;\n          return decodePeerId(initOptions.privateKey);\n        case 10:\n          _context3.t0 = _context3.sent;\n          _context3.next = 16;\n          break;\n        case 13:\n          _context3.next = 15;\n          return initPeerId(print, initOptions);\n        case 15:\n          _context3.t0 = _context3.sent;\n        case 16:\n          peerId = _context3.t0;\n          identity = peerIdToIdentity(peerId);\n          log('peer identity: %s', identity.PeerID);\n\n          // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n          config = _objectSpread(_objectSpread({}, mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config)), {}, {\n            Identity: identity\n          });\n          _context3.next = 22;\n          return repo.init(config);\n        case 22:\n          _context3.next = 24;\n          return repo.open();\n        case 24:\n          log('repo opened');\n\n          /** @type {import('./libp2p').KeychainConfig} */\n          keychainConfig = {\n            pass: options.pass\n          };\n          _context3.prev = 26;\n          _context3.next = 29;\n          return repo.config.get('Keychain.DEK');\n        case 29:\n          keychainConfig.dek = _context3.sent;\n          _context3.next = 36;\n          break;\n        case 32:\n          _context3.prev = 32;\n          _context3.t1 = _context3[\"catch\"](26);\n          if (!(_context3.t1.code !== 'ERR_NOT_FOUND')) {\n            _context3.next = 36;\n            break;\n          }\n          throw _context3.t1;\n        case 36:\n          _context3.next = 38;\n          return createLibp2p({\n            options: undefined,\n            multiaddrs: undefined,\n            peerId: peerId,\n            repo: repo,\n            config: config,\n            keychainConfig: keychainConfig\n          });\n        case 38:\n          libp2p = _context3.sent;\n          _context3.next = 41;\n          return repo.datastore.has(new Key('/info/self'));\n        case 41:\n          if (_context3.sent) {\n            _context3.next = 44;\n            break;\n          }\n          _context3.next = 44;\n          return libp2p.keychain.importPeer('self', peerId);\n        case 44:\n          _context3.next = 46;\n          return repo.config.set('Keychain', {\n            // @ts-expect-error private field\n            DEK: libp2p.keychain.init.dek\n          });\n        case 46:\n          return _context3.abrupt(\"return\", {\n            peerId: peerId,\n            keychain: libp2p.keychain\n          });\n        case 47:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[26, 32]]);\n  }));\n  return function initRepo(_x7, _x8, _x9) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>}\n */\nvar decodePeerId = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId) {\n    var rawPrivateKey, key;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          log('using user-supplied private-key');\n          if (!isPeerId(peerId)) {\n            _context4.next = 3;\n            break;\n          }\n          return _context4.abrupt(\"return\", peerId);\n        case 3:\n          rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad');\n          _context4.next = 6;\n          return unmarshalPrivateKey(rawPrivateKey);\n        case 6:\n          key = _context4.sent;\n          _context4.next = 9;\n          return peerIdFromKeys(key.public.bytes, key.bytes);\n        case 9:\n          return _context4.abrupt(\"return\", _context4.sent);\n        case 10:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function decodePeerId(_x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nvar initPeerId = function initPeerId(print, _ref4) {\n  var _ref4$algorithm = _ref4.algorithm,\n    algorithm = _ref4$algorithm === void 0 ? 'Ed25519' : _ref4$algorithm,\n    _ref4$bits = _ref4.bits,\n    bits = _ref4$bits === void 0 ? 2048 : _ref4$bits;\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n  if (algorithm === 'Ed25519') {\n    return createEd25519PeerId();\n  }\n  if (algorithm === 'RSA') {\n    return createRSAPeerId({\n      bits: bits\n    });\n  }\n  throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM');\n};\n\n/**\n * @param {PeerId} peerId\n */\nvar peerIdToIdentity = function peerIdToIdentity(peerId) {\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY');\n  }\n  return {\n    PeerID: peerId.toString(),\n    /** @type {string} */\n    PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')\n  };\n};\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nvar configureRepo = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(repo, options) {\n    var config, profiles, pass, original, changed, buf, key, peerId, libp2p;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          config = options.config;\n          profiles = options.init && options.init.profiles || [];\n          pass = options.pass;\n          _context5.next = 5;\n          return repo.config.getAll();\n        case 5:\n          original = _context5.sent;\n          changed = mergeConfigs(applyProfiles(original, profiles), config);\n          if (!(original !== changed)) {\n            _context5.next = 10;\n            break;\n          }\n          _context5.next = 10;\n          return repo.config.replace(changed);\n        case 10:\n          if (!(!changed.Identity || !changed.Identity.PrivKey)) {\n            _context5.next = 12;\n            break;\n          }\n          throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n        case 12:\n          buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad');\n          _context5.next = 15;\n          return unmarshalPrivateKey(buf);\n        case 15:\n          key = _context5.sent;\n          _context5.next = 18;\n          return peerIdFromKeys(key.public.bytes, key.bytes);\n        case 18:\n          peerId = _context5.sent;\n          _context5.next = 21;\n          return createLibp2p({\n            options: undefined,\n            multiaddrs: undefined,\n            peerId: peerId,\n            repo: repo,\n            config: changed,\n            keychainConfig: _objectSpread({\n              pass: pass\n            }, changed.Keychain)\n          });\n        case 21:\n          libp2p = _context5.sent;\n          return _context5.abrupt(\"return\", {\n            peerId: peerId,\n            keychain: libp2p.keychain\n          });\n        case 23:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return function configureRepo(_x11, _x12) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nvar mergeConfigs = function mergeConfigs(config, changes) {\n  return changes ? mergeOptions(config, changes) : config;\n};\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nvar applyProfiles = function applyProfiles(config, profiles) {\n  return (profiles || []).reduce(function (config, name) {\n    var profile = configProfiles[name];\n    if (!profile) {\n      throw new Error(\"Could not find profile with name '\".concat(name, \"'\"));\n    }\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":{"version":3,"names":["logger","createRepo","getDefaultConfig","fromString","uint8ArrayFromString","toString","uint8ArrayToString","peerIdFromKeys","isPeerId","mergeOpts","profiles","configProfiles","NotEnabledError","NotInitializedError","createLibp2p","ERR_REPO_NOT_INITIALIZED","createEd25519PeerId","createRSAPeerId","errCode","unmarshalPrivateKey","Key","mergeOptions","bind","ignoreUndefined","log","Storage","peerId","keychain","repo","print","isNew","_classCallCheck","_createClass","key","value","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","_yield$loadRepo","wrap","_callee$","_context","prev","next","path","autoMigrate","loadRepo","sent","abrupt","stop","start","_x","_x2","_x3","apply","arguments","_ref","_callee2","_callee2$","_context2","closed","t0","_objectSpread","t1","t2","configureRepo","t3","t4","t5","t6","open","t7","t8","t9","t10","t11","t12","t13","t14","code","init","allowNew","t15","t16","t17","initRepo","t18","t19","t20","t21","_x4","_x5","_x6","_ref2","_callee3","initOptions","exists","identity","config","keychainConfig","libp2p","_callee3$","_context3","Error","privateKey","decodePeerId","initPeerId","peerIdToIdentity","PeerID","applyProfiles","Identity","pass","get","dek","undefined","multiaddrs","datastore","has","importPeer","set","DEK","_x7","_x8","_x9","_ref3","_callee4","rawPrivateKey","_callee4$","_context4","public","bytes","_x10","_ref4","_ref4$algorithm","algorithm","_ref4$bits","bits","PrivKey","_ref5","_callee5","original","changed","buf","_callee5$","_context5","getAll","mergeConfigs","replace","Keychain","_x11","_x12","changes","reduce","name","profile","concat","transform"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/storage.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { createRepo } from 'ipfs-core-config/repo'\nimport getDefaultConfig from 'ipfs-core-config/config'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { isPeerId } from '@libp2p/interface-peer-id'\nimport mergeOpts from 'merge-options'\nimport { profiles as configProfiles } from './config/profiles.js'\nimport { NotEnabledError, NotInitializedError } from '../errors.js'\nimport { createLibp2p } from './libp2p.js'\nimport { ERR_REPO_NOT_INITIALIZED } from 'ipfs-repo/errors'\nimport { createEd25519PeerId, createRSAPeerId } from '@libp2p/peer-id-factory'\nimport errCode from 'err-code'\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { Key } from 'interface-datastore/key'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:components:peer:storage')\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@libp2p/crypto/keys').KeyTypes} KeyType\n * @typedef {import('@libp2p/interface-keychain').KeyChain} Keychain\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nexport class Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor (peerId, keychain, repo, print, isNew) {\n    this.print = print\n    this.peerId = peerId\n    this.keychain = keychain\n    this.repo = repo\n    this.print = print\n    this.isNew = isNew\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start (print, codecs, options) {\n    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options\n\n    const repo = (typeof inputRepo === 'string' || inputRepo == null)\n      ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      })\n      : inputRepo\n\n    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)\n\n    // TODO: throw error?\n    // @ts-expect-error On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew)\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...await configureRepo(repo, options), isNew: false }\n  }\n\n  try {\n    await repo.open()\n\n    return { ...await configureRepo(repo, options), isNew: false }\n  } catch (/** @type {any} */ err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')\n    }\n\n    return { ...await initRepo(print, repo, options), isNew: true }\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists()\n  log('repo exists?', exists)\n\n  if (exists === true) {\n    throw new Error('repo already exists')\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey\n    ? await decodePeerId(initOptions.privateKey)\n    : await initPeerId(print, initOptions)\n\n  const identity = peerIdToIdentity(peerId)\n\n  log('peer identity: %s', identity.PeerID)\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  }\n  await repo.init(config)\n\n  // 4. Open initialized repo.\n  await repo.open()\n\n  log('repo opened')\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  }\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK')\n  } catch (/** @type {any} */ err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  })\n\n  if (!(await repo.datastore.has(new Key('/info/self')))) {\n    await libp2p.keychain.importPeer('self', peerId)\n  }\n\n  await repo.config.set('Keychain', {\n    // @ts-expect-error private field\n    DEK: libp2p.keychain.init.dek\n  })\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>}\n */\nconst decodePeerId = async (peerId) => {\n  log('using user-supplied private-key')\n  if (isPeerId(peerId)) {\n    return peerId\n  }\n\n  const rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad')\n  const key = await unmarshalPrivateKey(rawPrivateKey)\n  return await peerIdFromKeys(key.public.bytes, key.bytes)\n}\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm)\n\n  if (algorithm === 'Ed25519') {\n    return createEd25519PeerId()\n  }\n\n  if (algorithm === 'RSA') {\n    return createRSAPeerId({ bits })\n  }\n\n  throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM')\n}\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = (peerId) => {\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY')\n  }\n\n  return {\n    PeerID: peerId.toString(),\n    /** @type {string} */\n    PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')\n  }\n}\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config\n  const profiles = (options.init && options.init.profiles) || []\n  const pass = options.pass\n  const original = await repo.config.getAll()\n  const changed = mergeConfigs(applyProfiles(original, profiles), config)\n\n  if (original !== changed) {\n    await repo.config.replace(changed)\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo')\n  }\n\n  const buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad')\n  const key = await unmarshalPrivateKey(buf)\n  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes)\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  })\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) =>\n  changes ? mergeOptions(config, changes) : config\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configProfiles[name]\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`)\n    }\n    log('applying profile %s', name)\n    return profile.transform(config)\n  }, config)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}