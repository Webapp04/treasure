{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport cache from 'hashlru';\nimport varint from 'varint';\nimport { Key } from 'interface-datastore/key';\nimport Queue from 'p-queue';\nimport { PROVIDERS_CLEANUP_INTERVAL, PROVIDERS_VALIDITY, PROVIDERS_LRU_CACHE_SIZE, PROVIDER_KEY_PREFIX } from './constants.js';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { Components } from '@libp2p/components';\nvar log = logger('libp2p:kad-dht:providers');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nexport var Providers = /*#__PURE__*/function () {\n  function Providers() {\n    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Providers);\n    this.components = new Components();\n    var cacheSize = init.cacheSize,\n      cleanupInterval = init.cleanupInterval,\n      provideValidity = init.provideValidity;\n    this.cleanupInterval = cleanupInterval !== null && cleanupInterval !== void 0 ? cleanupInterval : PROVIDERS_CLEANUP_INTERVAL;\n    this.provideValidity = provideValidity !== null && provideValidity !== void 0 ? provideValidity : PROVIDERS_VALIDITY;\n    this.cache = cache(cacheSize !== null && cacheSize !== void 0 ? cacheSize : PROVIDERS_LRU_CACHE_SIZE);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n    this.started = false;\n  }\n  _createClass(Providers, [{\n    key: \"init\",\n    value: function init(components) {\n      this.components = components;\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n    /**\n     * Start the provider cleanup service\n     */\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.started) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              this.started = true;\n              this.cleaner = setInterval(function () {\n                _this._cleanup().catch(function (err) {\n                  log.error(err);\n                });\n              }, this.cleanupInterval);\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n    /**\n     * Release any resources.\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.started = false;\n              if (this.cleaner != null) {\n                clearInterval(this.cleaner);\n                this.cleaner = undefined;\n              }\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Check all providers if they are still valid, and if not delete them\n     */\n  }, {\n    key: \"_cleanup\",\n    value: function () {\n      var _cleanup2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this2 = this;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                var start, count, deleteCount, deleted, batch, query, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, _parseProviderKey, cid, peerId, time, now, delta, expired, _deleted$get, peers, _iterator3, _step3, _step3$value, _cid, _peers, key, provs, _iterator4, _step4, _peerId;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      start = Date.now();\n                      count = 0;\n                      deleteCount = 0;\n                      deleted = new Map();\n                      batch = _this2.components.getDatastore().batch(); // Get all provider entries from the datastore\n                      query = _this2.components.getDatastore().query({\n                        prefix: PROVIDER_KEY_PREFIX\n                      });\n                      _iteratorAbruptCompletion = false;\n                      _didIteratorError = false;\n                      _context3.prev = 8;\n                      _iterator = _asyncIterator(query);\n                    case 10:\n                      _context3.next = 12;\n                      return _iterator.next();\n                    case 12:\n                      if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {\n                        _context3.next = 18;\n                        break;\n                      }\n                      entry = _step.value;\n                      try {\n                        // Add a delete to the batch for each expired entry\n                        _parseProviderKey = parseProviderKey(entry.key), cid = _parseProviderKey.cid, peerId = _parseProviderKey.peerId;\n                        time = readTime(entry.value).getTime();\n                        now = Date.now();\n                        delta = now - time;\n                        expired = delta > _this2.provideValidity;\n                        log('comparing: %d - %d = %d > %d %s', now, time, delta, _this2.provideValidity, expired ? '(expired)' : '');\n                        if (expired) {\n                          deleteCount++;\n                          batch.delete(entry.key);\n                          peers = (_deleted$get = deleted.get(cid)) !== null && _deleted$get !== void 0 ? _deleted$get : new Set();\n                          peers.add(peerId);\n                          deleted.set(cid, peers);\n                        }\n                        count++;\n                      } catch (err) {\n                        log.error(err.message);\n                      }\n                    case 15:\n                      _iteratorAbruptCompletion = false;\n                      _context3.next = 10;\n                      break;\n                    case 18:\n                      _context3.next = 24;\n                      break;\n                    case 20:\n                      _context3.prev = 20;\n                      _context3.t0 = _context3[\"catch\"](8);\n                      _didIteratorError = true;\n                      _iteratorError = _context3.t0;\n                    case 24:\n                      _context3.prev = 24;\n                      _context3.prev = 25;\n                      if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                        _context3.next = 29;\n                        break;\n                      }\n                      _context3.next = 29;\n                      return _iterator.return();\n                    case 29:\n                      _context3.prev = 29;\n                      if (!_didIteratorError) {\n                        _context3.next = 32;\n                        break;\n                      }\n                      throw _iteratorError;\n                    case 32:\n                      return _context3.finish(29);\n                    case 33:\n                      return _context3.finish(24);\n                    case 34:\n                      if (!(deleted.size > 0)) {\n                        _context3.next = 40;\n                        break;\n                      }\n                      log('deleting %d / %d entries', deleteCount, count);\n                      _context3.next = 38;\n                      return batch.commit();\n                    case 38:\n                      _context3.next = 41;\n                      break;\n                    case 40:\n                      log('nothing to delete');\n                    case 41:\n                      // Clear expired entries from the cache\n                      _iterator3 = _createForOfIteratorHelper(deleted);\n                      try {\n                        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                          _step3$value = _slicedToArray(_step3.value, 2), _cid = _step3$value[0], _peers = _step3$value[1];\n                          key = makeProviderKey(_cid);\n                          provs = _this2.cache.get(key);\n                          if (provs != null) {\n                            _iterator4 = _createForOfIteratorHelper(_peers);\n                            try {\n                              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                                _peerId = _step4.value;\n                                provs.delete(_peerId);\n                              }\n                            } catch (err) {\n                              _iterator4.e(err);\n                            } finally {\n                              _iterator4.f();\n                            }\n                            if (provs.size === 0) {\n                              _this2.cache.remove(key);\n                            } else {\n                              _this2.cache.set(key, provs);\n                            }\n                          }\n                        }\n                      } catch (err) {\n                        _iterator3.e(err);\n                      } finally {\n                        _iterator3.f();\n                      }\n                      log('Cleanup successful (%dms)', Date.now() - start);\n                    case 44:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3, null, [[8, 20, 24, 34], [25,, 29, 33]]);\n              })));\n            case 2:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _cleanup() {\n        return _cleanup2.apply(this, arguments);\n      }\n      return _cleanup;\n    }()\n    /**\n     * Get the currently known provider peer ids for a given CID\n     */\n  }, {\n    key: \"_getProvidersMap\",\n    value: function () {\n      var _getProvidersMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cid) {\n        var cacheKey, provs;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              cacheKey = makeProviderKey(cid);\n              provs = this.cache.get(cacheKey);\n              if (!(provs == null)) {\n                _context5.next = 7;\n                break;\n              }\n              _context5.next = 5;\n              return loadProviders(this.components.getDatastore(), cid);\n            case 5:\n              provs = _context5.sent;\n              this.cache.set(cacheKey, provs);\n            case 7:\n              return _context5.abrupt(\"return\", provs);\n            case 8:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _getProvidersMap(_x) {\n        return _getProvidersMap2.apply(this, arguments);\n      }\n      return _getProvidersMap;\n    }()\n    /**\n     * Add a new provider for the given CID\n     */\n  }, {\n    key: \"addProvider\",\n    value: function () {\n      var _addProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(cid, provider) {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n                var provs, now, dsKey;\n                return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                  while (1) switch (_context6.prev = _context6.next) {\n                    case 0:\n                      log('%p provides %s', provider, cid);\n                      _context6.next = 3;\n                      return _this3._getProvidersMap(cid);\n                    case 3:\n                      provs = _context6.sent;\n                      log('loaded %s provs', provs.size);\n                      now = new Date();\n                      provs.set(provider.toString(), now);\n                      dsKey = makeProviderKey(cid);\n                      _this3.cache.set(dsKey, provs);\n                      _context6.next = 11;\n                      return writeProviderEntry(_this3.components.getDatastore(), cid, provider, now);\n                    case 11:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }, _callee6);\n              })));\n            case 2:\n              return _context7.abrupt(\"return\", _context7.sent);\n            case 3:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function addProvider(_x2, _x3) {\n        return _addProvider.apply(this, arguments);\n      }\n      return addProvider;\n    }()\n    /**\n     * Get a list of providers for the given CID\n     */\n  }, {\n    key: \"getProviders\",\n    value: function () {\n      var _getProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(cid) {\n        var _this4 = this;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n                var provs;\n                return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                  while (1) switch (_context8.prev = _context8.next) {\n                    case 0:\n                      log('get providers for %s', cid);\n                      _context8.next = 3;\n                      return _this4._getProvidersMap(cid);\n                    case 3:\n                      provs = _context8.sent;\n                      return _context8.abrupt(\"return\", _toConsumableArray(provs.keys()).map(function (peerIdStr) {\n                        return peerIdFromString(peerIdStr);\n                      }));\n                    case 5:\n                    case \"end\":\n                      return _context8.stop();\n                  }\n                }, _callee8);\n              })));\n            case 2:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 3:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function getProviders(_x4) {\n        return _getProviders.apply(this, arguments);\n      }\n      return getProviders;\n    }()\n  }]);\n  return Providers;\n}();\n/**\n * Encode the given key its matching datastore key\n */\nfunction makeProviderKey(cid) {\n  var cidStr = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32');\n  return \"\".concat(PROVIDER_KEY_PREFIX, \"/\").concat(cidStr);\n}\n/**\n * Write a provider into the given store\n */\nfunction writeProviderEntry(_x5, _x6, _x7, _x8) {\n  return _writeProviderEntry.apply(this, arguments);\n}\n/**\n * Parse the CID and provider peer id from the key\n */\nfunction _writeProviderEntry() {\n  _writeProviderEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(store, cid, peer, time) {\n    var dsKey, key, buffer;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          dsKey = [makeProviderKey(cid), '/', peer.toString()].join('');\n          key = new Key(dsKey);\n          buffer = Uint8Array.from(varint.encode(time.getTime()));\n          _context10.next = 5;\n          return store.put(key, buffer);\n        case 5:\n          return _context10.abrupt(\"return\", _context10.sent);\n        case 6:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee10);\n  }));\n  return _writeProviderEntry.apply(this, arguments);\n}\nfunction parseProviderKey(key) {\n  var parts = key.toString().split('/');\n  if (parts.length !== 5) {\n    throw new Error(\"incorrectly formatted provider entry key in datastore: \".concat(key.toString()));\n  }\n  return {\n    cid: parts[3],\n    peerId: parts[4]\n  };\n}\n/**\n * Load providers for the given CID from the store\n */\nfunction loadProviders(_x9, _x10) {\n  return _loadProviders.apply(this, arguments);\n}\nfunction _loadProviders() {\n  _loadProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(store, cid) {\n    var providers, query, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, entry, _parseProviderKey2, peerId;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) switch (_context11.prev = _context11.next) {\n        case 0:\n          providers = new Map();\n          query = store.query({\n            prefix: makeProviderKey(cid)\n          });\n          _iteratorAbruptCompletion2 = false;\n          _didIteratorError2 = false;\n          _context11.prev = 4;\n          _iterator2 = _asyncIterator(query);\n        case 6:\n          _context11.next = 8;\n          return _iterator2.next();\n        case 8:\n          if (!(_iteratorAbruptCompletion2 = !(_step2 = _context11.sent).done)) {\n            _context11.next = 15;\n            break;\n          }\n          entry = _step2.value;\n          _parseProviderKey2 = parseProviderKey(entry.key), peerId = _parseProviderKey2.peerId;\n          providers.set(peerId, readTime(entry.value));\n        case 12:\n          _iteratorAbruptCompletion2 = false;\n          _context11.next = 6;\n          break;\n        case 15:\n          _context11.next = 21;\n          break;\n        case 17:\n          _context11.prev = 17;\n          _context11.t0 = _context11[\"catch\"](4);\n          _didIteratorError2 = true;\n          _iteratorError2 = _context11.t0;\n        case 21:\n          _context11.prev = 21;\n          _context11.prev = 22;\n          if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n            _context11.next = 26;\n            break;\n          }\n          _context11.next = 26;\n          return _iterator2.return();\n        case 26:\n          _context11.prev = 26;\n          if (!_didIteratorError2) {\n            _context11.next = 29;\n            break;\n          }\n          throw _iteratorError2;\n        case 29:\n          return _context11.finish(26);\n        case 30:\n          return _context11.finish(21);\n        case 31:\n          return _context11.abrupt(\"return\", providers);\n        case 32:\n        case \"end\":\n          return _context11.stop();\n      }\n    }, _callee11, null, [[4, 17, 21, 31], [22,, 26, 30]]);\n  }));\n  return _loadProviders.apply(this, arguments);\n}\nfunction readTime(buf) {\n  return new Date(varint.decode(buf));\n}","map":{"version":3,"names":["cache","varint","Key","Queue","PROVIDERS_CLEANUP_INTERVAL","PROVIDERS_VALIDITY","PROVIDERS_LRU_CACHE_SIZE","PROVIDER_KEY_PREFIX","logger","toString","uint8ArrayToString","peerIdFromString","Components","log","Providers","init","arguments","length","undefined","_classCallCheck","components","cacheSize","cleanupInterval","provideValidity","syncQueue","concurrency","started","_createClass","key","value","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this","wrap","_callee$","_context","prev","next","abrupt","cleaner","setInterval","_cleanup","catch","err","error","stop","start","apply","_stop","_callee2","_callee2$","_context2","clearInterval","_cleanup2","_callee4","_this2","_callee4$","_context4","add","_callee3","count","deleteCount","deleted","batch","query","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","entry","_parseProviderKey","cid","peerId","time","now","delta","expired","_deleted$get","peers","_iterator3","_step3","_step3$value","_cid","_peers","provs","_iterator4","_step4","_peerId","_callee3$","_context3","Date","Map","getDatastore","prefix","_asyncIterator","sent","done","parseProviderKey","readTime","getTime","delete","get","Set","set","message","t0","return","finish","size","commit","_createForOfIteratorHelper","s","n","_slicedToArray","makeProviderKey","e","f","remove","_getProvidersMap2","_callee5","cacheKey","_callee5$","_context5","loadProviders","_getProvidersMap","_x","_addProvider","_callee7","provider","_this3","_callee7$","_context7","_callee6","dsKey","_callee6$","_context6","writeProviderEntry","addProvider","_x2","_x3","_getProviders","_callee9","_this4","_callee9$","_context9","_callee8","_callee8$","_context8","_toConsumableArray","keys","map","peerIdStr","getProviders","_x4","cidStr","multihash","bytes","concat","_x5","_x6","_x7","_x8","_writeProviderEntry","_callee10","store","peer","buffer","_callee10$","_context10","join","Uint8Array","from","encode","put","parts","split","Error","_x9","_x10","_loadProviders","_callee11","providers","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_parseProviderKey2","_callee11$","_context11","buf","decode"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/kad-dht/src/providers.ts"],"sourcesContent":["import cache from 'hashlru'\nimport varint from 'varint'\nimport { Key } from 'interface-datastore/key'\nimport Queue from 'p-queue'\nimport {\n  PROVIDERS_CLEANUP_INTERVAL,\n  PROVIDERS_VALIDITY,\n  PROVIDERS_LRU_CACHE_SIZE,\n  PROVIDER_KEY_PREFIX\n} from './constants.js'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { Datastore } from 'interface-datastore'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { CID } from 'multiformats'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { Components, Initializable } from '@libp2p/components'\n\nconst log = logger('libp2p:kad-dht:providers')\n\nexport interface ProvidersInit {\n  cacheSize?: number\n  /**\n   * How often invalid records are cleaned. (in seconds)\n   */\n  cleanupInterval?: number\n  /**\n   * How long is a provider valid for. (in seconds)\n   */\n  provideValidity?: number\n}\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nexport class Providers implements Startable, Initializable {\n  private components: Components = new Components()\n  private readonly cache: ReturnType<typeof cache>\n  private readonly cleanupInterval: number\n  private readonly provideValidity: number\n  private readonly syncQueue: Queue\n  private started: boolean\n  private cleaner?: NodeJS.Timer\n\n  constructor (init: ProvidersInit = {}) {\n    const { cacheSize, cleanupInterval, provideValidity } = init\n\n    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL\n    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY\n    this.cache = cache(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE)\n    this.syncQueue = new Queue({ concurrency: 1 })\n    this.started = false\n  }\n\n  init (components: Components): void {\n    this.components = components\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * Start the provider cleanup service\n   */\n  async start () {\n    if (this.started) {\n      return\n    }\n\n    this.started = true\n\n    this.cleaner = setInterval(\n      () => {\n        this._cleanup().catch(err => {\n          log.error(err)\n        })\n      },\n      this.cleanupInterval\n    )\n  }\n\n  /**\n   * Release any resources.\n   */\n  async stop () {\n    this.started = false\n\n    if (this.cleaner != null) {\n      clearInterval(this.cleaner)\n      this.cleaner = undefined\n    }\n  }\n\n  /**\n   * Check all providers if they are still valid, and if not delete them\n   */\n  async _cleanup () {\n    return await this.syncQueue.add(async () => {\n      const start = Date.now()\n\n      let count = 0\n      let deleteCount = 0\n      const deleted = new Map<string, Set<string>>()\n      const batch = this.components.getDatastore().batch()\n\n      // Get all provider entries from the datastore\n      const query = this.components.getDatastore().query({ prefix: PROVIDER_KEY_PREFIX })\n\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const { cid, peerId } = parseProviderKey(entry.key)\n          const time = readTime(entry.value).getTime()\n          const now = Date.now()\n          const delta = now - time\n          const expired = delta > this.provideValidity\n\n          log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '')\n\n          if (expired) {\n            deleteCount++\n            batch.delete(entry.key)\n            const peers = deleted.get(cid) ?? new Set<string>()\n            peers.add(peerId)\n            deleted.set(cid, peers)\n          }\n          count++\n        } catch (err: any) {\n          log.error(err.message)\n        }\n      }\n\n      // Commit the deletes to the datastore\n      if (deleted.size > 0) {\n        log('deleting %d / %d entries', deleteCount, count)\n        await batch.commit()\n      } else {\n        log('nothing to delete')\n      }\n\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid)\n        const provs = this.cache.get(key)\n\n        if (provs != null) {\n          for (const peerId of peers) {\n            provs.delete(peerId)\n          }\n\n          if (provs.size === 0) {\n            this.cache.remove(key)\n          } else {\n            this.cache.set(key, provs)\n          }\n        }\n      }\n\n      log('Cleanup successful (%dms)', Date.now() - start)\n    })\n  }\n\n  /**\n   * Get the currently known provider peer ids for a given CID\n   */\n  async _getProvidersMap (cid: CID) {\n    const cacheKey = makeProviderKey(cid)\n    let provs: Map<string, Date> = this.cache.get(cacheKey)\n\n    if (provs == null) {\n      provs = await loadProviders(this.components.getDatastore(), cid)\n      this.cache.set(cacheKey, provs)\n    }\n\n    return provs\n  }\n\n  /**\n   * Add a new provider for the given CID\n   */\n  async addProvider (cid: CID, provider: PeerId) {\n    return await this.syncQueue.add(async () => {\n      log('%p provides %s', provider, cid)\n      const provs = await this._getProvidersMap(cid)\n\n      log('loaded %s provs', provs.size)\n      const now = new Date()\n      provs.set(provider.toString(), now)\n\n      const dsKey = makeProviderKey(cid)\n      this.cache.set(dsKey, provs)\n\n      await writeProviderEntry(this.components.getDatastore(), cid, provider, now)\n    })\n  }\n\n  /**\n   * Get a list of providers for the given CID\n   */\n  async getProviders (cid: CID): Promise<PeerId[]> {\n    return await this.syncQueue.add(async () => {\n      log('get providers for %s', cid)\n      const provs = await this._getProvidersMap(cid)\n\n      return [...provs.keys()].map(peerIdStr => {\n        return peerIdFromString(peerIdStr)\n      })\n    })\n  }\n}\n\n/**\n * Encode the given key its matching datastore key\n */\nfunction makeProviderKey (cid: CID | string) {\n  const cidStr = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32')\n\n  return `${PROVIDER_KEY_PREFIX}/${cidStr}`\n}\n\n/**\n * Write a provider into the given store\n */\nasync function writeProviderEntry (store: Datastore, cid: CID, peer: PeerId, time: Date) { // eslint-disable-line require-await\n  const dsKey = [\n    makeProviderKey(cid),\n    '/',\n    peer.toString()\n  ].join('')\n\n  const key = new Key(dsKey)\n  const buffer = Uint8Array.from(varint.encode(time.getTime()))\n\n  return await store.put(key, buffer)\n}\n\n/**\n * Parse the CID and provider peer id from the key\n */\nfunction parseProviderKey (key: Key) {\n  const parts = key.toString().split('/')\n\n  if (parts.length !== 5) {\n    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`)\n  }\n\n  return {\n    cid: parts[3],\n    peerId: parts[4]\n  }\n}\n\n/**\n * Load providers for the given CID from the store\n */\nasync function loadProviders (store: Datastore, cid: CID) {\n  const providers = new Map<string, Date>()\n  const query = store.query({ prefix: makeProviderKey(cid) })\n\n  for await (const entry of query) {\n    const { peerId } = parseProviderKey(entry.key)\n    providers.set(peerId, readTime(entry.value))\n  }\n\n  return providers\n}\n\nfunction readTime (buf: Uint8Array) {\n  return new Date(varint.decode(buf))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}