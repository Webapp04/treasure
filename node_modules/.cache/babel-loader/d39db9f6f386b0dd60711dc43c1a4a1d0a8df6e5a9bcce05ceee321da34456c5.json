{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { IpnsPublisher } from './publisher.js';\nimport { IpnsRepublisher } from './republisher.js';\nimport { IpnsResolver } from './resolver.js';\nimport { TLRU } from '../utils/tlru.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nvar log = logger('ipfs:ipns');\nvar defaultRecordTtl = 60 * 1000;\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nexport var IPNS = /*#__PURE__*/function () {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  function IPNS(routing, datastore, peerId, keychain, options) {\n    _classCallCheck(this, IPNS);\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  }\n\n  /**\n   * Publish\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  _createClass(IPNS, [{\n    key: \"publish\",\n    value: function () {\n      var _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, value) {\n        var lifetime,\n          options,\n          id,\n          ttEol,\n          ttl,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              lifetime = _args.length > 2 && _args[2] !== undefined ? _args[2] : IpnsPublisher.defaultRecordLifetime;\n              options = _args.length > 3 ? _args[3] : undefined;\n              _context.prev = 2;\n              _context.next = 5;\n              return this.publisher.publishWithEOL(peerId, value, lifetime, options);\n            case 5:\n              log(\"IPNS value \".concat(uint8ArrayToString(value, 'base32'), \" was published correctly\"));\n\n              // // Add to cache\n              id = peerId.toString(); // @ts-expect-error - parseFloat expects string\n              ttEol = parseFloat(lifetime);\n              ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n              this.cache.set(id, value, ttl);\n              log(\"IPNS value \".concat(uint8ArrayToString(value, 'base32'), \" was cached correctly\"));\n              return _context.abrupt(\"return\", {\n                name: id,\n                value: value\n              });\n            case 14:\n              _context.prev = 14;\n              _context.t0 = _context[\"catch\"](2);\n              log.error(_context.t0);\n              throw _context.t0;\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2, 14]]);\n      }));\n      function publish(_x, _x2) {\n        return _publish.apply(this, arguments);\n      }\n      return publish;\n    }()\n    /**\n     * Resolve\n     *\n     * @param {string} name\n     * @param {object} options\n     * @param {boolean} [options.nocache]\n     * @param {boolean} [options.recursive]\n     * @param {AbortSignal} [options.signal]\n     */\n  }, {\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {\n        var options,\n          id,\n          result,\n          _result,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              if (!(typeof name !== 'string')) {\n                _context2.next = 3;\n                break;\n              }\n              throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n            case 3:\n              if (!(!options.nocache && !options.recursive)) {\n                _context2.next = 8;\n                break;\n              }\n              // Try to get the record from cache\n              id = name.split('/')[2];\n              result = this.cache.get(id);\n              if (!result) {\n                _context2.next = 8;\n                break;\n              }\n              return _context2.abrupt(\"return\", result);\n            case 8:\n              _context2.prev = 8;\n              _context2.next = 11;\n              return this.resolver.resolve(name, options);\n            case 11:\n              _result = _context2.sent;\n              log(\"IPNS record from \".concat(name, \" was resolved correctly\"));\n              return _context2.abrupt(\"return\", _result);\n            case 16:\n              _context2.prev = 16;\n              _context2.t0 = _context2[\"catch\"](8);\n              log.error(_context2.t0);\n              throw _context2.t0;\n            case 20:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[8, 16]]);\n      }));\n      function resolve(_x3) {\n        return _resolve.apply(this, arguments);\n      }\n      return resolve;\n    }()\n    /**\n     * Initialize keyspace\n     *\n     * Sets the ipns record for the given key to point to an empty directory\n     *\n     * @param {PeerId} peerId\n     * @param {Uint8Array} value\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"initializeKeyspace\",\n    value: function () {\n      var _initializeKeyspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peerId, value, options) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", this.publish(peerId, value, IpnsPublisher.defaultRecordLifetime, options));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function initializeKeyspace(_x4, _x5, _x6) {\n        return _initializeKeyspace.apply(this, arguments);\n      }\n      return initializeKeyspace;\n    }()\n  }]);\n  return IPNS;\n}();","map":{"version":3,"names":["errcode","logger","IpnsPublisher","IpnsRepublisher","IpnsResolver","TLRU","toString","uint8ArrayToString","log","defaultRecordTtl","IPNS","routing","datastore","peerId","keychain","options","_classCallCheck","publisher","republisher","resolver","cache","_createClass","key","value","_publish","_asyncToGenerator","_regeneratorRuntime","mark","_callee","lifetime","id","ttEol","ttl","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","defaultRecordLifetime","publishWithEOL","concat","parseFloat","set","abrupt","name","t0","error","stop","publish","_x","_x2","apply","_resolve","_callee2","result","_result","_args2","_callee2$","_context2","Error","nocache","recursive","split","get","resolve","sent","_x3","_initializeKeyspace","_callee3","_callee3$","_context3","initializeKeyspace","_x4","_x5","_x6"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/ipns/index.js"],"sourcesContent":["import errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { IpnsPublisher } from './publisher.js'\nimport { IpnsRepublisher } from './republisher.js'\nimport { IpnsResolver } from './resolver.js'\nimport { TLRU } from '../utils/tlru.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst log = logger('ipfs:ipns')\nconst defaultRecordTtl = 60 * 1000\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nexport class IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new TLRU(1000)\n    this.routing = routing\n  }\n\n  /**\n   * Publish\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publish (peerId, value, lifetime = IpnsPublisher.defaultRecordLifetime, options) {\n    try {\n      await this.publisher.publishWithEOL(peerId, value, lifetime, options)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`)\n\n      // // Add to cache\n      const id = peerId.toString()\n      // @ts-expect-error - parseFloat expects string\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, ttl)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`)\n\n      return {\n        name: id,\n        value: value\n      }\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME')\n    }\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return result\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options)\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      return result\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  async initializeKeyspace (peerId, value, options) { // eslint-disable-line require-await\n    return this.publish(peerId, value, IpnsPublisher.defaultRecordLifetime, options)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}