{"ast":null,"code":"import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { SendingQuery, PeerResponse, FinalPeer, QueryError, Provider, Value, AddingPeer, DialingPeer } from './response-types.js';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { peerIdFromString } from '@libp2p/peer-id';\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {{Type: number, ID: string, Extra: string, Responses: {ID: string, Addrs: string[]}[]}} event\n * @returns {import('ipfs-core-types/src/dht').QueryEvent}\n */\nexport var mapEvent = function mapEvent(event) {\n  if (event.Type === SendingQuery) {\n    return {\n      name: 'SENDING_QUERY',\n      type: event.Type\n    };\n  }\n  if (event.Type === PeerResponse) {\n    return {\n      from: peerIdFromString(event.ID),\n      name: 'PEER_RESPONSE',\n      type: event.Type,\n      // TODO: how to infer this from the go-ipfs response\n      messageType: 0,\n      // TODO: how to infer this from the go-ipfs response\n      messageName: 'PUT_VALUE',\n      closer: (event.Responses || []).map(function (_ref) {\n        var ID = _ref.ID,\n          Addrs = _ref.Addrs;\n        return {\n          id: peerIdFromString(ID),\n          multiaddrs: Addrs.map(function (addr) {\n            return multiaddr(addr);\n          }),\n          protocols: []\n        };\n      }),\n      providers: (event.Responses || []).map(function (_ref2) {\n        var ID = _ref2.ID,\n          Addrs = _ref2.Addrs;\n        return {\n          id: peerIdFromString(ID),\n          multiaddrs: Addrs.map(function (addr) {\n            return multiaddr(addr);\n          }),\n          protocols: []\n        };\n      })\n      // TODO: how to infer this from the go-ipfs response\n      // record: ???\n    };\n  }\n\n  if (event.Type === FinalPeer) {\n    var _event$ID;\n    // dht.query ends with a FinalPeer event with no Responses\n    /** @type {import('@libp2p/interface-peer-info').PeerInfo} */\n    var peer = {\n      // @ts-expect-error go-ipfs does not return this\n      id: (_event$ID = event.ID) !== null && _event$ID !== void 0 ? _event$ID : peerIdFromString(event.ID),\n      /** @type {Multiaddr[]} */\n      multiaddrs: [],\n      protocols: []\n    };\n    if (event.Responses && event.Responses.length) {\n      // dht.findPeer has the result in the Responses field\n      peer = {\n        id: peerIdFromString(event.Responses[0].ID),\n        multiaddrs: event.Responses[0].Addrs.map(function (addr) {\n          return multiaddr(addr);\n        }),\n        protocols: []\n      };\n    }\n    return {\n      name: 'FINAL_PEER',\n      type: event.Type,\n      peer: peer\n    };\n  }\n  if (event.Type === QueryError) {\n    return {\n      name: 'QUERY_ERROR',\n      type: event.Type,\n      error: new Error(event.Extra)\n    };\n  }\n  if (event.Type === Provider) {\n    return {\n      name: 'PROVIDER',\n      type: event.Type,\n      providers: event.Responses.map(function (_ref3) {\n        var ID = _ref3.ID,\n          Addrs = _ref3.Addrs;\n        return {\n          id: peerIdFromString(ID),\n          multiaddrs: Addrs.map(function (addr) {\n            return multiaddr(addr);\n          }),\n          protocols: []\n        };\n      })\n    };\n  }\n  if (event.Type === Value) {\n    return {\n      name: 'VALUE',\n      type: event.Type,\n      value: uint8ArrayFromString(event.Extra, 'base64pad')\n    };\n  }\n  if (event.Type === AddingPeer) {\n    var peers = event.Responses.map(function (_ref4) {\n      var ID = _ref4.ID;\n      return peerIdFromString(ID);\n    });\n    if (!peers.length) {\n      throw new Error('No peer found');\n    }\n    return {\n      name: 'ADDING_PEER',\n      type: event.Type,\n      peer: peers[0]\n    };\n  }\n  if (event.Type === DialingPeer) {\n    return {\n      name: 'DIALING_PEER',\n      type: event.Type,\n      peer: peerIdFromString(event.ID)\n    };\n  }\n  throw new Error('Unknown DHT event type');\n};","map":{"version":3,"names":["fromString","uint8ArrayFromString","SendingQuery","PeerResponse","FinalPeer","QueryError","Provider","Value","AddingPeer","DialingPeer","multiaddr","peerIdFromString","mapEvent","event","Type","name","type","from","ID","messageType","messageName","closer","Responses","map","_ref","Addrs","id","multiaddrs","addr","protocols","providers","_ref2","_event$ID","peer","length","error","Error","Extra","_ref3","value","peers","_ref4"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-http-client/src/dht/map-event.js"],"sourcesContent":["import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport {\n  SendingQuery,\n  PeerResponse,\n  FinalPeer,\n  QueryError,\n  Provider,\n  Value,\n  AddingPeer,\n  DialingPeer\n} from './response-types.js'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {{Type: number, ID: string, Extra: string, Responses: {ID: string, Addrs: string[]}[]}} event\n * @returns {import('ipfs-core-types/src/dht').QueryEvent}\n */\nexport const mapEvent = (event) => {\n  if (event.Type === SendingQuery) {\n    return {\n      name: 'SENDING_QUERY',\n      type: event.Type\n    }\n  }\n\n  if (event.Type === PeerResponse) {\n    return {\n      from: peerIdFromString(event.ID),\n      name: 'PEER_RESPONSE',\n      type: event.Type,\n      // TODO: how to infer this from the go-ipfs response\n      messageType: 0,\n      // TODO: how to infer this from the go-ipfs response\n      messageName: 'PUT_VALUE',\n      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] })),\n      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] }))\n      // TODO: how to infer this from the go-ipfs response\n      // record: ???\n    }\n  }\n\n  if (event.Type === FinalPeer) {\n    // dht.query ends with a FinalPeer event with no Responses\n    /** @type {import('@libp2p/interface-peer-info').PeerInfo} */\n    let peer = {\n      // @ts-expect-error go-ipfs does not return this\n      id: event.ID ?? peerIdFromString(event.ID),\n      /** @type {Multiaddr[]} */\n      multiaddrs: [],\n      protocols: []\n    }\n\n    if (event.Responses && event.Responses.length) {\n      // dht.findPeer has the result in the Responses field\n      peer = {\n        id: peerIdFromString(event.Responses[0].ID),\n        multiaddrs: event.Responses[0].Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      }\n    }\n\n    return {\n      name: 'FINAL_PEER',\n      type: event.Type,\n      peer\n    }\n  }\n\n  if (event.Type === QueryError) {\n    return {\n      name: 'QUERY_ERROR',\n      type: event.Type,\n      error: new Error(event.Extra)\n    }\n  }\n\n  if (event.Type === Provider) {\n    return {\n      name: 'PROVIDER',\n      type: event.Type,\n      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] }))\n    }\n  }\n\n  if (event.Type === Value) {\n    return {\n      name: 'VALUE',\n      type: event.Type,\n      value: uint8ArrayFromString(event.Extra, 'base64pad')\n    }\n  }\n\n  if (event.Type === AddingPeer) {\n    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID))\n\n    if (!peers.length) {\n      throw new Error('No peer found')\n    }\n\n    return {\n      name: 'ADDING_PEER',\n      type: event.Type,\n      peer: peers[0]\n    }\n  }\n\n  if (event.Type === DialingPeer) {\n    return {\n      name: 'DIALING_PEER',\n      type: event.Type,\n      peer: peerIdFromString(event.ID)\n    }\n  }\n\n  throw new Error('Unknown DHT event type')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}