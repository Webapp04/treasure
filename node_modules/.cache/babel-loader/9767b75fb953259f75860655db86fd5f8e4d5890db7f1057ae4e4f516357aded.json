{"ast":null,"code":"var _slicedToArray = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar RateLimiterRes = require(\"./RateLimiterRes\");\n\n/**\n * Bursty rate limiter exposes only msBeforeNext time and doesn't expose points from bursty limiter by default\n * @type {BurstyRateLimiter}\n */\nmodule.exports = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function BurstyRateLimiter(rateLimiter, burstLimiter) {\n    _classCallCheck(this, BurstyRateLimiter);\n    this._rateLimiter = rateLimiter;\n    this._burstLimiter = burstLimiter;\n  }\n\n  /**\n   * Merge rate limiter response objects. Responses can be null\n   *\n   * @param {RateLimiterRes} [rlRes] Rate limiter response\n   * @param {RateLimiterRes} [blRes] Bursty limiter response\n   */\n  _createClass(BurstyRateLimiter, [{\n    key: \"_combineRes\",\n    value: function _combineRes(rlRes, blRes) {\n      return new RateLimiterRes(rlRes.remainingPoints, Math.min(rlRes.msBeforeNext, blRes.msBeforeNext), rlRes.consumedPoints, rlRes.isFirstInDuration);\n    }\n\n    /**\n     * @param key\n     * @param pointsToConsume\n     * @param options\n     * @returns {Promise<any>}\n     */\n  }, {\n    key: \"consume\",\n    value: function consume(key) {\n      var _this = this;\n      var pointsToConsume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._rateLimiter.consume(key, pointsToConsume, options).catch(function (rlRej) {\n        if (rlRej instanceof RateLimiterRes) {\n          return _this._burstLimiter.consume(key, pointsToConsume, options).then(function (blRes) {\n            return Promise.resolve(_this._combineRes(rlRej, blRes));\n          }).catch(function (blRej) {\n            if (blRej instanceof RateLimiterRes) {\n              return Promise.reject(_this._combineRes(rlRej, blRej));\n            } else {\n              return Promise.reject(blRej);\n            }\n          });\n        } else {\n          return Promise.reject(rlRej);\n        }\n      });\n    }\n\n    /**\n     * It doesn't expose available points from burstLimiter\n     *\n     * @param key\n     * @returns {Promise<RateLimiterRes>}\n     */\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var _this2 = this;\n      return Promise.all([this._rateLimiter.get(key), this._burstLimiter.get(key)]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          rlRes = _ref2[0],\n          blRes = _ref2[1];\n        return _this2._combineRes(rlRes, blRes);\n      });\n    }\n  }, {\n    key: \"points\",\n    get: function get() {\n      return this._rateLimiter.points;\n    }\n  }]);\n  return BurstyRateLimiter;\n}();","map":{"version":3,"names":["RateLimiterRes","require","module","exports","BurstyRateLimiter","rateLimiter","burstLimiter","_classCallCheck","_rateLimiter","_burstLimiter","_createClass","key","value","_combineRes","rlRes","blRes","remainingPoints","Math","min","msBeforeNext","consumedPoints","isFirstInDuration","consume","_this","pointsToConsume","arguments","length","undefined","options","catch","rlRej","then","Promise","resolve","blRej","reject","get","_this2","all","_ref","_ref2","_slicedToArray","points"],"sources":["/Users/apple/Documents/treasure/node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js"],"sourcesContent":["const RateLimiterRes = require(\"./RateLimiterRes\");\n\n/**\n * Bursty rate limiter exposes only msBeforeNext time and doesn't expose points from bursty limiter by default\n * @type {BurstyRateLimiter}\n */\nmodule.exports = class BurstyRateLimiter {\n  constructor(rateLimiter, burstLimiter) {\n    this._rateLimiter = rateLimiter;\n    this._burstLimiter = burstLimiter\n  }\n\n  /**\n   * Merge rate limiter response objects. Responses can be null\n   *\n   * @param {RateLimiterRes} [rlRes] Rate limiter response\n   * @param {RateLimiterRes} [blRes] Bursty limiter response\n   */\n  _combineRes(rlRes, blRes) {\n    return new RateLimiterRes(\n      rlRes.remainingPoints,\n      Math.min(rlRes.msBeforeNext, blRes.msBeforeNext),\n      rlRes.consumedPoints,\n      rlRes.isFirstInDuration\n    )\n  }\n\n  /**\n   * @param key\n   * @param pointsToConsume\n   * @param options\n   * @returns {Promise<any>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return this._rateLimiter.consume(key, pointsToConsume, options)\n      .catch((rlRej) => {\n        if (rlRej instanceof RateLimiterRes) {\n          return this._burstLimiter.consume(key, pointsToConsume, options)\n            .then((blRes) => {\n              return Promise.resolve(this._combineRes(rlRej, blRes))\n            })\n            .catch((blRej) => {\n                if (blRej instanceof RateLimiterRes) {\n                  return Promise.reject(this._combineRes(rlRej, blRej))\n                } else {\n                  return Promise.reject(blRej)\n                }\n              }\n            )\n        } else {\n          return Promise.reject(rlRej)\n        }\n      })\n  }\n\n  /**\n   * It doesn't expose available points from burstLimiter\n   *\n   * @param key\n   * @returns {Promise<RateLimiterRes>}\n   */\n  get(key) {\n    return Promise.all([\n      this._rateLimiter.get(key),\n      this._burstLimiter.get(key),\n    ]).then(([rlRes, blRes]) => {\n      return this._combineRes(rlRes, blRes);\n    });\n  }\n\n  get points() {\n    return this._rateLimiter.points;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}