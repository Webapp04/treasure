{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { logger } from '@libp2p/logger';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { RELAY_CODEC } from './multicodec.js';\nimport { canHop } from './circuit/hop.js';\nimport { namespaceToCid } from './utils.js';\nimport { CIRCUIT_PROTO_CODE, HOP_METADATA_KEY, HOP_METADATA_VALUE, RELAY_RENDEZVOUS_NS } from './constants.js';\nimport sort from 'it-sort';\nimport all from 'it-all';\nimport { pipe } from 'it-pipe';\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort';\nvar log = logger('libp2p:auto-relay');\nvar noop = function noop() {};\nexport var AutoRelay = /*#__PURE__*/function () {\n  function AutoRelay(components, init) {\n    var _init$addressSorter,\n      _init$maxListeners,\n      _init$onError,\n      _this = this;\n    _classCallCheck(this, AutoRelay);\n    this.components = components;\n    this.addressSorter = (_init$addressSorter = init.addressSorter) !== null && _init$addressSorter !== void 0 ? _init$addressSorter : publicAddressesFirst;\n    this.maxListeners = (_init$maxListeners = init.maxListeners) !== null && _init$maxListeners !== void 0 ? _init$maxListeners : 1;\n    this.listenRelays = new Set();\n    this.onError = (_init$onError = init.onError) !== null && _init$onError !== void 0 ? _init$onError : noop;\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n    this.components.getPeerStore().addEventListener('change:protocols', function (evt) {\n      void _this._onProtocolChange(evt).catch(function (err) {\n        log.error(err);\n      });\n    });\n    this.components.getConnectionManager().addEventListener('peer:disconnect', this._onPeerDisconnected);\n  }\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   */\n  _createClass(AutoRelay, [{\n    key: \"_onProtocolChange\",\n    value: function () {\n      var _onProtocolChange2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(evt) {\n        var _evt$detail, peerId, protocols, id, hasProtocol, connections, connection, supportsHop;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _evt$detail = evt.detail, peerId = _evt$detail.peerId, protocols = _evt$detail.protocols;\n              id = peerId.toString(); // Check if it has the protocol\n              hasProtocol = protocols.find(function (protocol) {\n                return protocol === RELAY_CODEC;\n              }); // If no protocol, check if we were keeping the peer before as a listenRelay\n              if (!(hasProtocol == null)) {\n                _context.next = 8;\n                break;\n              }\n              if (!this.listenRelays.has(id)) {\n                _context.next = 7;\n                break;\n              }\n              _context.next = 7;\n              return this._removeListenRelay(id);\n            case 7:\n              return _context.abrupt(\"return\");\n            case 8:\n              if (!this.listenRelays.has(id)) {\n                _context.next = 10;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 10:\n              _context.prev = 10;\n              connections = this.components.getConnectionManager().getConnections(peerId);\n              if (!(connections.length === 0)) {\n                _context.next = 14;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 14:\n              connection = connections[0]; // Do not hop on a relayed connection\n              if (!connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n                _context.next = 18;\n                break;\n              }\n              log(\"relayed connection to \".concat(id, \" will not be used to hop on\"));\n              return _context.abrupt(\"return\");\n            case 18:\n              _context.next = 20;\n              return canHop({\n                connection: connection\n              });\n            case 20:\n              supportsHop = _context.sent;\n              if (!supportsHop) {\n                _context.next = 26;\n                break;\n              }\n              _context.next = 24;\n              return this.components.getPeerStore().metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));\n            case 24:\n              _context.next = 26;\n              return this._addListenRelay(connection, id);\n            case 26:\n              _context.next = 31;\n              break;\n            case 28:\n              _context.prev = 28;\n              _context.t0 = _context[\"catch\"](10);\n              this.onError(_context.t0);\n            case 31:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[10, 28]]);\n      }));\n      function _onProtocolChange(_x) {\n        return _onProtocolChange2.apply(this, arguments);\n      }\n      return _onProtocolChange;\n    }()\n    /**\n     * Peer disconnects\n     */\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(evt) {\n      var connection = evt.detail;\n      var peerId = connection.remotePeer;\n      var id = peerId.toString();\n      // Not listening on this relay\n      if (!this.listenRelays.has(id)) {\n        return;\n      }\n      this._removeListenRelay(id).catch(function (err) {\n        log.error(err);\n      });\n    }\n    /**\n     * Attempt to listen on the given relay connection\n     */\n  }, {\n    key: \"_addListenRelay\",\n    value: function () {\n      var _addListenRelay2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(connection, id) {\n        var _this2 = this;\n        var remoteAddrs, result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.prev = 0;\n              if (!(this.listenRelays.size >= this.maxListeners)) {\n                _context4.next = 3;\n                break;\n              }\n              return _context4.abrupt(\"return\");\n            case 3:\n              _context4.t0 = pipe;\n              _context4.next = 6;\n              return this.components.getPeerStore().addressBook.get(connection.remotePeer);\n            case 6:\n              _context4.t1 = _context4.sent;\n              _context4.t2 = function (source) {\n                return sort(source, _this2.addressSorter);\n              };\n              _context4.t3 = /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return all(source);\n                      case 2:\n                        return _context2.abrupt(\"return\", _context2.sent);\n                      case 3:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2);\n                }));\n                return function (_x4) {\n                  return _ref.apply(this, arguments);\n                };\n              }();\n              _context4.next = 11;\n              return (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t3);\n            case 11:\n              remoteAddrs = _context4.sent;\n              _context4.next = 14;\n              return Promise.all(remoteAddrs.map( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(addr) {\n                  var multiaddr;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.prev = 0;\n                        multiaddr = addr.multiaddr;\n                        if (multiaddr.getPeerId() == null) {\n                          multiaddr = multiaddr.encapsulate(\"/p2p/\".concat(connection.remotePeer.toString()));\n                        }\n                        multiaddr = multiaddr.encapsulate('/p2p-circuit');\n                        // Announce multiaddrs will update on listen success by TransportManager event being triggered\n                        _context3.next = 6;\n                        return _this2.components.getTransportManager().listen([multiaddr]);\n                      case 6:\n                        return _context3.abrupt(\"return\", true);\n                      case 9:\n                        _context3.prev = 9;\n                        _context3.t0 = _context3[\"catch\"](0);\n                        log.error('error listening on circuit address', _context3.t0);\n                        _this2.onError(_context3.t0);\n                      case 13:\n                        return _context3.abrupt(\"return\", false);\n                      case 14:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3, null, [[0, 9]]);\n                }));\n                return function (_x5) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()));\n            case 14:\n              result = _context4.sent;\n              if (result.includes(true)) {\n                this.listenRelays.add(id);\n              }\n              _context4.next = 22;\n              break;\n            case 18:\n              _context4.prev = 18;\n              _context4.t4 = _context4[\"catch\"](0);\n              this.onError(_context4.t4);\n              this.listenRelays.delete(id);\n            case 22:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[0, 18]]);\n      }));\n      function _addListenRelay(_x2, _x3) {\n        return _addListenRelay2.apply(this, arguments);\n      }\n      return _addListenRelay;\n    }()\n    /**\n     * Remove listen relay\n     */\n  }, {\n    key: \"_removeListenRelay\",\n    value: function () {\n      var _removeListenRelay2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(id) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!this.listenRelays.delete(id)) {\n                _context5.next = 3;\n                break;\n              }\n              _context5.next = 3;\n              return this._listenOnAvailableHopRelays([id]);\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _removeListenRelay(_x6) {\n        return _removeListenRelay2.apply(this, arguments);\n      }\n      return _removeListenRelay;\n    }()\n    /**\n     * Try to listen on available hop relay connections.\n     * The following order will happen while we do not have enough relays.\n     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n     * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n     * 3. Search the network.\n     */\n  }, {\n    key: \"_listenOnAvailableHopRelays\",\n    value: function () {\n      var _listenOnAvailableHopRelays2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var peersToIgnore,\n          knownHopsToDial,\n          peers,\n          _iterator2,\n          _step2,\n          _step2$value,\n          id,\n          metadata,\n          idStr,\n          supportsHop,\n          connections,\n          _i,\n          _knownHopsToDial,\n          peerId,\n          cid,\n          _iteratorAbruptCompletion,\n          _didIteratorError,\n          _iteratorError,\n          _iterator,\n          _step,\n          provider,\n          _peerId,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              peersToIgnore = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : [];\n              if (!(this.listenRelays.size >= this.maxListeners)) {\n                _context6.next = 3;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 3:\n              knownHopsToDial = [];\n              _context6.next = 6;\n              return this.components.getPeerStore().all();\n            case 6:\n              peers = _context6.sent;\n              // Check if we have known hop peers to use and attempt to listen on the already connected\n              _iterator2 = _createForOfIteratorHelper(peers);\n              _context6.prev = 8;\n              _iterator2.s();\n            case 10:\n              if ((_step2 = _iterator2.n()).done) {\n                _context6.next = 30;\n                break;\n              }\n              _step2$value = _step2.value, id = _step2$value.id, metadata = _step2$value.metadata;\n              idStr = id.toString(); // Continue to next if listening on this or peer to ignore\n              if (!this.listenRelays.has(idStr)) {\n                _context6.next = 15;\n                break;\n              }\n              return _context6.abrupt(\"continue\", 28);\n            case 15:\n              if (!peersToIgnore.includes(idStr)) {\n                _context6.next = 17;\n                break;\n              }\n              return _context6.abrupt(\"continue\", 28);\n            case 17:\n              supportsHop = metadata.get(HOP_METADATA_KEY); // Continue to next if it does not support Hop\n              if (!(supportsHop == null || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE)) {\n                _context6.next = 20;\n                break;\n              }\n              return _context6.abrupt(\"continue\", 28);\n            case 20:\n              connections = this.components.getConnectionManager().getConnections(id); // If not connected, store for possible later use.\n              if (!(connections.length === 0)) {\n                _context6.next = 24;\n                break;\n              }\n              knownHopsToDial.push(id);\n              return _context6.abrupt(\"continue\", 28);\n            case 24:\n              _context6.next = 26;\n              return this._addListenRelay(connections[0], idStr);\n            case 26:\n              if (!(this.listenRelays.size >= this.maxListeners)) {\n                _context6.next = 28;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 28:\n              _context6.next = 10;\n              break;\n            case 30:\n              _context6.next = 35;\n              break;\n            case 32:\n              _context6.prev = 32;\n              _context6.t0 = _context6[\"catch\"](8);\n              _iterator2.e(_context6.t0);\n            case 35:\n              _context6.prev = 35;\n              _iterator2.f();\n              return _context6.finish(35);\n            case 38:\n              _i = 0, _knownHopsToDial = knownHopsToDial;\n            case 39:\n              if (!(_i < _knownHopsToDial.length)) {\n                _context6.next = 48;\n                break;\n              }\n              peerId = _knownHopsToDial[_i];\n              _context6.next = 43;\n              return this._tryToListenOnRelay(peerId);\n            case 43:\n              if (!(this.listenRelays.size >= this.maxListeners)) {\n                _context6.next = 45;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 45:\n              _i++;\n              _context6.next = 39;\n              break;\n            case 48:\n              _context6.prev = 48;\n              _context6.next = 51;\n              return namespaceToCid(RELAY_RENDEZVOUS_NS);\n            case 51:\n              cid = _context6.sent;\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context6.prev = 54;\n              _iterator = _asyncIterator(this.components.getContentRouting().findProviders(cid));\n            case 56:\n              _context6.next = 58;\n              return _iterator.next();\n            case 58:\n              if (!(_iteratorAbruptCompletion = !(_step = _context6.sent).done)) {\n                _context6.next = 74;\n                break;\n              }\n              provider = _step.value;\n              if (!(provider.multiaddrs.length === 0)) {\n                _context6.next = 62;\n                break;\n              }\n              return _context6.abrupt(\"continue\", 71);\n            case 62:\n              _peerId = provider.id;\n              if (!_peerId.equals(this.components.getPeerId())) {\n                _context6.next = 65;\n                break;\n              }\n              return _context6.abrupt(\"continue\", 71);\n            case 65:\n              _context6.next = 67;\n              return this.components.getPeerStore().addressBook.add(_peerId, provider.multiaddrs);\n            case 67:\n              _context6.next = 69;\n              return this._tryToListenOnRelay(_peerId);\n            case 69:\n              if (!(this.listenRelays.size >= this.maxListeners)) {\n                _context6.next = 71;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 71:\n              _iteratorAbruptCompletion = false;\n              _context6.next = 56;\n              break;\n            case 74:\n              _context6.next = 80;\n              break;\n            case 76:\n              _context6.prev = 76;\n              _context6.t1 = _context6[\"catch\"](54);\n              _didIteratorError = true;\n              _iteratorError = _context6.t1;\n            case 80:\n              _context6.prev = 80;\n              _context6.prev = 81;\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context6.next = 85;\n                break;\n              }\n              _context6.next = 85;\n              return _iterator.return();\n            case 85:\n              _context6.prev = 85;\n              if (!_didIteratorError) {\n                _context6.next = 88;\n                break;\n              }\n              throw _iteratorError;\n            case 88:\n              return _context6.finish(85);\n            case 89:\n              return _context6.finish(80);\n            case 90:\n              _context6.next = 95;\n              break;\n            case 92:\n              _context6.prev = 92;\n              _context6.t2 = _context6[\"catch\"](48);\n              this.onError(_context6.t2);\n            case 95:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[8, 32, 35, 38], [48, 92], [54, 76, 80, 90], [81,, 85, 89]]);\n      }));\n      function _listenOnAvailableHopRelays() {\n        return _listenOnAvailableHopRelays2.apply(this, arguments);\n      }\n      return _listenOnAvailableHopRelays;\n    }()\n  }, {\n    key: \"_tryToListenOnRelay\",\n    value: function () {\n      var _tryToListenOnRelay2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(peerId) {\n        var connection;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              _context7.next = 3;\n              return this.components.getConnectionManager().openConnection(peerId);\n            case 3:\n              connection = _context7.sent;\n              _context7.next = 6;\n              return this._addListenRelay(connection, peerId.toString());\n            case 6:\n              _context7.next = 12;\n              break;\n            case 8:\n              _context7.prev = 8;\n              _context7.t0 = _context7[\"catch\"](0);\n              log.error('Could not use %p as relay', peerId, _context7.t0);\n              this.onError(_context7.t0, \"could not connect and listen on known hop relay \".concat(peerId.toString()));\n            case 12:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[0, 8]]);\n      }));\n      function _tryToListenOnRelay(_x7) {\n        return _tryToListenOnRelay2.apply(this, arguments);\n      }\n      return _tryToListenOnRelay;\n    }()\n  }]);\n  return AutoRelay;\n}();","map":{"version":3,"names":["logger","fromString","uint8ArrayFromString","toString","uint8ArrayToString","RELAY_CODEC","canHop","namespaceToCid","CIRCUIT_PROTO_CODE","HOP_METADATA_KEY","HOP_METADATA_VALUE","RELAY_RENDEZVOUS_NS","sort","all","pipe","publicAddressesFirst","log","noop","AutoRelay","components","init","_init$addressSorter","_init$maxListeners","_init$onError","_this","_classCallCheck","addressSorter","maxListeners","listenRelays","Set","onError","_onProtocolChange","bind","_onPeerDisconnected","getPeerStore","addEventListener","evt","catch","err","error","getConnectionManager","_createClass","key","value","_onProtocolChange2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_evt$detail","peerId","protocols","id","hasProtocol","connections","connection","supportsHop","wrap","_callee$","_context","prev","next","detail","find","protocol","has","_removeListenRelay","abrupt","getConnections","length","remoteAddr","protoCodes","includes","concat","sent","metadataBook","setValue","_addListenRelay","t0","stop","_x","apply","arguments","remotePeer","_addListenRelay2","_callee4","_this2","remoteAddrs","result","_callee4$","_context4","size","addressBook","get","t1","t2","source","t3","_ref","_callee2","_callee2$","_context2","_x4","Promise","map","_ref2","_callee3","addr","multiaddr","_callee3$","_context3","getPeerId","encapsulate","getTransportManager","listen","_x5","add","t4","delete","_x2","_x3","_removeListenRelay2","_callee5","_callee5$","_context5","_listenOnAvailableHopRelays","_x6","_listenOnAvailableHopRelays2","_callee6","peersToIgnore","knownHopsToDial","peers","_iterator2","_step2","_step2$value","metadata","idStr","_i","_knownHopsToDial","cid","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","provider","_peerId","_args6","_callee6$","_context6","undefined","_createForOfIteratorHelper","s","n","done","push","e","f","finish","_tryToListenOnRelay","_asyncIterator","getContentRouting","findProviders","multiaddrs","equals","return","_tryToListenOnRelay2","_callee7","_callee7$","_context7","openConnection","_x7"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/circuit/auto-relay.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RELAY_CODEC } from './multicodec.js'\nimport { canHop } from './circuit/hop.js'\nimport { namespaceToCid } from './utils.js'\nimport {\n  CIRCUIT_PROTO_CODE,\n  HOP_METADATA_KEY,\n  HOP_METADATA_VALUE,\n  RELAY_RENDEZVOUS_NS\n} from './constants.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { AddressSorter, PeerProtocolsChangeData } from '@libp2p/interface-peer-store'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { Components } from '@libp2p/components'\nimport sort from 'it-sort'\nimport all from 'it-all'\nimport { pipe } from 'it-pipe'\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort'\n\nconst log = logger('libp2p:auto-relay')\n\nconst noop = () => {}\n\nexport interface AutoRelayInit {\n  addressSorter?: AddressSorter\n  maxListeners?: number\n  onError?: (error: Error, msg?: string) => void\n}\n\nexport class AutoRelay {\n  private readonly components: Components\n  private readonly addressSorter: AddressSorter\n  private readonly maxListeners: number\n  private readonly listenRelays: Set<string>\n  private readonly onError: (error: Error, msg?: string) => void\n\n  constructor (components: Components, init: AutoRelayInit) {\n    this.components = components\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst\n    this.maxListeners = init.maxListeners ?? 1\n    this.listenRelays = new Set()\n    this.onError = init.onError ?? noop\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n\n    this.components.getPeerStore().addEventListener('change:protocols', (evt) => {\n      void this._onProtocolChange(evt).catch(err => {\n        log.error(err)\n      })\n    })\n    this.components.getConnectionManager().addEventListener('peer:disconnect', this._onPeerDisconnected)\n  }\n\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   */\n  async _onProtocolChange (evt: CustomEvent<PeerProtocolsChangeData>) {\n    const {\n      peerId,\n      protocols\n    } = evt.detail\n    const id = peerId.toString()\n\n    // Check if it has the protocol\n    const hasProtocol = protocols.find(protocol => protocol === RELAY_CODEC)\n\n    // If no protocol, check if we were keeping the peer before as a listenRelay\n    if (hasProtocol == null) {\n      if (this.listenRelays.has(id)) {\n        await this._removeListenRelay(id)\n      }\n\n      return\n    }\n\n    if (this.listenRelays.has(id)) {\n      return\n    }\n\n    // If protocol, check if can hop, store info in the metadataBook and listen on it\n    try {\n      const connections = this.components.getConnectionManager().getConnections(peerId)\n\n      if (connections.length === 0) {\n        return\n      }\n\n      const connection = connections[0]\n\n      // Do not hop on a relayed connection\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`)\n        return\n      }\n\n      const supportsHop = await canHop({ connection })\n\n      if (supportsHop) {\n        await this.components.getPeerStore().metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE))\n        await this._addListenRelay(connection, id)\n      }\n    } catch (err: any) {\n      this.onError(err)\n    }\n  }\n\n  /**\n   * Peer disconnects\n   */\n  _onPeerDisconnected (evt: CustomEvent<Connection>) {\n    const connection = evt.detail\n    const peerId = connection.remotePeer\n    const id = peerId.toString()\n\n    // Not listening on this relay\n    if (!this.listenRelays.has(id)) {\n      return\n    }\n\n    this._removeListenRelay(id).catch(err => {\n      log.error(err)\n    })\n  }\n\n  /**\n   * Attempt to listen on the given relay connection\n   */\n  async _addListenRelay (connection: Connection, id: string): Promise<void> {\n    try {\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return\n      }\n\n      // Get peer known addresses and sort them with public addresses first\n      const remoteAddrs = await pipe(\n        await this.components.getPeerStore().addressBook.get(connection.remotePeer),\n        (source) => sort(source, this.addressSorter),\n        async (source) => await all(source)\n      )\n\n      // Attempt to listen on relay\n      const result = await Promise.all(\n        remoteAddrs.map(async addr => {\n          try {\n            let multiaddr = addr.multiaddr\n\n            if (multiaddr.getPeerId() == null) {\n              multiaddr = multiaddr.encapsulate(`/p2p/${connection.remotePeer.toString()}`)\n            }\n\n            multiaddr = multiaddr.encapsulate('/p2p-circuit')\n\n            // Announce multiaddrs will update on listen success by TransportManager event being triggered\n            await this.components.getTransportManager().listen([multiaddr])\n            return true\n          } catch (err: any) {\n            log.error('error listening on circuit address', err)\n            this.onError(err)\n          }\n\n          return false\n        })\n      )\n\n      if (result.includes(true)) {\n        this.listenRelays.add(id)\n      }\n    } catch (err: any) {\n      this.onError(err)\n      this.listenRelays.delete(id)\n    }\n  }\n\n  /**\n   * Remove listen relay\n   */\n  async _removeListenRelay (id: string) {\n    if (this.listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      await this._listenOnAvailableHopRelays([id])\n    }\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   */\n  async _listenOnAvailableHopRelays (peersToIgnore: string[] = []) {\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this.listenRelays.size >= this.maxListeners) {\n      return\n    }\n\n    const knownHopsToDial = []\n    const peers = await this.components.getPeerStore().all()\n\n    // Check if we have known hop peers to use and attempt to listen on the already connected\n    for (const { id, metadata } of peers) {\n      const idStr = id.toString()\n\n      // Continue to next if listening on this or peer to ignore\n      if (this.listenRelays.has(idStr)) {\n        continue\n      }\n\n      if (peersToIgnore.includes(idStr)) {\n        continue\n      }\n\n      const supportsHop = metadata.get(HOP_METADATA_KEY)\n\n      // Continue to next if it does not support Hop\n      if ((supportsHop == null) || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue\n      }\n\n      const connections = this.components.getConnectionManager().getConnections(id)\n\n      // If not connected, store for possible later use.\n      if (connections.length === 0) {\n        knownHopsToDial.push(id)\n        continue\n      }\n\n      await this._addListenRelay(connections[0], idStr)\n\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to listen on known peers that are not connected\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId)\n\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to find relays to hop on the network\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS)\n      for await (const provider of this.components.getContentRouting().findProviders(cid)) {\n        if (provider.multiaddrs.length === 0) {\n          continue\n        }\n\n        const peerId = provider.id\n\n        if (peerId.equals(this.components.getPeerId())) {\n          // Skip the provider if it's us as dialing will fail\n          continue\n        }\n\n        await this.components.getPeerStore().addressBook.add(peerId, provider.multiaddrs)\n\n        await this._tryToListenOnRelay(peerId)\n\n        // Check if already listening on enough relays\n        if (this.listenRelays.size >= this.maxListeners) {\n          return\n        }\n      }\n    } catch (err: any) {\n      this.onError(err)\n    }\n  }\n\n  async _tryToListenOnRelay (peerId: PeerId) {\n    try {\n      const connection = await this.components.getConnectionManager().openConnection(peerId)\n      await this._addListenRelay(connection, peerId.toString())\n    } catch (err: any) {\n      log.error('Could not use %p as relay', peerId, err)\n      this.onError(err, `could not connect and listen on known hop relay ${peerId.toString()}`)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}