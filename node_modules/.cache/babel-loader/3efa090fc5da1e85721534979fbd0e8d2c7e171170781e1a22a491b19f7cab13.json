{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _a;\nimport errCode from 'err-code';\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { codes } from '../errors.js';\nimport { Envelope as Protobuf } from './envelope.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nexport var RecordEnvelope = /*#__PURE__*/function () {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  function RecordEnvelope(init) {\n    _classCallCheck(this, RecordEnvelope);\n    var peerId = init.peerId,\n      payloadType = init.payloadType,\n      payload = init.payload,\n      signature = init.signature;\n    this.peerId = peerId;\n    this.payloadType = payloadType;\n    this.payload = payload;\n    this.signature = signature;\n  }\n  /**\n   * Marshal the envelope content\n   */\n  _createClass(RecordEnvelope, [{\n    key: \"marshal\",\n    value: function marshal() {\n      if (this.peerId.publicKey == null) {\n        throw new Error('Missing public key');\n      }\n      if (this.marshaled == null) {\n        this.marshaled = Protobuf.encode({\n          publicKey: this.peerId.publicKey,\n          payloadType: this.payloadType,\n          payload: this.payload.subarray(),\n          signature: this.signature\n        });\n      }\n      return this.marshaled;\n    }\n    /**\n     * Verifies if the other Envelope is identical to this one\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return uint8ArrayEquals(this.marshal(), other.marshal());\n    }\n    /**\n     * Validate envelope data signature for the given domain\n     */\n  }, {\n    key: \"validate\",\n    value: function () {\n      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(domain) {\n        var signData, key;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n              if (!(this.peerId.publicKey == null)) {\n                _context.next = 3;\n                break;\n              }\n              throw new Error('Missing public key');\n            case 3:\n              key = unmarshalPublicKey(this.peerId.publicKey);\n              _context.next = 6;\n              return key.verify(signData.subarray(), this.signature);\n            case 6:\n              return _context.abrupt(\"return\", _context.sent);\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function validate(_x) {\n        return _validate.apply(this, arguments);\n      }\n      return validate;\n    }()\n  }]);\n  return RecordEnvelope;\n}();\n_a = RecordEnvelope;\n/**\n * Unmarshal a serialized Envelope protobuf message\n */\nRecordEnvelope.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {\n    var envelopeData, peerId;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          envelopeData = Protobuf.decode(data);\n          _context2.next = 3;\n          return peerIdFromKeys(envelopeData.publicKey);\n        case 3:\n          peerId = _context2.sent;\n          return _context2.abrupt(\"return\", new RecordEnvelope({\n            peerId: peerId,\n            payloadType: envelopeData.payloadType,\n            payload: envelopeData.payload,\n            signature: envelopeData.signature\n          }));\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function (_x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key\n */\nRecordEnvelope.seal = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(record, peerId) {\n    var domain, payloadType, payload, signData, key, signature;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!(peerId.privateKey == null)) {\n            _context3.next = 2;\n            break;\n          }\n          throw new Error('Missing private key');\n        case 2:\n          domain = record.domain;\n          payloadType = record.codec;\n          payload = record.marshal();\n          signData = formatSignaturePayload(domain, payloadType, payload);\n          _context3.next = 8;\n          return unmarshalPrivateKey(peerId.privateKey);\n        case 8:\n          key = _context3.sent;\n          _context3.next = 11;\n          return key.sign(signData.subarray());\n        case 11:\n          signature = _context3.sent;\n          return _context3.abrupt(\"return\", new RecordEnvelope({\n            peerId: peerId,\n            payloadType: payloadType,\n            payload: payload,\n            signature: signature\n          }));\n        case 13:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function (_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n */\nRecordEnvelope.openAndCertify = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data, domain) {\n    var envelope, valid;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return RecordEnvelope.createFromProtobuf(data);\n        case 2:\n          envelope = _context4.sent;\n          _context4.next = 5;\n          return envelope.validate(domain);\n        case 5:\n          valid = _context4.sent;\n          if (valid) {\n            _context4.next = 8;\n            break;\n          }\n          throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID);\n        case 8:\n          return _context4.abrupt(\"return\", envelope);\n        case 9:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function (_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nvar formatSignaturePayload = function formatSignaturePayload(domain, payloadType, payload) {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n  var domainUint8Array = uint8arraysFromString(domain);\n  var domainLength = unsigned.encode(domainUint8Array.byteLength);\n  var payloadTypeLength = unsigned.encode(payloadType.length);\n  var payloadLength = unsigned.encode(payload.length);\n  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);\n};","map":{"version":3,"names":["errCode","fromString","uint8arraysFromString","equals","uint8ArrayEquals","unmarshalPrivateKey","unmarshalPublicKey","codes","Envelope","Protobuf","peerIdFromKeys","Uint8ArrayList","unsigned","RecordEnvelope","init","_classCallCheck","peerId","payloadType","payload","signature","_createClass","key","value","marshal","publicKey","Error","marshaled","encode","subarray","other","_validate","_asyncToGenerator","_regeneratorRuntime","mark","_callee","domain","signData","wrap","_callee$","_context","prev","next","formatSignaturePayload","verify","abrupt","sent","stop","validate","_x","apply","arguments","createFromProtobuf","_ref","_callee2","data","envelopeData","_callee2$","_context2","decode","_x2","seal","_ref2","_callee3","record","_callee3$","_context3","privateKey","codec","sign","_x3","_x4","openAndCertify","_ref3","_callee4","envelope","valid","_callee4$","_context4","ERR_SIGNATURE_NOT_VALID","_x5","_x6","domainUint8Array","domainLength","byteLength","payloadTypeLength","length","payloadLength"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/peer-record/src/envelope/index.ts"],"sourcesContent":["import errCode from 'err-code'\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { codes } from '../errors.js'\nimport { Envelope as Protobuf } from './envelope.js'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Record, Envelope } from '@libp2p/interface-record'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { unsigned } from 'uint8-varint'\n\nexport interface RecordEnvelopeInit {\n  peerId: PeerId\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport class RecordEnvelope implements Envelope {\n  /**\n   * Unmarshal a serialized Envelope protobuf message\n   */\n  static createFromProtobuf = async (data: Uint8Array | Uint8ArrayList) => {\n    const envelopeData = Protobuf.decode(data)\n    const peerId = await peerIdFromKeys(envelopeData.publicKey)\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    })\n  }\n\n  /**\n   * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n   * and signs it with the given peerId's private key\n   */\n  static seal = async (record: Record, peerId: PeerId) => {\n    if (peerId.privateKey == null) {\n      throw new Error('Missing private key')\n    }\n\n    const domain = record.domain\n    const payloadType = record.codec\n    const payload = record.marshal()\n    const signData = formatSignaturePayload(domain, payloadType, payload)\n    const key = await unmarshalPrivateKey(peerId.privateKey)\n    const signature = await key.sign(signData.subarray())\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType,\n      payload,\n      signature\n    })\n  }\n\n  /**\n   * Open and certify a given marshalled envelope.\n   * Data is unmarshalled and the signature validated for the given domain.\n   */\n  static openAndCertify = async (data: Uint8Array | Uint8ArrayList, domain: string) => {\n    const envelope = await RecordEnvelope.createFromProtobuf(data)\n    const valid = await envelope.validate(domain)\n\n    if (!valid) {\n      throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID)\n    }\n\n    return envelope\n  }\n\n  public peerId: PeerId\n  public payloadType: Uint8Array\n  public payload: Uint8Array\n  public signature: Uint8Array\n  public marshaled?: Uint8Array\n\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor (init: RecordEnvelopeInit) {\n    const { peerId, payloadType, payload, signature } = init\n\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n  }\n\n  /**\n   * Marshal the envelope content\n   */\n  marshal (): Uint8Array {\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: this.peerId.publicKey,\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n  equals (other: Envelope) {\n    return uint8ArrayEquals(this.marshal(), other.marshal())\n  }\n\n  /**\n   * Validate envelope data signature for the given domain\n   */\n  async validate (domain: string) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    const key = unmarshalPublicKey(this.peerId.publicKey)\n\n    return await key.verify(signData.subarray(), this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain: string, payloadType: Uint8Array, payload: Uint8Array | Uint8ArrayList): Uint8ArrayList => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = unsigned.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = unsigned.encode(payloadType.length)\n  const payloadLength = unsigned.encode(payload.length)\n\n  return new Uint8ArrayList(\n    domainLength,\n    domainUint8Array,\n    payloadTypeLength,\n    payloadType,\n    payloadLength,\n    payload\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}