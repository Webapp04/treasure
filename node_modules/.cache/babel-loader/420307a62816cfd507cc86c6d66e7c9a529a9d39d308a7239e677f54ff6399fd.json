{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as mafmt from '@multiformats/mafmt';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { CircuitRelay as CircuitPB } from './pb/index.js';\nimport { codes } from '../errors.js';\nimport { streamToMaConnection } from '@libp2p/utils/stream-to-ma-conn';\nimport { RELAY_CODEC } from './multicodec.js';\nimport { createListener as _createListener } from './listener.js';\nimport { handleCanHop, handleHop, hop } from './circuit/hop.js';\nimport { handleStop } from './circuit/stop.js';\nimport { StreamHandler } from './circuit/stream-handler.js';\nimport { symbol } from '@libp2p/interface-transport';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { Components } from '@libp2p/components';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { setMaxListeners } from 'events';\nvar log = logger('libp2p:circuit');\nexport var Circuit = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function Circuit(init) {\n    _classCallCheck(this, Circuit);\n    this.components = new Components();\n    this._init = init;\n  }\n  _createClass(Circuit, [{\n    key: \"init\",\n    value: function init(components) {\n      var _this = this;\n      this.components = components;\n      void this.components.getRegistrar().handle(RELAY_CODEC, function (data) {\n        void _this._onProtocol(data).catch(function (err) {\n          log.error(err);\n        });\n      }).catch(function (err) {\n        log.error(err);\n      });\n    }\n  }, {\n    key: \"hopEnabled\",\n    value: function hopEnabled() {\n      return true;\n    }\n  }, {\n    key: \"hopActive\",\n    value: function hopActive() {\n      return true;\n    }\n  }, {\n    key: symbol,\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'libp2p/circuit-relay-v1';\n    }\n  }, {\n    key: \"_onProtocol\",\n    value: function () {\n      var _onProtocol2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {\n        var connection, stream, controller, source, streamHandler, request, virtualConnection, _request$dstPeer, _request$srcPeer, remoteAddr, localAddr, maConn, type, conn;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              connection = data.connection, stream = data.stream;\n              controller = new TimeoutController(this._init.hop.timeout);\n              try {\n                // fails on node < 15.4\n                setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, controller.signal);\n              } catch (_unused) {}\n              _context.prev = 3;\n              source = abortableDuplex(stream, controller.signal);\n              streamHandler = new StreamHandler({\n                stream: _objectSpread(_objectSpread({}, stream), source)\n              });\n              _context.next = 8;\n              return streamHandler.read();\n            case 8:\n              request = _context.sent;\n              if (!(request == null)) {\n                _context.next = 14;\n                break;\n              }\n              log('request was invalid, could not read from stream');\n              streamHandler.write({\n                type: CircuitPB.Type.STATUS,\n                code: CircuitPB.Status.MALFORMED_MESSAGE\n              });\n              streamHandler.close();\n              return _context.abrupt(\"return\");\n            case 14:\n              _context.t0 = request.type;\n              _context.next = _context.t0 === CircuitPB.Type.CAN_HOP ? 17 : _context.t0 === CircuitPB.Type.HOP ? 21 : _context.t0 === CircuitPB.Type.STOP ? 25 : 30;\n              break;\n            case 17:\n              log('received CAN_HOP request from %p', connection.remotePeer);\n              _context.next = 20;\n              return handleCanHop({\n                circuit: this,\n                connection: connection,\n                streamHandler: streamHandler\n              });\n            case 20:\n              return _context.abrupt(\"break\", 34);\n            case 21:\n              log('received HOP request from %p', connection.remotePeer);\n              _context.next = 24;\n              return handleHop({\n                connection: connection,\n                request: request,\n                streamHandler: streamHandler,\n                circuit: this,\n                connectionManager: this.components.getConnectionManager()\n              });\n            case 24:\n              return _context.abrupt(\"break\", 34);\n            case 25:\n              log('received STOP request from %p', connection.remotePeer);\n              _context.next = 28;\n              return handleStop({\n                connection: connection,\n                request: request,\n                streamHandler: streamHandler\n              });\n            case 28:\n              virtualConnection = _context.sent;\n              return _context.abrupt(\"break\", 34);\n            case 30:\n              log('Request of type %s not supported', request.type);\n              streamHandler.write({\n                type: CircuitPB.Type.STATUS,\n                code: CircuitPB.Status.MALFORMED_MESSAGE\n              });\n              streamHandler.close();\n              return _context.abrupt(\"return\");\n            case 34:\n              if (!(virtualConnection != null)) {\n                _context.next = 45;\n                break;\n              }\n              remoteAddr = connection.remoteAddr.encapsulate('/p2p-circuit').encapsulate(multiaddr((_request$dstPeer = request.dstPeer) === null || _request$dstPeer === void 0 ? void 0 : _request$dstPeer.addrs[0]));\n              localAddr = multiaddr((_request$srcPeer = request.srcPeer) === null || _request$srcPeer === void 0 ? void 0 : _request$srcPeer.addrs[0]);\n              maConn = streamToMaConnection({\n                stream: virtualConnection,\n                remoteAddr: remoteAddr,\n                localAddr: localAddr\n              });\n              type = request.type === CircuitPB.Type.HOP ? 'relay' : 'inbound';\n              log('new %s connection %s', type, maConn.remoteAddr);\n              _context.next = 42;\n              return this.components.getUpgrader().upgradeInbound(maConn);\n            case 42:\n              conn = _context.sent;\n              log('%s connection %s upgraded', type, maConn.remoteAddr);\n              if (this.handler != null) {\n                this.handler(conn);\n              }\n            case 45:\n              _context.prev = 45;\n              controller.clear();\n              return _context.finish(45);\n            case 48:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3,, 45, 48]]);\n      }));\n      function _onProtocol(_x) {\n        return _onProtocol2.apply(this, arguments);\n      }\n      return _onProtocol;\n    }()\n    /**\n     * Dial a peer over a relay\n     */\n  }, {\n    key: \"dial\",\n    value: function () {\n      var _dial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ma) {\n        var options,\n          addrs,\n          relayAddr,\n          destinationAddr,\n          relayId,\n          destinationId,\n          errMsg,\n          relayPeer,\n          destinationPeer,\n          disconnectOnFailure,\n          relayConnections,\n          relayConnection,\n          virtualConnection,\n          localAddr,\n          maConn,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              // Check the multiaddr to see if it contains a relay and a destination peer\n              addrs = ma.toString().split('/p2p-circuit');\n              relayAddr = multiaddr(addrs[0]);\n              destinationAddr = multiaddr(addrs[addrs.length - 1]);\n              relayId = relayAddr.getPeerId();\n              destinationId = destinationAddr.getPeerId();\n              if (!(relayId == null || destinationId == null)) {\n                _context2.next = 10;\n                break;\n              }\n              errMsg = 'Circuit relay dial failed as addresses did not have peer id';\n              log.error(errMsg);\n              throw errCode(new Error(errMsg), codes.ERR_RELAYED_DIAL);\n            case 10:\n              relayPeer = peerIdFromString(relayId);\n              destinationPeer = peerIdFromString(destinationId);\n              disconnectOnFailure = false;\n              relayConnections = this.components.getConnectionManager().getConnections(relayPeer);\n              relayConnection = relayConnections[0];\n              if (!(relayConnection == null)) {\n                _context2.next = 22;\n                break;\n              }\n              _context2.next = 18;\n              return this.components.getPeerStore().addressBook.add(relayPeer, [relayAddr]);\n            case 18:\n              _context2.next = 20;\n              return this.components.getConnectionManager().openConnection(relayPeer, options);\n            case 20:\n              relayConnection = _context2.sent;\n              disconnectOnFailure = true;\n            case 22:\n              _context2.prev = 22;\n              _context2.next = 25;\n              return hop(_objectSpread(_objectSpread({}, options), {}, {\n                connection: relayConnection,\n                request: {\n                  type: CircuitPB.Type.HOP,\n                  srcPeer: {\n                    id: this.components.getPeerId().toBytes(),\n                    addrs: this.components.getAddressManager().getAddresses().map(function (addr) {\n                      return addr.bytes;\n                    })\n                  },\n                  dstPeer: {\n                    id: destinationPeer.toBytes(),\n                    addrs: [multiaddr(destinationAddr).bytes]\n                  }\n                }\n              }));\n            case 25:\n              virtualConnection = _context2.sent;\n              localAddr = relayAddr.encapsulate(\"/p2p-circuit/p2p/\".concat(this.components.getPeerId().toString()));\n              maConn = streamToMaConnection({\n                stream: virtualConnection,\n                remoteAddr: ma,\n                localAddr: localAddr\n              });\n              log('new outbound connection %s', maConn.remoteAddr);\n              _context2.next = 31;\n              return this.components.getUpgrader().upgradeOutbound(maConn);\n            case 31:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 34:\n              _context2.prev = 34;\n              _context2.t0 = _context2[\"catch\"](22);\n              log.error('Circuit relay dial failed', _context2.t0);\n              _context2.t1 = disconnectOnFailure;\n              if (!_context2.t1) {\n                _context2.next = 41;\n                break;\n              }\n              _context2.next = 41;\n              return relayConnection.close();\n            case 41:\n              throw _context2.t0;\n            case 42:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[22, 34]]);\n      }));\n      function dial(_x2) {\n        return _dial.apply(this, arguments);\n      }\n      return dial;\n    }()\n    /**\n     * Create a listener\n     */\n  }, {\n    key: \"createListener\",\n    value: function createListener(options) {\n      // Called on successful HOP and STOP requests\n      this.handler = options.handler;\n      return _createListener({\n        connectionManager: this.components.getConnectionManager(),\n        peerStore: this.components.getPeerStore()\n      });\n    }\n    /**\n     * Filter check for all Multiaddrs that this transport can dial on\n     *\n     * @param {Multiaddr[]} multiaddrs\n     * @returns {Multiaddr[]}\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n      return multiaddrs.filter(function (ma) {\n        return mafmt.Circuit.matches(ma);\n      });\n    }\n  }]);\n  return Circuit;\n}(Symbol.toStringTag);","map":{"version":3,"names":["logger","errCode","mafmt","multiaddr","CircuitRelay","CircuitPB","codes","streamToMaConnection","RELAY_CODEC","createListener","handleCanHop","handleHop","hop","handleStop","StreamHandler","symbol","peerIdFromString","Components","abortableDuplex","TimeoutController","setMaxListeners","log","Circuit","_Symbol$toStringTag","init","_classCallCheck","components","_init","_createClass","key","value","_this","getRegistrar","handle","data","_onProtocol","catch","err","error","hopEnabled","hopActive","get","_onProtocol2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","connection","stream","controller","source","streamHandler","request","virtualConnection","_request$dstPeer","_request$srcPeer","remoteAddr","localAddr","maConn","type","conn","wrap","_callee$","_context","prev","next","timeout","Infinity","signal","_unused","_objectSpread","read","sent","write","Type","STATUS","code","Status","MALFORMED_MESSAGE","close","abrupt","t0","CAN_HOP","HOP","STOP","remotePeer","circuit","connectionManager","getConnectionManager","encapsulate","dstPeer","addrs","srcPeer","getUpgrader","upgradeInbound","handler","clear","finish","stop","_x","apply","arguments","_dial","_callee2","ma","options","relayAddr","destinationAddr","relayId","destinationId","errMsg","relayPeer","destinationPeer","disconnectOnFailure","relayConnections","relayConnection","_args2","_callee2$","_context2","length","undefined","toString","split","getPeerId","Error","ERR_RELAYED_DIAL","getConnections","getPeerStore","addressBook","add","openConnection","id","toBytes","getAddressManager","getAddresses","map","addr","bytes","concat","upgradeOutbound","t1","dial","_x2","peerStore","filter","multiaddrs","Array","isArray","matches","Symbol","toStringTag"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/circuit/transport.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport * as mafmt from '@multiformats/mafmt'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { CircuitRelay as CircuitPB } from './pb/index.js'\nimport { codes } from '../errors.js'\nimport { streamToMaConnection } from '@libp2p/utils/stream-to-ma-conn'\nimport { RELAY_CODEC } from './multicodec.js'\nimport { createListener } from './listener.js'\nimport { handleCanHop, handleHop, hop } from './circuit/hop.js'\nimport { handleStop } from './circuit/stop.js'\nimport { StreamHandler } from './circuit/stream-handler.js'\nimport { symbol } from '@libp2p/interface-transport'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { Components, Initializable } from '@libp2p/components'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { IncomingStreamData } from '@libp2p/interface-registrar'\nimport type { Listener, Transport, CreateListenerOptions, ConnectionHandler } from '@libp2p/interface-transport'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { RelayConfig } from '../index.js'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { setMaxListeners } from 'events'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Duplex } from 'it-stream-types'\n\nconst log = logger('libp2p:circuit')\n\nexport class Circuit implements Transport, Initializable {\n  private handler?: ConnectionHandler\n  private components: Components = new Components()\n  private readonly _init: RelayConfig\n\n  constructor (init: RelayConfig) {\n    this._init = init\n  }\n\n  init (components: Components): void {\n    this.components = components\n    void this.components.getRegistrar().handle(RELAY_CODEC, (data) => {\n      void this._onProtocol(data).catch(err => {\n        log.error(err)\n      })\n    })\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  hopEnabled () {\n    return true\n  }\n\n  hopActive () {\n    return true\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'libp2p/circuit-relay-v1'\n  }\n\n  async _onProtocol (data: IncomingStreamData) {\n    const { connection, stream } = data\n    const controller = new TimeoutController(this._init.hop.timeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, controller.signal)\n    } catch {}\n\n    try {\n      const source = abortableDuplex(stream, controller.signal)\n      const streamHandler = new StreamHandler({\n        stream: {\n          ...stream,\n          ...source\n        }\n      })\n      const request = await streamHandler.read()\n\n      if (request == null) {\n        log('request was invalid, could not read from stream')\n        streamHandler.write({\n          type: CircuitPB.Type.STATUS,\n          code: CircuitPB.Status.MALFORMED_MESSAGE\n        })\n        streamHandler.close()\n        return\n      }\n\n      let virtualConnection: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array> | undefined\n\n      switch (request.type) {\n        case CircuitPB.Type.CAN_HOP: {\n          log('received CAN_HOP request from %p', connection.remotePeer)\n          await handleCanHop({ circuit: this, connection, streamHandler })\n          break\n        }\n        case CircuitPB.Type.HOP: {\n          log('received HOP request from %p', connection.remotePeer)\n          await handleHop({\n            connection,\n            request,\n            streamHandler,\n            circuit: this,\n            connectionManager: this.components.getConnectionManager()\n          })\n          break\n        }\n        case CircuitPB.Type.STOP: {\n          log('received STOP request from %p', connection.remotePeer)\n          virtualConnection = await handleStop({\n            connection,\n            request,\n            streamHandler\n          })\n          break\n        }\n        default: {\n          log('Request of type %s not supported', request.type)\n          streamHandler.write({\n            type: CircuitPB.Type.STATUS,\n            code: CircuitPB.Status.MALFORMED_MESSAGE\n          })\n          streamHandler.close()\n          return\n        }\n      }\n\n      if (virtualConnection != null) {\n        const remoteAddr = connection.remoteAddr\n          .encapsulate('/p2p-circuit')\n          .encapsulate(multiaddr(request.dstPeer?.addrs[0]))\n        const localAddr = multiaddr(request.srcPeer?.addrs[0])\n        const maConn = streamToMaConnection({\n          stream: virtualConnection,\n          remoteAddr,\n          localAddr\n        })\n        const type = request.type === CircuitPB.Type.HOP ? 'relay' : 'inbound'\n        log('new %s connection %s', type, maConn.remoteAddr)\n\n        const conn = await this.components.getUpgrader().upgradeInbound(maConn)\n        log('%s connection %s upgraded', type, maConn.remoteAddr)\n\n        if (this.handler != null) {\n          this.handler(conn)\n        }\n      }\n    } finally {\n      controller.clear()\n    }\n  }\n\n  /**\n   * Dial a peer over a relay\n   */\n  async dial (ma: Multiaddr, options: AbortOptions = {}): Promise<Connection> {\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit')\n    const relayAddr = multiaddr(addrs[0])\n    const destinationAddr = multiaddr(addrs[addrs.length - 1])\n    const relayId = relayAddr.getPeerId()\n    const destinationId = destinationAddr.getPeerId()\n\n    if (relayId == null || destinationId == null) {\n      const errMsg = 'Circuit relay dial failed as addresses did not have peer id'\n      log.error(errMsg)\n      throw errCode(new Error(errMsg), codes.ERR_RELAYED_DIAL)\n    }\n\n    const relayPeer = peerIdFromString(relayId)\n    const destinationPeer = peerIdFromString(destinationId)\n\n    let disconnectOnFailure = false\n    const relayConnections = this.components.getConnectionManager().getConnections(relayPeer)\n    let relayConnection = relayConnections[0]\n\n    if (relayConnection == null) {\n      await this.components.getPeerStore().addressBook.add(relayPeer, [relayAddr])\n      relayConnection = await this.components.getConnectionManager().openConnection(relayPeer, options)\n      disconnectOnFailure = true\n    }\n\n    try {\n      const virtualConnection = await hop({\n        ...options,\n        connection: relayConnection,\n        request: {\n          type: CircuitPB.Type.HOP,\n          srcPeer: {\n            id: this.components.getPeerId().toBytes(),\n            addrs: this.components.getAddressManager().getAddresses().map(addr => addr.bytes)\n          },\n          dstPeer: {\n            id: destinationPeer.toBytes(),\n            addrs: [multiaddr(destinationAddr).bytes]\n          }\n        }\n      })\n\n      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.getPeerId().toString()}`)\n      const maConn = streamToMaConnection({\n        stream: virtualConnection,\n        remoteAddr: ma,\n        localAddr\n      })\n      log('new outbound connection %s', maConn.remoteAddr)\n\n      return await this.components.getUpgrader().upgradeOutbound(maConn)\n    } catch (err: any) {\n      log.error('Circuit relay dial failed', err)\n      disconnectOnFailure && await relayConnection.close()\n      throw err\n    }\n  }\n\n  /**\n   * Create a listener\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    // Called on successful HOP and STOP requests\n    this.handler = options.handler\n\n    return createListener({\n      connectionManager: this.components.getConnectionManager(),\n      peerStore: this.components.getPeerStore()\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]}\n   */\n  filter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      return mafmt.Circuit.matches(ma)\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}