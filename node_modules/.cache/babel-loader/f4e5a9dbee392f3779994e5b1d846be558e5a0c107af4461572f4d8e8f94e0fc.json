{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport * as isIpfs from 'is-ipfs';\nimport { CID } from 'multiformats/cid';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { resolve as res } from '../utils.js';\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-utils/src/multibases').Multibases} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\nexport function createResolve(_ref) {\n  var repo = _ref.repo,\n    codecs = _ref.codecs,\n    bases = _ref.bases,\n    name = _ref.name;\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]}\n   */\n  function resolve(_x) {\n    return _resolve.apply(this, arguments);\n  }\n  function _resolve() {\n    _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path) {\n      var opts,\n        _iteratorAbruptCompletion,\n        _didIteratorError,\n        _iteratorError,\n        _iterator,\n        _step,\n        resolvedPath,\n        _path$split,\n        _path$split2,\n        schema,\n        hash,\n        rest,\n        base,\n        bytes,\n        str,\n        cid,\n        results,\n        value,\n        remainderPath,\n        _iteratorAbruptCompletion2,\n        _didIteratorError2,\n        _iteratorError2,\n        _iterator2,\n        _step2,\n        result,\n        _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            if (isIpfs.path(path)) {\n              _context.next = 3;\n              break;\n            }\n            throw new Error('invalid argument ' + path);\n          case 3:\n            if (!isIpfs.ipnsPath(path)) {\n              _context.next = 32;\n              break;\n            }\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 6;\n            _iterator = _asyncIterator(name.resolve(path, opts));\n          case 8:\n            _context.next = 10;\n            return _iterator.next();\n          case 10:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 16;\n              break;\n            }\n            resolvedPath = _step.value;\n            path = resolvedPath;\n          case 13:\n            _iteratorAbruptCompletion = false;\n            _context.next = 8;\n            break;\n          case 16:\n            _context.next = 22;\n            break;\n          case 18:\n            _context.prev = 18;\n            _context.t0 = _context[\"catch\"](6);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 22:\n            _context.prev = 22;\n            _context.prev = 23;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 27;\n              break;\n            }\n            _context.next = 27;\n            return _iterator.return();\n          case 27:\n            _context.prev = 27;\n            if (!_didIteratorError) {\n              _context.next = 30;\n              break;\n            }\n            throw _iteratorError;\n          case 30:\n            return _context.finish(27);\n          case 31:\n            return _context.finish(22);\n          case 32:\n            _path$split = path.split('/'), _path$split2 = _toArray(_path$split), schema = _path$split2[1], hash = _path$split2[2], rest = _path$split2.slice(3); // ['', 'ipfs', 'hash', ...path]\n            if (!opts.cidBase) {\n              _context.next = 39;\n              break;\n            }\n            _context.next = 36;\n            return bases.getBase(opts.cidBase);\n          case 36:\n            _context.t1 = _context.sent;\n            _context.next = 40;\n            break;\n          case 39:\n            _context.t1 = undefined;\n          case 40:\n            base = _context.t1;\n            bytes = parseBytes(hash); // nothing to resolve return the input\n            if (!(rest.length === 0)) {\n              _context.next = 45;\n              break;\n            }\n            str = base ? base.encoder.encode(bytes) : hash;\n            return _context.abrupt(\"return\", \"/\".concat(schema, \"/\").concat(str));\n          case 45:\n            cid = CID.decode(bytes);\n            path = rest.join('/');\n            results = res(cid, path, codecs, repo, opts);\n            value = cid;\n            remainderPath = path;\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context.prev = 52;\n            _iterator2 = _asyncIterator(results);\n          case 54:\n            _context.next = 56;\n            return _iterator2.next();\n          case 56:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context.sent).done)) {\n              _context.next = 62;\n              break;\n            }\n            result = _step2.value;\n            if (CID.asCID(result.value)) {\n              value = result.value;\n              remainderPath = result.remainderPath;\n            }\n          case 59:\n            _iteratorAbruptCompletion2 = false;\n            _context.next = 54;\n            break;\n          case 62:\n            _context.next = 68;\n            break;\n          case 64:\n            _context.prev = 64;\n            _context.t2 = _context[\"catch\"](52);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context.t2;\n          case 68:\n            _context.prev = 68;\n            _context.prev = 69;\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context.next = 73;\n              break;\n            }\n            _context.next = 73;\n            return _iterator2.return();\n          case 73:\n            _context.prev = 73;\n            if (!_didIteratorError2) {\n              _context.next = 76;\n              break;\n            }\n            throw _iteratorError2;\n          case 76:\n            return _context.finish(73);\n          case 77:\n            return _context.finish(68);\n          case 78:\n            return _context.abrupt(\"return\", \"/ipfs/\".concat(value.toString(base && base.encoder)).concat(remainderPath ? '/' + remainderPath : ''));\n          case 79:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[6, 18, 22, 32], [23,, 27, 31], [52, 64, 68, 78], [69,, 73, 77]]);\n    }));\n    return _resolve.apply(this, arguments);\n  }\n  return withTimeoutOption(resolve);\n}\n\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\nfunction parseBytes(str) {\n  try {\n    return peerIdFromString(str).toBytes();\n  } catch (_unused) {\n    return CID.parse(str).bytes;\n  }\n}","map":{"version":3,"names":["isIpfs","CID","peerIdFromString","withTimeoutOption","resolve","res","createResolve","_ref","repo","codecs","bases","name","_x","_resolve","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","path","opts","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","resolvedPath","_path$split","_path$split2","schema","hash","rest","base","bytes","str","cid","results","value","remainderPath","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","result","_args","wrap","_callee$","_context","prev","next","length","undefined","Error","ipnsPath","_asyncIterator","sent","done","t0","return","finish","split","_toArray","slice","cidBase","getBase","t1","parseBytes","encoder","encode","abrupt","concat","decode","join","asCID","t2","toString","stop","toBytes","_unused","parse"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/components/resolve.js"],"sourcesContent":["import * as isIpfs from 'is-ipfs'\nimport { CID } from 'multiformats/cid'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { resolve as res } from '../utils.js'\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-utils/src/multibases').Multibases} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\nexport function createResolve ({ repo, codecs, bases, name }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]}\n   */\n  async function resolve (path, opts = {}) {\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path)\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath\n      }\n    }\n\n    const [, schema, hash, ...rest] = path.split('/') // ['', 'ipfs', 'hash', ...path]\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined\n    const bytes = parseBytes(hash)\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash\n\n      return `/${schema}/${str}`\n    }\n\n    const cid = CID.decode(bytes)\n\n    path = rest.join('/')\n\n    const results = res(cid, path, codecs, repo, opts)\n    let value = cid\n    let remainderPath = path\n\n    for await (const result of results) {\n      if (CID.asCID(result.value)) {\n        value = result.value\n        remainderPath = result.remainderPath\n      }\n    }\n\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`\n  }\n\n  return withTimeoutOption(resolve)\n}\n\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\nfunction parseBytes (str) {\n  try {\n    return peerIdFromString(str).toBytes()\n  } catch {\n    return CID.parse(str).bytes\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}