{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as multistream from './multistream.js';\nimport { handshake } from 'it-handshake';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { PROTOCOL_ID } from './index.js';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nimport { reader } from 'it-reader';\nvar log = logger('libp2p:mss:select');\nexport function select(_x, _x2) {\n  return _select.apply(this, arguments);\n}\nfunction _select() {\n  _select = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(stream, protocols) {\n    var options,\n      _handshake,\n      reader,\n      writer,\n      rest,\n      shakeStream,\n      protocol,\n      p1,\n      p2,\n      response,\n      _iterator3,\n      _step3,\n      _protocol,\n      _response,\n      _args4 = arguments;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n          protocols = Array.isArray(protocols) ? _toConsumableArray(protocols) : [protocols];\n          _handshake = handshake(stream), reader = _handshake.reader, writer = _handshake.writer, rest = _handshake.rest, shakeStream = _handshake.stream;\n          protocol = protocols.shift();\n          if (!(protocol == null)) {\n            _context4.next = 6;\n            break;\n          }\n          throw new Error('At least one protocol must be specified');\n        case 6:\n          log('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol);\n          p1 = uint8ArrayFromString(PROTOCOL_ID);\n          p2 = uint8ArrayFromString(protocol);\n          multistream.writeAll(writer, [p1, p2], options);\n          _context4.next = 12;\n          return multistream.readString(reader, options);\n        case 12:\n          response = _context4.sent;\n          log('select: read \"%s\"', response);\n          // Read the protocol response if we got the protocolId in return\n          if (!(response === PROTOCOL_ID)) {\n            _context4.next = 19;\n            break;\n          }\n          _context4.next = 17;\n          return multistream.readString(reader, options);\n        case 17:\n          response = _context4.sent;\n          log('select: read \"%s\"', response);\n        case 19:\n          if (!(response === protocol)) {\n            _context4.next = 22;\n            break;\n          }\n          rest();\n          return _context4.abrupt(\"return\", {\n            stream: shakeStream,\n            protocol: protocol\n          });\n        case 22:\n          // We haven't gotten a valid ack, try the other protocols\n          _iterator3 = _createForOfIteratorHelper(protocols);\n          _context4.prev = 23;\n          _iterator3.s();\n        case 25:\n          if ((_step3 = _iterator3.n()).done) {\n            _context4.next = 38;\n            break;\n          }\n          _protocol = _step3.value;\n          log('select: write \"%s\"', _protocol);\n          multistream.write(writer, uint8ArrayFromString(_protocol), options);\n          _context4.next = 31;\n          return multistream.readString(reader, options);\n        case 31:\n          _response = _context4.sent;\n          log('select: read \"%s\" for \"%s\"', _response, _protocol);\n          if (!(_response === _protocol)) {\n            _context4.next = 36;\n            break;\n          }\n          rest(); // End our writer so others can start writing to stream\n          return _context4.abrupt(\"return\", {\n            stream: shakeStream,\n            protocol: _protocol\n          });\n        case 36:\n          _context4.next = 25;\n          break;\n        case 38:\n          _context4.next = 43;\n          break;\n        case 40:\n          _context4.prev = 40;\n          _context4.t0 = _context4[\"catch\"](23);\n          _iterator3.e(_context4.t0);\n        case 43:\n          _context4.prev = 43;\n          _iterator3.f();\n          return _context4.finish(43);\n        case 46:\n          rest();\n          throw errCode(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL');\n        case 48:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[23, 40, 43, 46]]);\n  }));\n  return _select.apply(this, arguments);\n}\nexport function lazySelect(stream, protocol) {\n  // This is a signal to write the multistream headers if the consumer tries to\n  // read from the source\n  var negotiateTrigger = pushable();\n  var negotiated = false;\n  return {\n    stream: {\n      sink: function () {\n        var _sink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return stream.sink(_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  var first, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, p1, p2, list;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        first = true;\n                        _iteratorAbruptCompletion = false;\n                        _didIteratorError = false;\n                        _context.prev = 3;\n                        _iterator = _asyncIterator(merge(source, negotiateTrigger));\n                      case 5:\n                        _context.next = 7;\n                        return _awaitAsyncGenerator(_iterator.next());\n                      case 7:\n                        if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                          _context.next = 25;\n                          break;\n                        }\n                        chunk = _step.value;\n                        if (!first) {\n                          _context.next = 20;\n                          break;\n                        }\n                        first = false;\n                        negotiated = true;\n                        negotiateTrigger.end();\n                        p1 = uint8ArrayFromString(PROTOCOL_ID);\n                        p2 = uint8ArrayFromString(protocol);\n                        list = new Uint8ArrayList(multistream.encode(p1), multistream.encode(p2));\n                        if (chunk.length > 0) list.append(chunk);\n                        return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(list), _awaitAsyncGenerator), \"t0\", 18);\n                      case 18:\n                        _context.next = 22;\n                        break;\n                      case 20:\n                        _context.next = 22;\n                        return chunk;\n                      case 22:\n                        _iteratorAbruptCompletion = false;\n                        _context.next = 5;\n                        break;\n                      case 25:\n                        _context.next = 31;\n                        break;\n                      case 27:\n                        _context.prev = 27;\n                        _context.t1 = _context[\"catch\"](3);\n                        _didIteratorError = true;\n                        _iteratorError = _context.t1;\n                      case 31:\n                        _context.prev = 31;\n                        _context.prev = 32;\n                        if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                          _context.next = 36;\n                          break;\n                        }\n                        _context.next = 36;\n                        return _awaitAsyncGenerator(_iterator.return());\n                      case 36:\n                        _context.prev = 36;\n                        if (!_didIteratorError) {\n                          _context.next = 39;\n                          break;\n                        }\n                        throw _iteratorError;\n                      case 39:\n                        return _context.finish(36);\n                      case 40:\n                        return _context.finish(31);\n                      case 41:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee, null, [[3, 27, 31, 41], [32,, 36, 40]]);\n                }))());\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n        function sink(_x3) {\n          return _sink.apply(this, arguments);\n        }\n        return sink;\n      }(),\n      source: _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var byteReader, response, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!negotiated) negotiateTrigger.push(new Uint8Array());\n              byteReader = reader(stream.source);\n              _context3.next = 4;\n              return _awaitAsyncGenerator(multistream.readString(byteReader));\n            case 4:\n              response = _context3.sent;\n              if (!(response === PROTOCOL_ID)) {\n                _context3.next = 9;\n                break;\n              }\n              _context3.next = 8;\n              return _awaitAsyncGenerator(multistream.readString(byteReader));\n            case 8:\n              response = _context3.sent;\n            case 9:\n              if (!(response !== protocol)) {\n                _context3.next = 11;\n                break;\n              }\n              throw errCode(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL');\n            case 11:\n              _iteratorAbruptCompletion2 = false;\n              _didIteratorError2 = false;\n              _context3.prev = 13;\n              _iterator2 = _asyncIterator(byteReader);\n            case 15:\n              _context3.next = 17;\n              return _awaitAsyncGenerator(_iterator2.next());\n            case 17:\n              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {\n                _context3.next = 23;\n                break;\n              }\n              chunk = _step2.value;\n              return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(chunk), _awaitAsyncGenerator), \"t0\", 20);\n            case 20:\n              _iteratorAbruptCompletion2 = false;\n              _context3.next = 15;\n              break;\n            case 23:\n              _context3.next = 29;\n              break;\n            case 25:\n              _context3.prev = 25;\n              _context3.t1 = _context3[\"catch\"](13);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context3.t1;\n            case 29:\n              _context3.prev = 29;\n              _context3.prev = 30;\n              if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                _context3.next = 34;\n                break;\n              }\n              _context3.next = 34;\n              return _awaitAsyncGenerator(_iterator2.return());\n            case 34:\n              _context3.prev = 34;\n              if (!_didIteratorError2) {\n                _context3.next = 37;\n                break;\n              }\n              throw _iteratorError2;\n            case 37:\n              return _context3.finish(34);\n            case 38:\n              return _context3.finish(29);\n            case 39:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[13, 25, 29, 39], [30,, 34, 38]]);\n      }))()\n    },\n    protocol: protocol\n  };\n}","map":{"version":3,"names":["logger","errCode","multistream","handshake","fromString","uint8ArrayFromString","PROTOCOL_ID","Uint8ArrayList","pushable","merge","reader","log","select","_x","_x2","_select","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee4","stream","protocols","options","_handshake","writer","rest","shakeStream","protocol","p1","p2","response","_iterator3","_step3","_protocol","_response","_args4","wrap","_callee4$","_context4","prev","next","length","undefined","Array","isArray","_toConsumableArray","shift","Error","writeAll","readString","sent","abrupt","_createForOfIteratorHelper","s","n","done","value","write","t0","e","f","finish","stop","lazySelect","negotiateTrigger","negotiated","sink","_sink","_callee2","source","_callee2$","_context2","_wrapAsyncGenerator","_callee","first","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","list","_callee$","_context","_asyncIterator","_awaitAsyncGenerator","end","encode","append","delegateYield","_asyncGeneratorDelegate","t1","return","_x3","_callee3","byteReader","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_callee3$","_context3","push","Uint8Array"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/multistream-select/src/select.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport * as multistream from './multistream.js'\nimport { handshake } from 'it-handshake'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { PROTOCOL_ID } from './index.js'\nimport type { Duplex } from 'it-stream-types'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport { reader } from 'it-reader'\nimport type { ByteArrayInit, ByteListInit, MultistreamSelectInit, ProtocolStream } from './index.js'\n\nconst log = logger('libp2p:mss:select')\n\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```js\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different impls\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select (stream: Duplex<Uint8Array>, protocols: string | string[], options: ByteArrayInit): Promise<ProtocolStream<Uint8Array>>\nexport async function select (stream: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>, protocols: string | string[], options?: ByteListInit): Promise<ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>>\nexport async function select (stream: Duplex<any>, protocols: string | string[], options: MultistreamSelectInit = {}): Promise<ProtocolStream<any>> {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n  const { reader, writer, rest, stream: shakeStream } = handshake(stream)\n\n  const protocol = protocols.shift()\n\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified')\n  }\n\n  log('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol)\n  const p1 = uint8ArrayFromString(PROTOCOL_ID)\n  const p2 = uint8ArrayFromString(protocol)\n  multistream.writeAll(writer, [p1, p2], options)\n\n  let response = await multistream.readString(reader, options)\n  log('select: read \"%s\"', response)\n\n  // Read the protocol response if we got the protocolId in return\n  if (response === PROTOCOL_ID) {\n    response = await multistream.readString(reader, options)\n    log('select: read \"%s\"', response)\n  }\n\n  // We're done\n  if (response === protocol) {\n    rest()\n    return { stream: shakeStream, protocol }\n  }\n\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    log('select: write \"%s\"', protocol)\n    multistream.write(writer, uint8ArrayFromString(protocol), options)\n    const response = await multistream.readString(reader, options)\n    log('select: read \"%s\" for \"%s\"', response, protocol)\n\n    if (response === protocol) {\n      rest() // End our writer so others can start writing to stream\n      return { stream: shakeStream, protocol }\n    }\n  }\n\n  rest()\n  throw errCode(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL')\n}\n\n/**\n * Lazily negotiates a protocol.\n *\n * It *does not* block writes waiting for the other end to respond. Instead, it\n * simply assumes the negotiation went successfully and starts writing data.\n *\n * Use when it is known that the receiver supports the desired protocol.\n */\nexport function lazySelect (stream: Duplex<Uint8Array>, protocol: string): ProtocolStream<Uint8Array>\nexport function lazySelect (stream: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>, protocol: string): ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>\nexport function lazySelect (stream: Duplex<any>, protocol: string): ProtocolStream<any> {\n  // This is a signal to write the multistream headers if the consumer tries to\n  // read from the source\n  const negotiateTrigger = pushable()\n  let negotiated = false\n  return {\n    stream: {\n      sink: async source => await stream.sink((async function * () {\n        let first = true\n        for await (const chunk of merge(source, negotiateTrigger)) {\n          if (first) {\n            first = false\n            negotiated = true\n            negotiateTrigger.end()\n            const p1 = uint8ArrayFromString(PROTOCOL_ID)\n            const p2 = uint8ArrayFromString(protocol)\n            const list = new Uint8ArrayList(multistream.encode(p1), multistream.encode(p2))\n            if (chunk.length > 0) list.append(chunk)\n            yield * list\n          } else {\n            yield chunk\n          }\n        }\n      })()),\n      source: (async function * () {\n        if (!negotiated) negotiateTrigger.push(new Uint8Array())\n        const byteReader = reader(stream.source)\n        let response = await multistream.readString(byteReader)\n        if (response === PROTOCOL_ID) {\n          response = await multistream.readString(byteReader)\n        }\n        if (response !== protocol) {\n          throw errCode(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL')\n        }\n        for await (const chunk of byteReader) {\n          yield * chunk\n        }\n      })()\n    },\n    protocol\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}