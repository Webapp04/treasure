{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { EventIterator } from 'event-iterator';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\n// copied from github.com/feross/buffer\n// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(\nfunction isArrayBuffer(obj) {\n  var _obj$constructor;\n  return obj instanceof ArrayBuffer || (obj === null || obj === void 0 || (_obj$constructor = obj.constructor) === null || _obj$constructor === void 0 ? void 0 : _obj$constructor.name) === 'ArrayBuffer' && typeof (obj === null || obj === void 0 ? void 0 : obj.byteLength) === 'number';\n}\nexport default (function (socket) {\n  socket.binaryType = 'arraybuffer';\n  var connected = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return new Promise(function (resolve, reject) {\n              if (isConnected) {\n                return resolve();\n              }\n              if (connError != null) {\n                return reject(connError);\n              }\n              var cleanUp = function cleanUp(cont) {\n                socket.removeEventListener('open', onOpen);\n                socket.removeEventListener('error', onError);\n                cont();\n              };\n              var onOpen = function onOpen() {\n                return cleanUp(resolve);\n              };\n              var onError = function onError(event) {\n                cleanUp(function () {\n                  var _event$error;\n                  return reject((_event$error = event.error) !== null && _event$error !== void 0 ? _event$error : new Error(\"connect ECONNREFUSED \".concat(socket.url)));\n                });\n              };\n              socket.addEventListener('open', onOpen);\n              socket.addEventListener('error', onError);\n            });\n          case 2:\n            return _context.abrupt(\"return\", _context.sent);\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function connected() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var source = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var messages, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          messages = new EventIterator(function (_ref3) {\n            var push = _ref3.push,\n              stop = _ref3.stop,\n              fail = _ref3.fail;\n            var onMessage = function onMessage(event) {\n              var data = null;\n              if (typeof event.data === 'string') {\n                data = uint8ArrayFromString(event.data);\n              }\n              if (isArrayBuffer(event.data)) {\n                data = new Uint8Array(event.data);\n              }\n              if (event.data instanceof Uint8Array) {\n                data = event.data;\n              }\n              if (data == null) {\n                return;\n              }\n              push(data);\n            };\n            var onError = function onError(event) {\n              var _event$error2;\n              return fail((_event$error2 = event.error) !== null && _event$error2 !== void 0 ? _event$error2 : new Error('Socket error'));\n            };\n            socket.addEventListener('message', onMessage);\n            socket.addEventListener('error', onError);\n            socket.addEventListener('close', stop);\n            return function () {\n              socket.removeEventListener('message', onMessage);\n              socket.removeEventListener('error', onError);\n              socket.removeEventListener('close', stop);\n            };\n          }, {\n            highWaterMark: Infinity\n          });\n          _context2.next = 3;\n          return _awaitAsyncGenerator(connected());\n        case 3:\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context2.prev = 5;\n          _iterator = _asyncIterator(messages);\n        case 7:\n          _context2.next = 9;\n          return _awaitAsyncGenerator(_iterator.next());\n        case 9:\n          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n            _context2.next = 16;\n            break;\n          }\n          chunk = _step.value;\n          _context2.next = 13;\n          return isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;\n        case 13:\n          _iteratorAbruptCompletion = false;\n          _context2.next = 7;\n          break;\n        case 16:\n          _context2.next = 22;\n          break;\n        case 18:\n          _context2.prev = 18;\n          _context2.t0 = _context2[\"catch\"](5);\n          _didIteratorError = true;\n          _iteratorError = _context2.t0;\n        case 22:\n          _context2.prev = 22;\n          _context2.prev = 23;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context2.next = 27;\n            break;\n          }\n          _context2.next = 27;\n          return _awaitAsyncGenerator(_iterator.return());\n        case 27:\n          _context2.prev = 27;\n          if (!_didIteratorError) {\n            _context2.next = 30;\n            break;\n          }\n          throw _iteratorError;\n        case 30:\n          return _context2.finish(27);\n        case 31:\n          return _context2.finish(22);\n        case 32:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[5, 18, 22, 32], [23,, 27, 31]]);\n  }))();\n  var isConnected = socket.readyState === 1;\n  var connError;\n  socket.addEventListener('open', function () {\n    isConnected = true;\n    connError = null;\n  });\n  socket.addEventListener('close', function () {\n    isConnected = false;\n    connError = null;\n  });\n  socket.addEventListener('error', function (event) {\n    if (!isConnected) {\n      var _event$error3;\n      connError = (_event$error3 = event.error) !== null && _event$error3 !== void 0 ? _event$error3 : new Error(\"connect ECONNREFUSED \".concat(socket.url));\n    }\n  });\n  return Object.assign(source, {\n    connected: connected\n  });\n});","map":{"version":3,"names":["EventIterator","fromString","uint8ArrayFromString","isArrayBuffer","obj","_obj$constructor","ArrayBuffer","constructor","name","byteLength","socket","binaryType","connected","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","Promise","resolve","reject","isConnected","connError","cleanUp","cont","removeEventListener","onOpen","onError","event","_event$error","error","Error","concat","url","addEventListener","abrupt","sent","stop","apply","arguments","source","_wrapAsyncGenerator","_callee2","messages","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","_callee2$","_context2","_ref3","push","fail","onMessage","data","Uint8Array","_event$error2","highWaterMark","Infinity","_awaitAsyncGenerator","_asyncIterator","done","value","t0","return","finish","readyState","_event$error3","Object","assign"],"sources":["/Users/apple/Documents/treasure/node_modules/it-ws/src/source.ts"],"sourcesContent":["\nimport { EventIterator } from 'event-iterator'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { WebSocket, ErrorEvent, MessageEvent } from 'ws'\n\n// copied from github.com/feross/buffer\n// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(\nfunction isArrayBuffer (obj: any): obj is ArrayBuffer {\n  return (obj instanceof ArrayBuffer) ||\n    (obj?.constructor?.name === 'ArrayBuffer' && typeof obj?.byteLength === 'number')\n}\n\nexport interface ConnectedSource extends AsyncIterable<Uint8Array> {\n  connected: () => Promise<void>\n}\n\nexport default (socket: WebSocket): ConnectedSource => {\n  socket.binaryType = 'arraybuffer'\n\n  const connected = async () => await new Promise<void>((resolve, reject) => {\n    if (isConnected) {\n      return resolve()\n    }\n    if (connError != null) {\n      return reject(connError)\n    }\n\n    const cleanUp = (cont: () => void) => {\n      socket.removeEventListener('open', onOpen)\n      socket.removeEventListener('error', onError)\n      cont()\n    }\n\n    const onOpen = () => cleanUp(resolve)\n    const onError = (event: ErrorEvent) => {\n      cleanUp(() => reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)))\n    }\n\n    socket.addEventListener('open', onOpen)\n    socket.addEventListener('error', onError)\n  })\n\n  const source = (async function * () {\n    const messages = new EventIterator<Uint8Array>(\n      ({ push, stop, fail }) => {\n        const onMessage = (event: MessageEvent) => {\n          let data: Uint8Array | null = null\n\n          if (typeof event.data === 'string') {\n            data = uint8ArrayFromString(event.data)\n          }\n\n          if (isArrayBuffer(event.data)) {\n            data = new Uint8Array(event.data)\n          }\n\n          if (event.data instanceof Uint8Array) {\n            data = event.data\n          }\n\n          if (data == null) {\n            return\n          }\n\n          push(data)\n        }\n        const onError = (event: ErrorEvent) => fail(event.error ?? new Error('Socket error'))\n\n        socket.addEventListener('message', onMessage)\n        socket.addEventListener('error', onError)\n        socket.addEventListener('close', stop)\n\n        return () => {\n          socket.removeEventListener('message', onMessage)\n          socket.removeEventListener('error', onError)\n          socket.removeEventListener('close', stop)\n        }\n      },\n      { highWaterMark: Infinity }\n    )\n\n    await connected()\n\n    for await (const chunk of messages) {\n      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk\n    }\n  }())\n\n  let isConnected = socket.readyState === 1\n  let connError: Error | null\n\n  socket.addEventListener('open', () => {\n    isConnected = true\n    connError = null\n  })\n\n  socket.addEventListener('close', () => {\n    isConnected = false\n    connError = null\n  })\n\n  socket.addEventListener('error', event => {\n    if (!isConnected) {\n      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)\n    }\n  })\n\n  return Object.assign(source, {\n    connected\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}