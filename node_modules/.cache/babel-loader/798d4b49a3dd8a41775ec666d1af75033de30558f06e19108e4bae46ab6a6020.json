{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { InvalidCryptoExchangeError, UnexpectedPeerError } from '@libp2p/interface-connection-encrypter/errors';\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder.js';\nimport { XX } from './handshakes/xx.js';\nimport { logger, logLocalStaticKeys, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey, logCipherState } from './logger.js';\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from './utils.js';\nexport var XXHandshake = /*#__PURE__*/function () {\n  function XXHandshake(isInitiator, payload, prologue, crypto, staticKeypair, connection, remotePeer, handshake) {\n    _classCallCheck(this, XXHandshake);\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n    this.xx = handshake !== null && handshake !== void 0 ? handshake : new XX(crypto);\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = new Uint8Array(0);\n  }\n  // stage 0\n  _createClass(XXHandshake, [{\n    key: \"propose\",\n    value: function () {\n      var _propose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var messageBuffer, receivedMessageBuffer, _this$xx$recvMessage, valid;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              logLocalStaticKeys(this.session.hs.s);\n              if (!this.isInitiator) {\n                _context.next = 9;\n                break;\n              }\n              logger('Stage 0 - Initiator starting to send first message.');\n              messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));\n              this.connection.writeLP(encode0(messageBuffer));\n              logger('Stage 0 - Initiator finished sending first message.');\n              logLocalEphemeralKeys(this.session.hs.e);\n              _context.next = 20;\n              break;\n            case 9:\n              logger('Stage 0 - Responder waiting to receive first message...');\n              _context.t0 = decode0;\n              _context.next = 13;\n              return this.connection.readLP();\n            case 13:\n              _context.t1 = _context.sent.subarray();\n              receivedMessageBuffer = (0, _context.t0)(_context.t1);\n              _this$xx$recvMessage = this.xx.recvMessage(this.session, receivedMessageBuffer), valid = _this$xx$recvMessage.valid;\n              if (valid) {\n                _context.next = 18;\n                break;\n              }\n              throw new InvalidCryptoExchangeError('xx handshake stage 0 validation fail');\n            case 18:\n              logger('Stage 0 - Responder received first message.');\n              logRemoteEphemeralKey(this.session.hs.re);\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function propose() {\n        return _propose.apply(this, arguments);\n      }\n      return propose;\n    }() // stage 1\n  }, {\n    key: \"exchange\",\n    value: function () {\n      var _exchange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var receivedMessageBuffer, _this$xx$recvMessage2, plaintext, valid, decodedPayload, err, messageBuffer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!this.isInitiator) {\n                _context2.next = 34;\n                break;\n              }\n              logger('Stage 1 - Initiator waiting to receive first message from responder...');\n              _context2.t0 = decode1;\n              _context2.next = 5;\n              return this.connection.readLP();\n            case 5:\n              _context2.t1 = _context2.sent.subarray();\n              receivedMessageBuffer = (0, _context2.t0)(_context2.t1);\n              _this$xx$recvMessage2 = this.xx.recvMessage(this.session, receivedMessageBuffer), plaintext = _this$xx$recvMessage2.plaintext, valid = _this$xx$recvMessage2.valid;\n              if (valid) {\n                _context2.next = 10;\n                break;\n              }\n              throw new InvalidCryptoExchangeError('xx handshake stage 1 validation fail');\n            case 10:\n              logger('Stage 1 - Initiator received the message.');\n              logRemoteEphemeralKey(this.session.hs.re);\n              logRemoteStaticKey(this.session.hs.rs);\n              logger(\"Initiator going to check remote's signature...\");\n              _context2.prev = 14;\n              decodedPayload = decodePayload(plaintext);\n              _context2.t2 = this.remotePeer;\n              if (_context2.t2) {\n                _context2.next = 21;\n                break;\n              }\n              _context2.next = 20;\n              return getPeerIdFromPayload(decodedPayload);\n            case 20:\n              _context2.t2 = _context2.sent;\n            case 21:\n              this.remotePeer = _context2.t2;\n              _context2.next = 24;\n              return verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n            case 24:\n              this.setRemoteEarlyData(decodedPayload.data);\n              _context2.next = 31;\n              break;\n            case 27:\n              _context2.prev = 27;\n              _context2.t3 = _context2[\"catch\"](14);\n              err = _context2.t3;\n              throw new UnexpectedPeerError(\"Error occurred while verifying signed payload: \".concat(err.message));\n            case 31:\n              logger('All good with the signature!');\n              _context2.next = 39;\n              break;\n            case 34:\n              logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n              messageBuffer = this.xx.sendMessage(this.session, this.payload);\n              this.connection.writeLP(encode1(messageBuffer));\n              logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n              logLocalEphemeralKeys(this.session.hs.e);\n            case 39:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[14, 27]]);\n      }));\n      function exchange() {\n        return _exchange.apply(this, arguments);\n      }\n      return exchange;\n    }() // stage 2\n  }, {\n    key: \"finish\",\n    value: function () {\n      var _finish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var messageBuffer, receivedMessageBuffer, _this$xx$recvMessage3, plaintext, valid, decodedPayload, err;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!this.isInitiator) {\n                _context3.next = 7;\n                break;\n              }\n              logger('Stage 2 - Initiator sending third handshake message.');\n              messageBuffer = this.xx.sendMessage(this.session, this.payload);\n              this.connection.writeLP(encode2(messageBuffer));\n              logger('Stage 2 - Initiator sent message with signed payload.');\n              _context3.next = 34;\n              break;\n            case 7:\n              logger('Stage 2 - Responder waiting for third handshake message...');\n              _context3.t0 = decode2;\n              _context3.next = 11;\n              return this.connection.readLP();\n            case 11:\n              _context3.t1 = _context3.sent.subarray();\n              receivedMessageBuffer = (0, _context3.t0)(_context3.t1);\n              _this$xx$recvMessage3 = this.xx.recvMessage(this.session, receivedMessageBuffer), plaintext = _this$xx$recvMessage3.plaintext, valid = _this$xx$recvMessage3.valid;\n              if (valid) {\n                _context3.next = 16;\n                break;\n              }\n              throw new InvalidCryptoExchangeError('xx handshake stage 2 validation fail');\n            case 16:\n              logger('Stage 2 - Responder received the message, finished handshake.');\n              _context3.prev = 17;\n              decodedPayload = decodePayload(plaintext);\n              _context3.t2 = this.remotePeer;\n              if (_context3.t2) {\n                _context3.next = 24;\n                break;\n              }\n              _context3.next = 23;\n              return getPeerIdFromPayload(decodedPayload);\n            case 23:\n              _context3.t2 = _context3.sent;\n            case 24:\n              this.remotePeer = _context3.t2;\n              _context3.next = 27;\n              return verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n            case 27:\n              this.setRemoteEarlyData(decodedPayload.data);\n              _context3.next = 34;\n              break;\n            case 30:\n              _context3.prev = 30;\n              _context3.t3 = _context3[\"catch\"](17);\n              err = _context3.t3;\n              throw new UnexpectedPeerError(\"Error occurred while verifying signed payload: \".concat(err.message));\n            case 34:\n              logCipherState(this.session);\n            case 35:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[17, 30]]);\n      }));\n      function finish() {\n        return _finish.apply(this, arguments);\n      }\n      return finish;\n    }()\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(plaintext, session) {\n      var cs = this.getCS(session);\n      return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(ciphertext, session) {\n      var cs = this.getCS(session, false);\n      return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext);\n    }\n  }, {\n    key: \"getRemoteStaticKey\",\n    value: function getRemoteStaticKey() {\n      return this.session.hs.rs;\n    }\n  }, {\n    key: \"getCS\",\n    value: function getCS(session) {\n      var encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!session.cs1 || !session.cs2) {\n        throw new InvalidCryptoExchangeError('Handshake not completed properly, cipher state does not exist.');\n      }\n      if (this.isInitiator) {\n        return encryption ? session.cs1 : session.cs2;\n      } else {\n        return encryption ? session.cs2 : session.cs1;\n      }\n    }\n  }, {\n    key: \"setRemoteEarlyData\",\n    value: function setRemoteEarlyData(data) {\n      if (data) {\n        this.remoteEarlyData = data;\n      }\n    }\n  }]);\n  return XXHandshake;\n}();","map":{"version":3,"names":["InvalidCryptoExchangeError","UnexpectedPeerError","decode0","decode1","decode2","encode0","encode1","encode2","XX","logger","logLocalStaticKeys","logLocalEphemeralKeys","logRemoteEphemeralKey","logRemoteStaticKey","logCipherState","decodePayload","getPeerIdFromPayload","verifySignedPayload","XXHandshake","isInitiator","payload","prologue","crypto","staticKeypair","connection","remotePeer","handshake","_classCallCheck","xx","session","initSession","remoteEarlyData","Uint8Array","_createClass","key","value","_propose","_asyncToGenerator","_regeneratorRuntime","mark","_callee","messageBuffer","receivedMessageBuffer","_this$xx$recvMessage","valid","wrap","_callee$","_context","prev","next","hs","s","sendMessage","writeLP","e","t0","readLP","t1","sent","subarray","recvMessage","re","stop","propose","apply","arguments","_exchange","_callee2","_this$xx$recvMessage2","plaintext","decodedPayload","err","_callee2$","_context2","rs","t2","setRemoteEarlyData","data","t3","concat","message","exchange","_finish","_callee3","_this$xx$recvMessage3","_callee3$","_context3","finish","encrypt","cs","getCS","encryptWithAd","decrypt","ciphertext","decryptWithAd","getRemoteStaticKey","encryption","length","undefined","cs1","cs2"],"sources":["/Users/apple/Documents/treasure/node_modules/@chainsafe/libp2p-noise/src/handshake-xx.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport { InvalidCryptoExchangeError, UnexpectedPeerError } from '@libp2p/interface-connection-encrypter/errors'\nimport type { ProtobufStream } from 'it-pb-stream'\nimport type { bytes, bytes32 } from './@types/basic.js'\nimport type { CipherState, NoiseSession } from './@types/handshake.js'\nimport type { KeyPair } from './@types/libp2p.js'\nimport type { IHandshake } from './@types/handshake-interface.js'\nimport type { ICryptoInterface } from './crypto.js'\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder.js'\nimport { XX } from './handshakes/xx.js'\nimport {\n  logger,\n  logLocalStaticKeys,\n  logLocalEphemeralKeys,\n  logRemoteEphemeralKey,\n  logRemoteStaticKey,\n  logCipherState\n} from './logger.js'\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload\n} from './utils.js'\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean\n  public session: NoiseSession\n  public remotePeer!: PeerId\n  public remoteEarlyData: bytes\n\n  protected payload: bytes\n  protected connection: ProtobufStream\n  protected xx: XX\n  protected staticKeypair: KeyPair\n\n  private readonly prologue: bytes32\n\n  constructor (\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    crypto: ICryptoInterface,\n    staticKeypair: KeyPair,\n    connection: ProtobufStream,\n    remotePeer?: PeerId,\n    handshake?: XX\n  ) {\n    this.isInitiator = isInitiator\n    this.payload = payload\n    this.prologue = prologue\n    this.staticKeypair = staticKeypair\n    this.connection = connection\n    if (remotePeer) {\n      this.remotePeer = remotePeer\n    }\n    this.xx = handshake ?? new XX(crypto)\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair)\n    this.remoteEarlyData = new Uint8Array(0)\n  }\n\n  // stage 0\n  public async propose (): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger('Stage 0 - Initiator starting to send first message.')\n      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0))\n      this.connection.writeLP(encode0(messageBuffer))\n      logger('Stage 0 - Initiator finished sending first message.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger('Stage 0 - Responder waiting to receive first message...')\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray())\n      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 0 validation fail')\n      }\n      logger('Stage 0 - Responder received first message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange (): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 1 - Initiator waiting to receive first message from responder...')\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 1 validation fail')\n      }\n      logger('Stage 1 - Initiator received the message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\")\n      try {\n        const decodedPayload = decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        const err = e as Error\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n      logger('All good with the signature!')\n    } else {\n      logger('Stage 1 - Responder sending out first message with signed payload and static key.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode1(messageBuffer))\n      logger('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish (): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 2 - Initiator sending third handshake message.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode2(messageBuffer))\n      logger('Stage 2 - Initiator sent message with signed payload.')\n    } else {\n      logger('Stage 2 - Responder waiting for third handshake message...')\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).subarray())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 2 validation fail')\n      }\n      logger('Stage 2 - Responder received the message, finished handshake.')\n\n      try {\n        const decodedPayload = decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        const err = e as Error\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt (plaintext: Uint8Array, session: NoiseSession): bytes {\n    const cs = this.getCS(session)\n\n    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext)\n  }\n\n  public decrypt (ciphertext: Uint8Array, session: NoiseSession): {plaintext: bytes, valid: boolean} {\n    const cs = this.getCS(session, false)\n\n    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext)\n  }\n\n  public getRemoteStaticKey (): bytes {\n    return this.session.hs.rs\n  }\n\n  private getCS (session: NoiseSession, encryption = true): CipherState {\n    if (!session.cs1 || !session.cs2) {\n      throw new InvalidCryptoExchangeError('Handshake not completed properly, cipher state does not exist.')\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2\n    } else {\n      return encryption ? session.cs2 : session.cs1\n    }\n  }\n\n  protected setRemoteEarlyData (data: Uint8Array|null|undefined): void {\n    if (data) {\n      this.remoteEarlyData = data\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}