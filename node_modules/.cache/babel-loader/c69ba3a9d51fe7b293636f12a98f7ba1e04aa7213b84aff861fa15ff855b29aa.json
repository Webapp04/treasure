{"ast":null,"code":"import _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { CID } from 'multiformats/cid';\nimport debug from 'debug';\nimport { notFoundError } from 'datastore-core/errors';\nimport parallelBatch from 'it-parallel-batch';\nimport { pipe } from 'it-pipe';\nimport merge from 'it-merge';\nimport map from 'it-map';\nimport filter from 'it-filter';\nimport { Key } from 'interface-datastore/key';\nimport { base32 } from 'multiformats/bases/base32';\nimport { walkDag } from './utils/walk-dag.js';\nvar log = debug('ipfs:repo:gc');\nvar ERR_NOT_FOUND = notFoundError().code;\n\n// Limit on the number of parallel block remove operations\nvar BLOCK_RM_CONCURRENCY = 256;\nvar MFS_ROOT_KEY = new Key('/local/filesroot');\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./types').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nexport function gc(_ref2) {\n  var gcLock = _ref2.gcLock,\n    pins = _ref2.pins,\n    blockstore = _ref2.blockstore,\n    root = _ref2.root,\n    loadCodec = _ref2.loadCodec;\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  function gc() {\n    return _gc.apply(this, arguments);\n  }\n  function _gc() {\n    _gc = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var start, release, markedSet, blockKeys;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            start = Date.now();\n            log('Creating set of marked blocks');\n            _context.next = 4;\n            return _awaitAsyncGenerator(gcLock.writeLock());\n          case 4:\n            release = _context.sent;\n            _context.prev = 5;\n            _context.next = 8;\n            return _awaitAsyncGenerator(createMarkedSet({\n              pins: pins,\n              blockstore: blockstore,\n              root: root,\n              loadCodec: loadCodec\n            }));\n          case 8:\n            markedSet = _context.sent;\n            // Get all blocks keys from the blockstore\n            blockKeys = blockstore.queryKeys({}); // Delete blocks that are not being used\n            // @ts-ignore ts cannot tell that we filter out null results\n            return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(deleteUnmarkedBlocks({\n              blockstore: blockstore\n            }, markedSet, blockKeys)), _awaitAsyncGenerator), \"t0\", 11);\n          case 11:\n            log(\"Complete (\".concat(Date.now() - start, \"ms)\"));\n          case 12:\n            _context.prev = 12;\n            release();\n            return _context.finish(12);\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[5,, 12, 15]]);\n    }));\n    return _gc.apply(this, arguments);\n  }\n  return gc;\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pin-manager').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nfunction createMarkedSet(_x4) {\n  return _createMarkedSet.apply(this, arguments);\n}\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nfunction _createMarkedSet() {\n  _createMarkedSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref3) {\n    var pins, blockstore, loadCodec, root, mfsSource, pinsSource, output, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          pins = _ref3.pins, blockstore = _ref3.blockstore, loadCodec = _ref3.loadCodec, root = _ref3.root;\n          mfsSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n            var mh, rootCid;\n            return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n              while (1) switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.prev = 0;\n                  _context5.next = 3;\n                  return _awaitAsyncGenerator(root.get(MFS_ROOT_KEY));\n                case 3:\n                  mh = _context5.sent;\n                  _context5.next = 12;\n                  break;\n                case 6:\n                  _context5.prev = 6;\n                  _context5.t0 = _context5[\"catch\"](0);\n                  if (!(_context5.t0.code === ERR_NOT_FOUND)) {\n                    _context5.next = 11;\n                    break;\n                  }\n                  log('No blocks in MFS');\n                  return _context5.abrupt(\"return\");\n                case 11:\n                  throw _context5.t0;\n                case 12:\n                  rootCid = CID.decode(mh);\n                  _context5.next = 15;\n                  return rootCid;\n                case 15:\n                  return _context5.delegateYield(_asyncGeneratorDelegate(_asyncIterator(walkDag(rootCid, blockstore, loadCodec)), _awaitAsyncGenerator), \"t1\", 16);\n                case 16:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }, _callee5, null, [[0, 6]]);\n          }))();\n          pinsSource = merge(map(pins.recursiveKeys(), function (_ref6) {\n            var cid = _ref6.cid;\n            return cid;\n          }), pins.indirectKeys(), map(pins.directKeys(), function (_ref7) {\n            var cid = _ref7.cid;\n            return cid;\n          }), mfsSource);\n          output = new Set();\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context6.prev = 6;\n          _iterator = _asyncIterator(merge(pinsSource, mfsSource));\n        case 8:\n          _context6.next = 10;\n          return _iterator.next();\n        case 10:\n          if (!(_iteratorAbruptCompletion = !(_step = _context6.sent).done)) {\n            _context6.next = 16;\n            break;\n          }\n          cid = _step.value;\n          output.add(base32.encode(cid.multihash.bytes));\n        case 13:\n          _iteratorAbruptCompletion = false;\n          _context6.next = 8;\n          break;\n        case 16:\n          _context6.next = 22;\n          break;\n        case 18:\n          _context6.prev = 18;\n          _context6.t0 = _context6[\"catch\"](6);\n          _didIteratorError = true;\n          _iteratorError = _context6.t0;\n        case 22:\n          _context6.prev = 22;\n          _context6.prev = 23;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context6.next = 27;\n            break;\n          }\n          _context6.next = 27;\n          return _iterator.return();\n        case 27:\n          _context6.prev = 27;\n          if (!_didIteratorError) {\n            _context6.next = 30;\n            break;\n          }\n          throw _iteratorError;\n        case 30:\n          return _context6.finish(27);\n        case 31:\n          return _context6.finish(22);\n        case 32:\n          return _context6.abrupt(\"return\", output);\n        case 33:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6, null, [[6, 18, 22, 32], [23,, 27, 31]]);\n  }));\n  return _createMarkedSet.apply(this, arguments);\n}\nfunction deleteUnmarkedBlocks(_x, _x2, _x3) {\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}\nfunction _deleteUnmarkedBlocks() {\n  _deleteUnmarkedBlocks = _wrapAsyncGenerator(function (_ref4, markedSet, blockKeys) {\n    var blockstore = _ref4.blockstore;\n    return /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var blocksCount, removedBlocksCount, removeBlock;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            // Iterate through all blocks and find those that are not in the marked set\n            // blockKeys yields { key: Key() }\n            blocksCount = 0;\n            removedBlocksCount = 0;\n            /**\n             * @param {CID} cid\n             */\n            removeBlock = /*#__PURE__*/function () {\n              var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid) {\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      return _context3.abrupt(\"return\", /*#__PURE__*/function () {\n                        var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                          var b32, msg;\n                          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                            while (1) switch (_context2.prev = _context2.next) {\n                              case 0:\n                                blocksCount++;\n                                _context2.prev = 1;\n                                b32 = base32.encode(cid.multihash.bytes);\n                                if (!markedSet.has(b32)) {\n                                  _context2.next = 5;\n                                  break;\n                                }\n                                return _context2.abrupt(\"return\", null);\n                              case 5:\n                                _context2.prev = 5;\n                                _context2.next = 8;\n                                return blockstore.delete(cid);\n                              case 8:\n                                removedBlocksCount++;\n                                _context2.next = 14;\n                                break;\n                              case 11:\n                                _context2.prev = 11;\n                                _context2.t0 = _context2[\"catch\"](5);\n                                return _context2.abrupt(\"return\", {\n                                  err: new Error(\"Could not delete block with CID \".concat(cid, \": \").concat(_context2.t0.message))\n                                });\n                              case 14:\n                                return _context2.abrupt(\"return\", {\n                                  cid: cid\n                                });\n                              case 17:\n                                _context2.prev = 17;\n                                _context2.t1 = _context2[\"catch\"](1);\n                                msg = \"Could delete block with CID \".concat(cid);\n                                log(msg, _context2.t1);\n                                return _context2.abrupt(\"return\", {\n                                  err: new Error(msg + \": \".concat(_context2.t1.message))\n                                });\n                              case 22:\n                              case \"end\":\n                                return _context2.stop();\n                            }\n                          }, _callee2, null, [[1, 17], [5, 11]]);\n                        }));\n                        function remove() {\n                          return _remove.apply(this, arguments);\n                        }\n                        return remove;\n                      }());\n                    case 1:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3);\n              }));\n              return function removeBlock(_x5) {\n                return _ref5.apply(this, arguments);\n              };\n            }();\n            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n            // filter nulls (blocks that were retained)\n            function (source) {\n              return filter(source, Boolean);\n            })), _awaitAsyncGenerator), \"t0\", 4);\n          case 4:\n            log(\"Marked set has \".concat(markedSet.size, \" unique blocks. Blockstore has \").concat(blocksCount, \" blocks. \") + \"Deleted \".concat(removedBlocksCount, \" blocks.\"));\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    })();\n  });\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}","map":{"version":3,"names":["CID","debug","notFoundError","parallelBatch","pipe","merge","map","filter","Key","base32","walkDag","log","ERR_NOT_FOUND","code","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","gc","_ref2","gcLock","pins","blockstore","root","loadCodec","_gc","apply","arguments","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","start","release","markedSet","blockKeys","wrap","_callee$","_context","prev","next","Date","now","_awaitAsyncGenerator","writeLock","sent","createMarkedSet","queryKeys","delegateYield","_asyncGeneratorDelegate","_asyncIterator","deleteUnmarkedBlocks","concat","finish","stop","_x4","_createMarkedSet","_asyncToGenerator","_callee6","_ref3","mfsSource","pinsSource","output","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","cid","_callee6$","_context6","_callee5","mh","rootCid","_callee5$","_context5","get","t0","abrupt","decode","recursiveKeys","_ref6","indirectKeys","directKeys","_ref7","Set","done","value","add","encode","multihash","bytes","return","_x","_x2","_x3","_deleteUnmarkedBlocks","_ref4","_callee4","blocksCount","removedBlocksCount","removeBlock","_callee4$","_context4","_ref5","_callee3","_callee3$","_context3","_remove","_callee2","b32","msg","_callee2$","_context2","has","delete","err","Error","message","t1","remove","_x5","source","Boolean","size"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-repo/src/gc.js"],"sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport debug from 'debug'\nimport { notFoundError } from 'datastore-core/errors'\nimport parallelBatch from 'it-parallel-batch'\nimport { pipe } from 'it-pipe'\nimport merge from 'it-merge'\nimport map from 'it-map'\nimport filter from 'it-filter'\nimport { Key } from 'interface-datastore/key'\nimport { base32 } from 'multiformats/bases/base32'\nimport { walkDag } from './utils/walk-dag.js'\n\nconst log = debug('ipfs:repo:gc')\nconst ERR_NOT_FOUND = notFoundError().code\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\nconst MFS_ROOT_KEY = new Key('/local/filesroot')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./types').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nexport function gc ({ gcLock, pins, blockstore, root, loadCodec }) {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function * gc () {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec })\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({})\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield * deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  }\n\n  return gc\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pin-manager').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet ({ pins, blockstore, loadCodec, root }) {\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await root.get(MFS_ROOT_KEY)\n    } catch (/** @type {any} */ err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n\n      throw err\n    }\n\n    const rootCid = CID.decode(mh)\n    yield rootCid\n    yield * walkDag(rootCid, blockstore, loadCodec)\n  })()\n\n  const pinsSource = merge(\n    map(pins.recursiveKeys(), ({ cid }) => cid),\n    pins.indirectKeys(),\n    map(pins.directKeys(), ({ cid }) => cid),\n    mfsSource\n  )\n\n  const output = new Set()\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes))\n  }\n\n  return output\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function * deleteUnmarkedBlocks ({ blockstore }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async (cid) => {\n    return async function remove () {\n      blocksCount++\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes)\n\n        if (markedSet.has(b32)) {\n          return null\n        }\n\n        try {\n          await blockstore.delete(cid)\n          removedBlocksCount++\n        } catch (/** @type {any} */ err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n        }\n\n        return { cid }\n      } catch (/** @type {any} */ err) {\n        const msg = `Could delete block with CID ${cid}`\n        log(msg, err)\n        return { err: new Error(msg + `: ${err.message}`) }\n      }\n    }\n  }\n\n  yield * pipe(\n    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n    // filter nulls (blocks that were retained)\n    source => filter(source, Boolean)\n  )\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}