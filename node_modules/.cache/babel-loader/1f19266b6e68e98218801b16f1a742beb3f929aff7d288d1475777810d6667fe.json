{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport errCode from 'err-code';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { IpnsEntry } from './pb/ipns.js';\nimport { parseRFC3339, extractPublicKey, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig, unmarshal, peerIdFromRoutingKey, parseCborData } from './utils.js';\nimport * as ERRORS from './errors.js';\nimport { logger } from '@libp2p/logger';\nvar log = logger('ipns:validator');\n/**\n * Validates the given ipns entry against the given public key\n */\nexport var validate = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(publicKey, entry) {\n    var value, validityType, validity, dataForSignature, signature, _entry$signature, isValid, validityDate;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          value = entry.value, validityType = entry.validityType, validity = entry.validity;\n          // Check v2 signature if it's available, otherwise use the v1 signature\n          if (entry.signatureV2 != null && entry.data != null) {\n            signature = entry.signatureV2;\n            dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n            validateCborDataMatchesPbData(entry);\n          } else {\n            signature = (_entry$signature = entry.signature) !== null && _entry$signature !== void 0 ? _entry$signature : new Uint8Array(0);\n            dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n          }\n          // Validate Signature\n          _context.prev = 2;\n          _context.next = 5;\n          return publicKey.verify(dataForSignature, signature);\n        case 5:\n          isValid = _context.sent;\n          _context.next = 11;\n          break;\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](2);\n          isValid = false;\n        case 11:\n          if (isValid) {\n            _context.next = 14;\n            break;\n          }\n          log.error('record signature verification failed');\n          throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n        case 14:\n          if (!(validity != null && validityType === IpnsEntry.ValidityType.EOL)) {\n            _context.next = 28;\n            break;\n          }\n          _context.prev = 15;\n          validityDate = parseRFC3339(uint8ArrayToString(validity));\n          _context.next = 23;\n          break;\n        case 19:\n          _context.prev = 19;\n          _context.t1 = _context[\"catch\"](15);\n          log.error('unrecognized validity format (not an rfc3339 format)');\n          throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n        case 23:\n          if (!(validityDate.getTime() < Date.now())) {\n            _context.next = 26;\n            break;\n          }\n          log.error('record has expired');\n          throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n        case 26:\n          _context.next = 31;\n          break;\n        case 28:\n          if (!(validityType != null)) {\n            _context.next = 31;\n            break;\n          }\n          log.error('unrecognized validity type');\n          throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n        case 31:\n          log('ipns entry for %b is valid', value);\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2, 8], [15, 19]]);\n  }));\n  return function validate(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar validateCborDataMatchesPbData = function validateCborDataMatchesPbData(entry) {\n  if (entry.data == null) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);\n  }\n  var data = parseCborData(entry.data);\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n};\nexport var ipnsValidator = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, marshalledData) {\n    var peerId, receivedEntry, pubKey;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          peerId = peerIdFromRoutingKey(key);\n          receivedEntry = unmarshal(marshalledData); // extract public key\n          _context2.next = 4;\n          return extractPublicKey(peerId, receivedEntry);\n        case 4:\n          pubKey = _context2.sent;\n          _context2.next = 7;\n          return validate(pubKey, receivedEntry);\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function ipnsValidator(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["errCode","toString","uint8ArrayToString","equals","uint8ArrayEquals","IpnsEntry","parseRFC3339","extractPublicKey","ipnsEntryDataForV1Sig","ipnsEntryDataForV2Sig","unmarshal","peerIdFromRoutingKey","parseCborData","ERRORS","logger","log","validate","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","publicKey","entry","value","validityType","validity","dataForSignature","signature","_entry$signature","isValid","validityDate","wrap","_callee$","_context","prev","next","signatureV2","data","validateCborDataMatchesPbData","Uint8Array","verify","sent","t0","error","Error","ERR_SIGNATURE_VERIFICATION","ValidityType","EOL","t1","ERR_UNRECOGNIZED_FORMAT","getTime","Date","now","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","stop","_x","_x2","apply","arguments","ERR_INVALID_RECORD_DATA","Value","Validity","Sequence","sequence","TTL","ttl","ipnsValidator","_ref2","_callee2","key","marshalledData","peerId","receivedEntry","pubKey","_callee2$","_context2","_x3","_x4"],"sources":["/Users/apple/Documents/treasure/node_modules/ipns/src/validator.ts"],"sourcesContent":["import errCode from 'err-code'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { IpnsEntry } from './pb/ipns.js'\nimport { parseRFC3339, extractPublicKey, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig, unmarshal, peerIdFromRoutingKey, parseCborData } from './utils.js'\nimport * as ERRORS from './errors.js'\nimport type { IPNSEntry } from './index.js'\nimport type { PublicKey } from '@libp2p/interface-keys'\nimport type { ValidateFn } from '@libp2p/interface-dht'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipns:validator')\n\n/**\n * Validates the given ipns entry against the given public key\n */\nexport const validate = async (publicKey: PublicKey, entry: IPNSEntry) => {\n  const { value, validityType, validity } = entry\n\n  let dataForSignature: Uint8Array\n  let signature: Uint8Array\n\n  // Check v2 signature if it's available, otherwise use the v1 signature\n  if ((entry.signatureV2 != null) && (entry.data != null)) {\n    signature = entry.signatureV2\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data)\n\n    validateCborDataMatchesPbData(entry)\n  } else {\n    signature = entry.signature ?? new Uint8Array(0)\n    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity)\n  }\n\n  // Validate Signature\n  let isValid\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature)\n  } catch (err) {\n    isValid = false\n  }\n  if (!isValid) {\n    log.error('record signature verification failed')\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  // Validate according to the validity type\n  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {\n    let validityDate\n\n    try {\n      validityDate = parseRFC3339(uint8ArrayToString(validity))\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)')\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT)\n    }\n\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired')\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD)\n    }\n  } else if (validityType != null) {\n    log.error('unrecognized validity type')\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  log('ipns entry for %b is valid', value)\n}\n\nconst validateCborDataMatchesPbData = (entry: IPNSEntry) => {\n  if (entry.data == null) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA)\n  }\n\n  const data = parseCborData(entry.data)\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n}\n\nexport const ipnsValidator: ValidateFn = async (key, marshalledData) => {\n  const peerId = peerIdFromRoutingKey(key)\n  const receivedEntry = unmarshal(marshalledData)\n\n  // extract public key\n  const pubKey = await extractPublicKey(peerId, receivedEntry)\n\n  // Record validation\n  await validate(pubKey, receivedEntry)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}