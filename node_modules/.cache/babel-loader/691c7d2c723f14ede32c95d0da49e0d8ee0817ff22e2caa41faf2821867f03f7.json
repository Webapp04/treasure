{"ast":null,"code":"import _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { SortedMap } from '../utils/sorted-map.js';\n\n/**\n * @typedef {object} PopTaskResult\n * @property {PeerId} [peerId]\n * @property {Task[]} tasks\n * @property {number} pendingSize\n *\n * @typedef {object} PendingTask\n * @property {number} created\n * @property {Task} task\n *\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMerger\n */\n\n/**\n * The task merger that is used by default.\n * Assumes that new tasks do not add any information over existing tasks,\n * and doesn't try to merge.\n *\n * @type {TaskMerger}\n */\nvar DefaultTaskMerger = {\n  hasNewInfo: function hasNewInfo() {\n    return false;\n  },\n  merge: function merge() {}\n};\n\n/**\n * Queue of requests to be processed by the engine.\n * The requests from each peer are added to the peer's queue, sorted by\n * priority.\n * Tasks are popped in priority order from the best peer - see popTasks()\n * for more details.\n */\nexport var RequestQueue = /*#__PURE__*/function () {\n  /**\n   * @param {TaskMerger} [taskMerger]\n   */\n  function RequestQueue() {\n    var taskMerger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultTaskMerger;\n    _classCallCheck(this, RequestQueue);\n    this._taskMerger = taskMerger;\n    /** @type {SortedMap<string, PeerTasks>} */\n    this._byPeer = new SortedMap([], PeerTasks.compare);\n  }\n\n  /**\n   * Push tasks onto the queue for the given peer\n   *\n   * @param {PeerId} peerId\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  _createClass(RequestQueue, [{\n    key: \"pushTasks\",\n    value: function pushTasks(peerId, tasks) {\n      var peerTasks = this._byPeer.get(peerId.toString());\n      if (!peerTasks) {\n        peerTasks = new PeerTasks(peerId, this._taskMerger);\n      }\n      peerTasks.pushTasks(tasks);\n      this._byPeer.set(peerId.toString(), peerTasks);\n    }\n\n    /**\n     * Choose the peer with the least active work (or if all have the same active\n     * work, the most pending tasks) and pop off the highest priority tasks until\n     * the total size is at least targetMinBytes.\n     * This puts the popped tasks into the \"active\" state, meaning they are\n     * actively being processed (and cannot be modified).\n     *\n     * @param {number} targetMinBytes - the minimum total size of tasks to pop\n     * @returns {PopTaskResult}\n     */\n  }, {\n    key: \"popTasks\",\n    value: function popTasks(targetMinBytes) {\n      // Get the queue of tasks for the best peer and pop off tasks up to\n      // targetMinBytes\n      var peerTasks = this._head();\n      if (peerTasks === undefined) {\n        return {\n          tasks: [],\n          pendingSize: 0\n        };\n      }\n      var _peerTasks$popTasks = peerTasks.popTasks(targetMinBytes),\n        tasks = _peerTasks$popTasks.tasks,\n        pendingSize = _peerTasks$popTasks.pendingSize;\n      if (tasks.length === 0) {\n        return {\n          tasks: tasks,\n          pendingSize: pendingSize\n        };\n      }\n      var peerId = peerTasks.peerId;\n      if (peerTasks.isIdle()) {\n        // If there are no more tasks for the peer, free up its memory\n        this._byPeer.delete(peerId.toString());\n      } else {\n        // If there are still tasks remaining, update the sort order of peerTasks\n        // (because it depends on the number of pending tasks)\n        this._byPeer.update(0);\n      }\n      return {\n        peerId: peerId,\n        tasks: tasks,\n        pendingSize: pendingSize\n      };\n    }\n\n    /**\n     * @private\n     * @returns {PeerTasks|undefined}\n     */\n  }, {\n    key: \"_head\",\n    value: function _head() {\n      // Shortcut\n      if (this._byPeer.size === 0) {\n        return undefined;\n      }\n\n      // eslint-disable-next-line no-unreachable-loop\n      var _iterator = _createForOfIteratorHelper(this._byPeer),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            v = _step$value[1];\n          return v;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return undefined;\n    }\n\n    /**\n     * Remove the task with the given topic for the given peer.\n     *\n     * @param {string} topic\n     * @param {PeerId} peerId\n     * @returns {void}\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(topic, peerId) {\n      var peerTasks = this._byPeer.get(peerId.toString());\n      peerTasks && peerTasks.remove(topic);\n    }\n\n    /**\n     * Called when the tasks for the given peer complete.\n     *\n     * @param {PeerId} peerId\n     * @param {Task[]} tasks\n     * @returns {void}\n     */\n  }, {\n    key: \"tasksDone\",\n    value: function tasksDone(peerId, tasks) {\n      var peerTasks = this._byPeer.get(peerId.toString());\n      if (!peerTasks) {\n        return;\n      }\n      var i = this._byPeer.indexOf(peerId.toString());\n      var _iterator2 = _createForOfIteratorHelper(tasks),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var task = _step2.value;\n          peerTasks.taskDone(task);\n        }\n\n        // Marking the tasks as done takes them out of the \"active\" state, and the\n        // sort order depends on the size of the active tasks, so we need to update\n        // the order.\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this._byPeer.update(i);\n    }\n  }]);\n  return RequestQueue;\n}();\n\n/**\n * Queue of tasks for a particular peer, sorted by priority.\n */\nvar PeerTasks = /*#__PURE__*/function () {\n  /**\n   * @param {PeerId} peerId\n   * @param {TaskMerger} taskMerger\n   */\n  function PeerTasks(peerId, taskMerger) {\n    _classCallCheck(this, PeerTasks);\n    this.peerId = peerId;\n    this._taskMerger = taskMerger;\n    this._activeTotalSize = 0;\n    this._pending = new PendingTasks();\n    this._active = new Set();\n  }\n\n  /**\n   * Push tasks onto the queue.\n   *\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  _createClass(PeerTasks, [{\n    key: \"pushTasks\",\n    value: function pushTasks(tasks) {\n      var _iterator3 = _createForOfIteratorHelper(tasks),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var t = _step3.value;\n          this._pushTask(t);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    /**\n     * @private\n     * @param {Task} task\n     * @returns {void}\n     */\n  }, {\n    key: \"_pushTask\",\n    value: function _pushTask(task) {\n      // If the new task doesn't add any more information over what we\n      // already have in the active queue, then we can skip the new task\n      if (!this._taskHasMoreInfoThanActiveTasks(task)) {\n        return;\n      }\n\n      // If there is already a non-active (pending) task with this topic\n      var existingTask = this._pending.get(task.topic);\n      if (existingTask) {\n        // If the new task has a higher priority than the old task,\n        if (task.priority > existingTask.priority) {\n          // Update the priority and the task's position in the queue\n          this._pending.updatePriority(task.topic, task.priority);\n        }\n\n        // Merge the information from the new task into the existing task\n        this._taskMerger.merge(task, existingTask);\n\n        // A task with the topic exists, so we don't need to add\n        // the new task to the queue\n        return;\n      }\n\n      // Push the new task onto the queue\n      this._pending.add(task);\n    }\n\n    /**\n     * Indicates whether the new task adds any more information over tasks that are\n     * already in the active task queue\n     *\n     * @private\n     * @param {Task} task\n     * @returns {boolean}\n     */\n  }, {\n    key: \"_taskHasMoreInfoThanActiveTasks\",\n    value: function _taskHasMoreInfoThanActiveTasks(task) {\n      var tasksWithTopic = [];\n      var _iterator4 = _createForOfIteratorHelper(this._active),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var activeTask = _step4.value;\n          if (activeTask.topic === task.topic) {\n            tasksWithTopic.push(activeTask);\n          }\n        }\n\n        // No tasks with that topic, so the new task adds information\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (tasksWithTopic.length === 0) {\n        return true;\n      }\n      return this._taskMerger.hasNewInfo(task, tasksWithTopic);\n    }\n\n    /**\n     * Pop tasks off the queue such that the total size is at least targetMinBytes\n     *\n     * @param {number} targetMinBytes\n     * @returns {PopTaskResult}\n     */\n  }, {\n    key: \"popTasks\",\n    value: function popTasks(targetMinBytes) {\n      var size = 0;\n      var tasks = [];\n\n      // Keep popping tasks until we get up to targetMinBytes (or one item over\n      // targetMinBytes)\n      var pendingTasks = this._pending.tasks();\n      for (var i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {\n        var task = pendingTasks[i];\n        tasks.push(task);\n        size += task.size;\n\n        // Move tasks from pending to active\n        this._pending.delete(task.topic);\n        this._activeTotalSize += task.size;\n        this._active.add(task);\n      }\n      return {\n        tasks: tasks,\n        pendingSize: this._pending.totalSize\n      };\n    }\n\n    /**\n     * Called when a task completes.\n     * Note: must be the same reference as returned from popTasks.\n     *\n     * @param {Task} task\n     * @returns {void}\n     */\n  }, {\n    key: \"taskDone\",\n    value: function taskDone(task) {\n      if (this._active.has(task)) {\n        this._activeTotalSize -= task.size;\n        this._active.delete(task);\n      }\n    }\n\n    /**\n     * Remove pending tasks with the given topic\n     *\n     * @param {string} topic\n     * @returns {void}\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(topic) {\n      this._pending.delete(topic);\n    }\n\n    /**\n     * No work to be done, this PeerTasks object can be freed.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isIdle\",\n    value: function isIdle() {\n      return this._pending.length === 0 && this._active.size === 0;\n    }\n\n    /**\n     * Compare PeerTasks\n     *\n     * @template Key\n     * @param {[Key, PeerTasks]} a\n     * @param {[Key, PeerTasks]} b\n     * @returns {number}\n     */\n  }], [{\n    key: \"compare\",\n    value: function compare(a, b) {\n      // Move peers with no pending tasks to the back of the queue\n      if (a[1]._pending.length === 0) {\n        return 1;\n      }\n      if (b[1]._pending.length === 0) {\n        return -1;\n      }\n\n      // If the amount of active work is the same\n      if (a[1]._activeTotalSize === b[1]._activeTotalSize) {\n        // Choose the peer with the most pending work\n        return b[1]._pending.length - a[1]._pending.length;\n      }\n\n      // Choose the peer with the least amount of active work (\"keep peers busy\")\n      return a[1]._activeTotalSize - b[1]._activeTotalSize;\n    }\n  }]);\n  return PeerTasks;\n}();\n/**\n * Queue of pending tasks for a particular peer, sorted by priority.\n */\nvar PendingTasks = /*#__PURE__*/function () {\n  function PendingTasks() {\n    _classCallCheck(this, PendingTasks);\n    /** @type {SortedMap<string, PendingTask>} */\n    this._tasks = new SortedMap([], this._compare);\n  }\n  _createClass(PendingTasks, [{\n    key: \"length\",\n    get: function get() {\n      return this._tasks.size;\n    }\n\n    /**\n     * Sum of the size of all pending tasks\n     *\n     * @type {number}\n     **/\n  }, {\n    key: \"totalSize\",\n    get: function get() {\n      return _toConsumableArray(this._tasks.values()).reduce(function (a, t) {\n        return a + t.task.size;\n      }, 0);\n    }\n\n    /**\n     * @param {string} topic\n     * @returns {Task|void}\n     */\n  }, {\n    key: \"get\",\n    value: function get(topic) {\n      return (this._tasks.get(topic) || {}).task;\n    }\n\n    /**\n     * @param {Task} task\n     */\n  }, {\n    key: \"add\",\n    value: function add(task) {\n      this._tasks.set(task.topic, {\n        created: Date.now(),\n        task: task\n      });\n    }\n\n    /**\n     * @param {string} topic\n     * @returns {void}\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(topic) {\n      this._tasks.delete(topic);\n    }\n\n    // All pending tasks, in priority order\n  }, {\n    key: \"tasks\",\n    value: function tasks() {\n      return _toConsumableArray(this._tasks.values()).map(function (i) {\n        return i.task;\n      });\n    }\n\n    /**\n     * Update the priority of the task with the given topic, and update the order\n     *\n     * @param {string} topic\n     * @param {number} priority\n     * @returns {void}\n     **/\n  }, {\n    key: \"updatePriority\",\n    value: function updatePriority(topic, priority) {\n      var obj = this._tasks.get(topic);\n      if (!obj) {\n        return;\n      }\n      var i = this._tasks.indexOf(topic);\n      obj.task.priority = priority;\n      this._tasks.update(i);\n    }\n\n    /**\n     * Sort by priority desc then FIFO\n     *\n     * @param {[string, PendingTask]} a\n     * @param {[string, PendingTask]} b\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_compare\",\n    value: function _compare(a, b) {\n      if (a[1].task.priority === b[1].task.priority) {\n        // FIFO\n        return a[1].created - b[1].created;\n      }\n      // Priority high -> low\n      return b[1].task.priority - a[1].task.priority;\n    }\n  }]);\n  return PendingTasks;\n}();","map":{"version":3,"names":["SortedMap","DefaultTaskMerger","hasNewInfo","merge","RequestQueue","taskMerger","arguments","length","undefined","_classCallCheck","_taskMerger","_byPeer","PeerTasks","compare","_createClass","key","value","pushTasks","peerId","tasks","peerTasks","get","toString","set","popTasks","targetMinBytes","_head","pendingSize","_peerTasks$popTasks","isIdle","delete","update","size","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","v","err","e","f","remove","topic","tasksDone","i","indexOf","_iterator2","_step2","task","taskDone","_activeTotalSize","_pending","PendingTasks","_active","Set","_iterator3","_step3","t","_pushTask","_taskHasMoreInfoThanActiveTasks","existingTask","priority","updatePriority","add","tasksWithTopic","_iterator4","_step4","activeTask","push","pendingTasks","totalSize","has","a","b","_tasks","_compare","_toConsumableArray","values","reduce","created","Date","now","_delete","map","obj"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-bitswap/src/decision-engine/req-queue.js"],"sourcesContent":["import { SortedMap } from '../utils/sorted-map.js'\n\n/**\n * @typedef {object} PopTaskResult\n * @property {PeerId} [peerId]\n * @property {Task[]} tasks\n * @property {number} pendingSize\n *\n * @typedef {object} PendingTask\n * @property {number} created\n * @property {Task} task\n *\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMerger\n */\n\n/**\n * The task merger that is used by default.\n * Assumes that new tasks do not add any information over existing tasks,\n * and doesn't try to merge.\n *\n * @type {TaskMerger}\n */\nconst DefaultTaskMerger = {\n  hasNewInfo () {\n    return false\n  },\n\n  merge () {}\n}\n\n/**\n * Queue of requests to be processed by the engine.\n * The requests from each peer are added to the peer's queue, sorted by\n * priority.\n * Tasks are popped in priority order from the best peer - see popTasks()\n * for more details.\n */\nexport class RequestQueue {\n  /**\n   * @param {TaskMerger} [taskMerger]\n   */\n  constructor (taskMerger = DefaultTaskMerger) {\n    this._taskMerger = taskMerger\n    /** @type {SortedMap<string, PeerTasks>} */\n    this._byPeer = new SortedMap([], PeerTasks.compare)\n  }\n\n  /**\n   * Push tasks onto the queue for the given peer\n   *\n   * @param {PeerId} peerId\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  pushTasks (peerId, tasks) {\n    let peerTasks = this._byPeer.get(peerId.toString())\n\n    if (!peerTasks) {\n      peerTasks = new PeerTasks(peerId, this._taskMerger)\n    }\n\n    peerTasks.pushTasks(tasks)\n    this._byPeer.set(peerId.toString(), peerTasks)\n  }\n\n  /**\n   * Choose the peer with the least active work (or if all have the same active\n   * work, the most pending tasks) and pop off the highest priority tasks until\n   * the total size is at least targetMinBytes.\n   * This puts the popped tasks into the \"active\" state, meaning they are\n   * actively being processed (and cannot be modified).\n   *\n   * @param {number} targetMinBytes - the minimum total size of tasks to pop\n   * @returns {PopTaskResult}\n   */\n  popTasks (targetMinBytes) {\n    // Get the queue of tasks for the best peer and pop off tasks up to\n    // targetMinBytes\n    const peerTasks = this._head()\n    if (peerTasks === undefined) {\n      return { tasks: [], pendingSize: 0 }\n    }\n\n    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes)\n    if (tasks.length === 0) {\n      return { tasks, pendingSize }\n    }\n\n    const peerId = peerTasks.peerId\n    if (peerTasks.isIdle()) {\n      // If there are no more tasks for the peer, free up its memory\n      this._byPeer.delete(peerId.toString())\n    } else {\n      // If there are still tasks remaining, update the sort order of peerTasks\n      // (because it depends on the number of pending tasks)\n      this._byPeer.update(0)\n    }\n\n    return {\n      peerId, tasks, pendingSize\n    }\n  }\n\n  /**\n   * @private\n   * @returns {PeerTasks|undefined}\n   */\n  _head () {\n    // Shortcut\n    if (this._byPeer.size === 0) {\n      return undefined\n    }\n\n    // eslint-disable-next-line no-unreachable-loop\n    for (const [, v] of this._byPeer) {\n      return v\n    }\n\n    return undefined\n  }\n\n  /**\n   * Remove the task with the given topic for the given peer.\n   *\n   * @param {string} topic\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  remove (topic, peerId) {\n    const peerTasks = this._byPeer.get(peerId.toString())\n    peerTasks && peerTasks.remove(topic)\n  }\n\n  /**\n   * Called when the tasks for the given peer complete.\n   *\n   * @param {PeerId} peerId\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  tasksDone (peerId, tasks) {\n    const peerTasks = this._byPeer.get(peerId.toString())\n    if (!peerTasks) {\n      return\n    }\n\n    const i = this._byPeer.indexOf(peerId.toString())\n    for (const task of tasks) {\n      peerTasks.taskDone(task)\n    }\n\n    // Marking the tasks as done takes them out of the \"active\" state, and the\n    // sort order depends on the size of the active tasks, so we need to update\n    // the order.\n    this._byPeer.update(i)\n  }\n}\n\n/**\n * Queue of tasks for a particular peer, sorted by priority.\n */\nclass PeerTasks {\n  /**\n   * @param {PeerId} peerId\n   * @param {TaskMerger} taskMerger\n   */\n  constructor (peerId, taskMerger) {\n    this.peerId = peerId\n    this._taskMerger = taskMerger\n    this._activeTotalSize = 0\n    this._pending = new PendingTasks()\n    this._active = new Set()\n  }\n\n  /**\n   * Push tasks onto the queue.\n   *\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  pushTasks (tasks) {\n    for (const t of tasks) {\n      this._pushTask(t)\n    }\n  }\n\n  /**\n   * @private\n   * @param {Task} task\n   * @returns {void}\n   */\n\n  _pushTask (task) {\n    // If the new task doesn't add any more information over what we\n    // already have in the active queue, then we can skip the new task\n    if (!this._taskHasMoreInfoThanActiveTasks(task)) {\n      return\n    }\n\n    // If there is already a non-active (pending) task with this topic\n    const existingTask = this._pending.get(task.topic)\n    if (existingTask) {\n      // If the new task has a higher priority than the old task,\n      if (task.priority > existingTask.priority) {\n        // Update the priority and the task's position in the queue\n        this._pending.updatePriority(task.topic, task.priority)\n      }\n\n      // Merge the information from the new task into the existing task\n      this._taskMerger.merge(task, existingTask)\n\n      // A task with the topic exists, so we don't need to add\n      // the new task to the queue\n      return\n    }\n\n    // Push the new task onto the queue\n    this._pending.add(task)\n  }\n\n  /**\n   * Indicates whether the new task adds any more information over tasks that are\n   * already in the active task queue\n   *\n   * @private\n   * @param {Task} task\n   * @returns {boolean}\n   */\n  _taskHasMoreInfoThanActiveTasks (task) {\n    const tasksWithTopic = []\n    for (const activeTask of this._active) {\n      if (activeTask.topic === task.topic) {\n        tasksWithTopic.push(activeTask)\n      }\n    }\n\n    // No tasks with that topic, so the new task adds information\n    if (tasksWithTopic.length === 0) {\n      return true\n    }\n\n    return this._taskMerger.hasNewInfo(task, tasksWithTopic)\n  }\n\n  /**\n   * Pop tasks off the queue such that the total size is at least targetMinBytes\n   *\n   * @param {number} targetMinBytes\n   * @returns {PopTaskResult}\n   */\n  popTasks (targetMinBytes) {\n    let size = 0\n    const tasks = []\n\n    // Keep popping tasks until we get up to targetMinBytes (or one item over\n    // targetMinBytes)\n    const pendingTasks = this._pending.tasks()\n    for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {\n      const task = pendingTasks[i]\n      tasks.push(task)\n      size += task.size\n\n      // Move tasks from pending to active\n      this._pending.delete(task.topic)\n      this._activeTotalSize += task.size\n      this._active.add(task)\n    }\n\n    return {\n      tasks, pendingSize: this._pending.totalSize\n    }\n  }\n\n  /**\n   * Called when a task completes.\n   * Note: must be the same reference as returned from popTasks.\n   *\n   * @param {Task} task\n   * @returns {void}\n   */\n  taskDone (task) {\n    if (this._active.has(task)) {\n      this._activeTotalSize -= task.size\n      this._active.delete(task)\n    }\n  }\n\n  /**\n   * Remove pending tasks with the given topic\n   *\n   * @param {string} topic\n   * @returns {void}\n   */\n  remove (topic) {\n    this._pending.delete(topic)\n  }\n\n  /**\n   * No work to be done, this PeerTasks object can be freed.\n   *\n   * @returns {boolean}\n   */\n  isIdle () {\n    return this._pending.length === 0 && this._active.size === 0\n  }\n\n  /**\n   * Compare PeerTasks\n   *\n   * @template Key\n   * @param {[Key, PeerTasks]} a\n   * @param {[Key, PeerTasks]} b\n   * @returns {number}\n   */\n  static compare (a, b) {\n    // Move peers with no pending tasks to the back of the queue\n    if (a[1]._pending.length === 0) {\n      return 1\n    }\n    if (b[1]._pending.length === 0) {\n      return -1\n    }\n\n    // If the amount of active work is the same\n    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {\n      // Choose the peer with the most pending work\n      return b[1]._pending.length - a[1]._pending.length\n    }\n\n    // Choose the peer with the least amount of active work (\"keep peers busy\")\n    return a[1]._activeTotalSize - b[1]._activeTotalSize\n  }\n}\n\n/**\n * Queue of pending tasks for a particular peer, sorted by priority.\n */\nclass PendingTasks {\n  constructor () {\n    /** @type {SortedMap<string, PendingTask>} */\n    this._tasks = new SortedMap([], this._compare)\n  }\n\n  get length () {\n    return this._tasks.size\n  }\n\n  /**\n   * Sum of the size of all pending tasks\n   *\n   * @type {number}\n   **/\n  get totalSize () {\n    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0)\n  }\n\n  /**\n   * @param {string} topic\n   * @returns {Task|void}\n   */\n  get (topic) {\n    return (this._tasks.get(topic) || {}).task\n  }\n\n  /**\n   * @param {Task} task\n   */\n  add (task) {\n    this._tasks.set(task.topic, {\n      created: Date.now(),\n      task\n    })\n  }\n\n  /**\n   * @param {string} topic\n   * @returns {void}\n   */\n  delete (topic) {\n    this._tasks.delete(topic)\n  }\n\n  // All pending tasks, in priority order\n  tasks () {\n    return [...this._tasks.values()].map(i => i.task)\n  }\n\n  /**\n   * Update the priority of the task with the given topic, and update the order\n   *\n   * @param {string} topic\n   * @param {number} priority\n   * @returns {void}\n   **/\n  updatePriority (topic, priority) {\n    const obj = this._tasks.get(topic)\n    if (!obj) {\n      return\n    }\n\n    const i = this._tasks.indexOf(topic)\n    obj.task.priority = priority\n    this._tasks.update(i)\n  }\n\n  /**\n   * Sort by priority desc then FIFO\n   *\n   * @param {[string, PendingTask]} a\n   * @param {[string, PendingTask]} b\n   * @returns {number}\n   * @private\n   */\n  _compare (a, b) {\n    if (a[1].task.priority === b[1].task.priority) {\n      // FIFO\n      return a[1].created - b[1].created\n    }\n    // Priority high -> low\n    return b[1].task.priority - a[1].task.priority\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}