{"ast":null,"code":"import _defineProperty from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport errCode from 'err-code';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport first from 'it-first';\nimport { abortableSource } from 'abortable-iterator';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { MAX_PROTOCOL_LENGTH } from './constants.js';\nimport { logger } from '@libp2p/logger';\nvar log = logger('libp2p:mss');\nvar NewLine = uint8ArrayFromString('\\n');\nexport function encode(buffer) {\n  var list = new Uint8ArrayList(buffer, NewLine);\n  return lp.encode.single(list);\n}\n/**\n * `write` encodes and writes a single buffer\n */\nexport function write(writer, buffer) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var encoded = encode(buffer);\n  if (options.writeBytes === true) {\n    writer.push(encoded.subarray());\n  } else {\n    writer.push(encoded);\n  }\n}\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport function writeAll(writer, buffers) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var list = new Uint8ArrayList();\n  var _iterator = _createForOfIteratorHelper(buffers),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var buf = _step.value;\n      list.append(encode(buf));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (options.writeBytes === true) {\n    writer.push(list.subarray());\n  } else {\n    writer.push(list);\n  }\n}\nexport function read(_x, _x2) {\n  return _read.apply(this, arguments);\n}\nfunction _read() {\n  _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(reader, options) {\n    var _varByteSource;\n    var byteLength, varByteSource, input, onLength, buf;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          byteLength = 1; // Read single byte chunks until the length is known\n          varByteSource = (_varByteSource = {}, _defineProperty(_varByteSource, Symbol.asyncIterator, function () {\n            return varByteSource;\n          }), _defineProperty(_varByteSource, \"next\", function () {\n            var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return reader.next(byteLength);\n                  case 2:\n                    return _context.abrupt(\"return\", _context.sent);\n                  case 3:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }));\n            function next() {\n              return _next.apply(this, arguments);\n            }\n            return next;\n          }()), _varByteSource);\n          input = varByteSource; // If we have been passed an abort signal, wrap the input source in an abortable\n          // iterator that will throw if the operation is aborted\n          if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n            input = abortableSource(varByteSource, options.signal);\n          }\n          // Once the length has been parsed, read chunk for that length\n          onLength = function onLength(l) {\n            byteLength = l;\n          };\n          _context3.next = 7;\n          return pipe(input, lp.decode({\n            onLength: onLength,\n            maxDataLength: MAX_PROTOCOL_LENGTH\n          }), /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                while (1) switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return first(source);\n                  case 2:\n                    return _context2.abrupt(\"return\", _context2.sent);\n                  case 3:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }, _callee2);\n            }));\n            return function (_x5) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n        case 7:\n          buf = _context3.sent;\n          if (!(buf == null || buf.length === 0)) {\n            _context3.next = 10;\n            break;\n          }\n          throw errCode(new Error('no buffer returned'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n        case 10:\n          if (!(buf.get(buf.byteLength - 1) !== NewLine[0])) {\n            _context3.next = 13;\n            break;\n          }\n          log.error('Invalid mss message - missing newline - %s', buf.subarray());\n          throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n        case 13:\n          return _context3.abrupt(\"return\", buf.sublist(0, -1));\n        case 14:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _read.apply(this, arguments);\n}\nexport function readString(_x3, _x4) {\n  return _readString.apply(this, arguments);\n}\nfunction _readString() {\n  _readString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(reader, options) {\n    var buf;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return read(reader, options);\n        case 2:\n          buf = _context4.sent;\n          return _context4.abrupt(\"return\", uint8ArrayToString(buf.subarray()));\n        case 4:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _readString.apply(this, arguments);\n}","map":{"version":3,"names":["Uint8ArrayList","lp","pipe","errCode","fromString","uint8ArrayFromString","first","abortableSource","toString","uint8ArrayToString","MAX_PROTOCOL_LENGTH","logger","log","NewLine","encode","buffer","list","single","write","writer","options","arguments","length","undefined","encoded","writeBytes","push","subarray","writeAll","buffers","_iterator","_createForOfIteratorHelper","_step","s","n","done","buf","value","append","err","e","f","read","_x","_x2","_read","apply","_asyncToGenerator","_regeneratorRuntime","mark","_callee3","reader","_varByteSource","byteLength","varByteSource","input","onLength","wrap","_callee3$","_context3","prev","next","_defineProperty","Symbol","asyncIterator","_next","_callee","_callee$","_context","abrupt","sent","stop","signal","l","decode","maxDataLength","_ref","_callee2","source","_callee2$","_context2","_x5","Error","get","error","sublist","readString","_x3","_x4","_readString","_callee4","_callee4$","_context4"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/multistream-select/src/multistream.ts"],"sourcesContent":["\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport errCode from 'err-code'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport first from 'it-first'\nimport { abortableSource } from 'abortable-iterator'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Pushable } from 'it-pushable'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Source } from 'it-stream-types'\nimport type { Reader } from 'it-reader'\nimport type { MultistreamSelectInit } from '.'\nimport { MAX_PROTOCOL_LENGTH } from './constants.js'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('libp2p:mss')\n\nconst NewLine = uint8ArrayFromString('\\n')\n\nexport function encode (buffer: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  const list = new Uint8ArrayList(buffer, NewLine)\n\n  return lp.encode.single(list)\n}\n\n/**\n * `write` encodes and writes a single buffer\n */\nexport function write (writer: Pushable<any>, buffer: Uint8Array | Uint8ArrayList, options: MultistreamSelectInit = {}) {\n  const encoded = encode(buffer)\n\n  if (options.writeBytes === true) {\n    writer.push(encoded.subarray())\n  } else {\n    writer.push(encoded)\n  }\n}\n\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport function writeAll (writer: Pushable<any>, buffers: Uint8Array[], options: MultistreamSelectInit = {}) {\n  const list = new Uint8ArrayList()\n\n  for (const buf of buffers) {\n    list.append(encode(buf))\n  }\n\n  if (options.writeBytes === true) {\n    writer.push(list.subarray())\n  } else {\n    writer.push(list)\n  }\n}\n\nexport async function read (reader: Reader, options?: AbortOptions): Promise<Uint8ArrayList> {\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = { // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator]: () => varByteSource,\n    next: async () => await reader.next(byteLength)\n  }\n\n  let input: Source<Uint8ArrayList> = varByteSource\n\n  // If we have been passed an abort signal, wrap the input source in an abortable\n  // iterator that will throw if the operation is aborted\n  if (options?.signal != null) {\n    input = abortableSource(varByteSource, options.signal)\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  const onLength = (l: number) => {\n    byteLength = l\n  }\n\n  const buf = await pipe(\n    input,\n    lp.decode({ onLength, maxDataLength: MAX_PROTOCOL_LENGTH }),\n    async (source) => await first(source)\n  )\n\n  if (buf == null || buf.length === 0) {\n    throw errCode(new Error('no buffer returned'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  if (buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    log.error('Invalid mss message - missing newline - %s', buf.subarray())\n    throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  return buf.sublist(0, -1) // Remove newline\n}\n\nexport async function readString (reader: Reader, options?: AbortOptions) {\n  const buf = await read(reader, options)\n\n  return uint8ArrayToString(buf.subarray())\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}