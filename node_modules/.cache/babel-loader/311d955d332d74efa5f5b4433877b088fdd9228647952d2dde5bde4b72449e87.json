{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { pipe } from 'it-pipe';\nimport { pushableV } from 'it-pushable';\nimport { abortableSource } from 'abortable-iterator';\nimport { encode } from './encode.js';\nimport { decode } from './decode.js';\nimport { restrictSize } from './restrict-size.js';\nimport { MessageTypes, MessageTypeNames } from './message-types.js';\nimport { createStream } from './stream.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { RateLimiterMemory } from 'rate-limiter-flexible';\nimport anySignal from 'any-signal';\nvar log = logger('libp2p:mplex');\nvar MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;\nvar MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;\nvar MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4; // 4MB\nvar DISCONNECT_THRESHOLD = 5;\nfunction printMessage(msg) {\n  var output = _objectSpread(_objectSpread({}, msg), {}, {\n    type: \"\".concat(MessageTypeNames[msg.type], \" (\").concat(msg.type, \")\")\n  });\n  if (msg.type === MessageTypes.NEW_STREAM) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());\n  }\n  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16');\n  }\n  return output;\n}\nexport var MplexStreamMuxer = /*#__PURE__*/function () {\n  function MplexStreamMuxer(components, init) {\n    var _init, _init$disconnectThres;\n    _classCallCheck(this, MplexStreamMuxer);\n    this.protocol = '/mplex/6.7.0';\n    init = (_init = init) !== null && _init !== void 0 ? _init : {};\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * Stream to ids map\n       */\n      initiators: new Map(),\n      /**\n       * Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._init = init;\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n    var source = this._createSource();\n    this._source = source;\n    this.source = source;\n    /**\n     * Close controller\n     */\n    this.closeController = new AbortController();\n    this.rateLimiter = new RateLimiterMemory({\n      points: (_init$disconnectThres = init.disconnectThreshold) !== null && _init$disconnectThres !== void 0 ? _init$disconnectThres : DISCONNECT_THRESHOLD,\n      duration: 1\n    });\n  }\n  _createClass(MplexStreamMuxer, [{\n    key: \"init\",\n    value: function init(components) {}\n    /**\n     * Returns a Map of streams and their ids\n     */\n  }, {\n    key: \"streams\",\n    get: function get() {\n      // Inbound and Outbound streams may have the same ids, so we need to make those unique\n      var streams = [];\n      var _iterator2 = _createForOfIteratorHelper(this._streams.initiators.values()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var stream = _step2.value;\n          streams.push(stream);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(this._streams.receivers.values()),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _stream = _step3.value;\n          streams.push(_stream);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return streams;\n    }\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of the stream will be used.\n     */\n  }, {\n    key: \"newStream\",\n    value: function newStream(name) {\n      if (this.closeController.signal.aborted) {\n        throw new Error('Muxer already closed');\n      }\n      var id = this._streamId++;\n      name = name == null ? id.toString() : name.toString();\n      var registry = this._streams.initiators;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'initiator',\n        registry: registry\n      });\n    }\n    /**\n     * Close or abort all tracked streams and stop the muxer\n     */\n  }, {\n    key: \"close\",\n    value: function close(err) {\n      if (this.closeController.signal.aborted) return;\n      if (err != null) {\n        this.streams.forEach(function (s) {\n          return s.abort(err);\n        });\n      } else {\n        this.streams.forEach(function (s) {\n          return s.close();\n        });\n      }\n      this.closeController.abort();\n    }\n    /**\n     * Called whenever an inbound stream is created\n     */\n  }, {\n    key: \"_newReceiverStream\",\n    value: function _newReceiverStream(options) {\n      var id = options.id,\n        name = options.name;\n      var registry = this._streams.receivers;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'receiver',\n        registry: registry\n      });\n    }\n  }, {\n    key: \"_newStream\",\n    value: function _newStream(options) {\n      var _this$_init$maxOutbou,\n        _this = this;\n      var id = options.id,\n        name = options.name,\n        type = options.type,\n        registry = options.registry;\n      log('new %s stream %s %s', type, id);\n      if (type === 'initiator' && this._streams.initiators.size === ((_this$_init$maxOutbou = this._init.maxOutboundStreams) !== null && _this$_init$maxOutbou !== void 0 ? _this$_init$maxOutbou : MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n        throw errCode(new Error('Too many outbound streams open'), 'ERR_TOO_MANY_OUTBOUND_STREAMS');\n      }\n      if (registry.has(id)) {\n        throw new Error(\"\".concat(type, \" stream \").concat(id, \" already exists!\"));\n      }\n      var send = function send(msg) {\n        if (log.enabled) {\n          log.trace('%s stream %s send', type, id, printMessage(msg));\n        }\n        _this._source.push(msg);\n      };\n      var onEnd = function onEnd() {\n        log('%s stream with id %s and protocol %s ended', type, id, stream.stat.protocol);\n        registry.delete(id);\n        if (_this._init.onStreamEnd != null) {\n          _this._init.onStreamEnd(stream);\n        }\n      };\n      var stream = createStream({\n        id: id,\n        name: name,\n        send: send,\n        type: type,\n        onEnd: onEnd,\n        maxMsgSize: this._init.maxMsgSize\n      });\n      registry.set(id, stream);\n      return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     */\n  }, {\n    key: \"_createSink\",\n    value: function _createSink() {\n      var _this2 = this;\n      var sink = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n          var abortSignals;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                // see: https://github.com/jacobheun/any-signal/pull/18\n                abortSignals = [_this2.closeController.signal];\n                if (_this2._init.signal != null) {\n                  abortSignals.push(_this2._init.signal);\n                }\n                source = abortableSource(source, anySignal(abortSignals));\n                _context2.prev = 3;\n                _context2.next = 6;\n                return pipe(source, decode, restrictSize(_this2._init.maxMsgSize), /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n                    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, msg;\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          _iteratorAbruptCompletion = false;\n                          _didIteratorError = false;\n                          _context.prev = 2;\n                          _iterator = _asyncIterator(source);\n                        case 4:\n                          _context.next = 6;\n                          return _iterator.next();\n                        case 6:\n                          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                            _context.next = 13;\n                            break;\n                          }\n                          msg = _step.value;\n                          _context.next = 10;\n                          return _this2._handleIncoming(msg);\n                        case 10:\n                          _iteratorAbruptCompletion = false;\n                          _context.next = 4;\n                          break;\n                        case 13:\n                          _context.next = 19;\n                          break;\n                        case 15:\n                          _context.prev = 15;\n                          _context.t0 = _context[\"catch\"](2);\n                          _didIteratorError = true;\n                          _iteratorError = _context.t0;\n                        case 19:\n                          _context.prev = 19;\n                          _context.prev = 20;\n                          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                            _context.next = 24;\n                            break;\n                          }\n                          _context.next = 24;\n                          return _iterator.return();\n                        case 24:\n                          _context.prev = 24;\n                          if (!_didIteratorError) {\n                            _context.next = 27;\n                            break;\n                          }\n                          throw _iteratorError;\n                        case 27:\n                          return _context.finish(24);\n                        case 28:\n                          return _context.finish(19);\n                        case 29:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n                  }));\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n              case 6:\n                _this2._source.end();\n                _context2.next = 13;\n                break;\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](3);\n                log('error in sink', _context2.t0);\n                _this2._source.end(_context2.t0); // End the source with an error\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2, null, [[3, 9]]);\n        }));\n        return function sink(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      return sink;\n    }\n    /**\n     * Creates a source that restricts outgoing message sizes\n     * and varint encodes them\n     */\n  }, {\n    key: \"_createSource\",\n    value: function _createSource() {\n      var _this3 = this;\n      var onEnd = function onEnd(err) {\n        _this3.close(err);\n      };\n      var source = pushableV({\n        objectMode: true,\n        onEnd: onEnd\n      });\n      return Object.assign(encode(source), {\n        push: source.push,\n        end: source.end,\n        return: source.return\n      });\n    }\n  }, {\n    key: \"_handleIncoming\",\n    value: function () {\n      var _handleIncoming2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {\n        var _this$_init$maxStream;\n        var id, type, _this$_init$maxInboun, _stream2, list, stream, maxBufferSize, error;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              id = message.id, type = message.type;\n              if (log.enabled) {\n                log.trace('incoming message', printMessage(message));\n              }\n              // Create a new stream?\n              if (!(message.type === MessageTypes.NEW_STREAM)) {\n                _context3.next = 20;\n                break;\n              }\n              if (!(this._streams.receivers.size === ((_this$_init$maxInboun = this._init.maxInboundStreams) !== null && _this$_init$maxInboun !== void 0 ? _this$_init$maxInboun : MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION))) {\n                _context3.next = 17;\n                break;\n              }\n              log('too many inbound streams open');\n              // not going to allow this stream, send the reset message manually\n              // instead of setting it up just to tear it down\n              this._source.push({\n                id: id,\n                type: MessageTypes.RESET_RECEIVER\n              });\n              // if we've hit our stream limit, and the remote keeps trying to open\n              // more new streams, if they are doing this very quickly maybe they\n              // are attacking us and we should close the connection\n              _context3.prev = 6;\n              _context3.next = 9;\n              return this.rateLimiter.consume('new-stream', 1);\n            case 9:\n              _context3.next = 16;\n              break;\n            case 11:\n              _context3.prev = 11;\n              _context3.t0 = _context3[\"catch\"](6);\n              log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection');\n              // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n              this._source.end(new Error('Too many open streams'));\n              return _context3.abrupt(\"return\");\n            case 16:\n              return _context3.abrupt(\"return\");\n            case 17:\n              _stream2 = this._newReceiverStream({\n                id: id,\n                name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray())\n              });\n              if (this._init.onIncomingStream != null) {\n                this._init.onIncomingStream(_stream2);\n              }\n              return _context3.abrupt(\"return\");\n            case 20:\n              list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;\n              stream = list.get(id);\n              if (!(stream == null)) {\n                _context3.next = 25;\n                break;\n              }\n              log('missing stream %s for message type %s', id, MessageTypeNames[type]);\n              return _context3.abrupt(\"return\");\n            case 25:\n              maxBufferSize = (_this$_init$maxStream = this._init.maxStreamBufferSize) !== null && _this$_init$maxStream !== void 0 ? _this$_init$maxStream : MAX_STREAM_BUFFER_SIZE;\n              _context3.t1 = type;\n              _context3.next = _context3.t1 === MessageTypes.MESSAGE_INITIATOR ? 29 : _context3.t1 === MessageTypes.MESSAGE_RECEIVER ? 29 : _context3.t1 === MessageTypes.CLOSE_INITIATOR ? 36 : _context3.t1 === MessageTypes.CLOSE_RECEIVER ? 36 : _context3.t1 === MessageTypes.RESET_INITIATOR ? 38 : _context3.t1 === MessageTypes.RESET_RECEIVER ? 38 : 40;\n              break;\n            case 29:\n              if (!(stream.sourceReadableLength() > maxBufferSize)) {\n                _context3.next = 34;\n                break;\n              }\n              // Stream buffer has got too large, reset the stream\n              this._source.push({\n                id: message.id,\n                type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n              });\n              // Inform the stream consumer they are not fast enough\n              error = errCode(new Error('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers'), 'ERR_STREAM_INPUT_BUFFER_FULL');\n              stream.abort(error);\n              return _context3.abrupt(\"return\");\n            case 34:\n              // We got data from the remote, push it into our local stream\n              stream.sourcePush(message.data);\n              return _context3.abrupt(\"break\", 41);\n            case 36:\n              // We should expect no more data from the remote, stop reading\n              stream.closeRead();\n              return _context3.abrupt(\"break\", 41);\n            case 38:\n              // Stop reading and writing to the stream immediately\n              stream.reset();\n              return _context3.abrupt(\"break\", 41);\n            case 40:\n              log('unknown message type %s', type);\n            case 41:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[6, 11]]);\n      }));\n      function _handleIncoming(_x3) {\n        return _handleIncoming2.apply(this, arguments);\n      }\n      return _handleIncoming;\n    }()\n  }]);\n  return MplexStreamMuxer;\n}();","map":{"version":3,"names":["pipe","pushableV","abortableSource","encode","decode","restrictSize","MessageTypes","MessageTypeNames","createStream","toString","uint8ArrayToString","logger","errCode","RateLimiterMemory","anySignal","log","MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION","MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION","MAX_STREAM_BUFFER_SIZE","DISCONNECT_THRESHOLD","printMessage","msg","output","_objectSpread","type","concat","NEW_STREAM","data","Uint8Array","subarray","MESSAGE_INITIATOR","MESSAGE_RECEIVER","MplexStreamMuxer","components","init","_init","_init$disconnectThres","_classCallCheck","protocol","_streamId","_streams","initiators","Map","receivers","sink","_createSink","source","_createSource","_source","closeController","AbortController","rateLimiter","points","disconnectThreshold","duration","_createClass","key","value","get","streams","_iterator2","_createForOfIteratorHelper","values","_step2","s","n","done","stream","push","err","e","f","_iterator3","_step3","newStream","name","signal","aborted","Error","id","registry","_newStream","close","forEach","abort","_newReceiverStream","options","_this$_init$maxOutbou","_this","size","maxOutboundStreams","has","send","enabled","trace","onEnd","stat","delete","onStreamEnd","maxMsgSize","set","_this2","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","abortSignals","wrap","_callee2$","_context2","prev","next","_ref2","_callee","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","_callee$","_context","_asyncIterator","sent","_handleIncoming","t0","return","finish","stop","_x2","apply","arguments","end","_x","_this3","objectMode","Object","assign","_handleIncoming2","_callee3","message","_this$_init$maxStream","_this$_init$maxInboun","_stream2","list","maxBufferSize","error","_callee3$","_context3","maxInboundStreams","RESET_RECEIVER","consume","abrupt","onIncomingStream","maxStreamBufferSize","t1","CLOSE_INITIATOR","CLOSE_RECEIVER","RESET_INITIATOR","sourceReadableLength","sourcePush","closeRead","reset","_x3"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/mplex/src/mplex.ts"],"sourcesContent":["import { pipe } from 'it-pipe'\nimport { pushableV } from 'it-pushable'\nimport { abortableSource } from 'abortable-iterator'\nimport { encode } from './encode.js'\nimport { decode } from './decode.js'\nimport { restrictSize } from './restrict-size.js'\nimport { MessageTypes, MessageTypeNames, Message } from './message-types.js'\nimport { createStream } from './stream.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays'\nimport { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { RateLimiterMemory } from 'rate-limiter-flexible'\nimport type { Components } from '@libp2p/components'\nimport type { Sink } from 'it-stream-types'\nimport type { StreamMuxer, StreamMuxerInit } from '@libp2p/interface-stream-muxer'\nimport type { Stream } from '@libp2p/interface-connection'\nimport type { MplexInit } from './index.js'\nimport anySignal from 'any-signal'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:mplex')\n\nconst MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024\nconst MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024\nconst MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4 // 4MB\nconst DISCONNECT_THRESHOLD = 5\n\nfunction printMessage (msg: Message) {\n  const output: any = {\n    ...msg,\n    type: `${MessageTypeNames[msg.type]} (${msg.type})`\n  }\n\n  if (msg.type === MessageTypes.NEW_STREAM) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray())\n  }\n\n  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16')\n  }\n\n  return output\n}\n\nexport interface MplexStream extends Stream {\n  sourceReadableLength: () => number\n  sourcePush: (data: Uint8ArrayList) => void\n}\n\ninterface MplexStreamMuxerInit extends MplexInit, StreamMuxerInit {}\n\nexport class MplexStreamMuxer implements StreamMuxer {\n  public protocol = '/mplex/6.7.0'\n\n  public sink: Sink<Uint8Array>\n  public source: AsyncIterable<Uint8Array>\n\n  private _streamId: number\n  private readonly _streams: { initiators: Map<number, MplexStream>, receivers: Map<number, MplexStream> }\n  private readonly _init: MplexStreamMuxerInit\n  private readonly _source: { push: (val: Message) => void, end: (err?: Error) => void }\n  private readonly closeController: AbortController\n  private readonly rateLimiter: RateLimiterMemory\n\n  constructor (components: Components, init?: MplexStreamMuxerInit) {\n    init = init ?? {}\n\n    this._streamId = 0\n    this._streams = {\n      /**\n       * Stream to ids map\n       */\n      initiators: new Map<number, MplexStream>(),\n      /**\n       * Stream to ids map\n       */\n      receivers: new Map<number, MplexStream>()\n    }\n    this._init = init\n\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink()\n\n    /**\n     * An iterable source\n     */\n    const source = this._createSource()\n    this._source = source\n    this.source = source\n\n    /**\n     * Close controller\n     */\n    this.closeController = new AbortController()\n\n    this.rateLimiter = new RateLimiterMemory({\n      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,\n      duration: 1\n    })\n  }\n\n  init (components: Components) {}\n\n  /**\n   * Returns a Map of streams and their ids\n   */\n  get streams () {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams: Stream[] = []\n    for (const stream of this._streams.initiators.values()) {\n      streams.push(stream)\n    }\n\n    for (const stream of this._streams.receivers.values()) {\n      streams.push(stream)\n    }\n    return streams\n  }\n\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of the stream will be used.\n   */\n  newStream (name?: string): Stream {\n    if (this.closeController.signal.aborted) {\n      throw new Error('Muxer already closed')\n    }\n    const id = this._streamId++\n    name = name == null ? id.toString() : name.toString()\n    const registry = this._streams.initiators\n    return this._newStream({ id, name, type: 'initiator', registry })\n  }\n\n  /**\n   * Close or abort all tracked streams and stop the muxer\n   */\n  close (err?: Error | undefined): void {\n    if (this.closeController.signal.aborted) return\n\n    if (err != null) {\n      this.streams.forEach(s => s.abort(err))\n    } else {\n      this.streams.forEach(s => s.close())\n    }\n    this.closeController.abort()\n  }\n\n  /**\n   * Called whenever an inbound stream is created\n   */\n  _newReceiverStream (options: { id: number, name: string }) {\n    const { id, name } = options\n    const registry = this._streams.receivers\n    return this._newStream({ id, name, type: 'receiver', registry })\n  }\n\n  _newStream (options: { id: number, name: string, type: 'initiator' | 'receiver', registry: Map<number, MplexStream> }) {\n    const { id, name, type, registry } = options\n\n    log('new %s stream %s %s', type, id)\n\n    if (type === 'initiator' && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n      throw errCode(new Error('Too many outbound streams open'), 'ERR_TOO_MANY_OUTBOUND_STREAMS')\n    }\n\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`)\n    }\n\n    const send = (msg: Message) => {\n      if (log.enabled) {\n        log.trace('%s stream %s send', type, id, printMessage(msg))\n      }\n\n      this._source.push(msg)\n    }\n\n    const onEnd = () => {\n      log('%s stream with id %s and protocol %s ended', type, id, stream.stat.protocol)\n      registry.delete(id)\n\n      if (this._init.onStreamEnd != null) {\n        this._init.onStreamEnd(stream)\n      }\n    }\n\n    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._init.maxMsgSize })\n    registry.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   */\n  _createSink () {\n    const sink: Sink<Uint8Array> = async source => {\n      // see: https://github.com/jacobheun/any-signal/pull/18\n      const abortSignals = [this.closeController.signal]\n      if (this._init.signal != null) {\n        abortSignals.push(this._init.signal)\n      }\n      source = abortableSource(source, anySignal(abortSignals))\n\n      try {\n        await pipe(\n          source,\n          decode,\n          restrictSize(this._init.maxMsgSize),\n          async source => {\n            for await (const msg of source) {\n              await this._handleIncoming(msg)\n            }\n          }\n        )\n\n        this._source.end()\n      } catch (err: any) {\n        log('error in sink', err)\n        this._source.end(err) // End the source with an error\n      }\n    }\n\n    return sink\n  }\n\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them\n   */\n  _createSource () {\n    const onEnd = (err?: Error) => {\n      this.close(err)\n    }\n    const source = pushableV<Message>({\n      objectMode: true,\n      onEnd\n    })\n\n    return Object.assign(encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    })\n  }\n\n  async _handleIncoming (message: Message) {\n    const { id, type } = message\n\n    if (log.enabled) {\n      log.trace('incoming message', printMessage(message))\n    }\n\n    // Create a new stream?\n    if (message.type === MessageTypes.NEW_STREAM) {\n      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {\n        log('too many inbound streams open')\n\n        // not going to allow this stream, send the reset message manually\n        // instead of setting it up just to tear it down\n        this._source.push({\n          id,\n          type: MessageTypes.RESET_RECEIVER\n        })\n\n        // if we've hit our stream limit, and the remote keeps trying to open\n        // more new streams, if they are doing this very quickly maybe they\n        // are attacking us and we should close the connection\n        try {\n          await this.rateLimiter.consume('new-stream', 1)\n        } catch {\n          log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection')\n          // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n          this._source.end(new Error('Too many open streams'))\n          return\n        }\n\n        return\n      }\n\n      const stream = this._newReceiverStream({ id, name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray()) })\n\n      if (this._init.onIncomingStream != null) {\n        this._init.onIncomingStream(stream)\n      }\n\n      return\n    }\n\n    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers\n    const stream = list.get(id)\n\n    if (stream == null) {\n      log('missing stream %s for message type %s', id, MessageTypeNames[type])\n\n      return\n    }\n\n    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        if (stream.sourceReadableLength() > maxBufferSize) {\n          // Stream buffer has got too large, reset the stream\n          this._source.push({\n            id: message.id,\n            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n          })\n\n          // Inform the stream consumer they are not fast enough\n          const error = errCode(new Error('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers'), 'ERR_STREAM_INPUT_BUFFER_FULL')\n          stream.abort(error)\n\n          return\n        }\n\n        // We got data from the remote, push it into our local stream\n        stream.sourcePush(message.data)\n        break\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        // We should expect no more data from the remote, stop reading\n        stream.closeRead()\n        break\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        // Stop reading and writing to the stream immediately\n        stream.reset()\n        break\n      default:\n        log('unknown message type %s', type)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}