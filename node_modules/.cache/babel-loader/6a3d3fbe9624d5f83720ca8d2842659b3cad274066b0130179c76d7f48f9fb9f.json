{"ast":null,"code":"import _objectSpread from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { logger } from '@libp2p/logger';\nimport all from 'it-all';\nimport filter from 'it-filter';\nimport { pipe } from 'it-pipe';\nimport errCode from 'err-code';\nimport { multiaddr, resolvers } from '@multiformats/multiaddr';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { AbortError } from '@libp2p/interfaces/errors';\nimport { anySignal } from 'any-signal';\nimport { setMaxListeners } from 'events';\nimport { DialRequest } from './dial-request.js';\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort';\nimport { trackedMap } from '@libp2p/tracked-map';\nimport { codes } from '../../errors.js';\nimport { DIAL_TIMEOUT, MAX_PARALLEL_DIALS, MAX_PER_PEER_DIALS, MAX_ADDRS_TO_DIAL } from '../../constants.js';\nimport { getPeer } from '../../get-peer.js';\nimport sort from 'it-sort';\nimport map from 'it-map';\nvar log = logger('libp2p:dialer');\nvar METRICS_COMPONENT = 'dialler';\nvar METRICS_PENDING_DIALS = 'pending-dials';\nvar METRICS_PENDING_DIAL_TARGETS = 'pending-dial-targets';\nexport var DefaultDialer = /*#__PURE__*/function () {\n  function DefaultDialer(components) {\n    var _init$addressSorter, _init$maxAddrsToDial, _init$dialTimeout, _init$maxDialsPerPeer, _init$maxParallelDial;\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, DefaultDialer);\n    this.started = false;\n    this.addressSorter = (_init$addressSorter = init.addressSorter) !== null && _init$addressSorter !== void 0 ? _init$addressSorter : publicAddressesFirst;\n    this.maxAddrsToDial = (_init$maxAddrsToDial = init.maxAddrsToDial) !== null && _init$maxAddrsToDial !== void 0 ? _init$maxAddrsToDial : MAX_ADDRS_TO_DIAL;\n    this.timeout = (_init$dialTimeout = init.dialTimeout) !== null && _init$dialTimeout !== void 0 ? _init$dialTimeout : DIAL_TIMEOUT;\n    this.maxDialsPerPeer = (_init$maxDialsPerPeer = init.maxDialsPerPeer) !== null && _init$maxDialsPerPeer !== void 0 ? _init$maxDialsPerPeer : MAX_PER_PEER_DIALS;\n    this.tokens = _toConsumableArray(new Array((_init$maxParallelDial = init.maxParallelDials) !== null && _init$maxParallelDial !== void 0 ? _init$maxParallelDial : MAX_PARALLEL_DIALS)).map(function (_, index) {\n      return index;\n    });\n    this.components = components;\n    this.pendingDials = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIALS,\n      metrics: init.metrics\n    });\n    this.pendingDialTargets = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIAL_TARGETS,\n      metrics: components.getMetrics()\n    });\n    for (var _i = 0, _Object$entries = Object.entries((_init$resolvers = init.resolvers) !== null && _init$resolvers !== void 0 ? _init$resolvers : {}); _i < _Object$entries.length; _i++) {\n      var _init$resolvers;\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      resolvers.set(key, value);\n    }\n  }\n  _createClass(DefaultDialer, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.started = true;\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n    /**\n     * Clears any pending dials\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _iterator2, _step2, dial, _iterator3, _step3, pendingTarget;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.started = false;\n              _iterator2 = _createForOfIteratorHelper(this.pendingDials.values());\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  dial = _step2.value;\n                  try {\n                    dial.controller.abort();\n                  } catch (err) {\n                    log.error(err);\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              this.pendingDials.clear();\n              _iterator3 = _createForOfIteratorHelper(this.pendingDialTargets.values());\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  pendingTarget = _step3.value;\n                  pendingTarget.reject(new AbortError('Dialer was destroyed'));\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              this.pendingDialTargets.clear();\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Connects to a given `peer` by dialing all of its known addresses.\n     * The dial to the first address that is successfully able to upgrade a connection\n     * will be used.\n     */\n  }, {\n    key: \"dial\",\n    value: function () {\n      var _dial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peer) {\n        var _this$pendingDials$ge;\n        var options,\n          _getPeer,\n          id,\n          multiaddrs,\n          dialTarget,\n          pendingDial,\n          connection,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n              _getPeer = getPeer(peer), id = _getPeer.id, multiaddrs = _getPeer.multiaddrs;\n              if (!this.components.getPeerId().equals(id)) {\n                _context3.next = 4;\n                break;\n              }\n              throw errCode(new Error('Tried to dial self'), codes.ERR_DIALED_SELF);\n            case 4:\n              log('check multiaddrs %p', id);\n              if (!(multiaddrs != null && multiaddrs.length > 0)) {\n                _context3.next = 9;\n                break;\n              }\n              log('storing multiaddrs %p', id, multiaddrs);\n              _context3.next = 9;\n              return this.components.getPeerStore().addressBook.add(id, multiaddrs);\n            case 9:\n              _context3.next = 11;\n              return this.components.getConnectionGater().denyDialPeer(id);\n            case 11:\n              if (!_context3.sent) {\n                _context3.next = 13;\n                break;\n              }\n              throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED);\n            case 13:\n              log('creating dial target for %p', id);\n              _context3.next = 16;\n              return this._createCancellableDialTarget(id, options);\n            case 16:\n              dialTarget = _context3.sent;\n              if (!(dialTarget.addrs.length === 0)) {\n                _context3.next = 19;\n                break;\n              }\n              throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n            case 19:\n              pendingDial = (_this$pendingDials$ge = this.pendingDials.get(dialTarget.id)) !== null && _this$pendingDials$ge !== void 0 ? _this$pendingDials$ge : this._createPendingDial(dialTarget, options);\n              _context3.prev = 20;\n              _context3.next = 23;\n              return pendingDial.promise;\n            case 23:\n              connection = _context3.sent;\n              log('dial succeeded to %s', dialTarget.id);\n              return _context3.abrupt(\"return\", connection);\n            case 28:\n              _context3.prev = 28;\n              _context3.t0 = _context3[\"catch\"](20);\n              log('dial failed to %s', dialTarget.id, _context3.t0);\n              // Error is a timeout\n              if (pendingDial.controller.signal.aborted) {\n                _context3.t0.code = codes.ERR_TIMEOUT;\n              }\n              log.error(_context3.t0);\n              throw _context3.t0;\n            case 34:\n              _context3.prev = 34;\n              pendingDial.destroy();\n              return _context3.finish(34);\n            case 37:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[20, 28, 34, 37]]);\n      }));\n      function dial(_x2) {\n        return _dial.apply(this, arguments);\n      }\n      return dial;\n    }()\n    /**\n     * Connects to a given `peer` by dialing all of its known addresses.\n     * The dial to the first address that is successfully able to upgrade a connection\n     * will be used.\n     */\n  }, {\n    key: \"_createCancellableDialTarget\",\n    value: function () {\n      var _createCancellableDialTarget2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peer, options) {\n        var _this = this;\n        var id, cancellablePromise, dialTarget;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              // Make dial target promise cancellable\n              id = \"\".concat(parseInt(String(Math.random() * 1e9), 10).toString()).concat(Date.now());\n              cancellablePromise = new Promise(function (resolve, reject) {\n                _this.pendingDialTargets.set(id, {\n                  resolve: resolve,\n                  reject: reject\n                });\n              });\n              _context4.prev = 2;\n              _context4.next = 5;\n              return Promise.race([this._createDialTarget(peer, options), cancellablePromise]);\n            case 5:\n              dialTarget = _context4.sent;\n              return _context4.abrupt(\"return\", dialTarget);\n            case 7:\n              _context4.prev = 7;\n              this.pendingDialTargets.delete(id);\n              return _context4.finish(7);\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[2,, 7, 10]]);\n      }));\n      function _createCancellableDialTarget(_x3, _x4) {\n        return _createCancellableDialTarget2.apply(this, arguments);\n      }\n      return _createCancellableDialTarget;\n    }()\n    /**\n     * Creates a DialTarget. The DialTarget is used to create and track\n     * the DialRequest to a given peer.\n     * If a multiaddr is received it should be the first address attempted.\n     * Multiaddrs not supported by the available transports will be filtered out.\n     */\n  }, {\n    key: \"_createDialTarget\",\n    value: function () {\n      var _createDialTarget2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(peer, options) {\n        var _this2 = this;\n        var _resolve, addrs;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _resolve = this._resolve.bind(this);\n              _context8.t0 = pipe;\n              _context8.next = 4;\n              return this.components.getPeerStore().addressBook.get(peer);\n            case 4:\n              _context8.t1 = _context8.sent;\n              _context8.t2 = function (source) {\n                return filter(source, /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(address) {\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _context5.next = 2;\n                          return _this2.components.getConnectionGater().denyDialMultiaddr(peer, address.multiaddr);\n                        case 2:\n                          return _context5.abrupt(\"return\", !_context5.sent);\n                        case 3:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }, _callee5);\n                  }));\n                  return function (_x7) {\n                    return _ref.apply(this, arguments);\n                  };\n                }());\n              };\n              _context8.t3 =\n              // Sort addresses so, for example, we try certified public address first\n              function (source) {\n                return sort(source, _this2.addressSorter);\n              };\n              _context8.t4 = /*#__PURE__*/function () {\n                var _resolve2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(source) {\n                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, a;\n                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                    while (1) switch (_context6.prev = _context6.next) {\n                      case 0:\n                        _iteratorAbruptCompletion = false;\n                        _didIteratorError = false;\n                        _context6.prev = 2;\n                        _iterator = _asyncIterator(source);\n                      case 4:\n                        _context6.next = 6;\n                        return _awaitAsyncGenerator(_iterator.next());\n                      case 6:\n                        if (!(_iteratorAbruptCompletion = !(_step = _context6.sent).done)) {\n                          _context6.next = 19;\n                          break;\n                        }\n                        a = _step.value;\n                        _context6.t0 = _asyncGeneratorDelegate;\n                        _context6.t1 = _asyncIterator;\n                        _context6.next = 12;\n                        return _awaitAsyncGenerator(_resolve(a.multiaddr, options));\n                      case 12:\n                        _context6.t2 = _context6.sent;\n                        _context6.t3 = (0, _context6.t1)(_context6.t2);\n                        _context6.t4 = _awaitAsyncGenerator;\n                        return _context6.delegateYield((0, _context6.t0)(_context6.t3, _context6.t4), \"t5\", 16);\n                      case 16:\n                        _iteratorAbruptCompletion = false;\n                        _context6.next = 4;\n                        break;\n                      case 19:\n                        _context6.next = 25;\n                        break;\n                      case 21:\n                        _context6.prev = 21;\n                        _context6.t6 = _context6[\"catch\"](2);\n                        _didIteratorError = true;\n                        _iteratorError = _context6.t6;\n                      case 25:\n                        _context6.prev = 25;\n                        _context6.prev = 26;\n                        if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                          _context6.next = 30;\n                          break;\n                        }\n                        _context6.next = 30;\n                        return _awaitAsyncGenerator(_iterator.return());\n                      case 30:\n                        _context6.prev = 30;\n                        if (!_didIteratorError) {\n                          _context6.next = 33;\n                          break;\n                        }\n                        throw _iteratorError;\n                      case 33:\n                        return _context6.finish(30);\n                      case 34:\n                        return _context6.finish(25);\n                      case 35:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }, _callee6, null, [[2, 21, 25, 35], [26,, 30, 34]]);\n                }));\n                function resolve(_x) {\n                  return _resolve2.apply(this, arguments);\n                }\n                return resolve;\n              }();\n              _context8.t5 =\n              // Multiaddrs not supported by the available transports will be filtered out.\n              function (source) {\n                return filter(source, function (ma) {\n                  return Boolean(_this2.components.getTransportManager().transportForMultiaddr(ma));\n                });\n              };\n              _context8.t6 = function (source) {\n                return map(source, function (ma) {\n                  if (peer.toString() === ma.getPeerId()) {\n                    return ma;\n                  }\n                  return ma.encapsulate(\"/p2p/\".concat(peer.toString()));\n                });\n              };\n              _context8.t7 = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(source) {\n                  return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                    while (1) switch (_context7.prev = _context7.next) {\n                      case 0:\n                        _context7.next = 2;\n                        return all(source);\n                      case 2:\n                        return _context7.abrupt(\"return\", _context7.sent);\n                      case 3:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }, _callee7);\n                }));\n                return function (_x8) {\n                  return _ref2.apply(this, arguments);\n                };\n              }();\n              _context8.next = 13;\n              return (0, _context8.t0)(_context8.t1, _context8.t2, _context8.t3, _context8.t4, _context8.t5, _context8.t6, _context8.t7);\n            case 13:\n              addrs = _context8.sent;\n              if (!(addrs.length > this.maxAddrsToDial)) {\n                _context8.next = 18;\n                break;\n              }\n              _context8.next = 17;\n              return this.components.getPeerStore().delete(peer);\n            case 17:\n              throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n            case 18:\n              return _context8.abrupt(\"return\", {\n                id: peer.toString(),\n                addrs: addrs\n              });\n            case 19:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function _createDialTarget(_x5, _x6) {\n        return _createDialTarget2.apply(this, arguments);\n      }\n      return _createDialTarget;\n    }()\n    /**\n     * Creates a PendingDial that wraps the underlying DialRequest\n     */\n  }, {\n    key: \"_createPendingDial\",\n    value: function _createPendingDial(dialTarget) {\n      var _this3 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      /**\n       * @param {Multiaddr} addr\n       * @param {{ signal: { aborted: any; }; }} options\n       */\n      var dialAction = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(addr) {\n          var _options$signal;\n          var options,\n            _args9 = arguments;\n          return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n            while (1) switch (_context9.prev = _context9.next) {\n              case 0:\n                options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n                if (!(((_options$signal = options.signal) === null || _options$signal === void 0 ? void 0 : _options$signal.aborted) === true)) {\n                  _context9.next = 3;\n                  break;\n                }\n                throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n              case 3:\n                _context9.next = 5;\n                return _this3.components.getTransportManager().dial(addr, options).catch(function (err) {\n                  log.error('dial to %s failed', addr, err);\n                  throw err;\n                });\n              case 5:\n                return _context9.abrupt(\"return\", _context9.sent);\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }, _callee9);\n        }));\n        return function dialAction(_x9) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      var dialRequest = new DialRequest({\n        addrs: dialTarget.addrs,\n        dialAction: dialAction,\n        dialer: this\n      });\n      // Combine the timeout signal and options.signal, if provided\n      var timeoutController = new TimeoutController(this.timeout);\n      var signals = [timeoutController.signal];\n      options.signal != null && signals.push(options.signal);\n      var signal = anySignal(signals);\n      // this signal will potentially be used while dialing lots of\n      // peers so prevent MaxListenersExceededWarning appearing in the console\n      try {\n        // fails on node < 15.4\n        setMaxListeners === null || setMaxListeners === void 0 ? void 0 : setMaxListeners(Infinity, signal);\n      } catch (_unused) {}\n      var pendingDial = {\n        dialRequest: dialRequest,\n        controller: timeoutController,\n        promise: dialRequest.run(_objectSpread(_objectSpread({}, options), {}, {\n          signal: signal\n        })),\n        destroy: function destroy() {\n          timeoutController.clear();\n          _this3.pendingDials.delete(dialTarget.id);\n        }\n      };\n      this.pendingDials.set(dialTarget.id, pendingDial);\n      return pendingDial;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function getTokens(num) {\n      var total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n      var tokens = this.tokens.splice(0, total);\n      log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n      return tokens;\n    }\n  }, {\n    key: \"releaseToken\",\n    value: function releaseToken(token) {\n      // Guard against duplicate releases\n      if (this.tokens.includes(token)) {\n        return;\n      }\n      log('token %d released', token);\n      this.tokens.push(token);\n    }\n    /**\n     * Resolve multiaddr recursively\n     */\n  }, {\n    key: \"_resolve\",\n    value: function () {\n      var _resolve3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(ma, options) {\n        var _this4 = this;\n        var resolvableProto, resolvedMultiaddrs, recursiveMultiaddrs, addrs;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n              // Now only supporting resolve for dnsaddr\n              resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n              if (resolvableProto) {\n                _context11.next = 3;\n                break;\n              }\n              return _context11.abrupt(\"return\", [ma]);\n            case 3:\n              _context11.next = 5;\n              return this._resolveRecord(ma, options);\n            case 5:\n              resolvedMultiaddrs = _context11.sent;\n              _context11.next = 8;\n              return Promise.all(resolvedMultiaddrs.map( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(nm) {\n                  return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n                    while (1) switch (_context10.prev = _context10.next) {\n                      case 0:\n                        _context10.next = 2;\n                        return _this4._resolve(nm, options);\n                      case 2:\n                        return _context10.abrupt(\"return\", _context10.sent);\n                      case 3:\n                      case \"end\":\n                        return _context10.stop();\n                    }\n                  }, _callee10);\n                }));\n                return function (_x12) {\n                  return _ref4.apply(this, arguments);\n                };\n              }()));\n            case 8:\n              recursiveMultiaddrs = _context11.sent;\n              addrs = recursiveMultiaddrs.flat();\n              return _context11.abrupt(\"return\", addrs.reduce(function (array, newM) {\n                if (array.find(function (m) {\n                  return m.equals(newM);\n                }) == null) {\n                  array.push(newM);\n                }\n                return array;\n              }, []));\n            case 11:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function _resolve(_x10, _x11) {\n        return _resolve3.apply(this, arguments);\n      }\n      return _resolve;\n    }()\n    /**\n     * Resolve a given multiaddr. If this fails, an empty array will be returned\n     */\n  }, {\n    key: \"_resolveRecord\",\n    value: function () {\n      var _resolveRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(ma, options) {\n        var multiaddrs;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.prev = 0;\n              ma = multiaddr(ma.toString()); // Use current multiaddr module\n              _context12.next = 4;\n              return ma.resolve(options);\n            case 4:\n              multiaddrs = _context12.sent;\n              return _context12.abrupt(\"return\", multiaddrs);\n            case 8:\n              _context12.prev = 8;\n              _context12.t0 = _context12[\"catch\"](0);\n              log.error(\"multiaddr \".concat(ma.toString(), \" could not be resolved\"), _context12.t0);\n              return _context12.abrupt(\"return\", []);\n            case 12:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, null, [[0, 8]]);\n      }));\n      function _resolveRecord(_x13, _x14) {\n        return _resolveRecord2.apply(this, arguments);\n      }\n      return _resolveRecord;\n    }()\n  }]);\n  return DefaultDialer;\n}();","map":{"version":3,"names":["logger","all","filter","pipe","errCode","multiaddr","resolvers","TimeoutController","AbortError","anySignal","setMaxListeners","DialRequest","publicAddressesFirst","trackedMap","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","getPeer","sort","map","log","METRICS_COMPONENT","METRICS_PENDING_DIALS","METRICS_PENDING_DIAL_TARGETS","DefaultDialer","components","_init$addressSorter","_init$maxAddrsToDial","_init$dialTimeout","_init$maxDialsPerPeer","_init$maxParallelDial","init","arguments","length","undefined","_classCallCheck","started","addressSorter","maxAddrsToDial","timeout","dialTimeout","maxDialsPerPeer","tokens","_toConsumableArray","Array","maxParallelDials","_","index","pendingDials","component","metric","metrics","pendingDialTargets","getMetrics","_i","_Object$entries","Object","entries","_init$resolvers","_Object$entries$_i","_slicedToArray","key","value","set","_createClass","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","stop","start","apply","_stop","_callee2","_iterator2","_step2","dial","_iterator3","_step3","pendingTarget","_callee2$","_context2","_createForOfIteratorHelper","values","s","n","done","controller","abort","err","error","e","f","clear","reject","_dial","_callee3","peer","_this$pendingDials$ge","options","_getPeer","id","multiaddrs","dialTarget","pendingDial","connection","_args3","_callee3$","_context3","getPeerId","equals","Error","ERR_DIALED_SELF","getPeerStore","addressBook","add","getConnectionGater","denyDialPeer","sent","ERR_PEER_DIAL_INTERCEPTED","_createCancellableDialTarget","addrs","ERR_NO_VALID_ADDRESSES","get","_createPendingDial","promise","abrupt","t0","signal","aborted","code","ERR_TIMEOUT","destroy","finish","_x2","_createCancellableDialTarget2","_callee4","_this","cancellablePromise","_callee4$","_context4","concat","parseInt","String","Math","random","toString","Date","now","Promise","resolve","race","_createDialTarget","delete","_x3","_x4","_createDialTarget2","_callee8","_this2","_resolve","_callee8$","_context8","bind","t1","t2","source","_ref","_callee5","address","_callee5$","_context5","denyDialMultiaddr","_x7","t3","t4","_resolve2","_wrapAsyncGenerator","_callee6","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","a","_callee6$","_context6","_asyncIterator","_awaitAsyncGenerator","_asyncGeneratorDelegate","delegateYield","t6","return","_x","t5","ma","Boolean","getTransportManager","transportForMultiaddr","encapsulate","t7","_ref2","_callee7","_callee7$","_context7","_x8","ERR_TOO_MANY_ADDRESSES","_x5","_x6","_this3","dialAction","_ref3","_callee9","addr","_options$signal","_args9","_callee9$","_context9","ERR_ALREADY_ABORTED","catch","_x9","dialRequest","dialer","timeoutController","signals","push","Infinity","_unused","run","_objectSpread","getTokens","num","total","min","splice","releaseToken","token","includes","_resolve3","_callee11","_this4","resolvableProto","resolvedMultiaddrs","recursiveMultiaddrs","_callee11$","_context11","protoNames","_resolveRecord","_ref4","_callee10","nm","_callee10$","_context10","_x12","flat","reduce","array","newM","find","m","_x10","_x11","_resolveRecord2","_callee12","_callee12$","_context12","_x13","_x14"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/connection-manager/dialer/index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport all from 'it-all'\nimport filter from 'it-filter'\nimport { pipe } from 'it-pipe'\nimport errCode from 'err-code'\nimport type { Multiaddr, Resolver } from '@multiformats/multiaddr'\nimport { multiaddr, resolvers } from '@multiformats/multiaddr'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { AbortError } from '@libp2p/interfaces/errors'\nimport { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'events'\nimport { DialAction, DialRequest } from './dial-request.js'\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort'\nimport { trackedMap } from '@libp2p/tracked-map'\nimport { codes } from '../../errors.js'\nimport {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} from '../../constants.js'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { getPeer } from '../../get-peer.js'\nimport sort from 'it-sort'\nimport type { Components } from '@libp2p/components'\nimport map from 'it-map'\nimport type { AddressSorter } from '@libp2p/interface-peer-store'\nimport type { ComponentMetricsTracker } from '@libp2p/interface-metrics'\nimport type { Dialer } from '@libp2p/interface-connection-manager'\n\nconst log = logger('libp2p:dialer')\n\nconst METRICS_COMPONENT = 'dialler'\nconst METRICS_PENDING_DIALS = 'pending-dials'\nconst METRICS_PENDING_DIAL_TARGETS = 'pending-dial-targets'\n\nexport interface DialTarget {\n  id: string\n  addrs: Multiaddr[]\n}\n\nexport interface PendingDial {\n  dialRequest: DialRequest\n  controller: TimeoutController\n  promise: Promise<Connection>\n  destroy: () => void\n}\n\nexport interface PendingDialTarget {\n  resolve: (value: any) => void\n  reject: (err: Error) => void\n}\n\nexport interface DialerInit {\n  /**\n   * Sort the known addresses of a peer before trying to dial\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * Number of max concurrent dials\n   */\n  maxParallelDials?: number\n\n  /**\n   * Number of max addresses to dial for a given peer\n   */\n  maxAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take\n   */\n  dialTimeout?: number\n\n  /**\n   * Number of max concurrent dials per peer\n   */\n  maxDialsPerPeer?: number\n\n  /**\n   * Multiaddr resolvers to use when dialing\n   */\n  resolvers?: Record<string, Resolver>\n  metrics?: ComponentMetricsTracker\n}\n\nexport class DefaultDialer implements Startable, Dialer {\n  private readonly components: Components\n  private readonly addressSorter: AddressSorter\n  private readonly maxAddrsToDial: number\n  private readonly timeout: number\n  private readonly maxDialsPerPeer: number\n  public tokens: number[]\n  public pendingDials: Map<string, PendingDial>\n  public pendingDialTargets: Map<string, PendingDialTarget>\n  private started: boolean\n\n  constructor (components: Components, init: DialerInit = {}) {\n    this.started = false\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst\n    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL\n    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT\n    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS\n    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index)\n    this.components = components\n    this.pendingDials = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIALS,\n      metrics: init.metrics\n    })\n    this.pendingDialTargets = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIAL_TARGETS,\n      metrics: components.getMetrics()\n    })\n\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value)\n    }\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    this.started = true\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  async stop () {\n    this.started = false\n\n    for (const dial of this.pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (err: any) {\n        log.error(err)\n      }\n    }\n    this.pendingDials.clear()\n\n    for (const pendingTarget of this.pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'))\n    }\n    this.pendingDialTargets.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   */\n  async dial (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<Connection> {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (this.components.getPeerId().equals(id)) {\n      throw errCode(new Error('Tried to dial self'), codes.ERR_DIALED_SELF)\n    }\n\n    log('check multiaddrs %p', id)\n\n    if (multiaddrs != null && multiaddrs.length > 0) {\n      log('storing multiaddrs %p', id, multiaddrs)\n      await this.components.getPeerStore().addressBook.add(id, multiaddrs)\n    }\n\n    if (await this.components.getConnectionGater().denyDialPeer(id)) {\n      throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED)\n    }\n\n    log('creating dial target for %p', id)\n\n    const dialTarget = await this._createCancellableDialTarget(id, options)\n\n    if (dialTarget.addrs.length === 0) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n\n    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (err: any) {\n      log('dial failed to %s', dialTarget.id, err)\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   */\n  async _createCancellableDialTarget (peer: PeerId, options: AbortOptions): Promise<DialTarget> {\n    // Make dial target promise cancellable\n    const id = `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n    const cancellablePromise = new Promise<DialTarget>((resolve, reject) => {\n      this.pendingDialTargets.set(id, { resolve, reject })\n    })\n\n    try {\n      const dialTarget = await Promise.race([\n        this._createDialTarget(peer, options),\n        cancellablePromise\n      ])\n\n      return dialTarget\n    } finally {\n      this.pendingDialTargets.delete(id)\n    }\n  }\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   */\n  async _createDialTarget (peer: PeerId, options: AbortOptions): Promise<DialTarget> {\n    const _resolve = this._resolve.bind(this)\n\n    const addrs = await pipe(\n      await this.components.getPeerStore().addressBook.get(peer),\n      (source) => filter(source, async (address) => {\n        return !(await this.components.getConnectionGater().denyDialMultiaddr(peer, address.multiaddr))\n      }),\n      // Sort addresses so, for example, we try certified public address first\n      (source) => sort(source, this.addressSorter),\n      async function * resolve (source) {\n        for await (const a of source) {\n          yield * await _resolve(a.multiaddr, options)\n        }\n      },\n      // Multiaddrs not supported by the available transports will be filtered out.\n      (source) => filter(source, (ma) => Boolean(this.components.getTransportManager().transportForMultiaddr(ma))),\n      (source) => map(source, (ma) => {\n        if (peer.toString() === ma.getPeerId()) {\n          return ma\n        }\n\n        return ma.encapsulate(`/p2p/${peer.toString()}`)\n      }),\n      async (source) => await all(source)\n    )\n\n    if (addrs.length > this.maxAddrsToDial) {\n      await this.components.getPeerStore().delete(peer)\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    return {\n      id: peer.toString(),\n      addrs\n    }\n  }\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   */\n  _createPendingDial (dialTarget: DialTarget, options: AbortOptions = {}): PendingDial {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction: DialAction = async (addr, options = {}) => {\n      if (options.signal?.aborted === true) {\n        throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      }\n\n      return await this.components.getTransportManager().dial(addr, options).catch(err => {\n        log.error('dial to %s failed', addr, err)\n        throw err\n      })\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n\n    const signals = [timeoutController.signal]\n    ;(options.signal != null) && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, signal)\n    } catch {}\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this.pendingDials.delete(dialTarget.id)\n      }\n    }\n    this.pendingDials.set(dialTarget.id, pendingDial)\n\n    return pendingDial\n  }\n\n  getTokens (num: number) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  releaseToken (token: number) {\n    // Guard against duplicate releases\n    if (this.tokens.includes(token)) {\n      return\n    }\n\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n\n  /**\n   * Resolve multiaddr recursively\n   */\n  async _resolve (ma: Multiaddr, options: AbortOptions): Promise<Multiaddr[]> {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma]\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma, options)\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {\n      return await this._resolve(nm, options)\n    }))\n\n    const addrs = recursiveMultiaddrs.flat()\n    return addrs.reduce<Multiaddr[]>((array, newM) => {\n      if (array.find(m => m.equals(newM)) == null) {\n        array.push(newM)\n      }\n      return array\n    }, ([]))\n  }\n\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   */\n  async _resolveRecord (ma: Multiaddr, options: AbortOptions): Promise<Multiaddr[]> {\n    try {\n      ma = multiaddr(ma.toString()) // Use current multiaddr module\n      const multiaddrs = await ma.resolve(options)\n      return multiaddrs\n    } catch (err) {\n      log.error(`multiaddr ${ma.toString()} could not be resolved`, err)\n      return []\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}