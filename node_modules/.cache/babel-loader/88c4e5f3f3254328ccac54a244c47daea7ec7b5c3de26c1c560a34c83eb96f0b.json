{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport Queue from 'p-queue';\nimport { xor } from 'uint8arrays/xor';\nimport { toString } from 'uint8arrays/to-string';\nimport defer from 'p-defer';\nimport errCode from 'err-code';\nimport { convertPeerId, convertBuffer } from '../utils.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nimport { queryErrorEvent } from './events.js';\nvar MAX_XOR = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before\n */\nexport function queryPath(_x) {\n  return _queryPath.apply(this, arguments);\n}\nfunction _queryPath() {\n  _queryPath = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {\n    var key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log, peersSeen, queue, kadId, queryPeer;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          queryPeer = function _queryPeer(peer, peerKadId) {\n            if (peer == null) {\n              return;\n            }\n            peersSeen.add(peer);\n            var peerXor = BigInt('0x' + toString(xor(peerKadId, kadId), 'base16'));\n            queue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var timeout, signals, compoundSignal, _timeout, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, event, _iterator2, _step2, closerPeer, closerPeerKadId, closerPeerXor, _timeout2;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    signals = [signal];\n                    if (queryFuncTimeout != null) {\n                      timeout = new TimeoutController(queryFuncTimeout);\n                      signals.push(timeout.signal);\n                    }\n                    compoundSignal = anySignal(signals);\n                    _context.prev = 3;\n                    _iteratorAbruptCompletion = false;\n                    _didIteratorError = false;\n                    _context.prev = 6;\n                    _iterator = _asyncIterator(query({\n                      key: key,\n                      peer: peer,\n                      signal: compoundSignal,\n                      pathIndex: pathIndex,\n                      numPaths: numPaths\n                    }));\n                  case 8:\n                    _context.next = 10;\n                    return _iterator.next();\n                  case 10:\n                    if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                      _context.next = 49;\n                      break;\n                    }\n                    event = _step.value;\n                    if (!compoundSignal.aborted) {\n                      _context.next = 14;\n                      break;\n                    }\n                    return _context.abrupt(\"return\");\n                  case 14:\n                    if (!(event.name === 'PEER_RESPONSE')) {\n                      _context.next = 45;\n                      break;\n                    }\n                    _iterator2 = _createForOfIteratorHelper(event.closer);\n                    _context.prev = 16;\n                    _iterator2.s();\n                  case 18:\n                    if ((_step2 = _iterator2.n()).done) {\n                      _context.next = 37;\n                      break;\n                    }\n                    closerPeer = _step2.value;\n                    if (!peersSeen.has(closerPeer.id)) {\n                      _context.next = 23;\n                      break;\n                    }\n                    // eslint-disable-line max-depth\n                    log('already seen %p in query', closerPeer.id);\n                    return _context.abrupt(\"continue\", 35);\n                  case 23:\n                    if (!ourPeerId.equals(closerPeer.id)) {\n                      _context.next = 26;\n                      break;\n                    }\n                    // eslint-disable-line max-depth\n                    log('not querying ourselves');\n                    return _context.abrupt(\"continue\", 35);\n                  case 26:\n                    _context.next = 28;\n                    return convertPeerId(closerPeer.id);\n                  case 28:\n                    closerPeerKadId = _context.sent;\n                    closerPeerXor = BigInt('0x' + toString(xor(closerPeerKadId, kadId), 'base16')); // only continue query if closer peer is actually closer\n                    if (!(closerPeerXor > peerXor)) {\n                      _context.next = 33;\n                      break;\n                    }\n                    // eslint-disable-line max-depth\n                    log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer);\n                    return _context.abrupt(\"continue\", 35);\n                  case 33:\n                    log('querying closer peer %p', closerPeer.id);\n                    queryPeer(closerPeer.id, closerPeerKadId);\n                  case 35:\n                    _context.next = 18;\n                    break;\n                  case 37:\n                    _context.next = 42;\n                    break;\n                  case 39:\n                    _context.prev = 39;\n                    _context.t0 = _context[\"catch\"](16);\n                    _iterator2.e(_context.t0);\n                  case 42:\n                    _context.prev = 42;\n                    _iterator2.f();\n                    return _context.finish(42);\n                  case 45:\n                    // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n                    queue.emit('completed', event);\n                  case 46:\n                    _iteratorAbruptCompletion = false;\n                    _context.next = 8;\n                    break;\n                  case 49:\n                    _context.next = 55;\n                    break;\n                  case 51:\n                    _context.prev = 51;\n                    _context.t1 = _context[\"catch\"](6);\n                    _didIteratorError = true;\n                    _iteratorError = _context.t1;\n                  case 55:\n                    _context.prev = 55;\n                    _context.prev = 56;\n                    if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                      _context.next = 60;\n                      break;\n                    }\n                    _context.next = 60;\n                    return _iterator.return();\n                  case 60:\n                    _context.prev = 60;\n                    if (!_didIteratorError) {\n                      _context.next = 63;\n                      break;\n                    }\n                    throw _iteratorError;\n                  case 63:\n                    return _context.finish(60);\n                  case 64:\n                    return _context.finish(55);\n                  case 65:\n                    (_timeout = timeout) === null || _timeout === void 0 ? void 0 : _timeout.clear();\n                    _context.next = 71;\n                    break;\n                  case 68:\n                    _context.prev = 68;\n                    _context.t2 = _context[\"catch\"](3);\n                    if (signal.aborted) {\n                      // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n                      queue.emit('error', _context.t2);\n                    } else {\n                      // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n                      queue.emit('completed', queryErrorEvent({\n                        from: peer,\n                        error: _context.t2\n                      }));\n                    }\n                  case 71:\n                    _context.prev = 71;\n                    (_timeout2 = timeout) === null || _timeout2 === void 0 ? void 0 : _timeout2.clear();\n                    return _context.finish(71);\n                  case 74:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, null, [[3, 68, 71, 74], [6, 51, 55, 65], [16, 39, 42, 45], [56,, 60, 64]]);\n            })), {\n              // use xor value as the queue priority - closer peers should execute first\n              // subtract it from MAX_XOR because higher priority values execute sooner\n              // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts\n              // as long as all priorities are BigInts since we won't mix BigInts and Number\n              // values in arithmetic operations\n              priority: MAX_XOR - peerXor\n            }).catch(function (err) {\n              log.error(err);\n            });\n          };\n          key = options.key, startingPeer = options.startingPeer, ourPeerId = options.ourPeerId, signal = options.signal, query = options.query, alpha = options.alpha, pathIndex = options.pathIndex, numPaths = options.numPaths, cleanUp = options.cleanUp, queryFuncTimeout = options.queryFuncTimeout, log = options.log, peersSeen = options.peersSeen; // Only ALPHA node/value lookups are allowed at any given time for each process\n          // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n          queue = new Queue({\n            concurrency: alpha\n          }); // perform lookups on kadId, not the actual value\n          _context2.next = 5;\n          return _awaitAsyncGenerator(convertBuffer(key));\n        case 5:\n          kadId = _context2.sent;\n          _context2.t0 = queryPeer;\n          _context2.t1 = startingPeer;\n          _context2.next = 10;\n          return _awaitAsyncGenerator(convertPeerId(startingPeer));\n        case 10:\n          _context2.t2 = _context2.sent;\n          (0, _context2.t0)(_context2.t1, _context2.t2);\n          return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(toGenerator(queue, signal, cleanUp, log)), _awaitAsyncGenerator), \"t3\", 13);\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _queryPath.apply(this, arguments);\n}\nfunction toGenerator(_x2, _x3, _x4, _x5) {\n  return _toGenerator.apply(this, arguments);\n}\nfunction _toGenerator() {\n  _toGenerator = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(queue, signal, cleanUp, log) {\n    var deferred, running, results, cleanup, result;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          deferred = defer();\n          running = true;\n          results = [];\n          cleanup = function cleanup() {\n            if (!running) {\n              return;\n            }\n            log('clean up queue, results %d, queue size %d, pending tasks %d', results.length, queue.size, queue.pending);\n            running = false;\n            queue.clear();\n            results.splice(0, results.length);\n          };\n          queue.on('completed', function (result) {\n            results.push(result);\n            deferred.resolve();\n          });\n          queue.on('error', function (err) {\n            log('queue error', err);\n            cleanup();\n            deferred.reject(err);\n          });\n          queue.on('idle', function () {\n            log('queue idle');\n            running = false;\n            deferred.resolve();\n          });\n          // clear the queue and throw if the query is aborted\n          signal.addEventListener('abort', function () {\n            log('abort queue');\n            var wasRunning = running;\n            cleanup();\n            if (wasRunning) {\n              deferred.reject(errCode(new Error('Query aborted'), 'ERR_QUERY_ABORTED'));\n            }\n          });\n          // the user broke out of the loop early, ensure we resolve the deferred result\n          // promise and clear the queue of any remaining jobs\n          cleanUp.addEventListener('cleanup', function () {\n            cleanup();\n            deferred.resolve();\n          });\n        case 9:\n          if (!running) {\n            _context3.next = 22;\n            break;\n          }\n          _context3.next = 12;\n          return _awaitAsyncGenerator(deferred.promise);\n        case 12:\n          deferred = defer();\n          // yield all available results\n        case 13:\n          if (!(results.length > 0)) {\n            _context3.next = 20;\n            break;\n          }\n          result = results.shift();\n          if (!(result != null)) {\n            _context3.next = 18;\n            break;\n          }\n          _context3.next = 18;\n          return result;\n        case 18:\n          _context3.next = 13;\n          break;\n        case 20:\n          _context3.next = 9;\n          break;\n        case 22:\n          return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(results), _awaitAsyncGenerator), \"t0\", 23);\n        case 23:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _toGenerator.apply(this, arguments);\n}","map":{"version":3,"names":["Queue","xor","toString","defer","errCode","convertPeerId","convertBuffer","TimeoutController","anySignal","queryErrorEvent","MAX_XOR","BigInt","queryPath","_x","_queryPath","apply","arguments","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee2","options","key","startingPeer","ourPeerId","signal","query","alpha","pathIndex","numPaths","cleanUp","queryFuncTimeout","log","peersSeen","queue","kadId","queryPeer","wrap","_callee2$","_context2","prev","next","_queryPeer","peer","peerKadId","add","peerXor","_asyncToGenerator","_callee","timeout","signals","compoundSignal","_timeout","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","event","_iterator2","_step2","closerPeer","closerPeerKadId","closerPeerXor","_timeout2","_callee$","_context","push","_asyncIterator","sent","done","value","aborted","abrupt","name","_createForOfIteratorHelper","closer","s","n","has","id","equals","t0","e","f","finish","emit","t1","return","clear","t2","from","error","stop","priority","catch","err","concurrency","_awaitAsyncGenerator","delegateYield","_asyncGeneratorDelegate","toGenerator","_x2","_x3","_x4","_x5","_toGenerator","_callee3","deferred","running","results","cleanup","result","_callee3$","_context3","length","size","pending","splice","on","resolve","reject","addEventListener","wasRunning","Error","promise","shift"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/kad-dht/src/query/query-path.ts"],"sourcesContent":["import Queue from 'p-queue'\nimport { xor } from 'uint8arrays/xor'\nimport { toString } from 'uint8arrays/to-string'\nimport defer from 'p-defer'\nimport errCode from 'err-code'\nimport { convertPeerId, convertBuffer } from '../utils.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\nimport { queryErrorEvent } from './events.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { EventEmitter } from '@libp2p/interfaces/events'\nimport type { CleanUpEvents } from './manager.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { QueryFunc } from '../query/types.js'\nimport type { QueryEvent } from '@libp2p/interface-dht'\nimport type { PeerSet } from '@libp2p/peer-collections'\n\nconst MAX_XOR = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')\n\nexport interface QueryPathOptions {\n  /**\n   * What are we trying to find\n   */\n  key: Uint8Array\n\n  /**\n   * Where we start our query\n   */\n  startingPeer: PeerId\n\n  /**\n   * Who we are\n   */\n  ourPeerId: PeerId\n\n  /**\n   * When to stop querying\n   */\n  signal: AbortSignal\n\n  /**\n   * The query function to run with each peer\n   */\n  query: QueryFunc\n\n  /**\n   * How many concurrent node/value lookups to run\n   */\n  alpha: number\n\n  /**\n   * How many concurrent node/value lookups to run\n   */\n  pathIndex: number\n\n  /**\n   * How many concurrent node/value lookups to run\n   */\n  numPaths: number\n\n  /**\n   * will emit a 'cleanup' event if the caller exits the for..await of early\n   */\n  cleanUp: EventEmitter<CleanUpEvents>\n\n  /**\n   * A timeout for queryFunc in ms\n   */\n  queryFuncTimeout?: number\n\n  /**\n   * Query log\n   */\n  log: Logger\n\n  /**\n   * Set of peers seen by this and other paths\n   */\n  peersSeen: PeerSet\n}\n\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before\n */\nexport async function * queryPath (options: QueryPathOptions) {\n  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log, peersSeen } = options\n  // Only ALPHA node/value lookups are allowed at any given time for each process\n  // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n  const queue = new Queue({\n    concurrency: alpha\n  })\n\n  // perform lookups on kadId, not the actual value\n  const kadId = await convertBuffer(key)\n\n  /**\n   * Adds the passed peer to the query queue if it's not us and no\n   * other path has passed through this peer\n   */\n  function queryPeer (peer: PeerId, peerKadId: Uint8Array) {\n    if (peer == null) {\n      return\n    }\n\n    peersSeen.add(peer)\n\n    const peerXor = BigInt('0x' + toString(xor(peerKadId, kadId), 'base16'))\n\n    queue.add(async () => {\n      let timeout\n      const signals = [signal]\n\n      if (queryFuncTimeout != null) {\n        timeout = new TimeoutController(queryFuncTimeout)\n        signals.push(timeout.signal)\n      }\n\n      const compoundSignal = anySignal(signals)\n\n      try {\n        for await (const event of query({\n          key,\n          peer,\n          signal: compoundSignal,\n          pathIndex,\n          numPaths\n        })) {\n          if (compoundSignal.aborted) {\n            return\n          }\n\n          // if there are closer peers and the query has not completed, continue the query\n          if (event.name === 'PEER_RESPONSE') {\n            for (const closerPeer of event.closer) {\n              if (peersSeen.has(closerPeer.id)) { // eslint-disable-line max-depth\n                log('already seen %p in query', closerPeer.id)\n                continue\n              }\n\n              if (ourPeerId.equals(closerPeer.id)) { // eslint-disable-line max-depth\n                log('not querying ourselves')\n                continue\n              }\n\n              const closerPeerKadId = await convertPeerId(closerPeer.id)\n              const closerPeerXor = BigInt('0x' + toString(xor(closerPeerKadId, kadId), 'base16'))\n\n              // only continue query if closer peer is actually closer\n              if (closerPeerXor > peerXor) { // eslint-disable-line max-depth\n                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer)\n                continue\n              }\n\n              log('querying closer peer %p', closerPeer.id)\n              queryPeer(closerPeer.id, closerPeerKadId)\n            }\n          }\n\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('completed', event)\n        }\n\n        timeout?.clear()\n      } catch (err: any) {\n        if (signal.aborted) {\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('error', err)\n        } else {\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('completed', queryErrorEvent({\n            from: peer,\n            error: err\n          }))\n        }\n      } finally {\n        timeout?.clear()\n      }\n    }, {\n      // use xor value as the queue priority - closer peers should execute first\n      // subtract it from MAX_XOR because higher priority values execute sooner\n\n      // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts\n      // as long as all priorities are BigInts since we won't mix BigInts and Number\n      // values in arithmetic operations\n      priority: MAX_XOR - peerXor\n    }).catch(err => {\n      log.error(err)\n    })\n  }\n\n  // begin the query with the starting peer\n  queryPeer(startingPeer, await convertPeerId(startingPeer))\n\n  // yield results as they come in\n  yield * toGenerator(queue, signal, cleanUp, log)\n}\n\nasync function * toGenerator (queue: Queue, signal: AbortSignal, cleanUp: EventEmitter<CleanUpEvents>, log: Logger) {\n  let deferred = defer()\n  let running = true\n  const results: QueryEvent[] = []\n\n  const cleanup = () => {\n    if (!running) {\n      return\n    }\n\n    log('clean up queue, results %d, queue size %d, pending tasks %d', results.length, queue.size, queue.pending)\n\n    running = false\n    queue.clear()\n    results.splice(0, results.length)\n  }\n\n  queue.on('completed', result => {\n    results.push(result)\n    deferred.resolve()\n  })\n  queue.on('error', err => {\n    log('queue error', err)\n    cleanup()\n    deferred.reject(err)\n  })\n  queue.on('idle', () => {\n    log('queue idle')\n    running = false\n    deferred.resolve()\n  })\n\n  // clear the queue and throw if the query is aborted\n  signal.addEventListener('abort', () => {\n    log('abort queue')\n    const wasRunning = running\n    cleanup()\n\n    if (wasRunning) {\n      deferred.reject(errCode(new Error('Query aborted'), 'ERR_QUERY_ABORTED'))\n    }\n  })\n\n  // the user broke out of the loop early, ensure we resolve the deferred result\n  // promise and clear the queue of any remaining jobs\n  cleanUp.addEventListener('cleanup', () => {\n    cleanup()\n    deferred.resolve()\n  })\n\n  while (running) { // eslint-disable-line no-unmodified-loop-condition\n    await deferred.promise\n    deferred = defer()\n\n    // yield all available results\n    while (results.length > 0) {\n      const result = results.shift()\n\n      if (result != null) {\n        yield result\n      }\n    }\n  }\n\n  // yield any remaining results\n  yield * results\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}