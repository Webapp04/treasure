{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as keysPBM from './keys.js';\nimport 'node-forge/lib/asn1.js';\nimport 'node-forge/lib/pbe.js';\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { keyStretcher } from './key-stretcher.js';\nimport generateEphemeralKeyPair from './ephemeral-keys.js';\nimport { importer } from './importer.js';\nimport * as RSA from './rsa-class.js';\nimport * as Ed25519 from './ed25519-class.js';\nimport * as Secp256k1 from './secp256k1-class.js';\nexport { keyStretcher };\nexport { generateEphemeralKeyPair };\nexport { keysPBM };\nexport var supportedKeys = {\n  rsa: RSA,\n  ed25519: Ed25519,\n  secp256k1: Secp256k1\n};\nfunction unsupportedKey(type) {\n  var supported = Object.keys(supportedKeys).join(' / ');\n  return new CodeError(\"invalid or unsupported key type \".concat(type, \". Must be \").concat(supported), 'ERR_UNSUPPORTED_KEY_TYPE');\n}\nfunction typeToKey(type) {\n  type = type.toLowerCase();\n  if (type === 'rsa' || type === 'ed25519' || type === 'secp256k1') {\n    return supportedKeys[type];\n  }\n  throw unsupportedKey(type);\n}\n// Generates a keypair of the given type and bitsize\nexport function generateKeyPair(_x, _x2) {\n  return _generateKeyPair.apply(this, arguments);\n}\n// Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\nfunction _generateKeyPair() {\n  _generateKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(type, bits) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return typeToKey(type).generateKeyPair(bits !== null && bits !== void 0 ? bits : 2048);\n        case 2:\n          return _context.abrupt(\"return\", _context.sent);\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _generateKeyPair.apply(this, arguments);\n}\nexport function generateKeyPairFromSeed(_x3, _x4, _x5) {\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\n// Converts a protobuf serialized public key into its\n// representative object\nfunction _generateKeyPairFromSeed() {\n  _generateKeyPairFromSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(type, seed, bits) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(type.toLowerCase() !== 'ed25519')) {\n            _context2.next = 2;\n            break;\n          }\n          throw new CodeError('Seed key derivation is unimplemented for RSA or secp256k1', 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n        case 2:\n          _context2.next = 4;\n          return Ed25519.generateKeyPairFromSeed(seed);\n        case 4:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\nexport function unmarshalPublicKey(buf) {\n  var _decoded$Data, _decoded$Type;\n  var decoded = keysPBM.PublicKey.decode(buf);\n  var data = (_decoded$Data = decoded.Data) !== null && _decoded$Data !== void 0 ? _decoded$Data : new Uint8Array();\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n    default:\n      throw unsupportedKey((_decoded$Type = decoded.Type) !== null && _decoded$Type !== void 0 ? _decoded$Type : 'RSA');\n  }\n}\n// Converts a public key object into a protobuf serialized public key\nexport function marshalPublicKey(key, type) {\n  var _type;\n  type = ((_type = type) !== null && _type !== void 0 ? _type : 'rsa').toLowerCase();\n  typeToKey(type); // check type\n  return key.bytes;\n}\n// Converts a protobuf serialized private key into its\n// representative object\nexport function unmarshalPrivateKey(_x6) {\n  return _unmarshalPrivateKey.apply(this, arguments);\n}\n// Converts a private key object into a protobuf serialized private key\nfunction _unmarshalPrivateKey() {\n  _unmarshalPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(buf) {\n    var _decoded$Data2, _decoded$Type2;\n    var decoded, data;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          decoded = keysPBM.PrivateKey.decode(buf);\n          data = (_decoded$Data2 = decoded.Data) !== null && _decoded$Data2 !== void 0 ? _decoded$Data2 : new Uint8Array();\n          _context3.t0 = decoded.Type;\n          _context3.next = _context3.t0 === keysPBM.KeyType.RSA ? 5 : _context3.t0 === keysPBM.KeyType.Ed25519 ? 8 : _context3.t0 === keysPBM.KeyType.Secp256k1 ? 9 : 10;\n          break;\n        case 5:\n          _context3.next = 7;\n          return supportedKeys.rsa.unmarshalRsaPrivateKey(data);\n        case 7:\n          return _context3.abrupt(\"return\", _context3.sent);\n        case 8:\n          return _context3.abrupt(\"return\", supportedKeys.ed25519.unmarshalEd25519PrivateKey(data));\n        case 9:\n          return _context3.abrupt(\"return\", supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data));\n        case 10:\n          throw unsupportedKey((_decoded$Type2 = decoded.Type) !== null && _decoded$Type2 !== void 0 ? _decoded$Type2 : 'RSA');\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _unmarshalPrivateKey.apply(this, arguments);\n}\nexport function marshalPrivateKey(key, type) {\n  var _type2;\n  type = ((_type2 = type) !== null && _type2 !== void 0 ? _type2 : 'rsa').toLowerCase();\n  typeToKey(type); // check type\n  return key.bytes;\n}\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\nexport function importKey(_x7, _x8) {\n  return _importKey.apply(this, arguments);\n}\nfunction _importKey() {\n  _importKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(encryptedKey, password) {\n    var _key, key, der;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.prev = 0;\n          _context4.next = 3;\n          return importer(encryptedKey, password);\n        case 3:\n          _key = _context4.sent;\n          _context4.next = 6;\n          return unmarshalPrivateKey(_key);\n        case 6:\n          return _context4.abrupt(\"return\", _context4.sent);\n        case 9:\n          _context4.prev = 9;\n          _context4.t0 = _context4[\"catch\"](0);\n        case 11:\n          // Only rsa supports pem right now\n          key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);\n          if (!(key === null)) {\n            _context4.next = 14;\n            break;\n          }\n          throw new CodeError('Cannot read the key, most likely the password is wrong or not a RSA key', 'ERR_CANNOT_DECRYPT_PEM');\n        case 14:\n          der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n          der = uint8ArrayFromString(der.getBytes(), 'ascii');\n          _context4.next = 18;\n          return supportedKeys.rsa.unmarshalRsaPrivateKey(der);\n        case 18:\n          return _context4.abrupt(\"return\", _context4.sent);\n        case 19:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[0, 9]]);\n  }));\n  return _importKey.apply(this, arguments);\n}","map":{"version":3,"names":["keysPBM","forge","CodeError","fromString","uint8ArrayFromString","keyStretcher","generateEphemeralKeyPair","importer","RSA","Ed25519","Secp256k1","supportedKeys","rsa","ed25519","secp256k1","unsupportedKey","type","supported","Object","keys","join","concat","typeToKey","toLowerCase","generateKeyPair","_x","_x2","_generateKeyPair","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","bits","wrap","_callee$","_context","prev","next","abrupt","sent","stop","generateKeyPairFromSeed","_x3","_x4","_x5","_generateKeyPairFromSeed","_callee2","seed","_callee2$","_context2","unmarshalPublicKey","buf","_decoded$Data","_decoded$Type","decoded","PublicKey","decode","data","Data","Uint8Array","Type","KeyType","unmarshalRsaPublicKey","unmarshalEd25519PublicKey","unmarshalSecp256k1PublicKey","marshalPublicKey","key","_type","bytes","unmarshalPrivateKey","_x6","_unmarshalPrivateKey","_callee3","_decoded$Data2","_decoded$Type2","_callee3$","_context3","PrivateKey","t0","unmarshalRsaPrivateKey","unmarshalEd25519PrivateKey","unmarshalSecp256k1PrivateKey","marshalPrivateKey","_type2","importKey","_x7","_x8","_importKey","_callee4","encryptedKey","password","_key","der","_callee4$","_context4","pki","decryptRsaPrivateKey","asn1","toDer","privateKeyToAsn1","getBytes"],"sources":["/Users/apple/Documents/treasure/node_modules/@libp2p/crypto/src/keys/index.ts"],"sourcesContent":["import * as keysPBM from './keys.js'\nimport 'node-forge/lib/asn1.js'\nimport 'node-forge/lib/pbe.js'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { keyStretcher } from './key-stretcher.js'\nimport generateEphemeralKeyPair from './ephemeral-keys.js'\nimport { importer } from './importer.js'\nimport * as RSA from './rsa-class.js'\nimport * as Ed25519 from './ed25519-class.js'\nimport * as Secp256k1 from './secp256k1-class.js'\nimport type { PrivateKey, PublicKey } from '@libp2p/interface-keys'\n\nexport { keyStretcher }\nexport { generateEphemeralKeyPair }\nexport { keysPBM }\n\nexport type KeyTypes = 'RSA' | 'Ed25519' | 'secp256k1'\n\nexport const supportedKeys = {\n  rsa: RSA,\n  ed25519: Ed25519,\n  secp256k1: Secp256k1\n}\n\nfunction unsupportedKey (type: string) {\n  const supported = Object.keys(supportedKeys).join(' / ')\n  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, 'ERR_UNSUPPORTED_KEY_TYPE')\n}\n\nfunction typeToKey (type: string) {\n  type = type.toLowerCase()\n\n  if (type === 'rsa' || type === 'ed25519' || type === 'secp256k1') {\n    return supportedKeys[type]\n  }\n\n  throw unsupportedKey(type)\n}\n\n// Generates a keypair of the given type and bitsize\nexport async function generateKeyPair (type: KeyTypes, bits?: number): Promise<PrivateKey> { // eslint-disable-line require-await\n  return await typeToKey(type).generateKeyPair(bits ?? 2048)\n}\n\n// Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\nexport async function generateKeyPairFromSeed (type: KeyTypes, seed: Uint8Array, bits?: number): Promise<PrivateKey> { // eslint-disable-line require-await\n  if (type.toLowerCase() !== 'ed25519') {\n    throw new CodeError('Seed key derivation is unimplemented for RSA or secp256k1', 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE')\n  }\n\n  return await Ed25519.generateKeyPairFromSeed(seed)\n}\n\n// Converts a protobuf serialized public key into its\n// representative object\nexport function unmarshalPublicKey (buf: Uint8Array): PublicKey {\n  const decoded = keysPBM.PublicKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)\n    default:\n      throw unsupportedKey(decoded.Type ?? 'RSA')\n  }\n}\n\n// Converts a public key object into a protobuf serialized public key\nexport function marshalPublicKey (key: { bytes: Uint8Array }, type?: string): Uint8Array {\n  type = (type ?? 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n// Converts a protobuf serialized private key into its\n// representative object\nexport async function unmarshalPrivateKey (buf: Uint8Array): Promise<PrivateKey> { // eslint-disable-line require-await\n  const decoded = keysPBM.PrivateKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return await supportedKeys.rsa.unmarshalRsaPrivateKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data)\n    default:\n      throw unsupportedKey(decoded.Type ?? 'RSA')\n  }\n}\n\n// Converts a private key object into a protobuf serialized private key\nexport function marshalPrivateKey (key: { bytes: Uint8Array }, type?: string): Uint8Array {\n  type = (type ?? 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\nexport async function importKey (encryptedKey: string, password: string): Promise<PrivateKey> { // eslint-disable-line require-await\n  try {\n    const key = await importer(encryptedKey, password)\n    return await unmarshalPrivateKey(key)\n  } catch (_) {\n    // Ignore and try the old pem decrypt\n  }\n\n  // Only rsa supports pem right now\n  const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password)\n  if (key === null) {\n    throw new CodeError('Cannot read the key, most likely the password is wrong or not a RSA key', 'ERR_CANNOT_DECRYPT_PEM')\n  }\n  let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))\n  der = uint8ArrayFromString(der.getBytes(), 'ascii')\n  return await supportedKeys.rsa.unmarshalRsaPrivateKey(der)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}