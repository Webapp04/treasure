{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createLibp2pNode } from './libp2p.js';\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n */\nexport function createLibp2p(_x) {\n  return _createLibp2p.apply(this, arguments);\n}\nfunction _createLibp2p() {\n  _createLibp2p = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return createLibp2pNode(options);\n        case 2:\n          return _context.abrupt(\"return\", _context.sent);\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _createLibp2p.apply(this, arguments);\n}","map":{"version":3,"names":["createLibp2pNode","createLibp2p","_x","_createLibp2p","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","wrap","_callee$","_context","prev","next","abrupt","sent","stop"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/index.ts"],"sourcesContent":["import { createLibp2pNode } from './libp2p.js'\nimport type { AbortOptions, RecursivePartial } from '@libp2p/interfaces'\nimport type { EventEmitter } from '@libp2p/interfaces/events'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { FaultTolerance } from './transport-manager.js'\nimport type { IdentifyServiceInit } from './identify/index.js'\nimport type { DualDHT } from '@libp2p/interface-dht'\nimport type { Datastore } from 'interface-datastore'\nimport type { PeerStore, PeerStoreInit } from '@libp2p/interface-peer-store'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { AutoRelayConfig, RelayAdvertiseConfig } from './circuit/index.js'\nimport type { PeerDiscovery } from '@libp2p/interface-peer-discovery'\nimport type { Connection, ConnectionGater, ConnectionProtector, Stream } from '@libp2p/interface-connection'\nimport type { Transport } from '@libp2p/interface-transport'\nimport type { StreamMuxerFactory } from '@libp2p/interface-stream-muxer'\nimport type { ConnectionEncrypter } from '@libp2p/interface-connection-encrypter'\nimport type { PeerRouting } from '@libp2p/interface-peer-routing'\nimport type { ContentRouting } from '@libp2p/interface-content-routing'\nimport type { PubSub } from '@libp2p/interface-pubsub'\nimport type { Registrar, StreamHandler, StreamHandlerOptions } from '@libp2p/interface-registrar'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { Metrics, MetricsInit } from '@libp2p/interface-metrics'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { KeyChain } from './keychain/index.js'\nimport type { ConnectionManagerInit } from './connection-manager/index.js'\nimport type { PingServiceInit } from './ping/index.js'\nimport type { FetchServiceInit } from './fetch/index.js'\n\nexport interface PersistentPeerStoreOptions {\n  threshold?: number\n}\n\nexport interface DEKConfig {\n  keyLength: number\n  iterationCount: number\n  salt: string\n  hash: string\n}\n\nexport interface KeychainConfig {\n  pass?: string\n  dek?: DEKConfig\n}\n\nexport interface MetricsConfig {\n  enabled?: boolean\n}\n\nexport interface HopConfig {\n  enabled?: boolean\n  active?: boolean\n  timeout: number\n}\n\nexport interface RelayConfig {\n  enabled: boolean\n  advertise: RelayAdvertiseConfig\n  hop: HopConfig\n  autoRelay: AutoRelayConfig\n}\n\nexport interface NatManagerConfig {\n  enabled: boolean\n  externalAddress?: string\n  localAddress?: string\n  description?: string\n  ttl?: number\n  keepAlive: boolean\n  gateway?: string\n}\n\nexport interface AddressesConfig {\n  listen: string[]\n  announce: string[]\n  noAnnounce: string[]\n  announceFilter: (multiaddrs: Multiaddr[]) => Multiaddr[]\n}\n\nexport interface TransportManagerConfig {\n  faultTolerance?: FaultTolerance\n}\n\nexport interface PeerStoreConfig {\n  persistence?: boolean\n  threshold?: number\n}\n\nexport interface PeerRoutingConfig {\n  refreshManager: RefreshManagerConfig\n}\n\nexport interface RefreshManagerConfig {\n  enabled?: boolean\n  interval: number\n  bootDelay: number\n}\n\nexport interface Libp2pInit {\n  peerId: PeerId\n  addresses: AddressesConfig\n  connectionManager: ConnectionManagerInit\n  connectionGater: Partial<ConnectionGater>\n  transportManager: TransportManagerConfig\n  datastore: Datastore\n  metrics: MetricsInit\n  peerStore: PeerStoreInit\n  peerRouting: PeerRoutingConfig\n  keychain: KeychainConfig\n  nat: NatManagerConfig\n  relay: RelayConfig\n  identify: IdentifyServiceInit\n  ping: PingServiceInit\n  fetch: FetchServiceInit\n\n  transports: Transport[]\n  streamMuxers?: StreamMuxerFactory[]\n  connectionEncryption?: ConnectionEncrypter[]\n  peerDiscovery?: PeerDiscovery[]\n  peerRouters?: PeerRouting[]\n  contentRouters?: ContentRouting[]\n  dht?: DualDHT\n  pubsub?: PubSub\n  connectionProtector?: ConnectionProtector\n}\n\nexport interface Libp2pEvents {\n  'peer:discovery': CustomEvent<PeerInfo>\n}\n\nexport interface Libp2p extends Startable, EventEmitter<Libp2pEvents> {\n  peerId: PeerId\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  contentRouting: ContentRouting\n  keychain: KeyChain\n  connectionManager: ConnectionManager\n  registrar: Registrar\n  metrics?: Metrics\n  pubsub: PubSub\n  dht: DualDHT\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   */\n  getMultiaddrs: () => Multiaddr[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   */\n  getConnections: (peerId?: PeerId) => Connection[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers: () => PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   */\n  dial: (peer: PeerId | Multiaddr, options?: AbortOptions) => Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   */\n  dialProtocol: (peer: PeerId | Multiaddr, protocols: string | string[], options?: AbortOptions) => Promise<Stream>\n\n  /**\n   * Disconnects all connections to the given `peer`\n   */\n  hangUp: (peer: PeerId | Multiaddr | string) => Promise<void>\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  handle: (protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions) => Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  unhandle: (protocols: string[] | string) => Promise<void>\n\n  /**\n   * Pings the given peer in order to obtain the operation latency\n   */\n  ping: (peer: Multiaddr | PeerId, options?: AbortOptions) => Promise<number>\n\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer.\n   */\n  fetch: (peer: PeerId | Multiaddr | string, key: string, options?: AbortOptions) => Promise<Uint8Array | null>\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA' type\n   * this may mean searching the DHT if the key is not present in the KeyStore.\n   */\n  getPublicKey: (peer: PeerId, options?: AbortOptions) => Promise<Uint8Array>\n}\n\nexport type Libp2pOptions = RecursivePartial<Libp2pInit>\n\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n */\nexport async function createLibp2p (options: Libp2pOptions): Promise<Libp2p> {\n  return await createLibp2pNode(options)\n}\n"],"mappings":";;AAAA,SAASA,gBAAgB,QAAQ,aAAa;AAmN9C;;;;AAIA,gBAAsBC,YAAYA,CAAAC,EAAA;EAAA,OAAAC,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAEjC,SAAAF,cAAA;EAAAA,aAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAFM,SAAAC,QAA6BC,OAAsB;IAAA,OAAAH,mBAAA,GAAAI,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OAC3Cf,gBAAgB,CAACU,OAAO,CAAC;QAAA;UAAA,OAAAG,QAAA,CAAAG,MAAA,WAAAH,QAAA,CAAAI,IAAA;QAAA;QAAA;UAAA,OAAAJ,QAAA,CAAAK,IAAA;MAAA;IAAA,GAAAT,OAAA;EAAA,CACvC;EAAA,OAAAN,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}