{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { logger } from '@libp2p/logger';\nimport { protocols } from '@multiformats/multiaddr';\nvar log = logger('libp2p:peer-record-updater');\nexport var PeerRecordUpdater = /*#__PURE__*/function () {\n  function PeerRecordUpdater(components) {\n    _classCallCheck(this, PeerRecordUpdater);\n    this.components = components;\n    this.started = false;\n    this.update = this.update.bind(this);\n  }\n  _createClass(PeerRecordUpdater, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.started = true;\n              this.components.getTransportManager().addEventListener('listener:listening', this.update);\n              this.components.getTransportManager().addEventListener('listener:close', this.update);\n              this.components.getAddressManager().addEventListener('change:addresses', this.update);\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.started = false;\n              this.components.getTransportManager().removeEventListener('listener:listening', this.update);\n              this.components.getTransportManager().removeEventListener('listener:close', this.update);\n              this.components.getAddressManager().removeEventListener('change:addresses', this.update);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n    /**\n     * Create (or update if existing) self peer record and store it in the AddressBook.\n     */\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this = this;\n      Promise.resolve().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var peerRecord, envelope;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              peerRecord = new PeerRecord({\n                peerId: _this.components.getPeerId(),\n                multiaddrs: _this.components.getAddressManager().getAddresses().map(function (ma) {\n                  return ma.decapsulateCode(protocols('p2p').code);\n                })\n              });\n              _context3.next = 3;\n              return RecordEnvelope.seal(peerRecord, _this.components.getPeerId());\n            case 3:\n              envelope = _context3.sent;\n              _context3.next = 6;\n              return _this.components.getPeerStore().addressBook.consumePeerRecord(envelope);\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }))).catch(function (err) {\n        log.error('Could not update self peer record: %o', err);\n      });\n    }\n  }]);\n  return PeerRecordUpdater;\n}();","map":{"version":3,"names":["RecordEnvelope","PeerRecord","logger","protocols","log","PeerRecordUpdater","components","_classCallCheck","started","update","bind","_createClass","key","value","isStarted","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","getTransportManager","addEventListener","getAddressManager","stop","start","apply","arguments","_stop","_callee2","_callee2$","_context2","removeEventListener","_this","Promise","resolve","then","_callee3","peerRecord","envelope","_callee3$","_context3","peerId","getPeerId","multiaddrs","getAddresses","map","ma","decapsulateCode","code","seal","sent","getPeerStore","addressBook","consumePeerRecord","catch","err","error"],"sources":["/Users/apple/Documents/treasure/node_modules/libp2p/src/peer-record-updater.ts"],"sourcesContent":["import { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport type { Components } from '@libp2p/components'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { logger } from '@libp2p/logger'\nimport { protocols } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:peer-record-updater')\n\nexport class PeerRecordUpdater implements Startable {\n  private readonly components: Components\n  private started: boolean\n\n  constructor (components: Components) {\n    this.components = components\n    this.started = false\n    this.update = this.update.bind(this)\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    this.started = true\n    this.components.getTransportManager().addEventListener('listener:listening', this.update)\n    this.components.getTransportManager().addEventListener('listener:close', this.update)\n    this.components.getAddressManager().addEventListener('change:addresses', this.update)\n  }\n\n  async stop () {\n    this.started = false\n    this.components.getTransportManager().removeEventListener('listener:listening', this.update)\n    this.components.getTransportManager().removeEventListener('listener:close', this.update)\n    this.components.getAddressManager().removeEventListener('change:addresses', this.update)\n  }\n\n  /**\n   * Create (or update if existing) self peer record and store it in the AddressBook.\n   */\n  update () {\n    Promise.resolve()\n      .then(async () => {\n        const peerRecord = new PeerRecord({\n          peerId: this.components.getPeerId(),\n          multiaddrs: this.components.getAddressManager().getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.components.getPeerId())\n        await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)\n      })\n      .catch(err => {\n        log.error('Could not update self peer record: %o', err)\n      })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}