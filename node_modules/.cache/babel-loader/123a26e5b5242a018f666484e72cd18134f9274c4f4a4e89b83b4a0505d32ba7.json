{"ast":null,"code":"import _slicedToArray from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { RejectReason } from './types.js';\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\nexport var IWantTracer = /*#__PURE__*/function () {\n  function IWantTracer(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {\n    _classCallCheck(this, IWantTracer);\n    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;\n    this.msgIdToStrFn = msgIdToStrFn;\n    this.metrics = metrics;\n    /**\n     * Promises to deliver a message\n     * Map per message id, per peer, promise expiration time\n     */\n    this.promises = new Map();\n    /**\n     * First request time by msgId. Used for metrics to track expire times.\n     * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n     */\n    this.requestMsByMsg = new Map();\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;\n  }\n  _createClass(IWantTracer, [{\n    key: \"size\",\n    get: function get() {\n      return this.promises.size;\n    }\n  }, {\n    key: \"requestMsByMsgSize\",\n    get: function get() {\n      return this.requestMsByMsg.size;\n    }\n    /**\n     * Track a promise to deliver a message from a list of msgIds we are requesting\n     */\n  }, {\n    key: \"addPromise\",\n    value: function addPromise(from, msgIds) {\n      // pick msgId randomly from the list\n      var ix = Math.floor(Math.random() * msgIds.length);\n      var msgId = msgIds[ix];\n      var msgIdStr = this.msgIdToStrFn(msgId);\n      var expireByPeer = this.promises.get(msgIdStr);\n      if (!expireByPeer) {\n        expireByPeer = new Map();\n        this.promises.set(msgIdStr, expireByPeer);\n      }\n      var now = Date.now();\n      // If a promise for this message id and peer already exists we don't update the expiry\n      if (!expireByPeer.has(from)) {\n        expireByPeer.set(from, now + this.gossipsubIWantFollowupMs);\n        if (this.metrics) {\n          this.metrics.iwantPromiseStarted.inc(1);\n          if (!this.requestMsByMsg.has(msgIdStr)) {\n            this.requestMsByMsg.set(msgIdStr, now);\n          }\n        }\n      }\n    }\n    /**\n     * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n     *\n     * This should be called not too often relative to the expire times, since it iterates over the whole data.\n     */\n  }, {\n    key: \"getBrokenPromises\",\n    value: function getBrokenPromises() {\n      var _this = this,\n        _this$metrics;\n      var now = Date.now();\n      var result = new Map();\n      var brokenPromises = 0;\n      this.promises.forEach(function (expireByPeer, msgId) {\n        expireByPeer.forEach(function (expire, p) {\n          // the promise has been broken\n          if (expire < now) {\n            var _result$get;\n            // add 1 to result\n            result.set(p, ((_result$get = result.get(p)) !== null && _result$get !== void 0 ? _result$get : 0) + 1);\n            // delete from tracked promises\n            expireByPeer.delete(p);\n            // for metrics\n            brokenPromises++;\n          }\n        });\n        // clean up empty promises for a msgId\n        if (!expireByPeer.size) {\n          _this.promises.delete(msgId);\n        }\n      });\n      (_this$metrics = this.metrics) === null || _this$metrics === void 0 ? void 0 : _this$metrics.iwantPromiseBroken.inc(brokenPromises);\n      return result;\n    }\n    /**\n     * Someone delivered a message, stop tracking promises for it\n     */\n  }, {\n    key: \"deliverMessage\",\n    value: function deliverMessage(msgIdStr) {\n      this.trackMessage(msgIdStr);\n      var expireByPeer = this.promises.get(msgIdStr);\n      // Expired promise, check requestMsByMsg\n      if (expireByPeer) {\n        this.promises.delete(msgIdStr);\n        if (this.metrics) {\n          this.metrics.iwantPromiseResolved.inc(1);\n          this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);\n        }\n      }\n    }\n    /**\n     * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n     * unless its an obviously invalid message.\n     */\n  }, {\n    key: \"rejectMessage\",\n    value: function rejectMessage(msgIdStr, reason) {\n      this.trackMessage(msgIdStr);\n      // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n      // With the expection of obvious invalid messages\n      switch (reason) {\n        case RejectReason.Error:\n          return;\n      }\n      this.promises.delete(msgIdStr);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.promises.clear();\n    }\n  }, {\n    key: \"prune\",\n    value: function prune() {\n      var maxMs = Date.now() - this.requestMsByMsgExpire;\n      var _iterator = _createForOfIteratorHelper(this.requestMsByMsg.entries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            k = _step$value[0],\n            v = _step$value[1];\n          if (v < maxMs) {\n            // messages that stay too long in the requestMsByMsg map, delete\n            this.requestMsByMsg.delete(k);\n          } else {\n            // recent messages, keep them\n            // sort by insertion order\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"trackMessage\",\n    value: function trackMessage(msgIdStr) {\n      if (this.metrics) {\n        var requestMs = this.requestMsByMsg.get(msgIdStr);\n        if (requestMs !== undefined) {\n          this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000);\n          this.requestMsByMsg.delete(msgIdStr);\n        }\n      }\n    }\n  }]);\n  return IWantTracer;\n}();","map":{"version":3,"names":["RejectReason","IWantTracer","gossipsubIWantFollowupMs","msgIdToStrFn","metrics","_classCallCheck","promises","Map","requestMsByMsg","requestMsByMsgExpire","_createClass","key","get","size","value","addPromise","from","msgIds","ix","Math","floor","random","length","msgId","msgIdStr","expireByPeer","set","now","Date","has","iwantPromiseStarted","inc","getBrokenPromises","_this","_this$metrics","result","brokenPromises","forEach","expire","p","_result$get","delete","iwantPromiseBroken","deliverMessage","trackMessage","iwantPromiseResolved","iwantPromiseResolvedPeers","rejectMessage","reason","Error","clear","prune","maxMs","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","k","v","err","e","f","requestMs","undefined","iwantPromiseDeliveryTime","observe"],"sources":["../../src/tracer.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}