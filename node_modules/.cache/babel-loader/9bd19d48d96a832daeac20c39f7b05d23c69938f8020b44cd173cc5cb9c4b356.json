{"ast":null,"code":"import _regeneratorRuntime from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/treasure/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Key } from 'interface-datastore/key';\nimport { Libp2pRecord } from '@libp2p/record';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nvar log = logger('ipfs:ipns:offline-datastore');\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nexport var OfflineDatastore = /*#__PURE__*/function () {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  function OfflineDatastore(datastore) {\n    _classCallCheck(this, OfflineDatastore);\n    this._datastore = datastore;\n    /** @type {any[]} */\n    this.stores = [];\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  _createClass(OfflineDatastore, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, value, options) {\n        var routingKey, record;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (key instanceof Uint8Array) {\n                _context.next = 2;\n                break;\n              }\n              throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n            case 2:\n              if (value instanceof Uint8Array) {\n                _context.next = 4;\n                break;\n              }\n              throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE');\n            case 4:\n              _context.prev = 4;\n              routingKey = this._routingKey(key);\n              _context.next = 12;\n              break;\n            case 8:\n              _context.prev = 8;\n              _context.t0 = _context[\"catch\"](4);\n              log.error(_context.t0);\n              throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n            case 12:\n              // Marshal to libp2p record as the DHT does\n              record = new Libp2pRecord(key, value, new Date());\n              _context.next = 15;\n              return this._datastore.put(routingKey, record.serialize(), options);\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[4, 8]]);\n      }));\n      function put(_x, _x2, _x3) {\n        return _put.apply(this, arguments);\n      }\n      return put;\n    }()\n    /**\n     * Get a value from the local datastore indexed by the received key properly encoded.\n     *\n     * @param {Uint8Array} key - identifier of the value to be obtained.\n     * @param {AbortOptions} [options]\n     */\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, options) {\n        var routingKey, res, record;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (key instanceof Uint8Array) {\n                _context2.next = 2;\n                break;\n              }\n              throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n            case 2:\n              _context2.prev = 2;\n              routingKey = this._routingKey(key);\n              _context2.next = 10;\n              break;\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](2);\n              log.error(_context2.t0);\n              throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n            case 10:\n              _context2.next = 12;\n              return this._datastore.get(routingKey, options);\n            case 12:\n              res = _context2.sent;\n              _context2.prev = 13;\n              record = Libp2pRecord.deserialize(res);\n              _context2.next = 21;\n              break;\n            case 17:\n              _context2.prev = 17;\n              _context2.t1 = _context2[\"catch\"](13);\n              log.error(_context2.t1);\n              throw _context2.t1;\n            case 21:\n              return _context2.abrupt(\"return\", record.value);\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[2, 6], [13, 17]]);\n      }));\n      function get(_x4, _x5) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n    /**\n     * encode key properly - base32(/ipns/{cid})\n     *\n     * @param {Uint8Array} key\n     */\n  }, {\n    key: \"_routingKey\",\n    value: function _routingKey(key) {\n      return new Key('/dht/record/' + uint8ArrayToString(key, 'base32'), false);\n    }\n  }]);\n  return OfflineDatastore;\n}();","map":{"version":3,"names":["Key","Libp2pRecord","errcode","logger","toString","uint8ArrayToString","log","OfflineDatastore","datastore","_classCallCheck","_datastore","stores","_createClass","key","value","_put","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","routingKey","record","wrap","_callee$","_context","prev","next","Uint8Array","Error","_routingKey","t0","error","Date","put","serialize","stop","_x","_x2","_x3","apply","arguments","_get","_callee2","res","_callee2$","_context2","get","sent","deserialize","t1","abrupt","_x4","_x5"],"sources":["/Users/apple/Documents/treasure/node_modules/ipfs-core/src/ipns/routing/offline-datastore.js"],"sourcesContent":["import { Key } from 'interface-datastore/key'\nimport { Libp2pRecord } from '@libp2p/record'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst log = logger('ipfs:ipns:offline-datastore')\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nexport class OfflineDatastore {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (datastore) {\n    this._datastore = datastore\n    /** @type {any[]} */\n    this.stores = []\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  async put (key, value, options) { // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    if (!(value instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    // Marshal to libp2p record as the DHT does\n    const record = new Libp2pRecord(key, value, new Date())\n\n    await this._datastore.put(routingKey, record.serialize(), options)\n  }\n\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n  async get (key, options) {\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    const res = await this._datastore.get(routingKey, options)\n\n    // Unmarshal libp2p record as the DHT does\n    let record\n    try {\n      record = Libp2pRecord.deserialize(res)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    return record.value\n  }\n\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n  _routingKey (key) {\n    return new Key('/dht/record/' + uint8ArrayToString(key, 'base32'), false)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}